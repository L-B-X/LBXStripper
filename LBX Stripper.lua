-- @version 0.94
-- @author lbx
-- @changelog

--[[
   * ReaScript Name: LBX Stripper
   * Lua script for Cockos REAPER
   * Author: Leon Bradley (LBX) 
   * Author URI: 
   * Licence: GPL v3
  ]]
    
  --------------------------------------------

  noteletters_tab = {'C','C#','D','D#','E','F','F#','G','G#','A','A#','B'}
        
  submode_table = {'FX PARAMS','GRAPHICS','STRIPS'}
  xxymode_table = {'SNAPSHOTS','PATHS'}
  ctltype_table = {'KNOB/SLIDER','BUTTON','BUTTON INV','CYCLE BUTTON','METER','MEM BUTTON','MOMENT BTN','MOMENT INV','FLASH BUTTON','FLASH INV'}
  trctltype_table = {'Track Controls','Track Sends','Track Meters','Other Controls'}
  --special_table = {'Action Trigger','Peak Meter L','Peak Meter R','Clip Indicator L','Clip Indicator R'}
  special_table = {}
  otherctl_table = {'Action Trigger','Macro Control','EQ Engine','Strip Switcher','ReaControlMidi Switch','Midi/OSC Control'}
  scalemode_preset_table = {'','NORMAL','REAPER VOL'}
  scalemode_table = {1/8,1/7,1/6,1/5,1/4,1/3,1/2,1,2,3,4,5,6,7,8}
  scalemode_dtable = {'1/8','1/7','1/6','1/5','1/4','1/3','1/2','1','2','3','4','5','6','7','8'}
  macroscale_table = {'Linear','Slow','Fast','Smooth','Slow 2 (Cubic)','Fast 2 (Cubic)', 'Smooth 2 (Cubic)', 'Slow 3', 'Fast 3', 'Smooth 3'}
  eqcontrol_colours = {'160 0 0','0 160 0','0 0 160','160 160 0','0 160 160','160 0 160','255 165 0','160 160 160','196 80 80','80 196 80','80 80 196','196 196 80','196 80 196'
                       ,'255 64 64','64 0 255','80 160 0','102 0 51','255 255 255','255 255 255','255 255 255'}
  
  midimsgtype_table = {'80 - Note Off','90 - Note On','A0 - Key Pressure','B0 - Control Change','C0 - Program Change','D0 - Channel Pressure','E0 - Pitch Bend'}
  midimsgval_table = {'0x8','0x9','0xA','0xB','0xC','0xD','0xE'}
  
  focus_table = {'Off','Arrange','MIDI Editor'}
  ctlfile_type_table = {'Knob','Slider','Button','Meter','Misc'}
  
  framemode_table = {'NORMAL','CIRC'}
  snapsubsets_table = {'PAGE'} 
  gaugetype_table = {'ARC','LINEAR VERT', 'LINEAR HORIZ'}
  gfxstretch_table = {'normal','fix edge'}
  
  trctltypeidx_table = {tr_ctls = 1,
                        tr_sends = 2,
                        tr_rcvs = 3,
                        tr_hwouts = 4
                       }  
      
  contexts = {updatefreq = 0,
              lockw = 1,
              lockh = 2,
              gridslider = 3,
              dragsidebar = 4,
              sliderctl = 5,
              scaleslider = 6,
              offsetslider = 7,
              valoffsetslider = 8,
              defvalslider = 9,
              textsizeslider = 10,
              dragctl = 11,
              draglasso = 12,
              dragparam = 13,
              draggfx = 14,
              stretch_x = 15,
              stretch_y = 16,
              stretch_xy = 17,
              draggfx2 = 18,
              dragstrip = 19,
              cycleknob = 20,
              dragparamlrn = 21,
              minov = 22,
              maxov = 23,
              dragparam_tr = 24,
              dragparam_snd = 25,
              shadxslider = 26,
              shadyslider = 27,
              shadaslider = 28,
              movesnapwindow = 29,
              resizesnapwindow = 30,
              dragparam_spec = 31,
              sliderctl_h = 32,
              dragcycle = 33,
              addsnapctl = 34,
              resizefsnapwindow = 35,
              hold = 36,
              insertstrip = 37,
              addxyctl = 38,
              dragxy = 39,
              auto_delayslider = 40,
              xxy_dragsnap = 41,
              xxy_movesnap = 42,
              xxy_drag = 43,
              xxy_gravityslider = 44,
              xxypath_dragcontrolpt = 45,
              xxypath_dragpt = 46,
              xxypath_posslider = 47,
              knobsens_norm = 48,
              knobsens_fine = 49,
              knobsens_wheel = 50,
              knobsens_wheelfine = 51,
              eqc_pminslider = 52,
              eqc_pmaxslider = 53,  
              eqc_drag = 54,                          
              eqc_gminslider = 55,
              eqc_gmaxslider = 56,
              eqc_dragfreq = 57,
              eqc_draggain = 58,
              eqc_dragq = 59,                
              eqc_dragc1 = 60,                
              eqc_dragc2 = 61,                
              eqc_dragc3 = 62,                
              eqc_dragc4 = 63,                
              eqc_dragc5 = 64, 
              macsliderA = 65,              
              macsliderB = 66,
              macctl = 67,
              macctl_h = 68,
              macctl2 = 69,
              reassplugin = 70,              
              dragcycle_h = 71,
              gauge_val = 80,
              gauge_arcrad = 82,
              gauge_arclen = 83,              
              gauge_arcrot = 84,              
              gauge_tksz = 85,              
              gauge_tkoffs = 86,              
              gauge_xoffs = 87,              
              gauge_yoffs = 88,              
              gauge_fs = 89,
              gauge_valfreq = 90,              
              gauge_nudge = 91,
              tfxo_shift = 92,
              midiout_chan = 93,
              midiout_msg = 94,
              snap_move = 95,
              snapshot_rand = 96,
              dragparam_other = 97, 
              dd = 98,
              textsizevslider = 99,
              gfxopt_bright = 100,
              gfxopt_contr = 101,
              gfxopt_r = 102,
              gfxopt_g = 103,
              gfxopt_b = 104,
              gfxopt_a = 105,
              gfxopt_edge = 106, 
              dummy = 999
              }
  
  ctlcats = {fxparam = 0,
             trackparam = 1,
             tracksend = 2,
             trackrecv = 3,
             trackhwout = 4,
             action = 5,
             snapshot = 6,
             pkmeter = 7,
             xy = 8,
             fxoffline = 9,
             macro = 10,
             eqcontrol = 11,
             switcher = 12,
             snapshotrand = 13,
             fxgui = 14,
             rcm_switch = 15,
             midictl = 16,
             oscctl = 17}

  ctlcats_nm = {'fxparam',
                'trackparam',
                'tracksend',
                'trackrecv',
                'trackhwout',
                 'action',
                 'snapshot',
                 'pkmeter',
                 'xy',
                 'fxoffline',
                 'macro',
                 'eqcontrol',
                 'switcher',
                 'snapshotrand',
                 'fxgui',
                 'rcm_switch',
                 'midictl',
                 'oscctl'}
             
  gfxtype = {img = 0,
             txt = 1
             }

  pi = 3.14159265359

  -----------------------------------
  -----------------------------------  
  
  function cfact(n) if n == 0 then return 1 else return n * cfact(n-1) end end

 -- mpl draw BÃ©zier curve

  function draw_curve(x_table, y_table, pt, last)
    order = #x_table
    ----------------------------
    ----------------------------
    function bezier_eq(n, tab_xy, dt)
      local B = 0
      for i = 0, n-1 do
        B = B + 
          ( fact[n] / ( fact[i] * fact[n-i] ) ) 
          *  (1-dt)^(n-i)  
          * dt ^ i
          * tab_xy[i+1]
      end 
      return B
    end  
    ----------------------------
    function draw_points(x,y, pt, last)
      local point_side = 5
      gfx.set(0,0.8,0,0.4)
      local xx = {}
      local yy = {}
      for i = 1, #x do
        xx[i] = (x[i]*obj.sections[220].w)        
        yy[i] = (y[i]*obj.sections[220].h)
      end
      
      for i = 1, #x do
        if i == 1 or i == 4 then
          if pt == 1 and i == 1 then
            f_Get_SSV('0 255 0')
          elseif pt == last and i == 4 then
            f_Get_SSV(gui.color.red)                    
          else
            f_Get_SSV(gui.color.yellow)          
          end
          gfx.a=1
          gfx.circle(xx[i] ,yy[i] ,point_side,1, 1)
        else
          gfx.a = 0.2
          if i == 2 then
            f_Get_SSV(gui.color.blue)          
            gfx.line(xx[1],yy[1],xx[2],yy[2],1)
          else
            f_Get_SSV(gui.color.blue)          
            gfx.line(xx[4],yy[4],xx[3],yy[3],1)          
          end        
          gfx.a = 1
          f_Get_SSV('255 0 255')          
          gfx.rect(xx[i] -point_side/2 ,yy[i] -point_side/2,point_side,point_side,1, 1)
        end
      end
    end
    ----------------------------
    local ox,oy = nil, nil
    if xxymode == 0 then
      f_Get_SSV('0 32 0')          
    else
      f_Get_SSV('0 128 0')          
    end
    for t = 0, 1, 0.01 do
      x_point = bezier_eq(order, x_table, t)+ t^order*x_table[order]
      y_point = bezier_eq(order, y_table, t)+ t^order*y_table[order] 
      x = (x_point*obj.sections[220].w)
      y = (y_point*obj.sections[220].h)
      if ox and oy then
        gfx.a = 1
        --gfx.setpixel(1,1,1)
        gfx.line(ox,oy,x,y,1)
      end
      ox,oy = x,y
    end
    if xxymode == 1 and xxypath_edit then    
      draw_points(x_table, y_table, pt, last)
    end
  end

  function curve_getxy(x_table, y_table, t)
    order = #x_table
    ----------------------------
    function bezier_eq(n, tab_xy, dt)
      local B = 0
      for i = 0, n-1 do
        B = B + 
          ( fact[n] / ( fact[i] * fact[n-i] ) ) 
          *  (1-dt)^(n-i)  
          * dt ^ i
          * tab_xy[i+1]
      end 
      return B
    end  
    ----------------------------
    x_point = bezier_eq(order, x_table, t)+ t^order*x_table[order]
    y_point = bezier_eq(order, y_table, t)+ t^order*y_table[order] 
    return x_point, y_point
  end

  -----------------------------------
  -----------------------------------
    
  --[[local x_table =
                 {10,  -- x1
                  70,  -- x2
                  0,  -- x3
                  0,  -- x4
                  --300,  -- x5
                  }
  local y_table =
                 {10,  -- y1
                  50,  -- y2
                  100,  -- y3
                  0,  -- y4
                  --0,  -- y5
                  }]]                 
                   
  --gfx.init('Draw BÃ©zier curve by mpl',300, 300)                
  --draw_curve(x_table, y_table)                        
  
  local log10 = function(x) return math.log(x, 10) end
  
  function get_peak_info(trn)

    local tr
    if trn == -1 then
      tr = reaper.GetMasterTrack(0)
    else  
      tr = reaper.GetTrack(0, trn)
    end
    local nchan = reaper.GetMediaTrackInfo_Value(tr, 'I_NCHAN')
    peak_info[trn] = {}
    local pk, peak_info_ch, peak_info_dB = 0
    for i = 0, nchan-1 do
      local peak_info_ch = reaper.Track_GetPeakInfo(tr, i)
      local peak_info_dB = 20*log10(peak_info_ch)
      local pk = 0
      if peak_info_dB > 0 then
        pk = 1
      end
      peak_info[trn][i] = {ch = normalize(-60,0,F_limit(peak_info_dB,-60,0)),
                           pk = pk,
                           ch_d = peak_info_dB}
    end
  end
  
  function copyfile(src, dest)
    local file = io.open(src, 'rb')
    local content = file:read('*a')
    file:close()
    local file = io.open(dest, 'wb')
    file:write(content)
    file:close()
  end

  function readbinaryfile(src)
    local file = io.open(src, 'rb')
    local content = file:read('*a')
    file:close()
    return content
  end

  function writebinaryfile(dest, content)
    local file = io.open(dest, 'wb')
    file:write(content)
    file:close()
  end
  
  function MoveGFXFileToFolder(file, folder)
  
    if graphics_files[graphics_folder_files[file]] then
      local srcfol = ''
      if graphics_files[graphics_folder_files[file]].fol ~= 'GENERAL' then
        srcfol = graphics_files[graphics_folder_files[file]].fol..'/'
      end
      local chkdfol = graphics_folders[folder]
      
      local srcfn = graphics_path..srcfol..graphics_files[graphics_folder_files[file]].fn
      --do nothing if file not exists or src and dest folders match
      if chkdfol ~= graphics_files[graphics_folder_files[file]].fol and reaper.file_exists(srcfn) then
        local dstfol = ''
        local dfol = ''
        if folder ~= 0 then
          dstfol = graphics_folders[folder]..'/'
          dfol = graphics_folders[folder]
        end
      
        local dstfn = graphics_path..dstfol..graphics_files[graphics_folder_files[file]].fn
        copyfile(srcfn, dstfn)
        os.remove(srcfn)
        
        if folder == 0 then
          graphics_files[graphics_folder_files[file]].fol = 'GENERAL'          
        else
          graphics_files[graphics_folder_files[file]].fol = dfol
        end
        PopGfxFolder(gfxfol_select)
        update_gfx = true
      else
        --DBG('file not found')
      end
    
    end
  
  end
  
  function StripData_ReadSnapContent(sdata)
  
    local snapdata = {}
    if sdata.version >= 4 and sdata.snapcontent then
      local snapcontent = sdata.snapcontent
      local data = {}
      local cnt = 0          
      local lines = split(snapcontent, "\n")
      if lines and #lines > 0 then
        for ln = 1, #lines do
          local idx, val = string.match(lines[ln],'%[(.-)%](.*)') 
          if idx then
            data[idx] = val
          end
        end
      end
      snapdata = LoadSnapDataX(nil,data)
    end    
    return snapdata
    
  end
  
  function StripShare_Export(fol, fn)
  
    savefn = fn
  
    local stripdata, stripfilecontent = LoadStripFN(fol..fn, nil, true)
    if stripdata.version and stripdata.version >= 4 then
      if stripdata.snapcontent then
        local snapd = StripData_ReadSnapContent(stripdata)
        if snapd then
          stripdata.snapshots = snapd
        end
      end
    else
      OpenMsgBox(1,'Please open and resave the strip file in the new strip format',1, 'before creating a stripshare file.') 
      return
    end
    
    local gfxchk = {}
    local ctlchk = {}
    local gfxf = {}
    local ctlf = {}
    
    if stripdata.strip.graphics then
      local gfxidx = PopulateGFXIdx()
      for g = 1, #stripdata.strip.graphics do      
        local gx = stripdata.strip.graphics[g]
        local idx = gfxidx[gx.fn]
        if idx then
          local gfn
          if graphics_files[idx].fol == 'GENERAL' then
            gfn = graphics_files[idx].fn
          else
            gfn = graphics_files[idx].fol..'/'..graphics_files[idx].fn
          end
          if gx.gfxtype == gfxtype.img and reaper.file_exists(graphics_path..gfn) then
            if gfxchk[gx.fn] == nil then
              gfxchk[gx.fn] = true 
              local imgbin = readbinaryfile(graphics_path..gfn)
              gfxf[#gfxf+1] = {fn = gx.fn, bindata = imgbin}
            end
          end
        end
      end
    end
    if stripdata.strip.controls then
      for c = 1, #stripdata.strip.controls do      
        local cx = stripdata.strip.controls[c]
        if nz(cx.ctl_info.fn,'') ~= '' and reaper.file_exists(controls_path..cx.ctl_info.fn) then
          local knbfn = string.match(cx.ctl_info.fn, '(.+)%.') ..'.knb'
          --DBG(knbfn)
          if reaper.file_exists(controls_path..knbfn) then
            if ctlchk[cx.ctl_info.fn] == nil then
              ctlchk[cx.ctl_info.fn] = true 
              local imgbin = readbinaryfile(controls_path..cx.ctl_info.fn)
              local knbbin = readbinaryfile(controls_path..knbfn)
              ctlf[#ctlf+1] = {fn = cx.ctl_info.fn, bindata = imgbin, knbdata = knbbin}
            end
          end
        end
      end
    end
    stripdata.sharedata = {stripfn = fn, ctls = ctlf, gfx = gfxf}
    
    local save_path=share_path..'/'
    local fn=save_path..string.match(savefn,'(.+)%.')..".sharestrip"

    local DELETE=true
    local file
    
    if reaper.file_exists(fn) then
    
    end
    
    if DELETE then
    
      local pickledsharedata=pickle(stripdata.sharedata)
      file=io.open(fn,"w")
      
      file:write('[SHARESTRIPFILE_VERSION]2\n')
      file:write('[SHAREDATA]\n'..pickledsharedata..'\n[\\SHAREDATA]\n')
      file:write('[SHARESTRIPDATA]\n')      
      file:write(stripfilecontent)
      file:write('[\\SHARESTRIPDATA]\n')      
      
      --local pickled_table=pickle(stripdata)
      --file:write(pickled_table)
      
      file:close()
    end

    --DBG('pickke time: '..reaper.time_precise()-t)
    OpenMsgBox(1,'Strip share file saved.',1)
  
  end
  
  function CompareStringToFile(str, fn)
  
    local fil = readbinaryfile(fn)
    local ret = false
    if fil == str then
      ret = true
    end
    return ret
    
  end
  
  function TestStuff()
  
    local gfxv = 1
    local fn = 'testttt.sharestrip'
    local tt = string.match(fn,'(.+)_v%d%d%d%d')
    local sfx = string.match(fn,'.+(%..*)')
    if tt == nil then
      tt = fn
    else
      tt = tt .. sfx
    end
    --tt = tt .. '_v'.. string.format('%04d',gfxv) .. string.match(fn,'.+(%..*)')
    DBG(tt)
    
  end
  
  function StripShare_Import()
  
    local loadfn
    local retval, fn = reaper.GetUserFileNameForRead(share_path..'*', 'Load Strip Share File', '.sharestrip')
    if retval then
    
      if reaper.file_exists(fn) then
        loadfn = string.match(fn, ".+\\(.*)")
      end
    end
            
    if loadfn then
      local stripdata, stripfiledata = LoadStripShareFN(nil,loadfn)
      local continue = false
      
      if stripdata.fx then
        local fxstring = 'The following plugins are required by this strip layout:\n\n'
        local fxns = {}
        for f = 1, #stripdata.fx do
        
          local fxn = nil
          if stripdata.fx[f].fxname then
            fxn = stripdata.fx[f].fxname
          else
            local fxc = string.match(stripdata.fx[f].fxchunk,'.-<(.-)\n')
            fxn = GetPlugNameFromChunk(fxc)
            if fxn and fxns[fxn] == nil then
              fxns[fxn] = true
            else
              fxn = nil
            end
          end
          if fxn then
            fxstring = fxstring .. fxn .. '\n'
          end
        end
        fxstring = fxstring .. '\nContinue with import?'
        local retval = reaper.MB(fxstring, 'Import Strip File', 4)
        if retval == 6 then
          continue = true
        end
      end      

      if continue == true then
        GUI_DrawStateWin(obj,gui,'Importing shared strip data... ',true)
        GUI_DrawStateWin(obj,gui,'')

        GUI_DrawStateWin(obj,gui,'Importing graphics data... ')
        GUI_DrawStateWin(obj,gui,'')

        --[[DBG('Importing shared strip data... ')
        DBG('')
        DBG('Importing graphics data... ')
        DBG('')]]

        for g = 1, #stripdata.sharedata.gfx do
          local gfxv = 0
          local base = string.match(stripdata.sharedata.gfx[g].fn,'(.+)_v%d%d%d%d')
          local suffx = string.match(stripdata.sharedata.gfx[g].fn,'.+(%..*)')
          if base == nil then
            base = string.match(stripdata.sharedata.gfx[g].fn,'(.+)%..*')
          end
          gfxfn = base .. suffx
          local fndg = false
          local gfn
          for gf = 0, #graphics_folders do
            local gfol = ''
            if graphics_folders[gf] ~= 'GENERAL' then
              gfol = graphics_folders[gf]..'/'
            end
            gfn = graphics_path..gfol..gfxfn
            if reaper.file_exists(gfn) then
              fndg = true
              break
            end
          end
          
          local copy = 0 --1 = overwrite, 2 = rename (? not implemented yet), 3 = don't copy - but update fn as might be diff
          if fndg == true then
            --compare saved file verses imported - ask to overwrite if not same
            if CompareStringToFile(stripdata.sharedata.gfx[g].bindata, gfn) == false then
              
              --different file
              while copy == 0 do
                gfxv = gfxv + 1
                gfxfn = base .. '_v' .. string.format('%04d',gfxv) .. suffx
                
                fndg = false
                for gf = 0, #graphics_folders do
                  local gfol = ''
                  if graphics_folders[gf] ~= 'GENERAL' then
                    gfol = graphics_folders[gf]..'/'
                  end
                  gfn = graphics_path..gfol..gfxfn
                  if reaper.file_exists(gfn) then
                    fndg = true
                    break
                  end
                end
                
                if fndg == true then  
                  if reaper.file_exists(gfn) then
                    if CompareStringToFile(stripdata.sharedata.gfx[g].bindata, gfn) == true then
                      --same file - rename
                      copy = 3
                    end
                  end
                else
                  --not found - copy and rename
                  copy = 1
                end  
              end
                     
            else
              --same file - rename
              copy = 3
            end
          else
            --not found - copy and rename
            copy = 1
          end
          
          if copy == 1 then
            GUI_DrawStateWin(obj,gui,'Importing graphic: '..stripdata.sharedata.gfx[g].fn..'   ('..gfxfn..')')
            --DBG('Importing graphic: '..stripdata.sharedata.gfx[g].fn..'   ('..gfxfn..')')
            gfn = graphics_path..gfxfn
            writebinaryfile(gfn, stripdata.sharedata.gfx[g].bindata)
          else
            GUI_DrawStateWin(obj,gui,'Already in graphics library: '..stripdata.sharedata.gfx[g].fn..'   ('..gfxfn..')')          
            --DBG('Already in graphics library: '..stripdata.sharedata.gfx[g].fn..'   ('..gfxfn..')')
          end    
          if copy > 0 then
            local src = stripdata.sharedata.gfx[g].fn
            --update gfx fn in stripdata
            for i = 1, #stripdata.sharedata.gfx do            
              if stripdata.sharedata.gfx[i].fn == src then
                stripdata.sharedata.gfx[i].fn = gfxfn
                stripdata.sharedata.gfx[i].imageidx = -1
              end 
            end
            for i = 1, #stripdata.strip.graphics do
              if stripdata.strip.graphics[i].fn == src then
                stripdata.strip.graphics[i].fn = gfxfn
                stripdata.strip.graphics[i].imageidx = -1
              end
            end
          end
        end

        GUI_DrawStateWin(obj,gui,'')
        GUI_DrawStateWin(obj,gui,'Importing controls data... ')
        GUI_DrawStateWin(obj,gui,'')
        --[[DBG('')
        DBG('Importing controls data... ')
        DBG('')]]
    
        for c = 1, #stripdata.sharedata.ctls do
          
          --local cfn = controls_path..stripdata.sharedata.ctls[c].fn

          local cfxv = 0
          local base = string.match(stripdata.sharedata.ctls[c].fn,'(.+)_v%d%d%d%d')
          local suffx = string.match(stripdata.sharedata.ctls[c].fn,'.+(%..*)')
          if base == nil then
            base = string.match(stripdata.sharedata.ctls[c].fn,'(.+)%..*')
          end
          cfxfn = base .. suffx
          local cfn = controls_path..cfxfn
          local copy = 0
          if reaper.file_exists(cfn) then
            if CompareStringToFile(stripdata.sharedata.ctls[c].bindata, cfn) == false then
              --different file
              while copy == 0 do
                cfxv = cfxv + 1
                cfxfn = base .. '_v' .. string.format('%04d',cfxv) .. suffx
                cfn = controls_path..cfxfn
                if reaper.file_exists(cfn) then
                  if CompareStringToFile(stripdata.sharedata.ctls[c].bindata, cfn) == true then
                    copy = 3
                  end
                else
                  copy = 1
                end
              end
            end
          else
            copy = 1
          end
          if copy == 1 then
            GUI_DrawStateWin(obj,gui,'Importing control: '..stripdata.sharedata.ctls[c].fn..'   ('..cfxfn..')')
            --DBG('Importing control: '..stripdata.sharedata.ctls[c].fn..'   ('..cfxfn..')')
            writebinaryfile(cfn, stripdata.sharedata.ctls[c].bindata)
            local knbfn = string.match(cfn, '(.+)%.') ..'.knb'
            writebinaryfile(knbfn, stripdata.sharedata.ctls[c].knbdata)

            setknbfn(knbfn,cfxfn)
          else
            GUI_DrawStateWin(obj,gui,'Already in controls library: '..stripdata.sharedata.ctls[c].fn..'   ('..cfxfn..')')
            --DBG('Already in controls library: '..stripdata.sharedata.ctls[c].fn..'   ('..cfxfn..')')
          end
          
          local src = stripdata.sharedata.ctls[c].fn
          if cfxfn ~= src then
            --DBG(src..'  '..cfxfn)
            --update ctl fn in stripdata
            for i = 1, #stripdata.sharedata.ctls do
              if stripdata.sharedata.ctls[i].fn == src then
                stripdata.sharedata.ctls[i].fn = cfxfn
                stripdata.sharedata.ctls[i].imageidx = -1
              end 
            end
            for i = 1, #stripdata.strip.controls do
              if stripdata.strip.controls[i].ctl_info.fn == src then
                stripdata.strip.controls[i].ctl_info.fn = cfxfn
                stripdata.strip.controls[i].ctl_info.imageidx = -1
                --stripdata.strip.controls[i].knob_select = nil
              end
            end
          end            
        end

        RCM_Neb_UpdateProgIDs(stripdata.strip.controls)
        
        GUI_DrawStateWin(obj,gui,'')
        GUI_DrawStateWin(obj,gui,'Importing strip data... ')
        GUI_DrawStateWin(obj,gui,'')
        --[[DBG('')
        DBG('Importing strip data... ')
        DBG('')]]
        
        local savefn = stripdata.sharedata.stripfn
        local save_path=strips_path..strip_folders[stripfol_select].fn..'/'
        local fn=save_path..savefn--..".strip"
        local copy = 0
        if reaper.file_exists(fn) then
          local str = 'The strip file already exists:\n\n'..savefn..'\n\nOverwrite?'
          local retval = reaper.MB(str, 'Import Strip', 4)
          if retval == 6 then
            copy = 1
          end
        else
          copy = 1
        end
        if copy == 1 then
          --stripdata.sharedata = nil
          
          local DELETE=true
          local file
          
          if DELETE then
          --DBG(fn)
            file=io.open(fn,"w")
          --DBG('pickling')
            if stripdata.version == 3 then
              local pickled_table=pickle(stripdata)
              file:write(pickled_table)                        
            else
              local fxdata 
              --if string.match(stripfiledata, '%[STRIPFILE_VERSION%].-%[\\FXDATA%]') then
                fxdata = string.match(stripfiledata, '%[STRIPFILE_VERSION%].-%[\\FXDATA%]')..'\n'
              --[[else
                fxdata = string.match(stripfiledata, '%[FXDATA%].-%[\\FXDATA%]')..'\n'
                if fxdata then
                  fxdata = '[STRIPFILE_VERSION]5\n'..fxdata
                end
              end]]
              file:write(fxdata)
              file:write('[STRIPDATA]\n')
              GenStripSaveData2(stripdata.strip,nil,file)
              file:write('[\\STRIPDATA]\n')
              
              --file:write(stripfiledata)                        
            end
            --local pickled_table=pickle(stripdata)
          --DBG('writing')
            file:close()
          --DBG('done')
          end
      
         -- DBG('Strip share file imported.')
          OpenMsgBox(1,'Strip share file imported.',1)
        end
      
        RepopulateGFX()
        RepopulateControls()
        PopulateStrips()
        
      end
    
    end    
  end
  
  function setknbfn(kfn, cfn)
  
    if reaper.file_exists(kfn) then
      local file
      --DBG(controls_path..kfn)
      file=io.open(kfn,"r")
      local content=file:read("*a")
      file:close()
      
      local knbdat = unpickle(content)
      knbdat.fn = cfn
  
      --save knb file
      file=io.open(kfn,"w")
      local pickled_table=pickle(knbdat)
      file:write(pickled_table)
      file:close()
    end
    
  end
  
  ------------------------------------------- --
  -- Pickle.lua
  -- A table serialization utility for lua
  -- Steve Dekorte, http://www.dekorte.com, Apr 2000
  -- (updated for Lua 5.3 by me)
  -- Freeware
  ----------------------------------------------
  
  function pickle(t)
  return Pickle:clone():pickle_(t)
  end
  
  Pickle = {
  clone = function (t) local nt={}; for i, v in pairs(t) do nt[i]=v end return nt end
  }
  
  function Pickle:pickle_(root)
  if type(root) ~= "table" then
  error("can only pickle tables, not ".. type(root).."s")
  end
  self._tableToRef = {}
  self._refToTable = {}
  local savecount = 0
  self:ref_(root)
  local s = ""
  
  while #self._refToTable > savecount do
  savecount = savecount + 1
  local t = self._refToTable[savecount]
  s = s.."{\n"
  
  for i, v in pairs(t) do
  s = string.format("%s[%s]=%s,\n", s, self:value_(i), self:value_(v))
  end
  s = s.."},\n"
  --DBG('*****************************************************************')
  --DBG(savecount)
  end
  return string.format("{%s}", s)
  end
  
  function Pickle:value_(v)
  local vtype = type(v)
  if vtype == "string" then return string.format("%q", v)
  elseif vtype == "number" then return v
  elseif vtype == "boolean" then return tostring(v)
  elseif vtype == "table" then return "{"..self:ref_(v).."}"
  else error("pickle a "..type(v).." is not supported")
  end
  end
  
  function Pickle:ref_(t)
  local ref = self._tableToRef[t]
  if not ref then
  if t == self then error("can't pickle the pickle class") end
  table.insert(self._refToTable, t)
  ref = #self._refToTable
  self._tableToRef[t] = ref
  end
  return ref
  end
  
  ----------------------------------------------
  -- unpickle
  ----------------------------------------------
  
  function unpickle(s)
  if s == nil or s == '' then return end
  if type(s) ~= "string" then
  error("can't unpickle a "..type(s)..", only strings")
  end
  local gentables = load("return "..s)
  if gentables then
    local tables = gentables()
    
    if tables then
      for tnum = 1, #tables do
      local t = tables[tnum]
      local tcopy = {}; for i, v in pairs(t) do tcopy[i] = v end
      for i, v in pairs(tcopy) do
      local ni, nv
      if type(i) == "table" then ni = tables[i[1]] else ni = i end
      if type(v) == "table" then nv = tables[v[1]] else nv = v end
      t[i] = nil
      t[ni] = nv
      end
      end
      return tables[1]
    end
  else
    --error
  end
  end
        
  ------------------------------------------------------------
  
  function DBG(str)
  if str==nil then str="nil" end
  reaper.ShowConsoleMsg(tostring(str).."\n")
  end
  
  ------------------------------------------------------------
  
  function tobool(b)
  
    local ret
    if tostring(b) == "true" then
      ret = true
    else
      ret = false
    end
    return ret
    
  end
  
  function convertguid(g)
    if g then
      return string.match(g,'{(.*)}')
    end
  end
  
  val_to_dB = function(val) return 20*math.log(val, 10) end
  dB_to_val = function(dB_val) return 10^(dB_val/20) end
  
  function GetObjects()
    
      local ss160
      if obj and obj.sections then
        ss160 = obj.sections[160]
      end
      
      local obj = {}
      
      obj.sections = {}
      
      local sizex, sizey = 350, 100
      local bsizex, bsizey = 60, 20
      obj.sections[5] = {x = gfx1.main_w/2 - sizex/2 + 25,
                         y = gfx1.main_h/2 - sizey/2 + 10,
                         w = sizex-50, 
                         h = 20}
      obj.sections[6] = {x = gfx1.main_w/2 + sizex/2 - bsizex - 50,
                               y = gfx1.main_h/2 + sizey/2 - bsizey - 10,
                               w = bsizex, 
                               h = bsizey}
      obj.sections[7] = {x = gfx1.main_w/2 + sizex/2 - (bsizex*2) - 60,
                               y = gfx1.main_h/2 + sizey/2 - bsizey - 10,
                               w = bsizex, 
                               h = bsizey}
      obj.sections[8] = {x = gfx1.main_w/2 - sizex/2,
                         y = gfx1.main_h/2 - sizey/2,
                         w = sizex, 
                         h = sizey}
      obj.sections[9] = {x = gfx1.main_w/2 - sizex/2 + 25,
                         y = gfx1.main_h/2 + sizey/2 - 60,
                         w = sizex-50, 
                         h = 20}
      
      --surface
      if hide_topbar then
        topbarheight = 0
      else
        topbarheight = butt_h      
      end
      if settings_showbars then
        obj.sections[10] = {x = plist_w+2 + sb_size + 2,
                            y = topbarheight + sb_size + 2,
                            w = gfx1.main_w-(plist_w+2+(sb_size+2)*2),
                            h = gfx1.main_h-(topbarheight+(sb_size+2)*2)}
        if lockx then
          obj.sections[10].x = math.max(obj.sections[10].x, obj.sections[10].x+(obj.sections[10].w/2-lockw/2))
          obj.sections[10].w = math.min(lockw,gfx1.main_w-(plist_w+2+(sb_size+4)*2))
        end
        if locky then
          obj.sections[10].y = math.max(obj.sections[10].y, obj.sections[10].y+(obj.sections[10].h/2-lockh/2))
          obj.sections[10].h = math.min(lockh,gfx1.main_h-(topbarheight+2+(sb_size+2)*2))
        end
      else
        obj.sections[10] = {x = plist_w,
                            y = topbarheight+1,
                            w = gfx1.main_w-(plist_w+2)+2,
                            h = gfx1.main_h-(topbarheight+1)}
        if lockx then
          obj.sections[10].x = math.max(obj.sections[10].x, obj.sections[10].x+(obj.sections[10].w/2-lockw/2))
          obj.sections[10].w = math.min(lockw,gfx1.main_w-(plist_w+2))
        end
        if locky then
          obj.sections[10].y = math.max(obj.sections[10].y, obj.sections[10].y+(obj.sections[10].h/2-lockh/2))
          obj.sections[10].h = math.min(lockh,gfx1.main_h-(topbarheight+2))
        end
      end
      surface_size.exceed = false
      if obj.sections[10].w > surface_size.w then
        obj.sections[10].w = surface_size.w
        surface_size.exceed = true
      end
      if obj.sections[10].h > surface_size.h then        
        obj.sections[10].h = surface_size.h        
        surface_size.exceed = true
      end

      --mode
      obj.sections[11] = {x = 0,
                          y = 0,
                          w = plist_w,
                          h = butt_h}
      
      --track title
      obj.sections[12] = {x = 126,
                          y = 0,
                          w = math.max(gfx1.main_w - plist_w - 352,0),
                          h = topbarheight}

      --submode
      obj.sections[13] = {x = 0,
                          y = butt_h+2,
                          w = plist_w,
                          h = butt_h}
      --pages
      obj.sections[14] = {x = gfx1.main_w - plist_w - 100,
                          y = 0,
                          w = 101,
                          h = topbarheight}
      --G page
      obj.sections[1000] = {x = gfx1.main_w - plist_w - 150,
                          y = 0,
                          w = 50,
                          h = topbarheight}
      
      obj.sections[15] = {x = 0,
                          y = (butt_h+2)*2,
                          w = plist_w,
                          h = butt_h}
      --save
      obj.sections[17] = {x = gfx1.main_w - plist_w - 250,
                          y = 0,
                          w = 74,
                          h = topbarheight}
      --show/hide sidebar
      obj.sections[18] = {x = 0,
                          y = 0,
                          w = 25,
                          h = butt_h}
      obj.sections[19] = {x = gfx1.main_w - plist_w - 125,
                          y = 0,
                          w = 25,
                          h = butt_h}
      --XYUD
      obj.sections[20] = {x = obj.sections[18].x+obj.sections[18].w+1,
                          y = 0,
                          w = 100,
                          h = topbarheight}
      if hide_topbar then
        obj.sections[21] = {x = gfx1.main_w - plist_w - 26,
                            y = 0,
                            w = 26,
                            h = butt_h}
      else
        obj.sections[21] = {x = gfx1.main_w - plist_w - 175,
                            y = 0,
                            w = 26,
                            h = butt_h}
      end
      
      local fx_h = 160
      local sf_h = 140

      --FX
      --[[obj.sections[41] = {x = 0,
                          y = (butt_h+2)*2,
                          w = plist_w,
                          h = fx_h}
      --PARAMS
      obj.sections[42] = {x = 0,
                          y = obj.sections[41].y + obj.sections[41].h + 10,
                          w = plist_w,
                          h = gfx1.main_h - (obj.sections[41].y + obj.sections[41].h + 10)}]]
      --TRACKS                    
      obj.sections[43] = {x = 0,
                          y = 0, --butt_h+2,
                          w = plist_w,
                          h = gfx1.main_h}                           
      --GRAPHICS
      --[[obj.sections[44] = {x = 0,
                          y = obj.sections[13].y+obj.sections[13].h+2,
                          w = plist_w,
                          h = gfx1.main_h - (obj.sections[13].y+obj.sections[13].h+2)} ]]                         

      --edit chooser
      obj.sections[501] = {x = 0,
                           y = (butt_h+2),
                           w = plist_w,
                           h = butt_h}
      --NEW TRACKS
      obj.sections[500] = {x = 0,
                          y = butt_h+2,
                          w = plist_w,
                          h = gfx1.main_h}
      --NEW STRIPS
      obj.sections[510] = {x = 0,
                           y = (butt_h+2)*3,
                           w = plist_w,
                           h = sf_h}
      --save
      obj.sections[511] = {x = 0,
                           y = (butt_h+2)*2,
                           w = plist_w,
                           h = butt_h}
      obj.sections[512] = {x = 0,
                           y = obj.sections[510].y+obj.sections[510].h+4,
                           w = plist_w,
                           h = gfx1.main_h - (obj.sections[510].y+obj.sections[510].h+2)}

      --NEW FX - plugins/track controls
      obj.sections[520] = {x = 0,
                           y = (butt_h+2)*2,
                           w = plist_w,
                           h = fx_h}
      --track select/lrn      
      obj.sections[521] = {x = 0,
                           y = obj.sections[520].y+obj.sections[520].h+2,
                           w = plist_w,
                           h = butt_h}
      --params
      obj.sections[522] = {x = 0,
                           y = obj.sections[521].y+obj.sections[521].h+2,
                           w = plist_w,
                           h = gfx1.main_h - (obj.sections[521].y+obj.sections[521].h+2)}
      --NEW GRAPHICS

      obj.sections[530] = {x = 0,
                           y = obj.sections[521].y+obj.sections[521].h+2,
                           w = plist_w,
                           h = gfx1.main_h - (obj.sections[521].y+obj.sections[521].h+2)}
      obj.sections[531] = {x = 0,
                           y = (butt_h+2)*2,
                           w = plist_w,
                           h = fx_h+butt_h}
      --[[obj.sections[530] = {x = 0,
                           y = (butt_h+2)*2,
                           w = plist_w,
                           h = gfx1.main_h - ((butt_h+2)*2)}]]


      --CONTROL OPTIONS
      local cow = 160
      obj.sections[45] = {x = math.max(gfx1.main_w - cow - 10, obj.sections[10].x + cow + 20),
                          y = math.max(gfx1.main_h - 470 - 10, obj.sections[10].y),
                          w = cow,
                          h = 470}                           
      
      --GAUGE EDIT
      local gaw, gah = 320, 500
      local gsw = 90
      local gofs = 270
      obj.sections[800] = {x = math.max(gfx1.main_w/2 -gaw/2,obj.sections[43].w),
                          y = math.max(gfx1.main_h/2 - gah/2, obj.sections[10].y),
                          w = gaw,
                          h = gah}
      obj.sections[806] = {x = obj.sections[800].x + 60,
                           y = obj.sections[800].y + butt_h,
                           w = gaw-120,
                           h = gofs-100}

      obj.sections[801] = {x = obj.sections[800].x + 60,
                           y = obj.sections[800].y + gofs - 8,
                           w = gsw,
                           h = butt_h}
      --radius, len
      obj.sections[802] = {x = obj.sections[800].x + 60,
                           y = obj.sections[800].y + gofs + (butt_h/2+13)*4 -20,
                           w = gsw,
                           h = butt_h/2+8}
      obj.sections[803] = {x = obj.sections[800].x + 60,
                           y = obj.sections[800].y + gofs + (butt_h/2+13)*5 -20,
                           w = gsw,
                           h = butt_h/2+8}
      obj.sections[804] = {x = obj.sections[800].x + 60,
                           y = obj.sections[800].y + gofs + (butt_h/2+13)*6 -20,
                           w = gsw,
                           h = butt_h/2+8}
      obj.sections[805] = {x = obj.sections[800].x + 60 + gsw/2,
                           y = obj.sections[800].y + gofs + (butt_h/2+8) +18,
                           w = gsw/2,
                           h = butt_h}
      obj.sections[807] = {x = obj.sections[800].x + 60,
                           y = obj.sections[800].y + gofs + (butt_h/2+13)*7 -20,
                           w = gsw,
                           h = butt_h/2+8}
      obj.sections[808] = {x = obj.sections[800].x + 60,
                           y = obj.sections[800].y + gofs + (butt_h/2+13)*8 -20,
                           w = gsw,
                           h = butt_h/2+8}
      --x, y
      obj.sections[809] = {x = obj.sections[800].x + obj.sections[800].w/2 + 55,
                           y = obj.sections[800].y + gofs -8 + (butt_h/2+13)*0,
                           w = gsw,
                           h = butt_h/2+8}
      obj.sections[810] = {x = obj.sections[800].x + obj.sections[800].w/2 + 55,
                           y = obj.sections[800].y + gofs -8 + (butt_h/2+13)*1,
                           w = gsw,
                           h = butt_h/2+8}

      obj.sections[811] = {x = obj.sections[800].x + obj.sections[800].w - 40,
                           y = obj.sections[800].y + 25,
                           w = 35,
                           h = butt_h/2+8}
      obj.sections[812] = {x = obj.sections[800].x + obj.sections[800].w - 40,
                           y = obj.sections[800].y + 25+ butt_h,
                           w = 35,
                           h = butt_h/2+8}
      obj.sections[813] = {x = obj.sections[800].x + obj.sections[800].w - 40,
                           y = obj.sections[800].y + 25 + butt_h*2,
                           w = 35,
                           h = butt_h/2+8}
                           
      obj.sections[814] = {x = obj.sections[800].x + obj.sections[800].w/2 + 55,
                           y = obj.sections[800].y + gofs + (butt_h/2+13)*4 -20,
                           w = gsw,
                           h = butt_h/2+8}
      obj.sections[815] = {x = obj.sections[800].x + obj.sections[800].w/2 - 60,
                           y = obj.sections[800].y + gofs -butt_h*2,
                           w = 120,
                           h = butt_h}
      obj.sections[816] = {x = obj.sections[800].x +5,
                           y = obj.sections[800].y + 25,
                           w = 35,
                           h = butt_h/2+8}
      obj.sections[817] = {x = obj.sections[800].x + obj.sections[800].w/2 + 55,
                           y = obj.sections[800].y + gofs + (butt_h/2+13)*5 -20,
                           w = 35,
                           h = butt_h/2+8}

      obj.sections[827] = {x = obj.sections[800].x + obj.sections[800].w/2 + 105,
                           y = obj.sections[800].y + gofs + (butt_h/2+13)*6 -20,
                           w = butt_h/2+4,
                           h = butt_h/2+4}

      obj.sections[832] = {x = obj.sections[800].x + obj.sections[800].w/2 + 105 + butt_h,
                           y = obj.sections[800].y + gofs + (butt_h/2+13)*6 -20,
                           w = butt_h/2+4,
                           h = butt_h/2+4}

      obj.sections[818] = {x = obj.sections[800].x + 60,
                           y = obj.sections[800].y + gofs + (butt_h/2+8) - 4,
                           w = gsw,
                           h = butt_h}

      obj.sections[823] = {x = obj.sections[800].x + 15,
                           y = obj.sections[800].y + obj.sections[800].h - butt_h*1.5 - 8,
                           w = gsw,
                           h = butt_h*1.5}
      obj.sections[824] = {x = obj.sections[823].x + obj.sections[823].w + 10,
                           y = obj.sections[823].y,
                           w = gsw,
                           h = butt_h*1.5}
      obj.sections[819] = {x = obj.sections[824].x + obj.sections[824].w + 10,
                           y = obj.sections[823].y,
                           w = gsw,
                           h = butt_h*1.5}

      obj.sections[820] = {x = obj.sections[800].x + obj.sections[800].w - 38 - butt_h,
                           y = obj.sections[800].y + 27,
                           w = butt_h/2+4,
                           h = butt_h/2+4}
      obj.sections[821] = {x = obj.sections[800].x + obj.sections[800].w - 38 - butt_h,
                           y = obj.sections[800].y + 27+ butt_h,
                           w = butt_h/2+4,
                           h = butt_h/2+4}
      obj.sections[822] = {x = obj.sections[800].x + obj.sections[800].w - 38 - butt_h,
                           y = obj.sections[800].y + 27 + butt_h*2,
                           w = butt_h/2+4,
                           h = butt_h/2+4}
      obj.sections[825] = {x = obj.sections[800].x + obj.sections[800].w/2 + 55,
                           y = obj.sections[800].y + gofs + (butt_h/2+13)*7 -20,
                           w = gsw,
                           h = butt_h/2+8}
      
      obj.sections[826] = {x = obj.sections[800].x + obj.sections[800].w/2 + 79,
                           y = obj.sections[800].y + gofs -butt_h*2-1,
                           w = 60,
                           h = butt_h}

      obj.sections[828] = {x = obj.sections[800].x + obj.sections[800].w/2 - 140,
                           y = obj.sections[800].y + gofs -butt_h*2-1,
                           w = 30,
                           h = butt_h}
      obj.sections[829] = {x = obj.sections[800].x + obj.sections[800].w/2 - 108,
                           y = obj.sections[800].y + gofs -butt_h*2-1,
                           w = 30,
                           h = butt_h}
      obj.sections[830] = {x = obj.sections[800].x + obj.sections[800].w/2 - 140 +1,
                           y = obj.sections[800].y + gofs -butt_h*2-3 - (butt_h/2+8),
                           w = 60,
                           h = butt_h/2+8}
      obj.sections[831] = {x = obj.sections[800].x + obj.sections[800].w/2 + 35,
                           y = obj.sections[800].y + gofs + (butt_h/2+13)*3 -26,
                           w = gsw+20,
                           h = butt_h}
      
      local gaw,gah = 400, math.max(200, obj.sections[10].h-40)
      obj.sections[900] = {x = math.max(gfx1.main_w/2 -gaw/2,obj.sections[43].w),
                          y = math.max(gfx1.main_h/2 - gah/2, obj.sections[10].y),
                          w = gaw,
                          h = gah}
      
      local sf_h = 140
      --STRIP FOLDERS
      obj.sections[47] = {x = 0,
                          y = obj.sections[15].y+obj.sections[15].h+2,
                          w = plist_w,
                          h = sf_h}                           

      --STRIPS
      --[[obj.sections[46] = {x = 0,
                          y = obj.sections[47].y+obj.sections[47].h+10,
                          w = plist_w,
                          h = gfx1.main_h - (obj.sections[47].y+obj.sections[47].h+10)} ]]                          

      --LEARN+TRX
      --[[obj.sections[48] = {x = 0,
                          y = obj.sections[41].y+obj.sections[41].h+8,
                          w = plist_w,
                          h = butt_h}     ]]                      

      --LABEL OPTS
      obj.sections[49] = {x = gfx1.main_w - cow - 20,
                          y = gfx1.main_h - 300 -20,
                          w = cow,
                          h = 300}                           
      --scale
      obj.sections[50] = {x = 50,
                          y = 150+butt_h+8,
                          w = obj.sections[45].w-60,
                          h = butt_h/2+8}                           
      --apply
      obj.sections[51] = {x = 10,
                          y = 150,
                          w = 80,
                          h = butt_h}                           
      
      obj.sections[99] = {x = obj.sections[51].x+obj.sections[51].w+2,
                          y = 150,
                          w = 58,
                          h = butt_h}
      
      obj.sections[52] = {x = obj.sections[45].w-104-butt_h/2+4,
                          y = 150+butt_h+10 + (butt_h/2+4 + 10)+24,
                          w = butt_h/2+4,
                          h = butt_h/2+4}                           

      obj.sections[53] = {x = obj.sections[45].w-104-butt_h/2+4,
                          y = 150+butt_h+10 + (butt_h/2+4 + 10) * 2+20,
                          w = butt_h/2+4,
                          h = butt_h/2+4}                           

      obj.sections[850] = {x = obj.sections[45].w-84-butt_h/2+4,
                          y = 150+butt_h+10 + (butt_h/2+4 + 10) * 2+20,
                          w = butt_h/2+4,
                          h = butt_h/2+4}                           

      obj.sections[851] = {x = obj.sections[52].x+obj.sections[52].w+26,
                          y = 150+butt_h+10 + (butt_h/2+4 + 10) * 2+20,
                          w = obj.sections[45].w-(obj.sections[52].x+obj.sections[52].w+36),
                          h = butt_h/2+4}                           

      obj.sections[852] = {x = obj.sections[851].x+obj.sections[851].w-22,
                          y = 150+butt_h+10 + (butt_h/2+4 + 10)+24-butt_h,
                          w = 26,
                          h = butt_h/2+4}                           

      obj.sections[54] = {x = obj.sections[45].w-84-butt_h/2+4,
                          y = 150+butt_h+10 + (butt_h/2+4 + 10)+24,
                          w = butt_h/2+4,
                          h = butt_h/2+4}                           

      obj.sections[55] = {x = 50,
                          y = 150+butt_h+7 + (butt_h/2+4 + 10) * 9,
                          w = obj.sections[45].w-60,
                          h = butt_h}
      obj.sections[56] = {x = 50,
                          y = 150+butt_h+10 + (butt_h/2+4 + 10) * 4,
                          w = obj.sections[45].w-80,
                          h = butt_h/2+8}                           
      obj.sections[57] = {x = 50,
                          y = 150+butt_h+10 + (butt_h/2+4 + 10) * 10,
                          w = obj.sections[45].w-60,
                          h = butt_h/2+8}                           

      obj.sections[48] = {x = 50,
                          y = 150+butt_h+10 + (butt_h/2+4 + 10) * 6 -1,
                          w = obj.sections[45].w-60,
                          h = butt_h}
                                                     
      obj.sections[58] = {x = obj.sections[52].x+obj.sections[52].w+26,
                          y = 150+butt_h+10 + (butt_h/2+4 + 10)+24,
                          w = obj.sections[45].w-(obj.sections[52].x+obj.sections[52].w+36),
                          h = butt_h/2+4}                           
      obj.sections[59] = {x = 50,
                          y = 150+butt_h+11 + (butt_h/2+4 + 10) * 8,
                          w = obj.sections[45].w-60,
                          h = butt_h}
      obj.sections[960] = {x = 50,
                          y = 150+butt_h+11 + (butt_h/2+4 + 10) * 7,
                          w = obj.sections[45].w-60,
                          h = butt_h}

      obj.sections[90] = {x = 2,
                          y = 75,
                          w = 12,
                          h = butt_h/2+8}                           
      obj.sections[91] = {x = obj.sections[45].w-14,
                          y = 75,
                          w = 12,
                          h = butt_h/2+8}                           

      obj.sections[65] = {x = 50,
                          y = 150+butt_h+10 + (butt_h/2+4 + 10) * 5,
                          w = obj.sections[45].w-80,
                          h = butt_h/2+8}                           

      obj.sections[68] = {x = 50+obj.sections[45].w-74,
                          y = 150+butt_h+10 + (butt_h/2+4 + 10) * 4.5,
                          w = butt_h/2+4,
                          h = butt_h/2+4}                           

      obj.sections[66] = {x = 50,
                          y = 150+butt_h+10 + (butt_h/2+4 + 10) * 11,
                          w = 40,
                          h = butt_h/2+4}
      obj.sections[67] = {x = 10,
                          y = 150+butt_h+7 + (butt_h/2+4 + 10) * 9,
                          w = 35,
                          h = butt_h}

      local binh = 45
      obj.sections[60] = {x = plist_w + 10,
                          y = gfx1.main_h - (binh + 10),
                          w = binh,
                          h = binh}
      local msgwinw, msgwinh = 500, 200
      obj.sections[61] = {x = gfx1.main_w/2-msgwinw/2,
                          y = gfx1.main_h/2-msgwinh/2,
                          w = msgwinw,
                          h = msgwinh}
      --ok
      local butt_w = 100
      obj.sections[62] = {x = gfx1.main_w/2+20,
                          y = obj.sections[61].y+obj.sections[61].h - butt_h*2,
                          w = butt_w,
                          h = butt_h}                            
      obj.sections[63] = {x = gfx1.main_w/2-msgwinw/2,
                          y = gfx1.main_h/2-msgwinh/2 + butt_h*2,
                          w = msgwinw,
                          h = butt_h}
      obj.sections[64] = {x = gfx1.main_w/2-butt_w - 20,
                          y = obj.sections[61].y+obj.sections[61].h - butt_h*2,
                          w = butt_w,
                          h = butt_h}                            
     
      --settings
      local setw, seth = 600, 530                            
      obj.sections[70] = {x = gfx1.main_w/2-setw/2,
                          y = gfx1.main_h/2-seth/2,
                          w = setw,
                          h = seth}
      local xofft, yoff, yoffm, bh, bw, sw = 200, 28, butt_h/2+14, butt_h/2+4, butt_h/2+4, 80
      obj.sections[71] = {x = obj.sections[70].x+xofft,
                          y = obj.sections[70].y+yoff + yoffm*0,
                          w = bw,
                          h = bh}
      obj.sections[72] = {x = obj.sections[70].x+xofft,
                                y = obj.sections[70].y+yoff + yoffm*1,
                                w = bw,
                                h = bh}
      obj.sections[73] = {x = obj.sections[70].x+xofft,
                                y = obj.sections[70].y+yoff + yoffm*2,
                                w = bw,
                                h = bh}
      obj.sections[74] = {x = obj.sections[70].x+xofft,
                                y = obj.sections[70].y+yoff + yoffm*3,
                                w = sw,
                                h = bh}
      obj.sections[75] = {x = obj.sections[70].x+xofft,
                                y = obj.sections[70].y+yoff + yoffm*4,
                                w = bw,
                                h = bh}
      obj.sections[76] = {x = obj.sections[70].x+xofft,
                                y = obj.sections[70].y+yoff + yoffm*5,
                                w = bw,
                                h = bh}
      obj.sections[77] = {x = obj.sections[70].x+xofft+bw+10,
                                y = obj.sections[70].y+yoff + yoffm*4,
                                w = 40,
                                h = bh}
      obj.sections[78] = {x = obj.sections[70].x+xofft+bw+10,
                                y = obj.sections[70].y+yoff + yoffm*5,
                                w = 40,
                                h = bh}
      obj.sections[79] = {x = obj.sections[70].x+xofft+bw+10,
                                y = obj.sections[70].y+yoff + yoffm*6,
                                w = 40,
                                h = bh}
      obj.sections[80] = {x = obj.sections[70].x+xofft,
                                y = obj.sections[70].y+yoff + yoffm*6,
                                w = bw,
                                h = bh}
      obj.sections[81] = {x = obj.sections[70].x+xofft,
                                y = obj.sections[70].y+yoff + yoffm*7,
                                w = bw,
                                h = bh}
      obj.sections[82] = {x = obj.sections[70].x+xofft,
                                y = obj.sections[70].y+yoff + yoffm*8,
                                w = bw,
                                h = bh}
      obj.sections[83] = {x = obj.sections[70].x+xofft,
                                y = obj.sections[70].y+yoff + yoffm*9,
                                w = bw,
                                h = bh}
      obj.sections[84] = {x = obj.sections[70].x+xofft,
                                y = obj.sections[70].y+yoff + yoffm*10,
                                w = bw,
                                h = bh}
      obj.sections[85] = {x = obj.sections[70].x+xofft,
                                y = obj.sections[70].y+yoff + yoffm*11,
                                w = bw,
                                h = bh}
      obj.sections[86] = {x = obj.sections[70].x+xofft+bw+10,
                                y = obj.sections[70].y+yoff + yoffm*12,
                                w = 40,
                                h = bh}
      obj.sections[87] = {x = obj.sections[70].x+xofft,
                                y = obj.sections[70].y+yoff + yoffm*17,
                                w = bw,
                                h = bh}
      obj.sections[88] = {x = obj.sections[70].x+xofft,
                                y = obj.sections[70].y+yoff + yoffm*13,
                                w = bw,
                                h = bh}
      obj.sections[89] = {x = obj.sections[70].x+xofft,
                                y = obj.sections[70].y+yoff + yoffm*14,
                                w = bw,
                                h = bh}
      obj.sections[95] = {x = obj.sections[70].x+xofft-75,
                                      y = obj.sections[70].y+yoff + yoffm*18,
                                      w = 150,
                                      h = bh+10}
      obj.sections[96] = {x = obj.sections[70].x+xofft,
                                 y = obj.sections[70].y+yoff + yoffm*15,
                                 w = bw,
                                 h = bh}
      obj.sections[97] = {x = obj.sections[70].x+xofft,
                                 y = obj.sections[70].y+yoff + yoffm*16,
                                 w = bw,
                                 h = bh}
      obj.sections[98] = {x = obj.sections[70].x+xofft, 
                                 y = obj.sections[70].y+yoff+10 + yoffm*19,
                                 w = bw,
                                 h = bh}
                                 
      obj.sections[700] = {x = obj.sections[70].x+obj.sections[70].w/2+xofft,
                          y = obj.sections[70].y+yoff + yoffm*0,
                          w = sw,
                          h = butt_h}
      obj.sections[701] = {x = obj.sections[70].x+obj.sections[70].w/2+xofft,
                          y = obj.sections[70].y+yoff + yoffm*1,
                          w = sw,
                          h = butt_h}
      obj.sections[702] = {x = obj.sections[70].x+obj.sections[70].w/2+xofft+bw+10,
                          y = obj.sections[70].y+yoff + yoffm*2,
                          w = 40,
                          h = bh}
      obj.sections[703] = {x = obj.sections[70].x+obj.sections[70].w/2+xofft,
                          y = obj.sections[70].y+yoff + yoffm*4,
                          w = sw,
                          h = butt_h}
      obj.sections[704] = {x = obj.sections[70].x+obj.sections[70].w/2+xofft,
                                y = obj.sections[70].y+yoff + yoffm*6,
                                w = bw,
                                h = bh}
                                
      --send midi data on track change
      obj.sections[705] = {x = obj.sections[70].x+obj.sections[70].w/2+xofft,
                                y = obj.sections[70].y+yoff + yoffm*7,
                                w = bw,
                                h = bh}
            
                                
      --Cycle
      local cw, ch = 160, 380
      obj.sections[100] = {x = obj.sections[45].x - cw - 10,
                           y = obj.sections[45].y + obj.sections[45].h - ch,
                           w = cw,
                           h = ch}

      local kw,_ = gfx.getimgdim(0)
      local kh = defctls[def_knob].cellh
      obj.sections[101] = {x = obj.sections[100].x+obj.sections[100].w/2-kw/2,
                           y = obj.sections[100].y+butt_h/2,
                           w = kw,
                           h = kh}
      obj.sections[102] = {x = obj.sections[100].x+obj.sections[100].w-40-10,
                           y = obj.sections[101].y+obj.sections[101].h+butt_h,
                           w = 40,
                           h = bh}

      obj.sections[103] = {x = obj.sections[100].x+8,
                           y = obj.sections[102].y+bh+60+butt_h,
                           w = obj.sections[100].w-16,
                           h = butt_h*8}

      obj.sections[104] = {x = obj.sections[102].x,
                           y = obj.sections[102].y-bh-2,
                           w = 40,
                           h = obj.sections[102].h}
      obj.sections[110] = {x = obj.sections[100].x +45,
                           y = obj.sections[102].y-bh-2,
                           w = 40,
                           h = obj.sections[102].h}
                           
      
      obj.sections[105] = {x = obj.sections[103].x,
                           y = obj.sections[103].y-butt_h,
                           w = obj.sections[103].w,
                           h = butt_h}
      obj.sections[106] = {x = obj.sections[103].x-2,
                           y = obj.sections[103].y+obj.sections[103].h+2,
                           w = obj.sections[103].w+4,
                           h = butt_h}
      obj.sections[107] = {x = obj.sections[102].x,
                           y = obj.sections[102].y+obj.sections[102].h+4,
                           w = bh,
                           h = bh}
      obj.sections[109] = {x = obj.sections[107].x,
                           y = obj.sections[107].y+obj.sections[107].h+4,
                           w = bh,
                           h = bh}
      obj.sections[108] = {x = obj.sections[107].x,
                           y = obj.sections[109].y+obj.sections[107].h+4,
                           w = bh,
                           h = bh}
      
      obj.sections[115] = {x = obj.sections[43].x+obj.sections[43].w+20,
                           y = obj.sections[43].y+20,
                           w = 160,
                           h = 200}
      obj.sections[116] = {x = obj.sections[115].x,
                           y = obj.sections[115].y+butt_h*4,
                           w = obj.sections[115].w,
                           h = obj.sections[115].h-(obj.sections[115].y+butt_h*4)}
      --learn track
      obj.sections[117] = {x = obj.sections[115].x,
                           y = obj.sections[115].y+butt_h,
                           w = obj.sections[115].w,
                           h = butt_h}
      --learn fx
      obj.sections[118] = {x = obj.sections[115].x,
                           y = obj.sections[115].y+butt_h*2,
                           w = obj.sections[115].w,
                           h = butt_h}
      --learn param
      obj.sections[119] = {x = obj.sections[115].x,
                           y = obj.sections[115].y+butt_h*3,
                           w = obj.sections[115].w,
                           h = butt_h}
      
      --CTL OPTIONS PG 2
      obj.sections[125] = {x = 60,
                          y = butt_h+10 + (butt_h/2+4 + 10) * 0,
                          w = obj.sections[45].w-70,
                          h = butt_h/2+8}

      obj.sections[126] = {x = 60,
                          y = butt_h+10 + (butt_h/2+4 + 10) * 5,
                          w = obj.sections[45].w-70,
                          h = butt_h}
      obj.sections[127] = {x = 60,
                          y = butt_h+6 + (butt_h/2+4 + 10) * 6,
                          w = obj.sections[45].w-70,
                          h = butt_h}
      local kwh = defctls[def_knobsm].cellh
      obj.sections[128] = {x = (obj.sections[45].w/4) - kwh/2,
                           y = butt_h+20 + (butt_h/2+4 + 10) * 1,
                          w = kwh,
                          h = kwh}
      obj.sections[129] = {x = (obj.sections[45].w*(3/4)) - kwh/2,
                           y = butt_h+20 + (butt_h/2+4 + 10) * 1,
                          w = kwh,
                          h = kwh}
      obj.sections[130] = {x = 20,
                          y = butt_h+10 + (butt_h/2+4 + 10) * 4,
                          w = obj.sections[45].w-40,
                          h = butt_h}

      obj.sections[131] = {x = 70,
                          y = butt_h + (butt_h/2+4 + 10) * 8 -8,
                          w = obj.sections[45].w-80,
                          h = butt_h}
      obj.sections[132] = {x = 70,
                          y = butt_h + (butt_h/2+4 + 10) * 9 -12,
                          w = obj.sections[45].w-80,
                          h = butt_h}
      obj.sections[133] = {x = 70,
                          y = butt_h + (butt_h/2+4 + 10) * 10 -16,
                          w = obj.sections[45].w-80,
                          h = butt_h}
      obj.sections[134] = {x = obj.sections[45].w-40-butt_h/2+4,
                          y = butt_h+6 + (butt_h/2+4 + 10) * 11 -16,
                          w = butt_h/2+4,
                          h = butt_h/2+4}                           
      obj.sections[139] = {x = obj.sections[45].w-40-butt_h/2+4,
                          y = butt_h+6 + (butt_h/2+4 + 10) * 11 + 4,
                          w = butt_h/2+4,
                          h = butt_h/2+4}                           

      obj.sections[135] = {x = 70,
                          y = butt_h+10 + (butt_h/2+4 + 10) * 13,
                          w = obj.sections[45].w-80,
                          h = butt_h/2+8}
      obj.sections[136] = {x = 70,
                          y = butt_h+10 + (butt_h/2+4 + 10) * 14,
                          w = obj.sections[45].w-80,
                          h = butt_h/2+8}
      obj.sections[137] = {x = 70,
                          y = butt_h+10 + (butt_h/2+4 + 10) * 15,
                          w = obj.sections[45].w-80,
                          h = butt_h/2+8}
      obj.sections[138] = {x = 70,
                          y = butt_h+10 + (butt_h/2+4 + 10) * 16,
                          w = obj.sections[45].w-80,
                          h = butt_h/2+8}

      --CTL OPTIONS PG 3
      obj.sections[860] = {x = obj.sections[45].w-40-butt_h/2+4,
                          y = butt_h+10 + (butt_h/2+4 + 10) * 0,
                          w = butt_h/2+4,
                          h = butt_h/2+4}
      obj.sections[861] = {x = obj.sections[45].w-40-butt_h/2+4,
                          y = butt_h+10 + (butt_h/2+4 + 10) * 1,
                          w = butt_h/2+4,
                          h = butt_h/2+4}
      obj.sections[862] = {x = obj.sections[45].w-40-butt_h/2+4,
                          y = butt_h+10 + (butt_h/2+4 + 10) * 2,
                          w = butt_h/2+4,
                          h = butt_h/2+4}
      obj.sections[863] = {x = obj.sections[45].w-40-butt_h/2+4,
                          y = butt_h+10 + (butt_h/2+4 + 10) * 4,
                          w = butt_h/2+4,
                          h = butt_h/2+4}
      
      --LBL OPTIONS 
      --EDIT
      obj.sections[140] = {x = obj.sections[49].x+20,
                          y = obj.sections[49].y+butt_h+10 + (butt_h/2+4 + 10) * 0,
                          w = obj.sections[49].w-40,
                          h = butt_h/2+8}                       

      local yo = 5
      obj.sections[141] = {x = obj.sections[49].x+50,
                          y = obj.sections[49].y+butt_h+10 + (butt_h/2+4 + 10) * 2 + yo,
                          w = obj.sections[49].w-60,
                          h = butt_h/2+4}                           

      obj.sections[142] = {x = obj.sections[49].x+obj.sections[49].w-40-butt_h/2+4,
                          y = obj.sections[49].y+butt_h+10 + (butt_h/2+4 + 10) * 3 + yo,
                          w = butt_h/2+4,
                          h = butt_h/2+4}                           
      obj.sections[143] = {x = obj.sections[49].x+obj.sections[49].w-40-butt_h/2+4,
                          y = obj.sections[49].y+butt_h+10 + (butt_h/2+4 + 10) * 4 + yo,
                          w = butt_h/2+4,
                          h = butt_h/2+4}                           
      obj.sections[144] = {x = obj.sections[49].x+obj.sections[49].w-40-butt_h/2+4,
                          y = obj.sections[49].y+butt_h+10 + (butt_h/2+4 + 10) * 5 + yo,
                          w = butt_h/2+4,
                          h = butt_h/2+4}                           
      obj.sections[145] = {x = obj.sections[49].x+obj.sections[49].w-40-butt_h/2+4,
                          y = obj.sections[49].y+butt_h+10 + (butt_h/2+4 + 10) * 6 + yo,
                          w = butt_h/2+4,
                          h = butt_h/2+4}                           
      obj.sections[146] = {x = obj.sections[49].x+obj.sections[49].w-40-butt_h/2+4,
                          y = obj.sections[49].y+butt_h+10 + (butt_h/2+4 + 10) * 7 + yo,
                          w = butt_h/2+4,
                          h = butt_h/2+4}                           

      obj.sections[147] = {x = obj.sections[49].x+20,
                          y = obj.sections[49].y+butt_h+10 + (butt_h/2+4 + 10) * 1,
                          w = obj.sections[49].w-40,
                          h = butt_h/2+8}                       

      obj.sections[148] = {x = obj.sections[49].x+50,
                          y = obj.sections[49].y+butt_h+10 + (butt_h/2+4 + 10) * 8 + yo,
                          w = obj.sections[49].w-60,
                          h = butt_h/2+4}                           
      obj.sections[149] = {x = obj.sections[49].x+50,
                          y = obj.sections[49].y+butt_h+10 + (butt_h/2+4 + 10) * 9 + yo,
                          w = obj.sections[49].w-60,
                          h = butt_h/2+4}                           
      obj.sections[150] = {x = obj.sections[49].x+50,
                          y = obj.sections[49].y+butt_h+10 + (butt_h/2+4 + 10) * 10 + yo,
                          w = obj.sections[49].w-60,
                          h = butt_h/2+4}

      obj.sections[910] = {x = obj.sections[49].x+75,
                          y = obj.sections[49].y+butt_h+10 + (butt_h/2+4 + 10) * 0 + yo,
                          w = obj.sections[49].w-85,
                          h = butt_h/2+4}                           
      obj.sections[911] = {x = obj.sections[49].x+75,
                          y = obj.sections[49].y+butt_h+10 + (butt_h/2+4 + 10) * 1 + yo,
                          w = obj.sections[49].w-85,
                          h = butt_h/2+4}                           

      obj.sections[913] = {x = obj.sections[49].x+75,
                          y = obj.sections[49].y+butt_h+10 + (butt_h/2+4 + 10) * 3 + yo,
                          w = obj.sections[49].w-85,
                          h = butt_h/2+4}                           
      obj.sections[914] = {x = obj.sections[49].x+75,
                          y = obj.sections[49].y+butt_h+10 + (butt_h/2+4 + 10) * 4 + yo,
                          w = obj.sections[49].w-85,
                          h = butt_h/2+4}                           
      obj.sections[915] = {x = obj.sections[49].x+75,
                          y = obj.sections[49].y+butt_h+10 + (butt_h/2+4 + 10) * 5 + yo,
                          w = obj.sections[49].w-85,
                          h = butt_h/2+4}                           
      obj.sections[916] = {x = obj.sections[49].x+75,
                          y = obj.sections[49].y+butt_h+10 + (butt_h/2+4 + 10) * 6 + yo,
                          w = obj.sections[49].w-85,
                          h = butt_h/2+4}                           
      
      obj.sections[912] = {x = obj.sections[49].x+20,
                          y = obj.sections[49].y+butt_h+10 + (butt_h/2+4 + 10) * 7 + 12,
                          w = obj.sections[49].w-40,
                          h = butt_h/2+8}                       
      
      obj.sections[917] = {x = obj.sections[49].x+75,
                                y = obj.sections[49].y+butt_h+10 + (butt_h/2+4 + 10) * 9,
                                w = obj.sections[49].w-85,
                                h = butt_h/2+8}                           
      obj.sections[918] = {x = obj.sections[49].x+75,
                          y = obj.sections[49].y+butt_h+10 + (butt_h/2+4 + 10) * 10,
                          w = obj.sections[49].w-125,
                          h = butt_h/2+8}   
                                           
      --SNAPSHOTS
      local ssh = snaph-160
      obj.sections[160] = {}
      obj.sections[160].w = 160
      obj.sections[160].h = snaph
      if ss160 == nil then
        obj.sections[160] = {x = gfx1.main_w - 160 - (sb_size+2),
                            y = gfx1.main_h - snaph - (sb_size+2),
                            w = 160,
                            h = snaph}                            
        if snapshot_win_pos and snapshot_win_pos.x and snapshot_win_pos.y then
          obj.sections[160].x = snapshot_win_pos.x
          obj.sections[160].y = snapshot_win_pos.y
        end        
        if obj.sections[160].x + obj.sections[160].w > gfx1.main_w then
          obj.sections[160].x = math.max(gfx1.main_w - obj.sections[160].w,obj.sections[10].x)
        end
        if obj.sections[160].y + obj.sections[160].h > gfx1.main_h then
          obj.sections[160].y = math.max(gfx1.main_h - obj.sections[160].h,obj.sections[10].y)
        end
      else
        obj.sections[160] = ss160
        if snapshot_win_pos and snapshot_win_pos.x and snapshot_win_pos.y then
          obj.sections[160].x = snapshot_win_pos.x
          obj.sections[160].y = snapshot_win_pos.y
        end        
        if obj.sections[160].x + obj.sections[160].w > gfx1.main_w then
          obj.sections[160].x = math.max(gfx1.main_w - obj.sections[160].w,obj.sections[10].x)
        end
        if obj.sections[160].y + obj.sections[160].h > gfx1.main_h then
          obj.sections[160].y = math.max(gfx1.main_h - obj.sections[160].h,obj.sections[10].y)
        end
      end
      obj.sections[160].x = math.max(obj.sections[160].x,obj.sections[10].x)      
      obj.sections[160].y = math.max(obj.sections[160].y,obj.sections[10].y)
      
      obj.sections[161] = {x = 30,
                          y = butt_h+10 + (butt_h/2+2 + 10) * 0,
                          w = obj.sections[160].w-20-20,
                          h = butt_h}                       
      obj.sections[162] = {x = 10,
                          y = butt_h+10 + (butt_h/2+2 + 10) * 4,
                          w = obj.sections[160].w-20,
                          h = butt_h+8}                       
      obj.sections[163] = {x = 10,
                          y = butt_h+10 + (butt_h/2+4 + 10) * 5,
                          w = obj.sections[160].w-20,
                          h = ssh}                       
      obj.sections[164] = {x = 10,
                          y = butt_h+10 + (butt_h/2+2 + 10) * 3,
                          w = (obj.sections[160].w-20)/2 - 1,
                          h = butt_h}                      

      obj.sections[165] = {x = 0,
                          y = obj.sections[160].h-12,
                          w = obj.sections[160].w,
                          h = 12}                       
      obj.sections[166] = {x = 10,
                          y = butt_h+10 + (butt_h/2+2 + 10) * 2,
                          w = (obj.sections[160].w-20)/2 - 1,
                          h = butt_h}                       
      obj.sections[167] = {x = 12 + (obj.sections[160].w-20)/2 +1,
                          y = butt_h+10 + (butt_h/2+2 + 10) * 2,
                          w = (obj.sections[160].w-20)/2 - 3,
                          h = butt_h*2+2}                       
      obj.sections[168] = {x = 10,
                          y = butt_h+10 + (butt_h/2+2 + 10) * 0,
                          w = 18,
                          h = butt_h/2+8}                       
      obj.sections[169] = {x = 12 + (obj.sections[160].w-20)/2 +1,
                          y = butt_h+10 + (butt_h/2+2 + 10) * 1,
                          w = (obj.sections[160].w-20)/2 - 3,
                          h = butt_h}                       
      obj.sections[224] = {x = 10,
                          y = butt_h+10 + (butt_h/2+2 + 10) * 1,
                          w = (obj.sections[160].w-20)/2 - 1,
                          h = butt_h}                       
      
      --Action chooser
      obj.sections[170] = {x = obj.sections[10].x+20,
                           y = obj.sections[10].y+20,
                           w = math.min(obj.sections[10].w-40,750),
                           h = obj.sections[10].h-40}
      obj.sections[171] = {x = obj.sections[170].x+10,
                           y = obj.sections[170].y+10+butt_h,
                           w = obj.sections[170].w-20,
                           h = obj.sections[170].h-60-butt_h}
      obj.sections[172] = {x = obj.sections[171].x,
                           y = obj.sections[171].y+obj.sections[171].h + 15,
                           w = 150,
                           h = butt_h}
      obj.sections[173] = {x = obj.sections[172].x+obj.sections[172].w+10,
                           y = obj.sections[172].y,
                           w = 150,
                           h = butt_h}
      obj.sections[174] = {x = obj.sections[171].x+obj.sections[171].w-310,
                           y = obj.sections[172].y,
                           w = 150,
                           h = butt_h}
      obj.sections[175] = {x = obj.sections[171].x+obj.sections[171].w-150,
                           y = obj.sections[172].y,
                           w = 150,
                           h = butt_h}
      --FLOATING SNAPS
      obj.sections[180] = {x = 0,
                          y = 0,
                          w = 138,
                          h = fsnaph}                            
      obj.sections[181] = {x = 3,
                          y = 2,
                          w = obj.sections[180].w-6,
                          h = obj.sections[180].h-12}                       
      obj.sections[182] = {x = 0,
                          y = obj.sections[180].h-6,
                          w = obj.sections[180].w,
                          h = 6}
      --CTL BROWSER
      ctl_browser_size = {w = obj.sections[10].w - 100 - obj.sections[45].w, h = obj.sections[10].h -100}
      local slsz = 100
      local cb_bw = 160
      ctl_browser_size.slotsz = slsz
      ctl_browser_size.slots_x = math.max(math.floor((ctl_browser_size.w - 20 - cb_bw) / slsz),3)
      ctl_browser_size.slots_y = math.max(math.floor((ctl_browser_size.h - (butt_h+2)*2 -20) / slsz),3)
      obj.sections[200] = {x = (obj.sections[10].w-ctl_browser_size.w)/2 +obj.sections[10].x,
                          y = (obj.sections[10].h-ctl_browser_size.h)/2 +obj.sections[10].y,
                          w = ctl_browser_size.w,
                          h = ctl_browser_size.h}                            
      obj.sections[210] = {x = obj.sections[200].x + cb_bw+10,
                           y = obj.sections[200].y + (butt_h*2)+10,
                           w = ctl_browser_size.slots_x * slsz,
                           h = ctl_browser_size.slots_y * slsz}
      obj.sections[200].w = obj.sections[210].w + cb_bw+10 + 4
      obj.sections[200].h = obj.sections[210].h + (butt_h*2)+10 + 4
      obj.sections[213] = {x = obj.sections[200].x+4,
                           y = obj.sections[200].y+(butt_h+2) * 13,
                           w = cb_bw,
                           h = obj.sections[200].h -(butt_h+2) * 13 - 6}
      
      obj.sections[201] = {x = obj.sections[200].x,
                           y = obj.sections[200].y+(butt_h+2) * 1,
                           w = cb_bw,
                           h = butt_h}
      obj.sections[202] = {x = obj.sections[200].x,
                           y = obj.sections[200].y+(butt_h+2) * 2,
                           w = cb_bw,
                           h = butt_h}
      obj.sections[203] = {x = obj.sections[200].x,
                           y = obj.sections[200].y+(butt_h+2) * 3,
                           w = cb_bw,
                           h = butt_h}
      obj.sections[204] = {x = obj.sections[200].x,
                           y = obj.sections[200].y+(butt_h+2) * 4,
                           w = cb_bw,
                           h = butt_h}
      obj.sections[205] = {x = obj.sections[200].x,
                           y = obj.sections[200].y+(butt_h+2) * 5,
                           w = cb_bw,
                           h = butt_h}
      obj.sections[206] = {x = obj.sections[200].x,
                           y = obj.sections[200].y+(butt_h+2) * 6,
                           w = cb_bw,
                           h = butt_h}
      obj.sections[211] = {x = obj.sections[200].x + obj.sections[200].w - 220-1,
                           y = obj.sections[200].y + butt_h+4,
                           w = 60,
                           h = butt_h}
      obj.sections[212] = {x = obj.sections[200].x + obj.sections[200].w -160 +1,
                           y = obj.sections[200].y + butt_h+4,
                           w = 60,
                           h = butt_h}
      
      local margin = 4
      local shrink = math.max(butt_h-topbarheight,0)
      obj.sections[220] = {x = margin,
                           y = butt_h+margin,
                           w = gfx1.main_w-160-margin*2,
                           h = obj.sections[10].h-shrink-margin*2}                     
      obj.sections[221] = {x = obj.sections[220].x+obj.sections[220].w+2,
                           y = butt_h+margin,
                           w = 160,
                           h = obj.sections[10].h-shrink-margin*2}                     
      obj.sections[222] = {x = obj.sections[220].x+obj.sections[220].w+2,
                           y = 0,
                           w = 160,
                           h = butt_h}                     

      local ssh2 = obj.sections[221].h - (butt_h+10) - (butt_h/2+4 + 10) * 6 - 10
      obj.sections[223] = {x = 10,
                          y = butt_h+10 + (butt_h/2+4 + 10) * 2,
                          w = obj.sections[221].w-20,
                          h = ssh2}                       

      obj.sections[225] = {x = 60,
                           y = butt_h+10 + (butt_h/2+4 + 10) * 1,
                           w = 90,
                           h = butt_h/2+4}                     
      obj.sections[226] = {x = 10,
                          y = butt_h+6 + (butt_h/2+2 + 10) * 0,
                          w = obj.sections[221].w-20,
                          h = butt_h+2}                       

      obj.sections[232] = {x = 25,
                          y = obj.sections[223].y + obj.sections[223].h + butt_h + 10,
                          w = obj.sections[221].w-35,
                          h = butt_h+2}                       
      obj.sections[233] = {x = 25,
                          y = obj.sections[223].y + obj.sections[223].h + (butt_h + 10)*2 - 8,
                          w = obj.sections[221].w-35,
                          h = butt_h+2}                       
      obj.sections[235] = {x = 10,
                          y = obj.sections[223].y + obj.sections[223].h + (butt_h + 10)*3 - 10,
                          w = obj.sections[221].w-20,
                          h = butt_h+2}                       

      obj.sections[227] = {x = 10,
                          y = butt_h+10 + (butt_h/2+2 + 10) * 2,
                          w = obj.sections[221].w-20,
                          h = butt_h+2}                       
      obj.sections[228] = {x = 10,
                          y = butt_h+10 + (butt_h/2+2 + 10) * 1,
                          w = obj.sections[221].w-20,
                          h = butt_h+2}                       
      obj.sections[229] = {x = 10,
                          y = butt_h+10 + (butt_h/2+2 + 10) * 0,
                          w = obj.sections[221].w-20,
                          h = butt_h+2}                       

      obj.sections[231] = {x = 10,
                          y = butt_h+10 + (butt_h/2+2 + 10) * 4,
                          w = obj.sections[221].w-20,
                          h = butt_h+2}                       

      obj.sections[230] = {x = obj.sections[220].x,
                          y = 2,
                          w = obj.sections[220].w,
                          h = obj.sections[220].y-4}                       


      --macros
      --exit macro learn param
      obj.sections[250] = {x = obj.sections[10].x + obj.sections[10].w - 120,
                          y = obj.sections[10].y + obj.sections[10].h - 60,
                          w = 100,
                          h = butt_h*2}                       

      --eq control
      obj.sections[300] = {x = obj.sections[10].x,
                           y = obj.sections[10].y,
                           w = obj.sections[10].w,
                           h = obj.sections[10].h}                       
      obj.sections[301] = {x = 0,
                           y = 0,
                           w = obj.sections[300].w,
                           h = 0}                       
      obj.sections[302] = {x = 40,
                           y = butt_h,
                           w = math.max(obj.sections[300].w-80,400),
                           h = math.max(obj.sections[300].h-butt_h-220,160)}
      obj.sections[303] = {x = 100,
                           y = obj.sections[302].y + obj.sections[302].h + 20,
                           w = obj.sections[300].w-120,
                           h = butt_h+10}
      obj.sections[304] = {x = 20,
                           y = obj.sections[302].y + obj.sections[302].h + 20,
                           w = 60,
                           h = butt_h}
      obj.sections[305] = {x = 100,
                           y = obj.sections[304].y + obj.sections[304].h + 44,
                           w = 300,
                           h = butt_h}
      obj.sections[306] = {x = 100,
                           y = obj.sections[305].y + obj.sections[305].h + 10,
                           w = 110,
                           h = butt_h}
      obj.sections[307] = {x = 100,
                           y = obj.sections[306].y + obj.sections[306].h + 4,
                           w = 110,
                           h = butt_h}
      obj.sections[308] = {x = 100,
                           y = obj.sections[307].y + obj.sections[307].h + 4,
                           w = 110,
                           h = butt_h}
      obj.sections[309] = {x = 520,
                           y = obj.sections[304].y + obj.sections[304].h + 20,
                           w = 100,
                           h = butt_h}
      obj.sections[310] = {x = 625,
                           y = obj.sections[304].y + obj.sections[304].h + 20,
                           w = 50,
                           h = butt_h}
      obj.sections[311] = {x = 20,
                           y = obj.sections[304].y + obj.sections[304].h + 20,
                           w = 60,
                           h = butt_h}
      obj.sections[312] = {x = 20,
                           y = obj.sections[311].y + obj.sections[311].h + 4,
                           w = 60,
                           h = butt_h}
      obj.sections[313] = {x = 100,
                           y = obj.sections[304].y + obj.sections[304].h + 20,
                           w = 120,
                           h = butt_h}
      obj.sections[314] = {x = 225,
                           y = obj.sections[304].y + obj.sections[304].h + 20,
                           w = 175,
                           h = butt_h}
      obj.sections[315] = {x = 20,
                           y = obj.sections[312].y + obj.sections[312].h + 4,
                           w = 60,
                           h = butt_h}
      obj.sections[316] = {x = 625,
                           y = obj.sections[310].y + obj.sections[310].h + 4,
                           w = 50,
                           h = butt_h}
      obj.sections[317] = {x = 215,
                           y = obj.sections[306].y + obj.sections[306].h + 4,
                           w = 40,
                           h = butt_h}
      obj.sections[318] = {x = 215,
                           y = obj.sections[317].y + obj.sections[317].h + 4,
                           w = 40,
                           h = butt_h}

      obj.sections[351] = {x = obj.sections[302].x+obj.sections[302].w+4,
                           y = obj.sections[302].y,
                           w = 32,
                           h = 32}
      obj.sections[320] = {x = obj.sections[302].x+obj.sections[302].w+4,
                           y = obj.sections[302].y + (32+2) * 2 -16,
                           w = 32,
                           h = 32}
      obj.sections[321] = {x = obj.sections[302].x+obj.sections[302].w+4,
                           y = obj.sections[302].y + (32+2) * 3 -16,
                           w = 32,
                           h = 32}
      obj.sections[322] = {x = 260,
                           y = obj.sections[305].y + obj.sections[305].h + 10,
                           w = 110,
                           h = butt_h}
      obj.sections[323] = {x = 260,
                           y = obj.sections[306].y + obj.sections[306].h + 4,
                           w = 110,
                           h = butt_h}
      obj.sections[324] = {x = 260,
                           y = obj.sections[307].y + obj.sections[307].h + 4,
                           w = 110,
                           h = butt_h}
      
      local w = gfx.getimgdim(def_eqcknobf)
      local h = ctl_files[def_eqcknobfctl].cellh
      
      local panw = 615+48-120
      obj.sections[350] = {x = math.max(obj.sections[302].x + (obj.sections[302].w/2) - panw/2,120),
                           y = obj.sections[303].y + 75,
                           w = panw,
                           h = obj.sections[300].h - (obj.sections[303].y + 75)}
      
      obj.sections[325] = {x = obj.sections[350].x,
                           y = obj.sections[303].y + 75,
                           w = w,
                           h = h+20}
      local w = gfx.getimgdim(def_eqcknobg)
      local h = ctl_files[def_eqcknobgctl].cellh
      obj.sections[326] = {x = obj.sections[350].x+70,
                           y = obj.sections[303].y + 75,
                           w = w,
                           h = h+20}
      obj.sections[327] = {x = obj.sections[350].x+140,
                           y = obj.sections[303].y + 75,
                           w = w,
                           h = h+20}

      local w = gfx.getimgdim(def_knobsm)
      local h = ctl_files[def_knobsmctl].cellh
      obj.sections[328] = {x = obj.sections[350].x+255,
                           y = obj.sections[303].y + 75,
                           w = w,
                           h = h+20}
      obj.sections[329] = {x = obj.sections[350].x+315,
                           y = obj.sections[303].y + 75,
                           w = w,
                           h = h+20}
      obj.sections[330] = {x = obj.sections[350].x+375,
                           y = obj.sections[303].y + 75,
                           w = w,
                           h = h+20}
      obj.sections[334] = {x = obj.sections[350].x+435,
                           y = obj.sections[303].y + 75,
                           w = w,
                           h = h+20}
      obj.sections[335] = {x = obj.sections[350].x+495,
                           y = obj.sections[303].y + 75,
                           w = w,
                           h = h+20}

      obj.sections[331] = {x = 375,
                           y = obj.sections[305].y + obj.sections[305].h + 10,
                           w = 110,
                           h = butt_h}
      obj.sections[332] = {x = 375,
                           y = obj.sections[331].y + obj.sections[331].h + 4,
                           w = 110,
                           h = butt_h}
      obj.sections[333] = {x = 375,
                           y = obj.sections[332].y + obj.sections[332].h + 4,
                           w = 110,
                           h = butt_h}
      obj.sections[337] = {x = obj.sections[309].x,
                           y = obj.sections[309].y + obj.sections[309].h + 4,
                           w = 100,
                           h = butt_h/2+4}
      obj.sections[338] = {x = obj.sections[309].x,
                           y = obj.sections[337].y + obj.sections[337].h + 4,
                           w = 100,
                           h = 56}
      obj.sections[336] = {x = obj.sections[309].x,
                           y = obj.sections[338].y + obj.sections[338].h + 4,
                           w = 100,
                           h = butt_h}
      
      obj.sections[340] = {x = 20,
                           y = obj.sections[315].y + obj.sections[315].h + 4,
                           w = 60,
                           h = butt_h}
      
      obj.sections[345] = {x = obj.sections[302].x+obj.sections[302].w+4,
                           y = obj.sections[302].y + (32+2) * 4 - 16,
                           w = 32,
                           h = 32}
      obj.sections[355] = {x = 405,
                           y = obj.sections[313].y,
                           w = butt_h * 2 + 5,
                           h = butt_h * 2 + 4}

      obj.sections[356] = {x = 100,
                           y = obj.sections[308].y + obj.sections[308].h + 10,
                           w = 200,
                           h = butt_h}

      obj.sections[357] = {x = 625,
                           y = obj.sections[316].y + obj.sections[316].h + 10,
                           w = 50,
                           h = (obj.sections[338].y + obj.sections[338].h)-(obj.sections[316].y + obj.sections[316].h+6) + butt_h}
      
      macroedit = {}
      macroedit.secyoff = 100
      macroedit.sech = 40
      macroedit.pcnt = math.floor((obj.sections[300].h-macroedit.secyoff-10)/macroedit.sech)
      macroedit.h = macroedit.pcnt*macroedit.sech
      macroedit.sliderw = 12
      macroedit.sliderh = 24

      obj.sections[401] = {x = obj.sections[300].w-16,
                           y = 0,
                           w = 16,
                           h = 16}
                          
      --Param name
      local sw = math.max(math.floor((obj.sections[300].w-470)/2),120)
      
      obj.sections[402] = {x = 20,
                           y = macroedit.secyoff,
                           w = 250,
                           h = macroedit.sech}
      --A
      obj.sections[403] = {x = obj.sections[402].x+obj.sections[402].w+20,
                           y = macroedit.secyoff,
                           w = sw,
                           h = macroedit.h}
      --B
      obj.sections[404] = {x = obj.sections[403].x+obj.sections[403].w+26,
                           y = macroedit.secyoff,
                           w = sw,
                           h = macroedit.h}
      obj.sections[405] = {x = obj.sections[404].x + obj.sections[404].w + 14,
                           y = macroedit.secyoff,
                           w = math.max(obj.sections[300].w - (obj.sections[404].x+obj.sections[404].w)-30,100),
                           h = macroedit.h}

      obj.sections[407] = {x = obj.sections[402].x+5,
                           y = macroedit.secyoff,
                           w = 20,
                           h = macroedit.h}
      obj.sections[406] = {x = obj.sections[402].x+obj.sections[402].w-25,
                           y = macroedit.secyoff,
                           w = 20,
                           h = macroedit.h}
      
      obj.sections[408] = {x = obj.sections[404].x + 10,
                           y = 30,
                           w = obj.sections[404].w-20,
                           h = butt_h+2} 

      obj.sections[409] = {x = 40,
                           y = 20,
                           w = obj.sections[402].w-40,
                           h = butt_h*3} 
      
      local w = gfx.getimgdim(def_eqcknobf)
      local h = ctl_files[def_eqcknobfctl].cellh
            
      obj.sections[410] = {x = obj.sections[405].x + math.floor(obj.sections[405].w/2 - w/2),
                           y = obj.sections[405].y /2 - math.floor(h/2),
                           w = w,
                           h = h}

      obj.sections[411] = {x = obj.sections[403].x + 10,
                           y = obj.sections[409].y+obj.sections[409].h-(butt_h+4),
                           w = obj.sections[403].w-20,
                           h = butt_h+4} 
      obj.sections[412] = {x = obj.sections[404].x + 10,
                           y = obj.sections[411].y,
                           w = obj.sections[404].w - 20,
                           h = butt_h+4} 
      obj.sections[413] = {x = obj.sections[403].x + 10,
                           y = 30,
                           w = obj.sections[403].w-20,
                           h = butt_h+2} 

      obj.sections[414] = {x = obj.sections[402].x+obj.sections[402].w-75,
                           y = macroedit.secyoff,
                           w = 20,
                           h = macroedit.h} 
      obj.sections[415] = {x = obj.sections[402].x+obj.sections[402].w-50,
                           y = macroedit.secyoff,
                           w = 20,
                           h = macroedit.h} 
      obj.sections[416] = {x = obj.sections[402].x+obj.sections[402].w-100,
                           y = macroedit.secyoff,
                           w = 20,
                           h = macroedit.h} 


      --MIDI OUt
      local mow, moh = 350, 430
      obj.sections[950] = {x = math.floor(obj.sections[10].x+obj.sections[10].w/2 - mow/2),
                           y = math.floor(obj.sections[10].y+obj.sections[10].h/2 - moh/2),
                           w = mow,
                           h = moh} 
      obj.sections[951] = {x = obj.sections[950].x+100,
                           y = obj.sections[950].y+butt_h*3,
                           w = obj.sections[950].w-120,
                           h = butt_h} 
      obj.sections[952] = {x = obj.sections[950].x+100,
                           y = obj.sections[950].y+butt_h*3 + (butt_h+10) * 2,
                           w = 60,
                           h = butt_h} 
      obj.sections[953] = {x = obj.sections[952].x+obj.sections[952].w+80,
                           y = obj.sections[950].y+butt_h*3 + (butt_h+10) * 2,
                           w = 60,
                           h = butt_h}
      obj.sections[954] = {x = obj.sections[950].x+100,
                           y = obj.sections[950].y+butt_h*3 + (butt_h+10) * 1,
                           w = obj.sections[950].w-120,
                           h = butt_h} 

      obj.sections[955] = {x = obj.sections[950].x+100,
                           y = obj.sections[950].y+butt_h*3 + (butt_h+10) * 5,
                           w = obj.sections[950].w-120,
                           h = butt_h} 

      obj.sections[956] = {x = obj.sections[950].x+100,
                           y = obj.sections[950].y+butt_h*3 + (butt_h+10) * 8,
                           w = 60,
                           h = butt_h} 
      obj.sections[957] = {x = obj.sections[952].x+obj.sections[952].w+80,
                           y = obj.sections[950].y+butt_h*3 + (butt_h+10) * 8,
                           w = 60,
                           h = butt_h}
      obj.sections[958] = {x = obj.sections[952].x+obj.sections[952].w+80,
                           y = obj.sections[950].y+butt_h*3 + (butt_h+10) * 9,
                           w = 60,
                           h = butt_h}
      obj.sections[959] = {x = obj.sections[952].x+obj.sections[952].w+80,
                           y = obj.sections[950].y+butt_h*3 + (butt_h+10) * 10,
                           w = butt_h/2+4,
                           h = butt_h/2+4}
      obj.sections[961] = {x = obj.sections[952].x+obj.sections[952].w+80,
                           y = obj.sections[950].y+butt_h*3 + (butt_h+10) * 11,
                           w = butt_h/2+4,
                           h = butt_h/2+4}
      
      local mow, moh = 300, 150
      obj.sections[980] = {x = math.floor(obj.sections[10].x+obj.sections[10].w/2 - mow/2),
                           y = math.floor(obj.sections[10].y+obj.sections[10].h/2 - moh/2),
                           w = mow,
                           h = moh}
      obj.sections[981] = {x = obj.sections[980].x+100,
                           y = obj.sections[980].y+butt_h*2,
                           w = obj.sections[980].w-120,
                           h = butt_h} 
      obj.sections[983] = {x = obj.sections[980].x+140,
                           y = obj.sections[980].y+butt_h*3.5,
                           w = obj.sections[980].w-160,
                           h = butt_h} 

      obj.sections[982] = {x = obj.sections[980].x+200,
                           y = obj.sections[980].y+butt_h*5.5,
                           w = 60,
                           h = butt_h} 
       
    return obj
  end
  
  -----------------------------------------------------------------------     
  
  function GetGUI_vars()
    gfx.mode = gmode
    
    local gui = {}
      gui.aa = 1
      gui.fontname = fontname_def
      gui.fontsize_tab = 20   
      gui.fontsz_knob = fontsize_def
      --gui.fontsz_get = fontsize_def

      if OS == "OSX32" or OS == "OSX64" then gui.fontsize_tab = gui.fontsize_tab - 5 end
      if OS == "OSX32" or OS == "OSX64" then gui.fontsz_knob = gui.fontsz_knob - 5 end
      --if OS == "OSX32" or OS == "OSX64" then gui.fontsz_get = gui.fontsz_get - 5 end
      
      gui.color = {['back'] = '71 71 71 ',
                 ['back2'] = '51 63 56',
                 ['black'] = '0 0 0',
                 ['green'] = '102 255 102',
                 ['green1'] = '0 120 169', --'0 156 36',
                 ['green_dark1'] = '0 76 0',
                 ['blue'] = '127 204 255',
                 ['white'] = '205 205 205',
                 ['red'] = '255 0 0',
                 ['green_dark'] = '102 153 102',
                 ['yellow'] = '200 200 0',
                 ['yellow1'] = '160 160 0',
                 ['bryellow'] = '220 220 0',
                 ['cbobg'] = '4 4 4',
                 ['cbobg2'] = '64 64 64',
                 ['grey'] = '0 13 25', --'64 64 64',
                 ['grey1'] = '0 25 50', --'32 32 32',
                 ['dgrey1'] = '0 25 50', --'16 16 16',
                 ['dgrey2'] = '16 16 16',
                 ['red1'] = '165 8 46',
                 ['red2'] = '93 4 28',
                 ['red3'] = '200 13 66',
                 ['blue1'] = '0 120 169',
                 ['dblue1'] = '0 25 50',
                 ['backg'] = '5 0 10'
               }
    return gui
  end  
  ------------------------------------------------------------
      
  function f_Get_SSV(s)
    if not s then return end
    local t = {}
    for i in s:gmatch("[%d%.]+") do 
      t[#t+1] = tonumber(i) / 255
    end
    gfx.r, gfx.g, gfx.b = t[1], t[2], t[3]
  end
  
  function ConvertColor(c)
    local r = (c & 255)
    local g = (c >> 8 & 255)
    local b = (c >> 16 & 255)
    return math.floor(r) .. ' ' .. math.floor(g) .. ' ' .. math.floor(b)
  end

  function ConvertColorString(s)
    if not s then return end
    local t = {}
    for i in s:gmatch("[%d%.]+") do 
      t[#t+1] = tonumber(i)
    end
    return t[1] + (t[2] << 8) + (t[3] << 16)
  end
  
  ------------------------------------------------------------
    
  function GUI_text(gui, xywh, text)
        f_Get_SSV(gui.color.white)  
        gfx.a = 1 
        gfx.setfont(1, gui.fontname, gui.fontsz_knob)
        local text_len = gfx.measurestr(text)
        gfx.x, gfx.y = xywh.x+(xywh.w-text_len)/2,xywh.y+(xywh.h-gfx.texth)/2 + 1
        gfx.drawstr(text)
  end
  
  function GUI_textXY(gui, x, y, text, col, fsz)
        f_Get_SSV(col)  
        gfx.a = 1 
        gfx.x, gfx.y = x,y
        gfx.drawstr(text)
  end
  
  function GUI_textsm_LJ(gui, xywh, text, c, offs, limitx)
        text = nz(text,'')
        f_Get_SSV(c)  
        gfx.a = 1 
        gfx.setfont(1, gui.fontname, gui.fontsz_knob + offs)
        local text_len, newlen = gfx.measurestr(text), string.len(text)
        if limitx ~= nil and text_len+4 > limitx then
          for l = string.len(text), 1, -2 do
            text_len = gfx.measurestr(string.sub(text,0,l))+4
            if text_len <= limitx then newlen = l break end
          end
        end
        gfx.x, gfx.y = xywh.x+4,xywh.y+(xywh.h-gfx.texth)/2 + 1
        gfx.drawstr(string.sub(text,1,newlen))
  end

  function GUI_textsm_CJ(gui, xywh, text, c, offs, limitx)
        text = nz(text,'')
        f_Get_SSV(c)  
        gfx.a = 1 
        gfx.setfont(1, gui.fontname, gui.fontsz_knob + offs)
        local text_len, newlen = gfx.measurestr(text), string.len(text)
        if limitx ~= nil and text_len+4 > limitx then
          for l = string.len(text), 1, -2 do
            text_len = gfx.measurestr(string.sub(text,0,l))+4
            if text_len <= limitx then newlen = l break end
          end
        end
        gfx.x, gfx.y = xywh.x+(xywh.w-text_len)/2,xywh.y+(xywh.h-gfx.texth)/2 + 1
        gfx.drawstr(string.sub(text,1,newlen))
  end

  function GUI_textsm_RJ(gui, xywh, text, c, offs)
        f_Get_SSV(c)  
        gfx.a = 1 
        gfx.setfont(1, gui.fontname, gui.fontsz_knob + offs)
        local text_len = gfx.measurestr(text)
        gfx.x, gfx.y = xywh.x+xywh.w-text_len, xywh.y+(xywh.h-gfx.texth)/2 + 1
        gfx.drawstr(text)
  end
  
  function GUI_textC(gui, xywh, text, color, offs, alpha, yoff)
        f_Get_SSV(color)  
        if alpha then gfx.a = alpha else gfx.a = 1 end
        if yoff == nil then yoff = 0 end 
        gfx.setfont(1, gui.fontname, gui.fontsz_knob + offs)
        local text_len = gfx.measurestr(text)
        gfx.x, gfx.y = xywh.x+(xywh.w-text_len)/2,xywh.y+(xywh.h-gfx.texth)/2 + 1 + yoff
        gfx.drawstr(text)
  end

  function GUI_textCtl(gui, xywh, text, color, offs, alpha, yoff)
        f_Get_SSV(color)  
        if alpha then gfx.a = alpha else gfx.a = 1 end
        if yoff == nil then yoff = 0 end 
        --gfx.setfont(1, gui.fontname, gui.fontsz_knob + offs)
        local text_len = gfx.measurestr(text)
        gfx.x, gfx.y = xywh.x+(xywh.w-text_len)/2,xywh.y+(xywh.h-gfx.texth)/2 + 1 + yoff
        gfx.drawstr(text)
  end

  function GUI_textC_LIM(gui, xywh, text, color, offs)
        text = nz(text,'')
        f_Get_SSV(color)  
        gfx.a = 1 
        gfx.setfont(1, gui.fontname, gui.fontsz_knob + offs)
        local text_len, newlen = gfx.measurestr(text), string.len(text)
        if text_len > xywh.w then
          for l = string.len(text), 1, -2 do
            text_len = gfx.measurestr(string.sub(text,0,l))
            if text_len <= xywh.w then newlen = l break end
          end
        end
        if xywh.w < 20 then return end
        if newlen < string.len(text) then
          gfx.x, gfx.y = xywh.x+2,xywh.y+(xywh.h-gfx.texth)/2 + 1
        else
          gfx.x, gfx.y = xywh.x+(xywh.w-text_len)/2,xywh.y+(xywh.h-gfx.texth)/2 + 1
        end
        gfx.drawstr(string.sub(text,1,newlen))
  end
  
  ------------------------------------------------------------
  
  function CropFXName(n)
  
    if n == nil then
      return ""
    else
      local fxn = string.match(n, ':(.+)%(')
      if fxn then
        return fxn
      else
        return n
      end
    end
    
  end
  
------------------------------------------------------------    

  function Strip_AddGFX(type)

    --loadimg and set imageidx in graphics_files and strip.graphics
    if tracks[track_select] then
    
      local strip = Strip_INIT()
      
      if type == gfxtype.img then
        if graphics_files[graphics_folder_files[gfx_select]].imageidx == nil then
          local iidx = LoadGraphics(graphics_files[graphics_folder_files[gfx_select]].fn)
          if iidx then
            local w, h = gfx.getimgdim(iidx)      
            if w == 0 or h == 0 then OpenMsgBox(1, 'Invalid gfx file: '..graphics_files[graphics_folder_files[gfx_select]].fn, 1) return end
            --DBG(iidx..'  '..image_count)
            if iidx > image_count then
              image_count = iidx
            end
            graphics_files[graphics_folder_files[gfx_select]].imageidx = iidx
          end  
          --[[image_count = F_limit(image_count + 1,0,image_max)
          gfx.loadimg(image_count, graphics_path..graphics_files[gfx_select].fn)
          graphics_files[gfx_select].imageidx = image_count]]
        end
  
        local x,y
        x = math.floor((draggfx.x)/settings_gridsize)*settings_gridsize + math.floor(surface_offset.x/settings_gridsize)*settings_gridsize - math.floor((obj.sections[10].x)/settings_gridsize)*settings_gridsize
        y = math.floor((draggfx.y)/settings_gridsize)*settings_gridsize + math.floor(surface_offset.y/settings_gridsize)*settings_gridsize - math.floor((obj.sections[10].y)/settings_gridsize)*settings_gridsize
        local w, h = gfx.getimgdim(graphics_files[graphics_folder_files[gfx_select]].imageidx)      
        gfxnum = #strips[strip][page].graphics + 1
        strips[strip][page].graphics[gfxnum] = {gfxtype = type,
                                          fn = graphics_files[graphics_folder_files[gfx_select]].fn,
                                          imageidx = graphics_files[graphics_folder_files[gfx_select]].imageidx,
                                          x = x,
                                          y = y,
                                          w = w,
                                          h = h,
                                          scale = 1,
                                          stretchw = w,
                                          stretchh = h,
                                          font = {idx = nil,
                                                  name = nil,
                                                  size = nil,
                                                  bold = nil,
                                                  italics = nil,
                                                  underline = nil,
                                                  shadow = nil
                                                  },
                                          text = nil,
                                          text_col = nil,
                                          poslock = false,
                                          bright = 0.5,
                                          contr = 0.5,
                                          rmult = 0.5,
                                          gmult = 0.5,
                                          bmult = 0.5,
                                          alpha = 1,
                      stretchmode = 1,
                                          edgesz = 8,
                                         }
      elseif type == gfxtype.txt then
        local x,y
        x = math.floor((label_add.x)/settings_gridsize)*settings_gridsize + math.floor(surface_offset.x/settings_gridsize)*settings_gridsize - math.floor((obj.sections[10].x)/settings_gridsize)*settings_gridsize
        y = math.floor((label_add.y)/settings_gridsize)*settings_gridsize + math.floor(surface_offset.y/settings_gridsize)*settings_gridsize - math.floor((obj.sections[10].y)/settings_gridsize)*settings_gridsize
        local w, h = 50, 50--gfx.getimgdim(graphics_files[gfx_select].imageidx)      
        gfxnum = #strips[strip][page].graphics + 1
        strips[strip][page].graphics[gfxnum] = {gfxtype = type,
                                          fn = '',
                                          imageidx = -1,
                                          x = x,
                                          y = y,
                                          w = w,
                                          h = h,
                                          scale = 1,
                                          stretchw = w,
                                          stretchh = h,
                                          font = {idx = gfx_font_select.idx,
                                                  name = gfx_font_select.name,
                                                  size = gfx_font_select.size,
                                                  bold = gfx_font_select.bold,
                                                  italics = gfx_font_select.italics,
                                                  underline = gfx_font_select.underline,
                                                  shadow = gfx_font_select.shadow,
                                                  shadow_x = gfx_font_select.shadow_x,
                                                  shadow_y = gfx_font_select.shadow_y,
                                                  shadow_a = gfx_font_select.shadow_a
                                                  },
                                          text = gfx_text_select,
                                          text_col = gfx_textcol_select,
                                          poslock = false
                                         }
      
      end
    end  

  end
  
------------------------------------------------------------

  function Strip_INIT()

    if tracks[track_select] then
    
      local strip
      
      if tracks[track_select].strip == -1 then
        strip = #strips+1
        strips[strip] = {track = tracks[track_select], page = page, {}}
        for i = 1,4 do
          strips[strip][i] = {surface_x = 0,
                             surface_y = 0,     
                             controls = {},
                             graphics = {}}
          Snapshots_INIT()
          --XXY_INIT()
          if snapshots and snapshots[s] then
            snapshots[s][i] = {}
            snapshots[s][i][1] = {}
          end
        end
        tracks[track_select].strip = strip
      else
        strip = tracks[track_select].strip
      end

      return strip
        
    end
    
  end
    
------------------------------------------------------------

  function Strip_AddParam()
  
    if tracks[track_select] then
    
      local strip = Strip_INIT()

      if ctl_files[knob_select].imageidx == nil then  
        image_count = F_limit(image_count + 1,0,image_max)
        gfx.loadimg(image_count, controls_path..ctl_files[knob_select].fn)
        ctl_files[knob_select].imageidx = image_count
      end
      
      local x,y
      x = round((dragparam.x)/settings_gridsize)*settings_gridsize
          + round(surface_offset.x/settings_gridsize)*settings_gridsize - round((obj.sections[10].x)/settings_gridsize)*settings_gridsize
      y = round((dragparam.y)/settings_gridsize)*settings_gridsize 
          + round(surface_offset.y/settings_gridsize)*settings_gridsize - round((obj.sections[10].y)/settings_gridsize)*settings_gridsize
      local w, h = gfx.getimgdim(ctl_files[knob_select].imageidx)
      ctlnum = #strips[strip][page].controls + 1
      if dragparam.type == 'track' then
        local ccats = ctlcats.fxparam
        local cts = ctltype_select
        local spv = show_paramval
        local toff = textoff_select
        if trackfxparam_select == #trackfxparams-1 then
          ccats = ctlcats.fxoffline
          cts = 2
        elseif trackfxparam_select == #trackfxparams then
          ccats = ctlcats.fxgui
          cts = 2
          spv = false
          toff = 8
        end
        strips[strip][page].controls[ctlnum] = {c_id = GenID(),
                                                ctlcat = ccats,
                                                fxname=trackfx[trackfx_select].name,
                                                fxguid=trackfx[trackfx_select].guid, 
                                                fxnum=trackfx[trackfx_select].fxnum, 
                                                fxfound = true,
                                                param = trackfxparam_select,
                                                param_info = trackfxparams[trackfxparam_select],
                                                ctltype = cts,
                                                knob_select = knob_select,
                                                ctl_info = {fn = ctl_files[knob_select].fn,
                                                            frames = ctl_files[knob_select].frames,
                                                            imageidx = ctl_files[knob_select].imageidx, 
                                                            cellh = ctl_files[knob_select].cellh},
                                                x = x,
                                                y = y,
                                                w = w,
                                                poslock = false,
                                                scale = scale_select,
                                                xsc = x + math.floor(w/2 - (w*scale_select)/2),
                                                ysc = y + math.floor(ctl_files[knob_select].cellh/2 - (ctl_files[knob_select].cellh*scale_select)/2),
                                                wsc = w*scale_select,
                                                hsc = ctl_files[knob_select].cellh*scale_select,
                                                show_paramname = show_paramname,
                                                show_paramval = spv,
                                                ctlname_override = '',
                                                textcol = textcol_select,
                                                textoff = toff,
                                                textoffval = textoffval_select,
                                                textoffx = textoff_selectx,
                                                textoffvalx = textoffval_selectx,
                                                textsize = textsize_select,
                                                textsizev = textsizev_select,
                                                textcolv = textcolv_select,
                                                val = GetParamValue(ctlcats.fxparam,
                                                                    tracks[trackedit_select].tracknum,
                                                                    trackfx[trackfx_select].fxnum,
                                                                    trackfxparam_select, nil),
                                                defval = GetParamValue(ctlcats.fxparam,
                                                                    tracks[trackedit_select].tracknum,
                                                                    trackfx[trackfx_select].fxnum,
                                                                    trackfxparam_select, nil),
                                                maxdp = maxdp_select,
                                                cycledata = {statecnt = 0,val = 0,mapptof = false,draggable = false,spread = false, {}},
                                                xydata = {snapa = 1, snapb = 1, snapc = 1, snapd = 1, x = 0.5, y = 0.5},
                                                membtn = {state = false,
                                                          mem = nil},
                                                id = nil,
                                                tracknum = tracks[trackedit_select].tracknum,
                                                trackguid = tracks[trackedit_select].guid,
                                                scalemode = 8,
                                                framemode = 1,
                                                horiz = horiz_select,
                                                bypassbg_c = bypass_bgdraw_c_select,
                                                bypassbg_n = bypass_bgdraw_n_select,
                                                bypassbg_v = bypass_bgdraw_v_select,
                                                clickthrough = clickthrough_select,
                                                knobsens = settings_defknobsens
                                                }
        if track_select == trackedit_select then
          strips[strip][page].controls[ctlnum].tracknum = nil
          strips[strip][page].controls[ctlnum].trackguid = nil         
        end

      elseif dragparam.type == 'rcmswitch' then
        local ccats = ctlcats.rcm_switch
        local cts = 5
        local spv = true
        local toff = textoff_select
        strips[strip][page].controls[ctlnum] = {c_id = GenID(),
                                                ctlcat = ccats,
                                                fxname='RCM Switch',
                                                fxguid=nil, 
                                                fxnum=nil, 
                                                fxfound = false,
                                                param = -1,
                                                param_info = {paramname = 'RCM (Unassigned)',
                                                              paramidx = nil},
                                                ctltype = cts,
                                                knob_select = knob_select,
                                                ctl_info = {fn = ctl_files[knob_select].fn,
                                                            frames = ctl_files[knob_select].frames,
                                                            imageidx = ctl_files[knob_select].imageidx, 
                                                            cellh = ctl_files[knob_select].cellh},
                                                x = x,
                                                y = y,
                                                w = w,
                                                poslock = false,
                                                scale = scale_select,
                                                xsc = x + math.floor(w/2 - (w*scale_select)/2),
                                                ysc = y + math.floor(ctl_files[knob_select].cellh/2 - (ctl_files[knob_select].cellh*scale_select)/2),
                                                wsc = w*scale_select,
                                                hsc = ctl_files[knob_select].cellh*scale_select,
                                                show_paramname = show_paramname,
                                                show_paramval = spv,
                                                ctlname_override = '',
                                                textcol = textcol_select,
                                                textoff = toff,
                                                textoffval = textoffval_select,
                                                textoffx = textoff_selectx,
                                                textoffvalx = textoffval_selectx,
                                                textsize = textsize_select,
                                                textsizev = textsizev_select,
                                                textcolv = textcolv_select,
                                                val = 0,
                                                defval = 0,
                                                maxdp = maxdp_select,
                                                cycledata = {statecnt = 0,val = 0,mapptof = false,draggable = false,spread = false, {}},
                                                xydata = {snapa = 1, snapb = 1, snapc = 1, snapd = 1, x = 0.5, y = 0.5},
                                                membtn = {state = false,
                                                          mem = nil},
                                                id = nil,
                                                tracknum = tracks[trackedit_select].tracknum,
                                                trackguid = tracks[trackedit_select].guid,
                                                scalemode = 8,
                                                framemode = 1,
                                                horiz = horiz_select,
                                                bypassbg_c = bypass_bgdraw_c_select,
                                                bypassbg_n = bypass_bgdraw_n_select,
                                                bypassbg_v = bypass_bgdraw_v_select,
                                                clickthrough = clickthrough_select,
                                                knobsens = settings_defknobsens
                                                }
        if track_select == trackedit_select then
          strips[strip][page].controls[ctlnum].tracknum = nil
          strips[strip][page].controls[ctlnum].trackguid = nil         
        end

      elseif dragparam.type == 'midimsgctl' then
        local ccats = ctlcats.midictl
        local cts = 1
        local spv = true
        local toff = textoff_select
        strips[strip][page].controls[ctlnum] = {c_id = GenID(),
                                                ctlcat = ccats,
                                                fxname='MIDI CTL',
                                                fxguid=nil, 
                                                fxnum=nil, 
                                                fxfound = true,
                                                param = -1,
                                                param_info = {paramname = 'MIDI/OSC (Unassigned)',
                                                              paramidx = nil},
                                                ctltype = cts,
                                                knob_select = knob_select,
                                                ctl_info = {fn = ctl_files[knob_select].fn,
                                                            frames = ctl_files[knob_select].frames,
                                                            imageidx = ctl_files[knob_select].imageidx, 
                                                            cellh = ctl_files[knob_select].cellh},
                                                x = x,
                                                y = y,
                                                w = w,
                                                poslock = false,
                                                scale = scale_select,
                                                xsc = x + math.floor(w/2 - (w*scale_select)/2),
                                                ysc = y + math.floor(ctl_files[knob_select].cellh/2 - (ctl_files[knob_select].cellh*scale_select)/2),
                                                wsc = w*scale_select,
                                                hsc = ctl_files[knob_select].cellh*scale_select,
                                                show_paramname = show_paramname,
                                                show_paramval = spv,
                                                ctlname_override = '',
                                                textcol = textcol_select,
                                                textoff = toff,
                                                textoffval = textoffval_select,
                                                textoffx = textoff_selectx,
                                                textoffvalx = textoffval_selectx,
                                                textsize = textsize_select,
                                                textsizev = textsizev_select,
                                                textcolv = textcolv_select,
                                                val = 0,
                                                defval = 0,
                                                maxdp = maxdp_select,
                                                cycledata = {statecnt = 0,val = 0,mapptof = false,draggable = false,spread = false, {}},
                                                xydata = {snapa = 1, snapb = 1, snapc = 1, snapd = 1, x = 0.5, y = 0.5},
                                                membtn = {state = false,
                                                          mem = nil},
                                                id = nil,
                                                tracknum = tracks[trackedit_select].tracknum,
                                                trackguid = tracks[trackedit_select].guid,
                                                scalemode = 8,
                                                framemode = 1,
                                                horiz = horiz_select,
                                                bypassbg_c = bypass_bgdraw_c_select,
                                                bypassbg_n = bypass_bgdraw_n_select,
                                                bypassbg_v = bypass_bgdraw_v_select,
                                                clickthrough = clickthrough_select,
                                                knobsens = settings_defknobsens
                                                }
        if track_select == trackedit_select then
          strips[strip][page].controls[ctlnum].tracknum = nil
          strips[strip][page].controls[ctlnum].trackguid = nil         
        end

      elseif dragparam.type == 'learn' then
        strips[strip][page].controls[ctlnum] = {c_id = GenID(),
                                                ctlcat = ctlcats.fxparam,
                                                fxname=last_touch_fx.fxname,
                                                fxguid=last_touch_fx.fxguid, 
                                                fxnum=last_touch_fx.fxnum, 
                                                fxfound = true,
                                                param = last_touch_fx.paramnum,
                                                param_info = {paramname = last_touch_fx.prname,
                                                              paramnum = last_touch_fx.paramnum},
                                                ctltype = ctltype_select,
                                                knob_select = knob_select,
                                                ctl_info = {fn = ctl_files[knob_select].fn,
                                                            frames = ctl_files[knob_select].frames,
                                                            imageidx = ctl_files[knob_select].imageidx, 
                                                            cellh = ctl_files[knob_select].cellh},
                                                x = x,
                                                y = y,
                                                w = w,
                                                poslock = false,
                                                scale = scale_select,
                                                xsc = x + math.floor(w/2 - (w*scale_select)/2),
                                                ysc = y + math.floor(ctl_files[knob_select].cellh/2 - (ctl_files[knob_select].cellh*scale_select)/2),
                                                wsc = w*scale_select,
                                                hsc = ctl_files[knob_select].cellh*scale_select,
                                                show_paramname = show_paramname,
                                                show_paramval = show_paramval,
                                                ctlname_override = '',
                                                textcol = textcol_select,
                                                textoff = textoff_select,
                                                textoffval = textoffval_select,
                                                textoffx = textoff_selectx,
                                                textoffvalx = textoffval_selectx,
                                                textsize = textsize_select,
                                                textsizev = textsizev_select,
                                                textcolv = textcolv_select,
                                                val = GetParamValue(ctlcats.fxparam,
                                                                    last_touch_fx.tracknum,
                                                                    last_touch_fx.fxnum,
                                                                    last_touch_fx.paramnum, nil),
                                                defval = GetParamValue(ctlcats.fxparam,
                                                                    last_touch_fx.tracknum,
                                                                    last_touch_fx.fxnum,
                                                                    last_touch_fx.paramnum, nil),
                                                maxdp = maxdp_select,
                                                cycledata = {statecnt = 0,val = 0,mapptof = false,draggable = false,spread = false, {}},
                                                xydata = {snapa = 1, snapb = 1, snapc = 1, snapd = 1, x = 0.5, y = 0.5},
                                                membtn = {state = false,
                                                          mem = nil},
                                                id = nil,
                                                tracknum = last_touch_fx.tracknum,
                                                trackguid = last_touch_fx.trguid,
                                                scalemode = 8,
                                                framemode = 1,
                                                horiz = horiz_select,
                                                poslock = false,
                                                bypassbg_c = bypass_bgdraw_c_select,
                                                bypassbg_n = bypass_bgdraw_n_select,
                                                bypassbg_v = bypass_bgdraw_v_select,
                                                clickthrough = clickthrough_select,
                                                knobsens = settings_defknobsens
                                                }
        if last_touch_fx.tracknum == strips[strip].track.tracknum then
          strips[strip][page].controls[ctlnum].tracknum = nil
          strips[strip][page].controls[ctlnum].trackguid = nil 
        end      
      
      elseif dragparam.type == 'trctl' then
        strips[strip][page].controls[ctlnum] = {c_id = GenID(),
                                                ctlcat = ctlcats.trackparam,
                                                fxname='Track Parameter',
                                                fxguid=nil, 
                                                fxnum=nil, 
                                                fxfound = true,
                                                param = trctl_select,
                                                param_info = {paramname = 'Track '..trctls_table[trctl_select].name,
                                                              paramnum = trctl_select},
                                                ctltype = ctltype_select,
                                                knob_select = knob_select,
                                                ctl_info = {fn = ctl_files[knob_select].fn,
                                                            frames = ctl_files[knob_select].frames,
                                                            imageidx = ctl_files[knob_select].imageidx, 
                                                            cellh = ctl_files[knob_select].cellh},
                                                x = x,
                                                y = y,
                                                w = w,
                                                poslock = false,
                                                scale = scale_select,
                                                xsc = x + math.floor(w/2 - (w*scale_select)/2),
                                                ysc = y + math.floor(ctl_files[knob_select].cellh/2 - (ctl_files[knob_select].cellh*scale_select)/2),
                                                wsc = w*scale_select,
                                                hsc = ctl_files[knob_select].cellh*scale_select,
                                                show_paramname = show_paramname,
                                                show_paramval = show_paramval,
                                                ctlname_override = '',
                                                textcol = textcol_select,
                                                textoff = textoff_select,
                                                textoffval = textoffval_select,
                                                textoffx = textoff_selectx,
                                                textoffvalx = textoffval_selectx,
                                                textsize = textsize_select,
                                                textsizev = textsizev_select,
                                                textcolv = textcolv_select,
                                                val = GetParamValue(ctlcats.trackparam,
                                                                    tracks[trackedit_select].tracknum,
                                                                    nil,
                                                                    trctl_select, nil),
                                                defval = GetParamValue(ctlcats.trackparam,
                                                                    tracks[trackedit_select].tracknum,
                                                                    nil,
                                                                    trctl_select, nil),
                                                maxdp = maxdp_select,
                                                cycledata = {statecnt = 0,val = 0,mapptof = false,draggable = false,spread = false, {}},
                                                xydata = {snapa = 1, snapb = 1, snapc = 1, snapd = 1, x = 0.5, y = 0.5},
                                                membtn = {state = false,
                                                          mem = nil},
                                                id = nil,
                                                tracknum = tracks[trackedit_select].tracknum,
                                                trackguid = tracks[trackedit_select].guid,
                                                scalemode = 8,
                                                framemode = 1,
                                                horiz = horiz_select,
                                                poslock = false,
                                                bypassbg_c = bypass_bgdraw_c_select,
                                                bypassbg_n = bypass_bgdraw_n_select,
                                                bypassbg_v = bypass_bgdraw_v_select,
                                                clickthrough = clickthrough_select,
                                                knobsens = settings_defknobsens
                                                }
        if track_select == trackedit_select then
          strips[strip][page].controls[ctlnum].tracknum = nil
          strips[strip][page].controls[ctlnum].trackguid = nil         
        end

      elseif dragparam.type == 'trsnd' then
        --local unique, guid = CheckTrackUnique(trsends_table[trctl_select].sendname)
        
        --if unique == true then 
          local sidx = math.floor((trctl_select-1) / 3)
          local pidx = (trctl_select-1) % 3 +1
          strips[strip][page].controls[ctlnum] = {c_id = GenID(),
                                                  ctlcat = ctlcats.tracksend,
                                                  fxname='Track Send',
                                                  fxguid=nil, 
                                                  fxnum=nil, 
                                                  fxfound = true,
                                                  param = trctl_select,
                                                  param_info = {paramname = trsends_table[sidx][pidx].name,
                                                                paramnum = trctl_select,
                                                                paramidx = trsends_table[sidx].idx,
                                                                paramstr = trsends_table[sidx][pidx].parmname,
                                                                paramdesttrnum = trsends_table[sidx].desttracknum,
                                                                paramdestguid = trsends_table[sidx].desttrackguid,
                                                                paramdestchan = trsends_table[sidx].dstchan,
                                                                paramsrcchan = trsends_table[sidx].srcchan},
                                                  ctltype = ctltype_select,
                                                  knob_select = knob_select,
                                                  ctl_info = {fn = ctl_files[knob_select].fn,
                                                              frames = ctl_files[knob_select].frames,
                                                              imageidx = ctl_files[knob_select].imageidx, 
                                                              cellh = ctl_files[knob_select].cellh},
                                                  x = x,
                                                  y = y,
                                                  w = w,
                                                  poslock = false,
                                                  scale = scale_select,
                                                  xsc = x + math.floor(w/2 - (w*scale_select)/2),
                                                  ysc = y + math.floor(ctl_files[knob_select].cellh/2 - (ctl_files[knob_select].cellh*scale_select)/2),
                                                  wsc = w*scale_select,
                                                  hsc = ctl_files[knob_select].cellh*scale_select,
                                                  show_paramname = show_paramname,
                                                  show_paramval = show_paramval,
                                                  ctlname_override = '',
                                                  textcol = textcol_select,
                                                  textoff = textoff_select,
                                                  textoffval = textoffval_select,
                                                  textoffx = textoff_selectx,
                                                  textoffvalx = textoffval_selectx,
                                                  textsize = textsize_select,
                                                  textsizev = textsizev_select,
                                                  textcolv = textcolv_select,
                                                  val = 0,
                                                  defval = 0,
                                                  maxdp = maxdp_select,
                                                  cycledata = {statecnt = 0,val = 0,mapptof = mapptof_select,draggable = draggable_select,spread = spread_select, {}},
                                                  xydata = {snapa = 1, snapb = 1, snapc = 1, snapd = 1, x = 0.5, y = 0.5},
                                                  membtn = {state = false,
                                                            mem = nil},
                                                  id = nil,
                                                  tracknum = tracks[trackedit_select].tracknum,
                                                  trackguid = tracks[trackedit_select].guid,
                                                  scalemode = 8,
                                                  framemode = 1,
                                                  horiz = horiz_select,
                                                  poslock = false,
                                                  bypassbg_c = bypass_bgdraw_c_select,
                                                  bypassbg_n = bypass_bgdraw_n_select,
                                                  bypassbg_v = bypass_bgdraw_v_select,
                                                  clickthrough = clickthrough_select,
                                                  knobsens = settings_defknobsens
                                                  }
          
          if track_select == trackedit_select then
            strips[strip][page].controls[ctlnum].tracknum = nil
            strips[strip][page].controls[ctlnum].trackguid = nil         
          end
          strips[strip][page].controls[ctlnum].val = GetParamValue(ctlcats.tracksend,
                                                                    tracks[trackedit_select].tracknum,
                                                                    nil,
                                                                    trctl_select, ctlnum)
          strips[strip][page].controls[ctlnum].defval = strips[strip][page].controls[ctlnum].val
          
        --else
          --not unique
        --  OpenMsgBox(1, 'Please ensure the target track name for send is unique.', 1)
        --end
      elseif dragparam.type == 'action' then
        strips[strip][page].controls[ctlnum] = {c_id = GenID(),
                                                ctlcat = ctlcats.action,
                                                fxname='Action Trigger',
                                                fxguid=nil, 
                                                fxnum=nil, 
                                                fxfound = true,
                                                param = trctl_select,
                                                param_info = {paramname = 'Unassigned Action',
                                                              paramidx = nil},
                                                ctltype = 9,
                                                knob_select = knob_select,
                                                ctl_info = {fn = ctl_files[knob_select].fn,
                                                            frames = ctl_files[knob_select].frames,
                                                            imageidx = ctl_files[knob_select].imageidx, 
                                                            cellh = ctl_files[knob_select].cellh},
                                                x = x,
                                                y = y,
                                                w = w,
                                                poslock = false,
                                                scale = scale_select,
                                                xsc = x + math.floor(w/2 - (w*scale_select)/2),
                                                ysc = y + math.floor(ctl_files[knob_select].cellh/2 - (ctl_files[knob_select].cellh*scale_select)/2),
                                                wsc = w*scale_select,
                                                hsc = ctl_files[knob_select].cellh*scale_select,
                                                show_paramname = show_paramname,
                                                show_paramval = show_paramval,
                                                ctlname_override = '',
                                                textcol = textcol_select,
                                                textoff = textoff_select,
                                                textoffval = textoffval_select,
                                                textoffx = textoff_selectx,
                                                textoffvalx = textoffval_selectx,
                                                textsize = textsize_select,
                                                textsizev = textsizev_select,
                                                textcolv = textcolv_select,
                                                val = 0,
                                                defval = 0,
                                                maxdp = maxdp_select,
                                                cycledata = {statecnt = 0,val = 0,mapptof = false,draggable = false,spread = false, {}},
                                                xydata = {snapa = 1, snapb = 1, snapc = 1, snapd = 1, x = 0.5, y = 0.5},
                                                membtn = {state = false,
                                                          mem = nil},
                                                id = nil,
                                                tracknum = nil,
                                                trackguid = nil,
                                                scalemode = 8,
                                                framemode = 1,
                                                horiz = horiz_select,
                                                poslock = false,
                                                bypassbg_c = bypass_bgdraw_c_select,
                                                bypassbg_n = bypass_bgdraw_n_select,
                                                bypassbg_v = bypass_bgdraw_v_select,
                                                clickthrough = clickthrough_select,
                                                knobsens = settings_defknobsens
                                               }
      elseif dragparam.type == 'pkmeter' then
        local tcs = trctl_select - special_offs
        --local pname = 'Tr' .. tracks[trackedit_select].tracknum .. ' '
        local pname = ''
        if tcs >= special_table_chans then
          pname = pname .. 'Ch' .. string.format('%i',tcs+1-special_table_chans)
          tcs = tcs - special_table_chans + 64
        else
          pname = pname .. 'Ch' .. string.format('%i',tcs+1)
        end 
        if tcs >= 64 then
          pname = pname .. ' Clip'
        end
        strips[strip][page].controls[ctlnum] = {c_id = GenID(),
                                                ctlcat = ctlcats.pkmeter,
                                                fxname='Peak Meter',
                                                fxguid=nil, 
                                                fxnum=nil, 
                                                fxfound = true,
                                                param = tcs,
                                                param_info = {paramname = pname,
                                                              paramnum = tcs,
                                                              paramidx = nil},
                                                ctltype = 5,
                                                knob_select = knob_select,
                                                ctl_info = {fn = ctl_files[knob_select].fn,
                                                            frames = ctl_files[knob_select].frames,
                                                            imageidx = ctl_files[knob_select].imageidx, 
                                                            cellh = ctl_files[knob_select].cellh},
                                                x = x,
                                                y = y,
                                                w = w,
                                                poslock = false,
                                                scale = scale_select,
                                                xsc = x + math.floor(w/2 - (w*scale_select)/2),
                                                ysc = y + math.floor(ctl_files[knob_select].cellh/2 - (ctl_files[knob_select].cellh*scale_select)/2),
                                                wsc = w*scale_select,
                                                hsc = ctl_files[knob_select].cellh*scale_select,
                                                show_paramname = show_paramname,
                                                show_paramval = show_paramval,
                                                ctlname_override = '',
                                                textcol = textcol_select,
                                                textoff = textoff_select,
                                                textoffval = textoffval_select,
                                                textoffx = textoff_selectx,
                                                textoffvalx = textoffval_selectx,
                                                textsize = textsize_select,
                                                textsizev = textsizev_select,
                                                textcolv = textcolv_select,
                                                val = 0,
                                                defval = 0,
                                                maxdp = maxdp_select,
                                                cycledata = {statecnt = 0,val = 0,mapptof = false,draggable = false,spread = false, {}},
                                                xydata = {snapa = 1, snapb = 1, snapc = 1, snapd = 1, x = 0.5, y = 0.5},
                                                membtn = {state = false,
                                                          mem = nil},
                                                id = nil,
                                                tracknum = tracks[trackedit_select].tracknum,
                                                trackguid = tracks[trackedit_select].guid,
                                                scalemode = 8,
                                                framemode = 1,
                                                horiz = horiz_select,
                                                poslock = false,
                                                bypassbg_c = bypass_bgdraw_c_select,
                                                bypassbg_n = bypass_bgdraw_n_select,
                                                bypassbg_v = bypass_bgdraw_v_select,
                                                clickthrough = clickthrough_select,
                                                knobsens = settings_defknobsens
                                               }
        if track_select == trackedit_select then
          strips[strip][page].controls[ctlnum].tracknum = nil
          strips[strip][page].controls[ctlnum].trackguid = nil         
        end

      elseif dragparam.type == 'snapctl' then
        local pname = 'Page Snapshots'
        if sstype_select > 1 then
          pname = snapshots[strip][page][sstype_select].subsetname .. ' SNAPSHOTS'
        end
        
        strips[strip][page].controls[ctlnum] = {c_id = GenID(),
                                                ctlcat = ctlcats.snapshot,
                                                fxname='Snapshot Selector',
                                                fxguid=nil, 
                                                fxnum=nil, 
                                                fxfound = true,
                                                param = sstype_select,
                                                param_info = {paramname = pname,
                                                              paramidx = sstype_select},
                                                ctltype = 5,
                                                knob_select = knob_select,
                                                ctl_info = {fn = ctl_files[knob_select].fn,
                                                            frames = ctl_files[knob_select].frames,
                                                            imageidx = ctl_files[knob_select].imageidx, 
                                                            cellh = ctl_files[knob_select].cellh},
                                                x = x,
                                                y = y,
                                                w = w,
                                                poslock = false,
                                                scale = 1,
                                                xsc = x + math.floor(w/2 - (w*1)/2),
                                                ysc = y + math.floor(ctl_files[knob_select].cellh/2 - (ctl_files[knob_select].cellh*1)/2),
                                                wsc = w*1,
                                                hsc = ctl_files[knob_select].cellh*1,
                                                show_paramname = show_paramname,
                                                show_paramval = show_paramval,
                                                ctlname_override = '',
                                                textcol = textcol_select,
                                                textoff = 22.25,
                                                textoffval = -6.0,
                                                textoffx = textoff_selectx,
                                                textoffvalx = textoffval_selectx,
                                                textsize = textsize_select,
                                                textsizev = textsizev_select,
                                                textcolv = textcolv_select,
                                                val = 0,
                                                defval = 0,
                                                maxdp = maxdp_select,
                                                cycledata = {statecnt = 0,val = 0,mapptof = false,draggable = false,spread = false, {}},
                                                xydata = {snapa = 1, snapb = 1, snapc = 1, snapd = 1, x = 0.5, y = 0.5},
                                                membtn = {state = false,
                                                          mem = nil},
                                                id = nil,
                                                tracknum = nil,
                                                trackguid = nil,
                                                scalemode = 8,
                                                framemode = 1,
                                                horiz = horiz_select,
                                                poslock = false,
                                                bypassbg_c = bypass_bgdraw_c_select,
                                                bypassbg_n = bypass_bgdraw_n_select,
                                                bypassbg_v = bypass_bgdraw_v_select,
                                                clickthrough = clickthrough_select,
                                                knobsens = settings_defknobsens
                                               }

      elseif dragparam.type == 'xyctl' then
        local pname = 'XY'
        if snapshots[strip][page][sstype_select] then
          pname = snapshots[strip][page][sstype_select].subsetname
        end
        strips[strip][page].controls[ctlnum] = {c_id = GenID(),
                                                ctlcat = ctlcats.xy,
                                                fxname='XY Pad',
                                                fxguid=nil, 
                                                fxnum=nil, 
                                                fxfound = true,
                                                param = sstype_select,
                                                param_info = {paramname = pname,
                                                              paramidx = sstype_select},
                                                ctltype = 5,
                                                knob_select = knob_select,
                                                ctl_info = {fn = ctl_files[knob_select].fn,
                                                            frames = ctl_files[knob_select].frames,
                                                            imageidx = ctl_files[knob_select].imageidx, 
                                                            cellh = ctl_files[knob_select].cellh},
                                                x = x,
                                                y = y,
                                                w = w,
                                                poslock = false,
                                                scale = 1,
                                                xsc = x + math.floor(w/2 - (w*1)/2),
                                                ysc = y + math.floor(ctl_files[knob_select].cellh/2 - (ctl_files[knob_select].cellh*1)/2),
                                                wsc = w*1,
                                                hsc = ctl_files[knob_select].cellh*1,
                                                show_paramname = show_paramname,
                                                show_paramval = false,
                                                ctlname_override = '',
                                                textcol = textcol_select,
                                                textoff = 90.25,
                                                textoffval = -6.0,
                                                textoffx = textoff_selectx,
                                                textoffvalx = textoffval_selectx,
                                                textsize = textsize_select,
                                                textsizev = textsizev_select,
                                                textcolv = textcolv_select,
                                                val = 0,
                                                defval = 0,
                                                maxdp = maxdp_select,
                                                cycledata = {statecnt = 0,val = 0,mapptof = false,draggable = false,spread = false, {}},
                                                xydata = {snapa = 1, snapb = 1, snapc = 1, snapd = 1, x = 0.5, y = 0.5},
                                                membtn = {state = false,
                                                          mem = nil},
                                                id = nil,
                                                tracknum = nil,
                                                trackguid = nil,
                                                scalemode = 8,
                                                framemode = 1,
                                                horiz = horiz_select,
                                                poslock = false,
                                                bypassbg_c = bypass_bgdraw_c_select,
                                                bypassbg_n = bypass_bgdraw_n_select,
                                                bypassbg_v = bypass_bgdraw_v_select,
                                                clickthrough = clickthrough_select,
                                                knobsens = settings_defknobsens
                                               }
      elseif dragparam.type == 'macro' then
        local mcnt = 0
        for c = 1, #strips[strip][page].controls do
          if strips[strip][page].controls[c].ctlcat == ctlcats.macro then
            mcnt = mcnt + 1
          end
        end
        strips[strip][page].controls[ctlnum] = {c_id = GenID(),
                                                ctlcat = ctlcats.macro,
                                                fxname='Macro Control',
                                                fxguid=nil, 
                                                fxnum=nil, 
                                                fxfound = true,
                                                param = trctl_select,
                                                param_info = {paramname = 'Macro '..string.format('%i',mcnt+1),
                                                              paramidx = nil},
                                                ctltype = 1,
                                                knob_select = knob_select,
                                                ctl_info = {fn = ctl_files[knob_select].fn,
                                                            frames = ctl_files[knob_select].frames,
                                                            imageidx = ctl_files[knob_select].imageidx, 
                                                            cellh = ctl_files[knob_select].cellh},
                                                x = x,
                                                y = y,
                                                w = w,
                                                poslock = false,
                                                scale = scale_select,
                                                xsc = x + math.floor(w/2 - (w*scale_select)/2),
                                                ysc = y + math.floor(ctl_files[knob_select].cellh/2 - (ctl_files[knob_select].cellh*scale_select)/2),
                                                wsc = w*scale_select,
                                                hsc = ctl_files[knob_select].cellh*scale_select,
                                                show_paramname = show_paramname,
                                                show_paramval = show_paramval,
                                                ctlname_override = '',
                                                textcol = textcol_select,
                                                textoff = textoff_select,
                                                textoffval = textoffval_select,
                                                textoffx = textoff_selectx,
                                                textoffvalx = textoffval_selectx,
                                                textsize = textsize_select,
                                                textsizev = textsizev_select,
                                                textcolv = textcolv_select,
                                                val = 0,
                                                defval = 0,
                                                maxdp = maxdp_select,
                                                cycledata = {statecnt = 0,val = 0,mapptof = false,draggable = false,spread = false, {}},
                                                xydata = {snapa = 1, snapb = 1, snapc = 1, snapd = 1, x = 0.5, y = 0.5},
                                                membtn = {state = false,
                                                          mem = nil},
                                                id = nil,
                                                tracknum = nil,
                                                trackguid = nil,
                                                scalemode = 8,
                                                framemode = 1,
                                                horiz = horiz_select,
                                                poslock = false,
                                                bypassbg_c = bypass_bgdraw_c_select,
                                                bypassbg_n = bypass_bgdraw_n_select,
                                                bypassbg_v = bypass_bgdraw_v_select,
                                                clickthrough = clickthrough_select,
                                                knobsens = settings_defknobsens
                                               }
      elseif dragparam.type == 'eqcontrol' then
        local mcnt = 0
        for c = 1, #strips[strip][page].controls do
          if strips[strip][page].controls[c].ctlcat == ctlcats.eqcontrol then
            mcnt = mcnt + 1
          end
        end
        strips[strip][page].controls[ctlnum] = {c_id = GenID(),
                                                ctlcat = ctlcats.eqcontrol,
                                                fxname='EQ Control',
                                                fxguid=nil, 
                                                fxnum=nil, 
                                                fxfound = true,
                                                param = trctl_select,
                                                param_info = {paramname = 'EQ '..string.format('%i',mcnt+1),
                                                              paramidx = nil},
                                                ctltype = 5,
                                                knob_select = knob_select,
                                                ctl_info = {fn = ctl_files[knob_select].fn,
                                                            frames = ctl_files[knob_select].frames,
                                                            imageidx = ctl_files[knob_select].imageidx, 
                                                            cellh = ctl_files[knob_select].cellh},
                                                x = x,
                                                y = y,
                                                w = w,
                                                poslock = false,
                                                scale = scale_select,
                                                xsc = x + math.floor(w/2 - (w*scale_select)/2),
                                                ysc = y + math.floor(ctl_files[knob_select].cellh/2 - (ctl_files[knob_select].cellh*scale_select)/2),
                                                wsc = w*scale_select,
                                                hsc = ctl_files[knob_select].cellh*scale_select,
                                                show_paramname = show_paramname,
                                                show_paramval = false,
                                                ctlname_override = '',
                                                textcol = textcol_select,
                                                textoff = textoff_select-34,
                                                textoffval = textoffval_select,
                                                textoffx = textoff_selectx,
                                                textoffvalx = textoffval_selectx,
                                                textsize = 4,
                                                textsizev = textsizev_select,
                                                textcolv = textcolv_select,
                                                val = 0,
                                                defval = 0,
                                                maxdp = maxdp_select,
                                                cycledata = {statecnt = 0,val = 0,mapptof = false,draggable = false,spread = false, {}},
                                                xydata = {snapa = 1, snapb = 1, snapc = 1, snapd = 1, x = 0.5, y = 0.5},
                                                membtn = {state = false,
                                                          mem = nil},
                                                id = nil,
                                                tracknum = nil,
                                                trackguid = nil,
                                                scalemode = 8,
                                                framemode = 1,
                                                horiz = horiz_select,
                                                poslock = false,
                                                bypassbg_c = bypass_bgdraw_c_select,
                                                bypassbg_n = bypass_bgdraw_n_select,
                                                bypassbg_v = bypass_bgdraw_v_select,
                                                knobsens = settings_defknobsens,
                                                clickthrough = clickthrough_select,
                                                eqgraph = def_graph
                                               }

      elseif dragparam.type == 'switcher' then
        local swcnt = #switchers+1
        switchers[swcnt] = {grpids ={},
                            current = -1}
        
        strips[strip][page].controls[ctlnum] = {c_id = GenID(),
                                                ctlcat = ctlcats.switcher,
                                                fxname='Strip Switcher',
                                                fxguid=nil, 
                                                fxnum=nil, 
                                                fxfound = true,
                                                param = trctl_select,
                                                param_info = {paramname = 'Switcher '..string.format('%i',swcnt+1),
                                                              paramidx = nil},
                                                ctltype = 5,
                                                knob_select = knob_select,
                                                ctl_info = {fn = ctl_files[knob_select].fn,
                                                            frames = ctl_files[knob_select].frames,
                                                            imageidx = ctl_files[knob_select].imageidx, 
                                                            cellh = ctl_files[knob_select].cellh},
                                                x = x,
                                                y = y,
                                                w = w,
                                                poslock = false,
                                                scale = scale_select,
                                                xsc = x + math.floor(w/2 - (w*scale_select)/2),
                                                ysc = y + math.floor(ctl_files[knob_select].cellh/2 - (ctl_files[knob_select].cellh*scale_select)/2),
                                                wsc = w*scale_select,
                                                hsc = ctl_files[knob_select].cellh*scale_select,
                                                show_paramname = show_paramname,
                                                show_paramval = false,
                                                ctlname_override = '',
                                                textcol = textcol_select,
                                                textoff = 9,
                                                textoffval = textoffval_select,
                                                textoffx = textoff_selectx,
                                                textoffvalx = textoffval_selectx,
                                                textsize = 0,
                                                textsizev = textsizev_select,
                                                textcolv = textcolv_select,
                                                val = 0,
                                                defval = 0,
                                                maxdp = maxdp_select,
                                                cycledata = {statecnt = 0,val = 0,mapptof = false,draggable = false,spread = false, {}},
                                                xydata = {snapa = 1, snapb = 1, snapc = 1, snapd = 1, x = 0.5, y = 0.5},
                                                membtn = {state = false,
                                                          mem = nil},
                                                switcherid = swcnt,
                                                id = nil,
                                                grpid = nil,
                                                tracknum = nil,
                                                trackguid = nil,
                                                scalemode = 8,
                                                framemode = 1,
                                                horiz = horiz_select,
                                                poslock = false,
                                                bypassbg_c = bypass_bgdraw_c_select,
                                                bypassbg_n = bypass_bgdraw_n_select,
                                                bypassbg_v = bypass_bgdraw_v_select,
                                                knobsens = settings_defknobsens,
                                                clickthrough = clickthrough_select,
                                                eqgraph = def_graph
                                               }

      elseif dragparam.type == 'snaprand' then
        local pname = 'RND PAGE'
        if sstype_select > 1 then
          pname = 'RND '..snapshots[strip][page][sstype_select].subsetname
        end
        
        strips[strip][page].controls[ctlnum] = {c_id = GenID(),
                                                ctlcat = ctlcats.snapshotrand,
                                                fxname='Snapshot Randomize',
                                                fxguid=nil, 
                                                fxnum=nil, 
                                                fxfound = true,
                                                param = sstype_select,
                                                param_info = {paramname = pname,
                                                              paramidx = sstype_select},
                                                ctltype = 2,
                                                knob_select = knob_select,
                                                ctl_info = {fn = ctl_files[knob_select].fn,
                                                            frames = ctl_files[knob_select].frames,
                                                            imageidx = ctl_files[knob_select].imageidx, 
                                                            cellh = ctl_files[knob_select].cellh},
                                                x = x,
                                                y = y,
                                                w = w,
                                                poslock = false,
                                                scale = 1,
                                                xsc = x + math.floor(w/2 - (w*1)/2),
                                                ysc = y + math.floor(ctl_files[knob_select].cellh/2 - (ctl_files[knob_select].cellh*1)/2),
                                                wsc = w*1,
                                                hsc = ctl_files[knob_select].cellh*1,
                                                show_paramname = show_paramname,
                                                show_paramval = false,
                                                ctlname_override = '',
                                                textcol = textcol_select,
                                                textoff = 8,
                                                textoffval = -6.0,
                                                textoffx = textoff_selectx,
                                                textoffvalx = textoffval_selectx,
                                                textsize = textsize_select,
                                                textsizev = textsizev_select,
                                                textcolv = textcolv_select,
                                                val = 0,
                                                defval = 0,
                                                maxdp = maxdp_select,
                                                cycledata = {statecnt = 0,val = 0,mapptof = false,draggable = false,spread = false, {}},
                                                xydata = {snapa = 1, snapb = 1, snapc = 1, snapd = 1, x = 0.5, y = 0.5},
                                                membtn = {state = false,
                                                          mem = nil},
                                                id = nil,
                                                tracknum = nil,
                                                trackguid = nil,
                                                scalemode = 8,
                                                framemode = 1,
                                                horiz = horiz_select,
                                                poslock = false,
                                                bypassbg_c = bypass_bgdraw_c_select,
                                                bypassbg_n = bypass_bgdraw_n_select,
                                                bypassbg_v = bypass_bgdraw_v_select,
                                                clickthrough = clickthrough_select,
                                                knobsens = settings_defknobsens
                                               }
      end
    end  
  
    GUI_DrawCtlBitmap()
  end

  -------------------------------------------------------
  
  function PopulateStripFolders()
  
    strip_folders = {}
    sflist_offset = 0
    
    local i = 0
    local sf = reaper.EnumerateSubdirectories(strips_path,i)
    while sf ~= nil do
      strip_folders[i] = {fn = sf}
      i=i+1
      sf = reaper.EnumerateSubdirectories(strips_path,i)
    end
    
  end

  -------------------------------------------------------
  
  function PopulateStrips()
  
    strip_files = {}
    slist_offset = 0
    
    local i = 0
    if strip_folders[stripfol_select] then
      local sf = reaper.EnumerateFiles(strips_path..'/'..strip_folders[stripfol_select].fn,i)
      while sf ~= nil do
        strip_files[i] = {fn = sf}
        i=i+1
        sf = reaper.EnumerateFiles(strips_path..'/'..strip_folders[stripfol_select].fn,i)
      end
    end    
  end

  -------------------------------------------------------
  function PopGfxFolder(folnum)
  
    graphics_folder_files = {}
    glist_offset = 0
    
    gf = 0
    if graphics_files and #graphics_files > 0 then
      for i = 0, #graphics_files do
        if graphics_files[i].fol == graphics_folders[folnum] then
          graphics_folder_files[gf] = i
          gf = gf + 1
        end
      end
    end
      
  end

  function PopulateGFXIdx()
  
    local gfxidx = {}
    if graphics_files and #graphics_files > 0 then
      for i = 1, #graphics_files do
      
        gfxidx[graphics_files[i].fn] = i
      
      end
    end
    return gfxidx
    
  end
    
  function PopulateGFX()
  
    graphics_files = {}
    graphics_folders = {}
    glist_offset = 0
    gflist_offset = 0
    
    local i = 0
    local gf = reaper.EnumerateFiles(graphics_path,i)
    while gf ~= nil do
      graphics_files[i] = {fn = gf, fol = 'GENERAL', imageidx = nil}
      i=i+1
      gf = reaper.EnumerateFiles(graphics_path,i)
    end
    
    local f = 0
    graphics_folders[f] = 'GENERAL'
    local gfo = reaper.EnumerateSubdirectories(graphics_path,f)
    while gfo ~= nil do
      gi = 0
      graphics_folders[f+1] = gfo  
      local gf = reaper.EnumerateFiles(graphics_path..gfo,gi)
      while gf ~= nil do
        graphics_files[i] = {fn = gf, fol = gfo, imageidx = nil}
        --DBG(gfo..'  '..gf)
        i=i+1
        gi=gi+1
        gf = reaper.EnumerateFiles(graphics_path..gfo,gi)
      end
      f=f+1    
      gfo = reaper.EnumerateSubdirectories(graphics_path,f)
    end
    
    PopGfxFolder(gfxfol_select)
  end

  function RepopulateGFX()
  
    local gfxtab = {}
    --glist_offset = 0
    
    for i = 0, #graphics_files do
      gfxtab[graphics_files[i].fn] = true
    end

    local i = 0
    local gf = reaper.EnumerateFiles(graphics_path,i)
    while gf ~= nil do
      if gfxtab[gf] ~= true then
        graphics_files[#graphics_files+1] = {fn = gf, fol = 'GENERAL', imageidx = nil}
      end
      i=i+1
      gf = reaper.EnumerateFiles(graphics_path,i)
    end

    local f = 0
    local gfo = reaper.EnumerateSubdirectories(graphics_path,f)
    while gfo ~= nil do
      gi = 0
      local gf = reaper.EnumerateFiles(graphics_path..gfo,gi)
      while gf ~= nil do
        if gfxtab[gf] ~= true then
          graphics_files[#graphics_files+1] = {fn = gf, fol = gfo, imageidx = nil}
        end
        i=i+1
        gi=gi+1
        gf = reaper.EnumerateFiles(graphics_path..gfo,gi)
      end
      f=f+1    
      gfo = reaper.EnumerateSubdirectories(graphics_path,f)
    end
    
    PopGfxFolder(gfxfol_select)
  end
  
  -------------------------------------------------------
  
  function PopulateControls()
  
    ctl_files = {}
    klist_offset = 0
    
    local i = 0
    local c = 0
    local kf = reaper.EnumerateFiles(controls_path,i)
    while kf ~= nil do
      if string.sub(kf,string.len(kf)-3) == '.knb' then
        local file
        file=io.open(controls_path..kf,"r")
        local content=file:read("*a")
        file:close()
        
        ctl_files[c] = unpickle(content)
        if ctl_files[c] then 
          if ctl_files[c].ctltype == nil then
            ctl_files[c].ctltype = 4
          end
           --= --{fn = kf, imageidx = nil, cellh = 100, frames = 101}
          if kf == '__default.knb' then
            ctl_files[c].imageidx = 0
            knob_select = c
          elseif kf == '__Snapshot.knb' then
            ctl_files[c].imageidx = def_snapshot
            def_snapshotctl = c
          elseif kf == '__XY.knb' then
            ctl_files[c].imageidx = def_XY
            def_xyctl = c
          elseif kf == '__XYTarget.knb' then
            ctl_files[c].imageidx = def_xytarget
            def_xytargetctl = c
          elseif kf == 'SimpleFlat_48.knb' then
            ctl_files[c].imageidx = def_knobsm
            def_knobsmctl = c
          elseif kf == 'SimpleFlat_64.knb' then
            ctl_files[c].imageidx = def_eqcknobf
            def_eqcknobfctl = c
          elseif kf == 'SimpleFlat2_64.knb' then
            ctl_files[c].imageidx = def_eqcknobg
            def_eqcknobgctl = c
          elseif kf == 'SimpleBox_9632.knb' then
            ctl_files[c].imageidx = def_box
            def_boxctl = c
          elseif kf == 'Switcher.knb' then
            ctl_files[c].imageidx = def_switch
            def_switchctl = c
          end
        else
          DBG('Error found with control file: '..kf)
        end
        c = c + 1
      end
      i=i+1
      kf = reaper.EnumerateFiles(controls_path,i)
    end
    
  end

  function RepopulateControls()
  
    local ctltab = {}
    for i = 0, #ctl_files do
      ctltab[ctl_files[i].fn] = true
    end
  
    local i = 0 
    local kf = reaper.EnumerateFiles(controls_path,i)
    while kf ~= nil do
      if string.sub(kf,string.len(kf)-3) == '.knb' then
        local file
        file=io.open(controls_path..kf,"r")
        local content=file:read("*a")
        file:close()

        if ctltab[kf] ~= true then        
          ctl_files[#ctl_files+1] = unpickle(content)
        end
      end
      i=i+1
      kf = reaper.EnumerateFiles(controls_path,i)      
    end
    update_gfx = true
  
  end
  
  function LoadControl(iidx, fn)

    if string.sub(fn,string.len(fn)-3) == '.knb' then
      if reaper.file_exists(controls_path..fn) then
        local file
        file=io.open(controls_path..fn,"r")
        local content=file:read("*a")
        file:close()
        
        defctls[iidx] = unpickle(content)
        if defctls[iidx] then
          gfx.loadimg(iidx,controls_path..defctls[iidx].fn)
          return iidx
        else
          return -1
        end
      else
        return -1
      end
    end
    
  end

  function LoadSkinIMG(iidx, fn)

    if reaper.file_exists(skins_path..fn) then
    --DBG(iidx)
      gfx.loadimg(iidx,skins_path..fn)
      return iidx
    else
      DBG('Skin file: '..fn..' missing.  Please ensure you have the latest skin folder from LBXCS_resources.zip on github installed inside your LBXCS_resources folder.')
      return -1
    end
    
  end

  function LoadSkin()
  
    local skin = {}
    local ret = true
    
    skin.panela_top = LoadSkinIMG(850, 'PanelA_TOP.png')
    skin.panela_mid = LoadSkinIMG(851, 'PanelA_MID.png')
    skin.panela_bot = LoadSkinIMG(852, 'PanelA_BOT.png')
    skin.slider_fg = LoadSkinIMG(854, 'Slider_FG.png')
    skin.butt18 = LoadSkinIMG(855, 'Button18.png')
    skin.butt18G = LoadSkinIMG(853, 'Button18G.png')
    skin.butt18R = LoadSkinIMG(856, 'Button18R.png')
    skin.butt18T = LoadSkinIMG(857, 'Button18T.png')
    skin.bar = LoadSkinIMG(858, 'Bar.png')
    skin.barR = LoadSkinIMG(859, 'BarR.png')
    skin.barUD = LoadSkinIMG(860, 'BarUD.png')
    skin.arrowup = LoadSkinIMG(861, 'ArrowUp.png')
    skin.arrowdn = LoadSkinIMG(862, 'ArrowDown.png')
    skin.highlight = LoadSkinIMG(863, 'ListHighlight.png')
    skin.barG = LoadSkinIMG(864, 'BarG.png')
    skin.butt18Y = LoadSkinIMG(865, 'Button18Y.png')
    skin.slidbutt = LoadSkinIMG(866, 'SliderButton.png')
    skin.star = LoadSkinIMG(867, 'Star.png')
    skin.starout = LoadSkinIMG(868, 'StarOut.png')
    --skin.led = LoadSkinIMG(869, 'LBX_Button32_Yellow.png')
  
    if skin.panela_top == -1 or 
       skin.panela_mid == -1 or 
       skin.panela_bot == -1 or 
       skin.slider_fg == -1 or 
       skin.butt18 == -1 or 
       skin.butt18G == -1 or 
       skin.butt18R == -1 or 
       skin.butt18T == -1 or 
       skin.bar == -1 or 
       skin.barR == -1 or 
       skin.barUD == -1 or
       skin.arrowup == -1 or
       skin.arrowdn == -1 or
       skin.highlight == -1 or
       skin.barG == -1 or
       skin.butt18Y == -1 or 
       skin.slidbutt == -1 or
       skin.star == -1 or
       --skin.led == -1 or
       skin.starout == -1
       then
      ret = false   
    end
  
    return skin, ret
    
  end
    
  -------------------------------------------------------

  function GetTrack(t)
  
    local tr
    if t == -2 then
      track = nil
    elseif t== nil or t == -1 then
      track = reaper.GetMasterTrack(0)
    else
      track = reaper.GetTrack(0, t)
    end
    return track
  
  end

  -------------------------------------------------------

  function CheckTrackUnique(name)
  
    local cnt = 0
    local guid
    for i = 0, reaper.CountTracks(0)-1 do
    
      local track = GetTrack(i)
      if name == reaper.GetTrackState(track) then
        if guid == nil then
          guid = reaper.GetTrackGUID(track)
        end
        cnt = cnt + 1
      end          
    
    end
    local retval = true
    if cnt > 1 then
      guid = nil
      retval = false
    end
    return retval, guid
  
  end

  -------------------------------------------------------
  
  function split(str,sep)
      local array = {}
      local reg = string.format("([^%s]+)",sep)
      for mem in string.gmatch(str,reg) do
          --table.insert(array, mem)
          array[#array+1] = mem
      end
      return array
  end
  
  function trackfromguid(guid)
  
    local ret=-1
    local tr
    for t = 0, reaper.CountTracks(0)-1 do
    
      tr = reaper.GetTrack(0, t)
      if guid == reaper.GetTrackGUID(tr) then
        ret = t
        break
      end
    end
  
    return ret, tr
  end
  
  function CheckStripSends(tsends)
  
    if tsends == nil then
      tsends = {}
    end
    if track_select and tracks[track_select] and strips[tracks[track_select].strip] then
    
      local tn = strips[tracks[track_select].strip].track.tracknum
      if tsends[tn] == nil then
        tsends[tn] = PopSendInfo(tn)
      end
      
      if tsends and tsends[tn] then
        for c = 1, #strips[tracks[track_select].strip][page].controls do
          if strips[tracks[track_select].strip][page].controls[c].ctlcat == ctlcats.tracksend then
                  
            local paramnum = strips[tracks[track_select].strip][page].controls[c].param_info.paramnum
            local tnl = strips[tracks[track_select].strip][page].controls[c].tracknum
            if tnl == nil then
              tnl = tn
            elseif tsends[tnl] == nil then
              tsends[tnl] = PopSendInfo(tnl)
            end
            local sidx = math.floor((paramnum-1) / 3)
            local pidx = (paramnum-1) % 3 +1
            if tsends[tnl] and tsends[tnl][sidx] and strips[tracks[track_select].strip][page].controls[c].param_info.paramdestguid ==
               tsends[tnl][sidx].desttrackguid and
                   tsends[tnl][sidx].dstchan == strips[tracks[track_select].strip][page].controls[c].param_info.paramdestchan and
                   tsends[tnl][sidx].srcchan == strips[tracks[track_select].strip][page].controls[c].param_info.paramsrcchan then
            else   
              for i = 0, #tsends[tnl] do
                
                if tsends[tnl][i] and tsends[tnl][i].desttrackguid == strips[tracks[track_select].strip][page].controls[c].param_info.paramdestguid and
                   tsends[tnl][i].dstchan == strips[tracks[track_select].strip][page].controls[c].param_info.paramdestchan and
                   tsends[tnl][i].srcchan == strips[tracks[track_select].strip][page].controls[c].param_info.paramsrcchan then
                  strips[tracks[track_select].strip][page].controls[c].param_info.paramnum = i*3+pidx-1
                  strips[tracks[track_select].strip][page].controls[c].param_info.param = i*3+pidx-1
                  strips[tracks[track_select].strip][page].controls[c].param_info.paramidx = tsends[tnl][i].idx
                  break
                end 
              end
            end
          end
      
        end
      else
      end    
    end
  
    return tsends
  end
  
  function CheckSendGUID(tr, dtracknum, paramnum, guid, dstchan, srcchan, sendinfo)
 
    local check = false
    local sidx = math.floor((paramnum-1) / 3)
    local pidx = (paramnum-1) % 3 +1
    if sendinfo == nil then
      sendinfo = PopSendInfo(tr)
    end
    if sendinfo[sidx] and sendinfo[sidx].desttrackguid == guid and sendinfo[sidx].dstchan == dstchan and sendinfo[sidx].srcchan == srcchan then
      check = true
    end
    return check, sendinfo
    
  end
  
  function PopSendInfo(tr)
  
    if settings_ExtendedAPI == false then
      return PopSendInfoFromChunk(tr)
    else
    
      tbl = {}

      local track = GetTrack(tr)

      if track then
        local sndcnt = reaper.GetTrackNumSends(track,0)
        for i = 0, sndcnt-1 do
          local dsttrack = reaper.BR_GetMediaTrackSendInfo_Track(track, 0, i, 1)
          if dsttrack then
            local guid = reaper.GetTrackGUID(dsttrack)
            local dst = reaper.GetTrackSendInfo_Value(track, 0, i, 'I_DSTCHAN')
            local src = reaper.GetTrackSendInfo_Value(track, 0, i, 'I_SRCCHAN')
    
            tbl[i] = {}
            local sname, _ = reaper.GetTrackState(dsttrack)
            
            t = -1 --not used
            tbl[i] = {idx = i,
                          sendname = sname,
                          desttracknum = t,
                          desttrackguid = guid,
                          dstchan = dst,
                          srcchan = src,
                          {}}
            tbl[i][1] = {
                                  name = 'Send Volume '..tostring(sname),
                                  parmname = 'D_VOL'
                                 }
            tbl[i][2] = {
                                  name = 'Send Pan '..tostring(sname),
                                  parmname = 'D_PAN'
                                 }
            tbl[i][3] = {
                                  name = 'Send Mute '..tostring(sname),
                                  parmname = 'B_MUTE'
                                 }
          end
        end    
      end
      return tbl
    end
      
  end
    
  function PopSendInfoFromChunk(tr)
  
      tbl = {}
      local sidx = 0
      local auxrcv = ''
      for t = 0, reaper.CountTracks(0)-1 do    
      
        local track = GetTrack(t)
        local _, chunk = reaper.GetTrackStateChunk(track,'')
        local guid = reaper.GetTrackGUID(track)
        local s, e, le = _, 1, 0
        s,e = string.find(string.sub(chunk,e),'AUXRECV .-\n')
        while s and s > 0 do
          ns = le-1+s
          le = le + e
          
          auxrcv = string.sub(chunk,ns,le-1)
          local tx = split(auxrcv, ' ')
          src_tr = tonumber(tx[2])
          src = tonumber(tx[9])
          dst = tonumber(tx[10])
          
          if tonumber(src_tr) == tr then        
            tbl[sidx] = {}
            local sname, _ = reaper.GetTrackState(track)
            tbl[sidx] = {idx = sidx,
                          sendname = sname,
                          desttracknum = t,
                          desttrackguid = guid,
                          dstchan = dst,
                          srcchan = src,
                          {}}
            tbl[sidx][1] = {
                                  name = 'Send Volume '..tostring(sname),
                                  parmname = 'D_VOL'
                                 }
            tbl[sidx][2] = {
                                  name = 'Send Pan '..tostring(sname),
                                  parmname = 'D_PAN'
                                 }
            tbl[sidx][3] = {
                                  name = 'Send Mute '..tostring(sname),
                                  parmname = 'B_MUTE'
                                 }
            
            sidx = sidx + 1
          end
          
          s,e = string.find(string.sub(chunk,le),'AUXRECV .-\n')
        end
      end
      return tbl
        
  end
  
  -------------------------------------------------------

  function PopulateTrackSendsInfo()
  
    --CheckStripSends()
    if tracks[trackedit_select] then
      trsends_table = PopSendInfo(tracks[trackedit_select].tracknum)
    end
    
    trsends_mmtable = {}
    
    trsends_mmtable[1] = {paramstr = 'D_VOL', min = 0, max = 4}
    trsends_mmtable[2] = {paramstr = 'D_PAN', min = -1, max = 1}
    trsends_mmtable[3] = {paramstr = 'B_MUTE', min = 0, max = 1}
    
  end

  function PopulateSpecial()
  
    special_table = {}
    local trn = trackedit_select
    local tr
    if trn == -1 then
      tr = reaper.GetMasterTrack(0)
    else  
      tr = reaper.GetTrack(0, trn)
    end
    if tr then
      local nchan = reaper.GetMediaTrackInfo_Value(tr, 'I_NCHAN')
      special_offs = 1 --#special_table+1
      for i = 0, nchan-1 do
        special_table[i+special_offs] = 'Peak Meter Ch'..i+1
        special_table[i+special_offs+nchan] = 'Clip Indicator Ch'..i+1
      end
      special_table_chans = nchan
    end
      
  end

  -------------------------------------------------------

  function PopulateMediaItemInfo()
  
    trctls_table = {}
    trctls_table[1] = {idx = 1,
                       name = 'Volume',
                       parmname = 'D_VOL',
                       min = 0,
                       max = 4,
                       }
    trctls_table[2] = {idx = 2,
                       name = 'Pan',
                       parmname = 'D_PAN',
                       min = -1,
                       max = 1,
                       }
    trctls_table[3] = {idx = 3,
                       name = 'Width',
                       parmname = 'D_WIDTH',
                       min = -1,
                       max = 1,
                       }
    trctls_table[4] = {idx = 4,
                       name = 'Pan (Left)',
                       parmname = 'D_DUALPANL',
                       min = -1,
                       max = 1,
                       }
    trctls_table[5] = {idx = 5,
                       name = 'Pan (Right)',
                       parmname = 'D_DUALPANR',
                       min = -1,
                       max = 1,
                       }
    trctls_table[6] = {idx = 6,
                       name = 'Mute',
                       parmname = 'B_MUTE',
                       min = 0,
                       max = 1,
                       }
    trctls_table[7] = {idx = 7,
                       name = 'Solo',
                       parmname = 'I_SOLO',
                       min = 0,
                       max = 2,
                       }
    trctls_table[8] = {idx = 8,
                       name = 'Pan Mode',
                       parmname = 'I_PANMODE',
                       min = 0,
                       max = 6,
                       }
    trctls_table[9] = {idx = 9,
                       name = 'Record Arm',
                       parmname = 'I_RECARM',
                       min = 0,
                       max = 1,
                       }
    trctls_table[10] = {idx = 10,
                       name = 'FX Enabled',
                       parmname = 'I_FXEN',
                       min = 0,
                       max = 1,
                       }
    trctls_table[11] = {idx = 11,
                       name = 'Phase',
                       parmname = 'B_PHASE',
                       min = 0,
                       max = 1,
                       }
    trctls_table[12] = {idx = 12,
                       name = 'Monitor',
                       parmname = 'I_RECMON',
                       min = 0,
                       max = 2,
                       }
    
    
  end

  -------------------------------------------------------

  function PopulateTracks()
  --DBG('*** PT ***')
  
    if LBX_CTL_TRACK_INF then
      local LBX_CTL_TRACK_INF_CNT = LBX_CTL_TRACK_INF.count
    end
    LBX_GTRACK = nil
    LBX_CTL_TRACK = nil
    LBX_CTL_TRACK_INF = nil
    local tracks_tmp = {}
    local guid_tr = {}
    local sendsdirty = false
    tracks_idx = {}
    for i = -1, reaper.CountTracks(0) do
      local track = GetTrack(i)
      if track ~= nil then
        local trname, _ = reaper.GetTrackState(track)
  
        tracks_tmp[i] = {name = trname,
                         guid = reaper.GetTrackGUID(track),
                         tracknum = i,
                         strip = -1
                        }
        guid_tr[tracks_tmp[i].guid] = i
        if trname == LBX_CTL_TRNAME then
          LBX_CTL_TRACK = i
          LBX_CTL_TRACK_INF = {count = reaper.TrackFX_GetCount(track),
                               guids = {}}
          if LBX_CTL_TRACK_INF.count > 0 then                     
            for f = 0, LBX_CTL_TRACK_INF.count-1 do
              LBX_CTL_TRACK_INF.guids[f] = reaper.TrackFX_GetFXGUID(track,f)
            end
            if LBX_CTL_TRACK_INF_CNT ~= LBX_CTL_TRACK_INF.count then
              Faders_INIT()
            end
          end
        elseif trname == LBX_GTRACK_NAME then
          LBX_GTRACK = i
        end
        
        --if tracks then
          --if tracks_tmp[i].guid ~= tracks[i].guid then
          --  sendsdirty = true
          --end
        --end
      end  
    end
    tracks = tracks_tmp

    if #strips > 0 then
      for j = 1, #strips do
        
        if strips[j].track.tracknum == -1 then
          tracks_tmp[-1].strip = j
        elseif guid_tr[strips[j].track.guid] then --== tracks_tmp[i].guid then
          tracks_tmp[guid_tr[strips[j].track.guid]].strip = j
        end 
      end
    end
    
    if LBX_GTRACK then
      CheckGlobalTrackSel()
    end
    --if sendsdirty == true then
      --CheckStripSends()
    --end
  end
  
  function PopulateTrackFX()
  
    trackfx = {}
    trackfx_select = 0
    flist_offset = 0

    if trackedit_select and tracks[trackedit_select] then
      local track = GetTrack(tracks[trackedit_select].tracknum)
      if track then
        local fxc = reaper.TrackFX_GetCount(track)
        for i = 0, fxc-1 do
          local _, name = reaper.TrackFX_GetFXName(track,i,'')
          
          trackfx[i] = {name = name,
                        guid = reaper.TrackFX_GetFXGUID(track,i),
                        fxnum = i,
                        found = true}
        end
        PopulateTrackFXParams()
        ofxcnt = fxc
      end
    end
    
  end

  function PopulateTrackFXParams()
  
    trackfxparams = {}
    trackfxparam_select = 0
    plist_offset = 0
    
    if trackedit_select and tracks[trackedit_select] then
      local track = GetTrack(tracks[trackedit_select].tracknum)
      for i = 0, reaper.TrackFX_GetNumParams(track, trackfx_select)-1 do
        local _, name = reaper.TrackFX_GetParamName(track, trackfx_select, i, '')
        
        trackfxparams[i] = {paramnum = i,
                            paramname = name}
      end
      
      local p = #trackfxparams+1
      trackfxparams[p] = {paramnum = p,
                          paramname = 'Offline'}
      p=p+1
      trackfxparams[p] = {paramnum = p,
                          paramname = 'Open GUI'}      
    end
  end
  
  function CalcTListPos(t)
    local oldp = tlist_offset
    if t > oldp-2 and t < oldp+T_butt_cnt-2 then
      return oldp
    else
      return math.max(math.min(t-(math.floor(T_butt_cnt/2)-1), (#tracks+1)-(T_butt_cnt-2)),0)  
    end
  end
  
  function GUI_DrawTracks(obj, gui)
  
    gfx.dest = 1001
  
    if T_butt_cnt == nil then
      T_butt_cnt = math.floor(obj.sections[500].h / butt_h) - 1
      tlist_offset = CalcTListPos(track_select)
      --DBG(tlist_offset)
    else
      T_butt_cnt = math.floor(obj.sections[500].h / butt_h) - 1
    end
    
    for i = 0, T_butt_cnt-1 do
    
      if tracks[i-1 + tlist_offset] then
        local xywh = {x = obj.sections[500].x,
                      y = obj.sections[500].y + butt_h + 2 + butt_h*(i),
                      w = obj.sections[500].w,
                      h = butt_h}
        local c = gui.color.white
        if track_select == i-1 + tlist_offset then
          --[[f_Get_SSV(gui.color.white)
          gfx.rect(xywh.x,
                   xywh.y, 
                   xywh.w,
                   xywh.h, 1, 1)]]
          GUI_DrawBar(gui,'',xywh,skin.highlight,true,gui.color.black,nil,-2)

          c = gui.color.black        
        else
          local s = tracks[i-1+tlist_offset].strip
          if tracks[i-1 + tlist_offset].name == LBX_GTRACK_NAME or 
             tracks[i-1 + tlist_offset].name == LBX_CTL_TRNAME then
            c = '255 192 60' 
          
          elseif strips and strips[s] then
            if (strips[s][1] and #strips[s][1].controls > 0) or --error s3 (nil)
               (strips[s][2] and #strips[s][2].controls > 0) or 
               (strips[s][3] and #strips[s][3].controls > 0) or 
               (strips[s][4] and #strips[s][4].controls > 0) or
               (strips[s][1] and #strips[s][1].graphics > 0) or  
               (strips[s][2] and #strips[s][2].graphics > 0) or  
               (strips[s][3] and #strips[s][3].graphics > 0) or  
               (strips[s][4] and #strips[s][4].graphics > 0) then
              c = '0 192 0' 
            end  
          end 
        
        end
        local nm = tracks[i-1 + tlist_offset].name
        if nm == '' then
          nm = '[unnamed track]'
        elseif nm == LBX_GTRACK_NAME then
          nm = '[LBX GLOBAL]'
        elseif nm == LBX_CTL_TRNAME then
          nm = '[LBX CTL]'
        end
        GUI_textsm_LJ(gui, xywh, tracks[i-1 + tlist_offset].tracknum+1 ..' - '..nm, c, -4, plist_w)
                    
      end                      
    end           

    local xywh = {x = obj.sections[500].x,
                  y = obj.sections[500].y,
                  w = obj.sections[500].w,
                  h = butt_h}
    GUI_DrawBar(gui,'',xywh,skin.barUD,true,gui.color.black,nil,-2)
    gfx.line(xywh.x+xywh.w/2,xywh.y,xywh.x+xywh.w/2,xywh.y+xywh.h)
    local w, h = gfx.getimgdim(skin.arrowup)
    gfx.blit(skin.arrowup,1,0,0,0,w,h,xywh.x+xywh.w/4-w/2,xywh.y+xywh.h/2-h/2)
    gfx.blit(skin.arrowdn,1,0,0,0,w,h,xywh.x+xywh.w*0.75-w/2,xywh.y+xywh.h/2-h/2)
     
  end

  ------------------------------------------------------------
  
  function GetFXEnabled(tracknum, fxnum)
  
    local enb = true
    local tr = GetTrack(tracknum)
    if tr then
      enb = reaper.TrackFX_GetEnabled(track, fxnum)
      if enb then
        --check global track bypass
        local _, flags = reaper.GetTrackState(tr)
        if flags then
          enb = flags&4==4
        end
      end
    end
    return enb
  
  end
  
  ------------------------------------------------------------

  function GUI_DrawBar(gui, t, b, png, v, fg1, fg2, ts, limit)
  
    local c = fg1
    if v == false then
      c = fg2
    end
  
    local sl, sr, sm, wl ,hl, wr, hr, wm, hm, w, h
    w, h = gfx.getimgdim(png)
    sl = png
    
    local corner = 6
    local corner2 = 12
    --TL
    gfx.blit(sl, 1, 0, 0, 0, corner, corner, b.x, b.y) 
    --TR
    gfx.blit(sl, 1, 0, w-corner, 0, corner, corner, b.x+b.w-corner, b.y) 
    --BL
    gfx.blit(sl, 1, 0, 0, h-corner, corner, corner, b.x, b.y+b.h-corner) 
    --BR
    gfx.blit(sl, 1, 0, w-corner, h-corner, corner, corner, b.x+b.w-corner, b.y+b.h-corner) 
    --T
    gfx.blit(sl, 1, 0, corner, 0, w-corner2, corner, b.x+corner, b.y, b.w-corner2, corner) 
    --B
    gfx.blit(sl, 1, 0, corner, h-corner, w-corner2, corner, b.x+corner, b.y+b.h-corner, b.w-corner2, corner) 
    --L
    gfx.blit(sl, 1, 0, 0, corner, corner, h-corner2, b.x, b.y+corner, corner, b.h-corner2) 
    --R
    gfx.blit(sl, 1, 0, w-corner, corner, corner, h-corner2, b.x+b.w-corner, b.y+corner, corner, b.h-corner2) 
    --M
    gfx.blit(sl, 1, 0, corner, corner, w-corner2, h-corner2, b.x+corner, b.y+corner, b.w-corner2, b.h-corner2) 
        
    local xywh = {x=b.x,y=b.y-1,w=b.w,h=b.h}
    if limit~=nil and limit==true then
      GUI_textsm_LJ(gui,xywh,t,c,ts,b.w)
    else
      GUI_textC(gui,xywh,t,c,ts)
    end
    
  end

  function GUI_DrawSidebar(obj, gui)

    gfx.dest = 1001

    if resize_display then
      gfx.setimgdim(1001,obj.sections[43].w+2, obj.sections[43].h)
    end
    
    local xywh = {x = obj.sections[43].x,
                  y = obj.sections[43].y,
                  w = obj.sections[43].w,
                  h = obj.sections[43].h}
    f_Get_SSV(gui.color.cbobg)
    gfx.a = 1 
    gfx.rect(xywh.x,
             xywh.y, 
             xywh.w,
             xywh.h, 1 )
             
    if mode == 0 then

      GUI_DrawBar(gui,'LIVE MODE',obj.sections[11],skin.bar,true,gui.color.black,nil,-2)

      f_Get_SSV(gui.color.black)
      gfx.rect(obj.sections[11].x+obj.sections[11].w-6,
               obj.sections[11].y,
               1,
               obj.sections[11].h,1)        
      f_Get_SSV(gui.color.white)
               
      GUI_DrawTracks(obj, gui)    
    
    else
    
      GUI_DrawBar(gui,'EDIT MODE',obj.sections[11],skin.barR,true,gui.color.black,nil,-2)
      gfx.a=1
     
      GUI_DrawBar(gui,'',obj.sections[13],skin.bar,true,gui.color.black,nil,-2)
      if mode == 1 and submode == 0 then
        local xywh = {x = obj.sections[13].x,
                      y = obj.sections[13].y, 
                      w = obj.sections[13].x+obj.sections[13].w-30,
                      h = obj.sections[13].h}
        if fxmode == 0 then
          GUI_textsm_CJ(gui,xywh,submode_table[submode+1],gui.color.black,-2,xywh.w)
        elseif fxmode == 1 then
          GUI_textsm_CJ(gui,xywh,'TR PARAMS',gui.color.black,-2,xywh.w) --hardcoded - sort out eventually
        end
      else
        GUI_textC(gui,obj.sections[13],submode_table[submode+1],gui.color.black,-2)
      end
      if submode == 0 then
        f_Get_SSV(gui.color.black)
        local xywh = {x = obj.sections[13].x+obj.sections[13].w - 30,
                      y = obj.sections[13].y, 
                      w = 30,
                      h = obj.sections[13].h}
        gfx.rect(xywh.x,
                 xywh.y, 
                 1,
                 xywh.h, 1, 1)
        GUI_textC(gui,xywh,'*',gui.color.black,-2)

      end
      
    end
    
    if mode == 1 then
      if submode == 0 then
      
        GUI_DrawFXParams(obj, gui)    
      
      elseif submode == 1 then
      
        GUI_DrawGraphicsChooser(obj, gui)
      
      elseif submode == 2 then
  
        GUI_DrawStripChooser(obj, gui)
  
      end
    end
    
    gfx.dest = 1  
  
  end

  ------------------------------------------------------------

  function GUI_DrawFXParams(obj, gui)
    if track_select == nil then return end
    gfx.dest = 1001
    --[[if resize_display then
      gfx.setimgdim(1001,obj.sections[43].w+2, obj.sections[43].h)
    end]]
    
    F_butt_cnt = math.floor(obj.sections[520].h / butt_h) - 1
    
    if fxmode == 0 then
      for i = 0, F_butt_cnt-1 do
      
        if trackfx[i + flist_offset] then
          local xywh = {x = obj.sections[520].x,
                        y = obj.sections[520].y +2+ (i+1) * butt_h,
                        w = obj.sections[520].w,
                        h = butt_h}
          local c
          local bypassed = not GetFXEnabled(tracks[trackedit_select].tracknum, i+ flist_offset)
          if bypassed == false then        
            c = gui.color.white
          else
            c = gui.color.red        
          end
          if trackfx_select == i + flist_offset then
            f_Get_SSV(gui.color.white)
            gfx.rect(xywh.x,
                     xywh.y, 
                     xywh.w,
                     xywh.h, 1, 1)
  
            if bypassed == false then        
              c = gui.color.black
            end
          end
          GUI_textsm_LJ(gui, xywh, CropFXName(trackfx[i + flist_offset].name), c, -4, plist_w)
        else
          break
        end
                
      end
    elseif fxmode == 1 then
    
      for i = 0, F_butt_cnt-1 do
        
        if trctltype_table[i + trctltypelist_offset + 1] then
          local xywh = {x = obj.sections[520].x,
                        y = obj.sections[520].y +2+ (i+1) * butt_h,
                        w = obj.sections[520].w,
                        h = butt_h}
          local c = gui.color.white
          if trctltype_select == i + trctltypelist_offset then
            f_Get_SSV(gui.color.white)
            gfx.rect(xywh.x,
                     xywh.y, 
                     xywh.w,
                     xywh.h, 1, 1)
  
            c = gui.color.black
          end
          GUI_textsm_LJ(gui, xywh, trctltype_table[i + trctltypelist_offset + 1], c, -4, plist_w)
        else
          break
        end

      end      
    end
    
    local xywh = {x = obj.sections[520].x,
                  y = obj.sections[520].y,
                  w = obj.sections[520].w,
                  h = butt_h}
    GUI_DrawBar(gui,'',xywh,skin.barUD,true,gui.color.black,nil,-2)
    gfx.line(xywh.x+xywh.w/2,xywh.y,xywh.x+xywh.w/2,xywh.y+xywh.h)
    local w, h = gfx.getimgdim(skin.arrowup)
    gfx.blit(skin.arrowup,1,0,0,0,w,h,xywh.x+xywh.w/4-w/2,xywh.y+xywh.h/2-h/2)
    gfx.blit(skin.arrowdn,1,0,0,0,w,h,xywh.x+xywh.w*0.75-w/2,xywh.y+xywh.h/2-h/2)
    
    --Params
    P_butt_cnt = math.floor(obj.sections[522].h / butt_h)

    if fxmode == 0 then
      for i = 0, P_butt_cnt do
      
        if trackfxparams[i + plist_offset] then
          local xywh = {x = obj.sections[522].x,
                        y = obj.sections[522].y +2 + (i+1) * butt_h,
                        w = obj.sections[522].w,
                        h = butt_h}  
          local c = gui.color.white
          --if trackfxparam_select == i + plist_offset then
          if tfxp_sel and tfxp_sel[i + plist_offset] then  
            f_Get_SSV(gui.color.white)
            gfx.rect(xywh.x,
                     xywh.y, 
                     xywh.w,
                     xywh.h, 1, 1)
  
            c = gui.color.black        
          end
          GUI_textsm_LJ(gui, xywh, trackfxparams[i + plist_offset].paramname, c, -4, plist_w)
        else
          break
        end
                
      end
    elseif fxmode == 1 then
      local tbl = {}
      if trctltype_select == 0 then
        --track controls
        tbl = trctls_table
      elseif trctltype_select == 1 then
        --track sends
        tbl = trsends_table
      elseif trctltype_select == 2 then
        --track meters
        tbl = special_table
      elseif trctltype_select == 3 then
        --other controls
        tbl = otherctl_table
      end
      
      if trctltype_select == 0 then
        for i = 0, #tbl-1 do
          if tbl[i + trctlslist_offset+1] then
            local xywh = {x = obj.sections[522].x,
                          y = obj.sections[522].y +2 + (i+1) * butt_h,
                          w = obj.sections[522].w,
                          h = butt_h}  
            local c = gui.color.white
            if trctl_select-1 == i + trctlslist_offset then  
              f_Get_SSV(gui.color.white)
              gfx.rect(xywh.x,
                       xywh.y, 
                       xywh.w,
                       xywh.h, 1, 1)
              c = gui.color.black        
            end
            GUI_textsm_LJ(gui, xywh, tbl[i + trctlslist_offset+1].name, c, -4, plist_w)
          else
            break
          end
        end
      elseif trctltype_select == 1 then
        for i = 0, (#tbl)*3+2 do
          local ii = i + trctlslist_offset
          local sidx = math.floor(ii / 3)
          local pidx = ii % 3 + 1
          if tbl[sidx] and tbl[sidx][pidx] then
            local xywh = {x = obj.sections[522].x,
                          y = obj.sections[522].y +2 + (i+1) * butt_h,
                          w = obj.sections[522].w,
                          h = butt_h}  
            local c = gui.color.white
            if trctl_select-1 == i + trctlslist_offset then  
              f_Get_SSV(gui.color.white)
              gfx.rect(xywh.x,
                       xywh.y, 
                       xywh.w,
                       xywh.h, 1, 1)
              c = gui.color.black        
            end
            GUI_textsm_LJ(gui, xywh, tbl[sidx][pidx].name, c, -4, plist_w)
          else
            break
          end
        end      
      elseif trctltype_select == 2 or trctltype_select == 3 then
        for i = 1, #tbl do
          --local ii = i-1 + trctlslist_offset
          if tbl[i + trctlslist_offset] then
            local xywh = {x = obj.sections[522].x,
                          y = obj.sections[522].y +2 + (i) * butt_h,
                          w = obj.sections[522].w,
                          h = butt_h}  
            local c = gui.color.white
            if trctl_select == i + trctlslist_offset then  
              f_Get_SSV(gui.color.white)
              gfx.rect(xywh.x,
                       xywh.y, 
                       xywh.w,
                       xywh.h, 1, 1)
              c = gui.color.black        
            end
            GUI_textsm_LJ(gui, xywh, tbl[i + trctlslist_offset], c, -4, plist_w)
          else
            break
          end
        end      
      end

      
    end
    
    local xywh = {x = obj.sections[522].x,
                  y = obj.sections[522].y,
                  w = obj.sections[522].w,
                  h = butt_h}
    GUI_DrawBar(gui,'',xywh,skin.barUD,true,gui.color.black,nil,-2)
    gfx.line(xywh.x+xywh.w/2,xywh.y,xywh.x+xywh.w/2,xywh.y+xywh.h)
    local w, h = gfx.getimgdim(skin.arrowup)
    gfx.blit(skin.arrowup,1,0,0,0,w,h,xywh.x+xywh.w/4-w/2,xywh.y+xywh.h/2-h/2)
    gfx.blit(skin.arrowdn,1,0,0,0,w,h,xywh.x+xywh.w*0.75-w/2,xywh.y+xywh.h/2-h/2)

    --[[f_Get_SSV(gui.color.white)
    gfx.a = 1  
    gfx.rect(obj.sections[521].x,
             obj.sections[521].y, 
             obj.sections[521].w,
             obj.sections[521].h, 1)]]
             
    f_Get_SSV(gui.color.black)
    local xywh = {x = obj.sections[521].x+obj.sections[521].w - 40,
                  y = obj.sections[521].y, 
                  w = 40,
                  h = obj.sections[521].h}
    GUI_DrawBar(gui,'',xywh,skin.bar,true,gui.color.black,nil,-2)
    
    --[[gfx.rect(xywh.x,
             xywh.y, 
             2,
             xywh.h, 1)]]
    if fxmode == 0 then
      GUI_textC(gui,xywh,'LRN',gui.color.black,-2)
    end
    
    local xywh = {x = obj.sections[521].x,
                  y = obj.sections[521].y, 
                  w = obj.sections[521].w-41,
                  h = obj.sections[521].h}
    local sb = skin.bar
    if trackedit_select ~= track_select then
      sb = skin.barR
    end
    GUI_DrawBar(gui,'',xywh,sb,true,gui.color.black,nil,-2)
    f_Get_SSV(gui.color.black)
    if trackedit_select >= 0 and tracks[trackedit_select] then
      GUI_textsm_CJ(gui,xywh,'TR'..trackedit_select+1 ..':'..tracks[trackedit_select].name,gui.color.black,-2,xywh.w)
    else
      GUI_textsm_CJ(gui,xywh,'TR: Master',gui.color.black,-2,xywh.w)        
    end                 

  end

  ------------------------------------------------------------
  
  function GUI_DrawGraphicsChooser(obj, gui)

    gfx.dest = 1001
    --[[if resize_display then
      gfx.setimgdim(1001,obj.sections[43].w+2, obj.sections[43].h)
    end]]

    --PopGfxFolder(gfxfol_select) --MOVE TO WHEN FOLDER CHANGED

    local butt_cnt = math.floor((obj.sections[530].h) / butt_h)  
    GF_butt_cnt = math.floor(obj.sections[531].h / butt_h) - 1

    for i = 0, GF_butt_cnt-1 do
      --DBG(graphics_folders[i + gflist_offset])
      if graphics_folders[i + gflist_offset] then
        local xywh = {x = obj.sections[531].x,
                      y = obj.sections[531].y +2+ (i+1) * butt_h,
                      w = obj.sections[531].w,
                      h = butt_h}
        local c = gui.color.white
        if gfxfol_select == i + gflist_offset then
          f_Get_SSV(gui.color.white)
          gfx.rect(xywh.x,
                   xywh.y, 
                   xywh.w,
                   xywh.h, 1, 1)

          c = gui.color.black
        end
        if gfx_dropfolder == i + gflist_offset then
          f_Get_SSV(gui.color.red)
          gfx.rect(xywh.x,
                   xywh.y, 
                   xywh.w,
                   xywh.h, 0, 1)        
        end
        GUI_textsm_LJ(gui, xywh, graphics_folders[i + gflist_offset], c, -4, plist_w)
      else
        break
      end
              
    end
    
    local xywh = {x = obj.sections[531].x,
                  y = obj.sections[531].y,
                  w = obj.sections[531].w,
                  h = butt_h}
    GUI_DrawBar(gui,'',xywh,skin.barUD,true,gui.color.black,nil,-2)
    gfx.line(xywh.x+xywh.w/2,xywh.y,xywh.x+xywh.w/2,xywh.y+xywh.h)
    local w, h = gfx.getimgdim(skin.arrowup)
    gfx.blit(skin.arrowup,1,0,0,0,w,h,xywh.x+xywh.w/4-w/2,xywh.y+xywh.h/2-h/2)
    gfx.blit(skin.arrowdn,1,0,0,0,w,h,xywh.x+xywh.w*0.75-w/2,xywh.y+xywh.h/2-h/2)
        
    G_butt_cnt = math.floor(obj.sections[530].h / butt_h) - 2
      
    for i = 0, butt_cnt-1 do
    
      if graphics_files[graphics_folder_files[i + glist_offset]] then
        local xywh = {x = obj.sections[530].x,
                      y = obj.sections[530].y+2 + (i+1) * butt_h,
                      w = obj.sections[530].w,
                      h = butt_h}
        local c = gui.color.white
        if gfx_select == i + glist_offset then
          f_Get_SSV(gui.color.white)
          gfx.rect(xywh.x,
                   xywh.y, 
                   xywh.w,
                   xywh.h, 1, 1)

          c = gui.color.black        
        end
        GUI_textsm_LJ(gui, xywh, graphics_files[graphics_folder_files[i + glist_offset]].fn, c, -4, plist_w)
                    
      end                      
    end           

    local xywh = {x = obj.sections[530].x,
                  y = obj.sections[530].y,
                  w = obj.sections[530].w,
                  h = butt_h}
    GUI_DrawBar(gui,'',xywh,skin.barUD,true,gui.color.black,nil,-2)
    gfx.line(xywh.x+xywh.w/2,xywh.y,xywh.x+xywh.w/2,xywh.y+xywh.h)
    local w, h = gfx.getimgdim(skin.arrowup)
    gfx.blit(skin.arrowup,1,0,0,0,w,h,xywh.x+xywh.w/4-w/2,xywh.y+xywh.h/2-h/2)
    gfx.blit(skin.arrowdn,1,0,0,0,w,h,xywh.x+xywh.w*0.75-w/2,xywh.y+xywh.h/2-h/2)
  
  end

  ------------------------------------------------------------
  
  function RemoveFav(fn)
  
    local ret
    local cnt = #strip_favs
    for i = 1, cnt do
      if strip_favs[i] == fn then
        strip_favs[i] = nil
        ret = true
        break
      end
    end
    if ret then
      strip_favs = Table_RemoveNils(strip_favs, cnt)
    end
    
  end

  function InFavs(fn)
  
    local ret
    for i = 1, #strip_favs do
      if strip_favs[i] == fn then
        ret = true
        break
      end
    end
    return ret
    
  end

  function CheckFavs()
  
    local cnt = #strip_favs
    for i = 1, cnt do
      local fn = strips_path..strip_favs[i]
      if reaper.file_exists(fn) == false then
        strip_favs[i] = nil
        ret = true
      end
    end
    if ret then
      strip_favs = Table_RemoveNils(strip_favs, cnt)
    end    
    
  end
  
  function GUI_DrawStripChooser(obj, gui)

    gfx.dest = 1001

    GUI_DrawBar(gui,'SAVE STRIP',obj.sections[511],skin.bar,true,gui.color.black,nil,-2)

    SF_butt_cnt = math.floor(obj.sections[510].h / butt_h) 
    for i = 0, SF_butt_cnt-1 do
    
      if strip_folders[i + sflist_offset] then
        local xywh = {x = obj.sections[510].x,
                      y = obj.sections[510].y+2 + (i+1) * butt_h,
                      w = obj.sections[510].w,
                      h = butt_h}
        local c = gui.color.white
        if stripfol_select == i + sflist_offset then
          f_Get_SSV(gui.color.white)
          gfx.rect(xywh.x,
                   xywh.y, 
                   xywh.w,
                   xywh.h, 1, 1)

          c = gui.color.black        
        end
        GUI_textsm_LJ(gui, xywh, strip_folders[i + sflist_offset].fn, c, -4, plist_w)
                    
      end                      
    end           

    gfx.a = 1  
    local xywh = {x = obj.sections[510].x,
                  y = obj.sections[510].y,
                  w = obj.sections[510].w,
                  h = butt_h}
    GUI_DrawBar(gui,'',xywh,skin.barUD,true,gui.color.black,nil,-2)
    gfx.line(xywh.x+xywh.w/2,xywh.y,xywh.x+xywh.w/2,xywh.y+xywh.h)
    local w, h = gfx.getimgdim(skin.arrowup)
    gfx.blit(skin.arrowup,1,0,0,0,w,h,xywh.x+xywh.w/4-w/2,xywh.y+xywh.h/2-h/2)
    gfx.blit(skin.arrowdn,1,0,0,0,w,h,xywh.x+xywh.w*0.75-w/2,xywh.y+xywh.h/2-h/2)

    S_butt_cnt = math.floor(obj.sections[512].h / butt_h) 
    local w, h = gfx.getimgdim(skin.star)
    for i = 0, S_butt_cnt-1 do
    
      if strip_files[i + slist_offset] then
        local xywh = {x = obj.sections[512].x,
                      y = obj.sections[512].y+2 + (i+1) * butt_h,
                      w = obj.sections[512].w,
                      h = butt_h}
        local c = gui.color.white
        if strip_select == i + slist_offset then
          f_Get_SSV(gui.color.white)
          gfx.rect(xywh.x,
                   xywh.y, 
                   xywh.w,
                   xywh.h, 1, 1)

          c = gui.color.black        
        end
        
        if InFavs(strip_folders[stripfol_select].fn..'/'..strip_files[i + slist_offset].fn) then
          gfx.blit(skin.star,1,0,0,0,w,h,xywh.x+xywh.w-w,xywh.y+xywh.h/2-h/2)
        else
          gfx.blit(skin.starout,1,0,0,0,w,h,xywh.x+xywh.w-w,xywh.y+xywh.h/2-h/2)        
        end
        
        GUI_textsm_LJ(gui, xywh, strip_files[i + slist_offset].fn, c, -4, plist_w-butt_h)
                    
      end                      
    end           

    local xywh = {x = obj.sections[512].x,
                  y = obj.sections[512].y,
                  w = obj.sections[512].w,
                  h = butt_h}
    GUI_DrawBar(gui,'',xywh,skin.barUD,true,gui.color.black,nil,-2)
    gfx.line(xywh.x+xywh.w/2,xywh.y,xywh.x+xywh.w/2,xywh.y+xywh.h)
    local w, h = gfx.getimgdim(skin.arrowup)
    gfx.blit(skin.arrowup,1,0,0,0,w,h,xywh.x+xywh.w/4-w/2,xywh.y+xywh.h/2-h/2)
    gfx.blit(skin.arrowdn,1,0,0,0,w,h,xywh.x+xywh.w*0.75-w/2,xywh.y+xywh.h/2-h/2)

  end
      
  ------------------------------------------------------------

  function OpenDropDown(idx, ddtab, variwidth)
  
    ddlist = ddtab
    ddlist.idx = idx
    ddlist.offset = 0
    ddlist.textsize = -5
    
    if variwidth == true then
      local text_len = 0
      gfx.setfont(1, gui.fontname, gui.fontsz_knob + ddlist.textsize)
      
      for i = 1, #ddlist.items do
        text_len = math.max(gfx.measurestr(ddlist.items[i]),text_len)
      end
      ddlist.w = text_len + ddlist.wpad
    end

    gfx.setimgdim(996,-1,-1)
    
    show_dd = true
    update_dd = true
    update_surface = true
    mouse.context = contexts.dd
    
  end
  
  function GUI_DrawDropdown(gui, obj)
  
    gfx.dest = 996
    if ddlist and ddlist.items then
      local size = #ddlist.items
      if size > 0 then
        local h = math.min(size*butt_h,obj.sections[10].h)+2
        if h > gfx1.main_h then 
          h = gfx1.main_h 
          size = math.floor(h / butt_h)
        end
        ddlist.h = h
        
        local w = math.max(ddlist.w,100)
        ddlist.w = w
        
        gfx.setimgdim(996,w+6,h+6)
        --local x, y = ddlist.x, ddlist.y
        if ddlist.y + ddlist.h > gfx1.main_h then
          ddlist.y = gfx1.main_h - ddlist.h
        end
        if ddlist.x + ddlist.w > gfx1.main_w then
          ddlist.x = gfx1.main_w - ddlist.w
        end
        
        --[[gfx.a = 0.2
        f_Get_SSV(gui.color.black)
        gfx.rect(4,4,w+2,h+2,1)]]
                
        gfx.a = 1
        gfx.rect(0,0,w+2,h+2,1)
        f_Get_SSV(gui.color.white)
        gfx.rect(1,1,w,h,0)
        
        local xywh = {x = 1, y = 0, w = w, h = butt_h}
        for i = 1, size do
        
          xywh.y = (i-1)*butt_h +2
          if ddlist.over == i then
            f_Get_SSV(gui.color.white)
            gfx.rect(xywh.x+2,xywh.y+1,xywh.w-4,xywh.h-2,1)
            GUI_textC_LIM(gui, xywh, ddlist.items[i+ddlist.offset], gui.color.black, -5)            
          else
            GUI_textC_LIM(gui, xywh, ddlist.items[i+ddlist.offset], gui.color.white, -5)
          end   
        end
  
      end
    end
    gfx.dest = 1
    
  end

  function GUI_DrawMIDILrn(gui, obj)

    local strip = tracks[track_select].strip
    local ctl = strips[strip][page].controls[lbx_midilrnctl]
    GUI_DrawPanel(obj.sections[980],true,'FADERBOX LEARN - '..ctl.param_info.paramname)

    if lbx_midilrnval then
      local c = gui.color.black
      if lbx_midilrnval and faders[lbx_midilrnval] and faders[lbx_midilrnval].targettype then
        if (faders[lbx_midilrnval].targettype == 4 or faders[lbx_midilrnval].targettype == 7) and faders[lbx_midilrnval].strip == strip and 
           faders[lbx_midilrnval].page == page and faders[lbx_midilrnval].ctl == lbx_midilrnctl then
          c = '0 128 0'        
        else
          c = gui.color.red
        end
      end
      GUI_DrawButton(gui, 'FADER '..string.format('%i',lbx_midilrnval), obj.sections[981], gui.color.white, c, true, 'FADER', false)      
    else
      GUI_DrawButton(gui, 'NONE', obj.sections[981], -3, gui.color.black, false, 'FADER', false)
    end
    
    if ctl.ctlcat == ctlcats.snapshot then
      local vv = nz(lbx_midilrnoff,0)
      local v = string.format('%i',vv)..'  -  '..num2note(vv)
      GUI_DrawButton(gui, v, obj.sections[983], gui.color.white, c, true, 'Fader Value Offset', false)      
    end
    
    GUI_DrawButton(gui, "OK", obj.sections[982], gui.color.white, gui.color.black, true)
    
  end
  
  function GUI_DrawMIDIOut(gui, obj)

    local strip = tracks[track_select].strip
    local ctl = strips[strip][page].controls[midioutedit_select]
    GUI_DrawPanel(obj.sections[950],true,'MIDI OUT - '..ctl.param_info.paramname)

    local xywh = {x = obj.sections[950].x, y = obj.sections[951].y-butt_h*1.5, w = obj.sections[950].w, h = obj.sections[951].h}
    GUI_textC_LIM(gui, xywh, 'TRANSMIT MIDI MESSAGE', gui.color.white, -2) 

    GUI_DrawButton(gui, nz(midiout_select.output,'--- [None] ---'), obj.sections[951], gui.color.white, gui.color.black, true, 'MIDI OUTPUT')
    GUI_DrawButton(gui, midiout_select.mchan, obj.sections[952], gui.color.white, gui.color.black, true, 'MIDI CHANNEL')
    local msglab = ''
    if midiout_select.msgtype then      
      if midiout_select.msgtype >= 1 and midiout_select.msgtype <= 3 then
        msglab = 'KEY'
      elseif midiout_select.msgtype == 4 then
        msglab = 'MIDI CC#'    
      elseif midiout_select.msgtype >= 5 and midiout_select.msgtype <= 7 then
        msglab = 'N/A'
      end
    end
    GUI_DrawButton(gui, midiout_select.msg3, obj.sections[953], gui.color.white, gui.color.black, true, msglab)
    GUI_DrawButton(gui, nz(midimsgtype_table[nz(midiout_select.msgtype,-1)],'NONE'), obj.sections[954], gui.color.white, gui.color.black, true, 'MESSAGE TYPE')

    local xywh = {x = obj.sections[950].x, y = obj.sections[955].y-butt_h*1.5, w = obj.sections[950].w, h = obj.sections[955].h}
    GUI_textC_LIM(gui, xywh, 'TRANSMIT OSC MESSAGE', gui.color.white, -2) 
    GUI_DrawButton(gui, nz(midiout_select.osc,'none'), obj.sections[955], gui.color.white, gui.color.black, true, 'OSC MESSAGE')

    local xywh = {x = obj.sections[950].x, y = obj.sections[956].y-butt_h*1.5, w = obj.sections[950].w, h = obj.sections[956].h}
    GUI_textC_LIM(gui, xywh, 'CONTROL PARAMETERS', gui.color.white, -2)     
    GUI_DrawButton(gui, midiout_select.vmin, obj.sections[956], gui.color.white, gui.color.black, true, 'VALUE RANGE')
    GUI_DrawButton(gui, midiout_select.vmax, obj.sections[957], gui.color.white, gui.color.black, true, 'TO')

    GUI_DrawButton(gui, focus_table[nz(midiout_select.focus, 1)], obj.sections[958], gui.color.white, gui.color.black, true, 'Focus window')
    GUI_DrawTick(gui, 'Update display before sending msg', obj.sections[959], gui.color.white, nz(midiout_select.updategfx, false))
    GUI_DrawTick(gui, 'Send midi on mouse up', obj.sections[961], gui.color.white, nz(midiout_select.onmu, false))
    
  end
  
  function GetTFXOButtCnt()
    local tfxo_butth = 30
    return math.floor((obj.sections[900].h-30)/tfxo_butth), tfxo_butth
  end

  function GUI_DrawTrackFXOrder(gui, obj)

    GUI_DrawPanel(obj.sections[900],true,'TRACK FX ORDER')
    if tfxreorder then
    
      local butt_cnt, butt_h = GetTFXOButtCnt()
      local offs = 0
      --DBG(tostring(tfxo_sel)..'  '..tostring(tfxo_pos))
      for i = 1, butt_cnt do
    
        if tfxreorder[i+tfxo_listpos] then
          local xywh = {x = obj.sections[900].x+30,
                        y = obj.sections[900].y + 30 + ((i-1) * (butt_h)),
                        w = obj.sections[900].w-50,
                        h = butt_h-5}
          local tc = gui.color.black
          if tostring(tfxreorder[i+tfxo_listpos].offline) == '1' then
            tc = '128 128 128'
          elseif tostring(tfxreorder[i+tfxo_listpos].bypass) == '1' then
            tc = gui.color.red
          end
          if i+tfxo_listpos == tfxo_pos then
            GUI_DrawButton(gui, CropFXName(tfxreorder[i+tfxo_listpos].name), xywh, -4, tc, true, string.format('%i',i+tfxo_listpos))
          elseif tostring(tfxreorder[i+tfxo_listpos].offline) == '1' then
            GUI_DrawButton(gui, CropFXName(tfxreorder[i+tfxo_listpos].name), xywh, -1, tc, true, string.format('%i',i+tfxo_listpos))          
          else
            GUI_DrawButton(gui, CropFXName(tfxreorder[i+tfxo_listpos].name), xywh, gui.color.white, tc, true, string.format('%i',i+tfxo_listpos))
          end          
        end    
      end
      
    end
  
  end

  function GUI_DrawGaugeEdit()
  
    if ctl_select ~= nil then
      GUI_DrawPanel(obj.sections[800],true,'GAUGE EDIT')
      
      local strip = tracks[track_select].strip
      local ctl = strips[strip][page].controls[ctl_select[1].ctl]
      if ctl then
      
        local iidx = ctl.ctl_info.imageidx
        local ctlw, _ = ctl.wsc
        local ctlh = ctl.hsc
        local ctlx, ctly = obj.sections[800].x+obj.sections[800].w/2 - ctlw/2, obj.sections[800].y+120 - ctlh/2
        --local bgx = ctl.xsc+ctl.wsc/2 - obj.sections[800].w/2
        --local bgy = ctl.ysc+ctl.hsc/2 - 120 -butt_h
                
        GUI_DrawGauge2(gauge_select, ctlx+ctlw/2, ctly+ctlh/2, ctl, true)
        
        local v2 = nz(frameScale(ctl.framemode, gauge_select.val),0)
        local frame = F_limit(round(ctl.ctl_info.frames*v2),0,ctl.ctl_info.frames-1)
        
        --local frame = F_limit(math.floor(gauge_select.val * ctl.ctl_info.frames),0,ctl.ctl_info.frames-1)
        gfx.blit(iidx,ctl.scale,0,0,frame*ctl.ctl_info.cellh,ctl.w,ctl.ctl_info.cellh,ctlx,ctly)
        
        f_Get_SSV(gui.color.white)
        gfx.rect(obj.sections[815].x,obj.sections[815].y+1,obj.sections[815].w,obj.sections[815].h,0)
        
        GUI_textC(gui,obj.sections[815],gauge_select.dval,gui.color.white,0)
        
        GUI_DrawButton(gui, gaugetype_table[gauge_select.type], obj.sections[801], gui.color.white, gui.color.black, true, 'TYPE')
        if gauge_select.type == 1 then
          GUI_DrawSliderH(gui, 'RADIUS', obj.sections[802], gui.color.black, gui.color.white, F_limit(((gauge_select.radius-10)/110),0,1))
          GUI_DrawSliderH(gui, 'ROTATE', obj.sections[804], gui.color.black, gui.color.white, F_limit(((gauge_select.rotation)),0,1))
        end
        GUI_DrawSliderH(gui, 'LENGTH', obj.sections[803], gui.color.black, gui.color.white, F_limit(((gauge_select.arclen)),0,1))
        
        --local xywh = {x = obj.sections[805].x, y = obj.sections[805].y - butt_h, w = obj.sections[805].w*2, h = butt_h}
        --GUI_textC(gui,xywh,'AUTO',gui.color.white,-2)
        
        GUI_DrawButton(gui, gauge_select.ticks, obj.sections[805], gui.color.white, gui.color.black, true, 'TICKS (AUTO)')
        GUI_DrawSliderH(gui, 'TICK SIZE', obj.sections[807], gui.color.black, gui.color.white, F_limit(((gauge_select.tick_size-2)/10),0,1))
        GUI_DrawSliderH(gui, 'OFFSET', obj.sections[808], gui.color.black, gui.color.white, F_limit(((gauge_select.tick_offs)/12),0,1))
        GUI_DrawSliderH(gui, 'X OFFSET', obj.sections[809], gui.color.black, gui.color.white, F_limit(((gauge_select.x_offs+30)/60),0,1))
        GUI_DrawSliderH(gui, 'Y OFFSET', obj.sections[810], gui.color.black, gui.color.white, F_limit(((gauge_select.y_offs+30)/60),0,1))
        GUI_DrawButton(gui, gauge_select.font, obj.sections[831], gui.color.white, gui.color.black, true, 'FONT')
        GUI_DrawSliderH(gui, 'FONT SIZE', obj.sections[814], gui.color.black, gui.color.white, F_limit(((gauge_select.fontsz+8)/8),0,1))
        GUI_DrawSliderH(gui, 'VAL FREQ', obj.sections[825], gui.color.black, gui.color.white, F_limit(((gauge_select.val_freq-1)/23),0,1))
        
        local mdptxt = gauge_select.val_dp
        if gauge_select.val_dp < 0 then
          mdptxt = 'OFF'
        end
        GUI_DrawButton(gui, mdptxt, obj.sections[817], gui.color.white, gui.color.black, true, 'MAX DP')
        GUI_DrawTick(gui, 'NUMERIC ONLY', obj.sections[827], gui.color.white, nz(gauge_select.numonly, false))
        local xywh = {x = obj.sections[832].x,
                      y = obj.sections[832].y-butt_h,
                      w = 1,
                      h = butt_h}
        GUI_textC(gui,xywh,'1000 = 1k',gui.color.white,-5)
        GUI_DrawTick(gui, '', obj.sections[832], gui.color.white, nz(gauge_select.abbrev, false))
        
        if ctl.ctltype == 4 then
          GUI_DrawButton(gui, 'COPY CYCLE DATA', obj.sections[818], gui.color.white, gui.color.black, true)
        end
        GUI_DrawButton(gui, 'DEL SEL', obj.sections[826], gui.color.white, gui.color.black, true)
        GUI_DrawButton(gui, '<<', obj.sections[828], gui.color.white, gui.color.black, true)
        GUI_DrawButton(gui, '>>', obj.sections[829], gui.color.white, gui.color.black, true)
        if gauge_ticksel and gauge_select.vals and gauge_select.vals[gauge_ticksel] then
          GUI_DrawSliderH(gui, '', obj.sections[830], gui.color.black, gui.color.white, F_limit(((nz(gauge_select.vals[gauge_ticksel].nudge,0)+10)/20),0,1))
        end
        
        local txt = 'ARC'
        if gauge_select.type > 1 then
          txt = 'LINE'        
        end
        GUI_DrawButton(gui, txt, obj.sections[811], gui.color.white, gui.color.black, gauge_select.show_arc)
        
        GUI_DrawButton(gui, 'TICKS', obj.sections[812], gui.color.white, gui.color.black, gauge_select.show_tick)
        GUI_DrawButton(gui, 'VALS', obj.sections[813], gui.color.white, gui.color.black, gauge_select.show_val)
        GUI_DrawColorBox(gui, '', obj.sections[820], gui.color.white, gauge_select.col_arc)
        GUI_DrawColorBox(gui, '', obj.sections[821], gui.color.white, gauge_select.col_tick)
        GUI_DrawColorBox(gui, '', obj.sections[822], gui.color.white, gauge_select.col_val)
        GUI_DrawSliderH(gui, '', obj.sections[816], gui.color.black, gui.color.white, F_limit(auto_delay/10,0,1))
        GUI_textC(gui,obj.sections[816],auto_delay,gui.color.red,-2)
        xywh = {x = obj.sections[816].x+obj.sections[816].w+5,
                y = obj.sections[816].y,
                w = 30, h = obj.sections[816].h}
        GUI_textC(gui,xywh,'SENS',gui.color.white,-5)

        GUI_DrawButton(gui, 'REMOVE', obj.sections[823], gui.color.white, gui.color.black, true)
        GUI_DrawButton(gui, 'RESET', obj.sections[824], gui.color.white, gui.color.black, true)
        GUI_DrawButton(gui, 'SAVE', obj.sections[819], gui.color.white, gui.color.black, true)
        
      end
    
    else
      show_gaugeedit = false
    end
  
  end

  function GUI_DrawGauge2(gtab, cx, cy, ctl, edit)
  
    if gtab then
    
      local strip = tracks[track_select].strip

      cx = cx + gtab.x_offs
      cy = cy + gtab.y_offs
      
      if gtab.type == 1 then
        if gtab.show_arc == true then
          f_Get_SSV(gtab.col_arc)
          gfx.arc(cx,cy,gtab.radius,-pi*gtab.arclen +(gtab.rotation*(2*pi)),pi*gtab.arclen +(gtab.rotation*(2*pi)),1)
        end
        
        local len = pi*(gtab.arclen*2)
        local steps = gtab.ticks
        local ticksize = gtab.tick_size
        local toffx = 4
        local toffy = 1
        local fs = gtab.fontsz
        r=gtab.radius+gtab.tick_offs
        
        if gtab.show_tick == true or gtab.show_val == true then
          gfx.setfont(1, nz(gtab.font,fontname_def), gui.fontsz_knob+fs)
          
          local vals = gtab.vals
          if vals and #vals > 0 then
            for i = 0, #vals-1 do

              local nudge = 0
              if gtab.vals[i+1].nudge then
                nudge = gtab.vals[i+1].nudge * 0.002
              end

              local theta
              if gtab.mapptof and gtab.spread then
                theta = -pi*gtab.arclen -(pi*0.5) +(gtab.rotation*(2*pi)) + (i/(#vals-1) + nudge) * len
              else
                theta = frameScale(ctl.framemode, vals[i+1].val+nudge) * (2*pi*gtab.arclen) - pi*gtab.arclen -(pi*0.5) +(gtab.rotation*(2*pi))
              end
              
              local showv
              if (i) % gtab.val_freq == 0 then
                showv = true
              end
  
              local x1, y1 = math.floor(cx + r * math.cos(theta)), math.floor(cy + r * math.sin(theta))
              local x2, y2
              if showv then
                x2, y2 = math.floor(cx + (r+ticksize) * math.cos(theta)), math.floor(cy + (r+ticksize) * math.sin(theta))
              else
                x2, y2 = math.floor(cx + (r+ticksize/3) * math.cos(theta)), math.floor(cy + (r+ticksize/3) * math.sin(theta))            
              end
              
              if gtab.show_tick == true then
                if edit and gauge_ticksel and gauge_ticksel == i+1 then
                  f_Get_SSV('255 0 0')
                else
                  f_Get_SSV(gtab.col_tick)
                end
                gfx.line(x1,y1,x2,y2)
              end
              if gtab.show_val == true and gtab.vals[i+1] then
                if showv then
                  local dv = gtab.vals[i+1].dval
                  if gtab.val_dp > -1 or gtab.vals[i+1].dover then
                    dv = gtab.vals[i+1].dover              
                  end
                  local text_len, th = gfx.measurestr(dv)
                  local chkx = math.floor(x2)-math.floor(cx)
                  local chky = math.floor(y2)-math.floor(cy)
                  if chkx < -10 then
                    tx = x2-text_len - toffx
                  elseif chkx > 10 then
                    tx = x2 + toffx
                  else
                    tx = x2-text_len/2
                  end
                  if chky < -10 then
                    ty = y2-th -toffy         
                  elseif chky > 10 then
                    ty = y2 +toffy         
                  else
                    ty = y2-th/2              
                  end
                  local col = gtab.col_val
                  if edit and gauge_ticksel and gauge_ticksel == i+1 then
                    col = '255 0 0'
                  end
                  GUI_textXY(gui,tx,ty,dv,col,0)
                end
              end
            end  
          end

        end
        
      elseif gtab.type == 2 then
        
        local lx = cx+gtab.x_offs
        local ly1 = cy+gtab.y_offs-(gtab.arclen/2 * ctl.hsc)
        local ly2 = cy+gtab.y_offs+(gtab.arclen/2 * ctl.hsc)
        if gtab.show_arc == true then
          f_Get_SSV(gtab.col_arc)
          gfx.line(lx,ly1,lx,ly2,1)
        end
        
        local len = gtab.arclen*ctl.hsc
        local steps = gtab.ticks
        local ticksize = gtab.tick_size
        local toffx = 4
        local toffy = 1
        local fs = gtab.fontsz
        
        if gtab.show_tick == true or gtab.show_val == true then
          gfx.setfont(1, nz(gtab.font,fontname_def), gui.fontsz_knob+fs)
          
          local vals = gtab.vals
          if vals and #vals > 0 then
            for i = 0, #vals-1 do

              local nudge = 0
              if gtab.vals[i+1].nudge then
                nudge = gtab.vals[i+1].nudge * 0.002
              end

              local theta
              if gtab.mapptof and gtab.spread then
                theta = (i/(#vals-1) +nudge) * len
              else
                theta = (frameScale(ctl.framemode, vals[i+1].val)+nudge) * len
              end
              
              local showv
              if (i) % gtab.val_freq == 0 then
                showv = true
              end
              
              local x1, y1
              local x2
              if lx <= cx then
                x1, y1 = lx-gtab.tick_offs, ly2-theta              
                if showv then
                  x2 = lx-gtab.tick_offs-gtab.tick_size
                else
                  x2 = lx-gtab.tick_offs-(gtab.tick_size/3)
                end
              else
                x1, y1 = lx+gtab.tick_offs, ly2-theta              
                if showv then
                  x2 = lx+gtab.tick_offs+gtab.tick_size
                else
                  x2 = lx+gtab.tick_offs+(gtab.tick_size/3)
                end              
              end
              
              if gtab.show_tick == true then
                if edit and gauge_ticksel and gauge_ticksel == i+1 then
                  f_Get_SSV('255 0 0')
                else
                  f_Get_SSV(gtab.col_tick)
                end
                gfx.line(x1,y1,x2,y1)
              end
            
              if gtab.show_val == true and gtab.vals[i+1] then
                if showv then
                  local dv = gtab.vals[i+1].dval
                  if gtab.val_dp > -1 then
                    dv = gtab.vals[i+1].dover              
                  end
                  local text_len, th = gfx.measurestr(dv)
                  if lx <= cx then
                    tx = x2-text_len - toffx
                  else
                    tx = x2 + toffx
                  end
                  ty = y1-th/2              
                  local col = gtab.col_val
                  if edit and gauge_ticksel and gauge_ticksel == i+1 then
                    col = '255 0 0'
                  end
                  GUI_textXY(gui,tx,ty,dv,col,0)
                end
              end
            end
          end
        end
      elseif gtab.type == 3 then
        
        local ly = cy+gtab.y_offs
        local lx1 = cx+gtab.x_offs-(gtab.arclen/2 * ctl.wsc)
        local lx2 = cx+gtab.x_offs+(gtab.arclen/2 * ctl.wsc)
        if gtab.show_arc == true then
          f_Get_SSV(gtab.col_arc)
          gfx.line(lx1,ly,lx2,ly,1)
        end
        
        local len = gtab.arclen*ctl.wsc
        local steps = gtab.ticks
        local ticksize = gtab.tick_size
        local toffx = 1
        local toffy = 4
        local fs = gtab.fontsz
        
        if gtab.show_tick == true or gtab.show_val == true then
          gfx.setfont(1, nz(gtab.font,fontname_def), gui.fontsz_knob+fs)
          
          local vals = gtab.vals
          if vals and #vals > 0 then
            for i = 0, #vals-1 do

              local nudge = 0
              if gtab.vals[i+1].nudge then
                nudge = gtab.vals[i+1].nudge * 0.002
              end

              local theta
              if gtab.mapptof and gtab.spread then
                theta = (i/(#vals-1) +nudge) * len
              else
                theta = (frameScale(ctl.framemode, vals[i+1].val)+nudge) * len
              end
              
              local showv
              if (i) % gtab.val_freq == 0 then
                showv = true
              end
              
              local x1, y1
              local y2
              if ly <= cy then
                y1, x1 = ly-gtab.tick_offs, lx1+theta              
                if showv then
                  y2 = ly-gtab.tick_offs-gtab.tick_size
                else
                  y2 = ly-gtab.tick_offs-(gtab.tick_size/3)
                end
              else
                y1, x1 = ly+gtab.tick_offs, lx1+theta              
                if showv then
                  y2 = ly+gtab.tick_offs+gtab.tick_size
                else
                  y2 = ly+gtab.tick_offs+(gtab.tick_size/3)
                end              
              end
              
              if gtab.show_tick == true then
                if edit and gauge_ticksel and gauge_ticksel == i+1 then
                  f_Get_SSV('255 0 0')
                else
                  f_Get_SSV(gtab.col_tick)
                end
                gfx.line(x1,y1,x1,y2)
              end
            
              if gtab.show_val == true and gtab.vals[i+1] then
                if showv then
                  local dv = gtab.vals[i+1].dval
                  if gtab.val_dp > -1 then
                    dv = gtab.vals[i+1].dover              
                  end
                  local text_len, th = gfx.measurestr(dv)
                  if ly <= cy then
                    ty = y2-th - toffy
                  else
                    ty = y2 + toffy
                  end
                  tx = x1-text_len/2              
                  local col = gtab.col_val
                  if edit and gauge_ticksel and gauge_ticksel == i+1 then
                    col = '255 0 0'
                  end
                  GUI_textXY(gui,tx,ty,dv,col,0)
                end
              end
            end
          end
        end
      end    
    end
  end

  function Gauge_CalcTickVals()
  
    local gtab = gauge_select
    local steps = gtab.ticks
    local c = ctl_select[1].ctl
    
    local strip = tracks[track_select].strip
    local ctl = strips[strip][page].controls[c]
    if ctl then
  
      if steps > 0 then
        --if not gtab.vals then gtab.vals = {} end
        for i = 0, steps-1 do
        
          if steps-1 <= 0 then
            val = 0
          else
            val = i/(steps-1)
          end
          local dval = nz(GetParamDisp_Val(c, val, true),val)
        
          gtab.vals[i+1] = {val = val, dval = dval, dover = nil}
          local nonly
          if gtab.numonly then
            nonly = ''
          end
          if gtab.val_dp > -1 then
            gtab.vals[i+1].dover = roundX(dval, gtab.val_dp, nonly)
          end
        end
      else
        gtab.vals = {}
      end      
    end
    
  end

  function Gauge_SortVals()
  
    local vals = table_slowsort_val(gauge_select.vals)
    if vals then
      gauge_select.vals = vals
    end
    
  end

  function Gauge_RecalcTickVals()
  
    local gtab = gauge_select
    local c = ctl_select[1].ctl
    
    local strip = tracks[track_select].strip
    local ctl = strips[strip][page].controls[c]
    if ctl then
  
      if gtab.vals and #gtab.vals > 0 then

        for i = 1, #gtab.vals do
          
          local dval = gtab.vals[i].dval --GetParamDisp_Val(c, gtab.vals[i].val, true)
          if dval then
            local nonly
            if gtab.numonly then
              nonly = ''
            end        
            gtab.vals[i].dover = roundX(dval, gtab.val_dp, nonly, gtab.abbrev)
          end
        end
        
        --Gauge_SortVals()
      end
    end
    
  end
  
  function Gauge_CopySelect(gt)  
    
    --local gt = gauge_select  
    local gtab
    if gt then              
      gtab = {type = gt.type,
              x_offs = gt.x_offs,
              y_offs = gt.y_offs,
              radius = gt.radius,
              arclen = gt.arclen,
              rotation = gt.rotation,
              ticks = gt.ticks,
              tick_size = gt.tick_size,
              tick_offs = gt.tick_offs,
              val_freq = gt.val_freq,
              col_tick = gt.col_tick,
              col_arc = gt.col_arc,
              col_val = gt.col_val,
              show_arc = gt.show_arc,
              show_tick = gt.show_tick,
              show_val = gt.show_val,
              vals = {},
              val_dp = gt.val_dp,
              font = gt.font,
              fontsz = gt.fontsz,
              spread = gt.spread,
              mapptof = gt.mapptof,
              numonly = gt.numonly,
              abbrev = gt.abbrev,
              val = 0}
                  
      if gt.vals and #gt.vals > 0 then
    
        for i = 1, #gt.vals do
        
          gtab.vals[i] = {val = gt.vals[i].val,
                          dval = gt.vals[i].dval,
                          dover = gt.vals[i].dover,
                          nudge = gt.vals[i].nudge}
        
        end
      end
    end
    
    return gtab
    
  end
  
  function Gauge_CopyCycleData()
  
    local gtab = gauge_select
    local c = ctl_select[1].ctl
    
    local strip = tracks[track_select].strip
    local ctl = strips[strip][page].controls[c]
    if ctl then
    
      if ctl.ctltype == 4 then
        local cycdata = ctl.cycledata
        if cycdata and cycdata.statecnt > 0 then

          gtab.spread = cycdata.spread
          gtab.mapptof = cycdata.mapptof
          
          gtab.vals = {}      
          for i = 1, cycdata.statecnt do
          
            --DBG(tostring(cycdata[i].dval)..'  '..tostring(cycdata[i].dv)) 
            local gcnt = #gtab.vals+1
            gtab.vals[gcnt] = {val = cycdata[i].val,
                               dval = cycdata[i].dv,
                               dover = cycdata[i].dv}
            local nonly
            if gtab.numonly then
              nonly = ''
            end
            if gtab.val_dp > -1 then
              gtab.vals[gcnt].dover = roundX(gtab.vals[gcnt].dval,gtab.val_dp,nonly)
            end
          end
        end
      end
  
    end
    
  end

  function GUI_DrawGauge()
  
    if tracks[track_select] then
      f_Get_SSV(gui.color.white)
      local strip = tracks[track_select].strip
      
      --local x,y = 500,500
      if strips and strips[strip] and strips[strip][page].controls[1] then
        for z = 1, #strips[strip][page].controls do
          local ctl = strips[strip][page].controls[z]
          if ctl.gauge then
            local hidden = Switcher_CtlsHidden(ctl.switcher, ctl.grpid)
            if ctl.hidden ~= true and hidden ~= true and ctl.hide ~= true then
              
              local x = math.floor(ctl.xsc + ctl.wsc/2)
              local y = math.floor(ctl.ysc + ctl.hsc/2)
              GUI_DrawGauge2(ctl.gauge,x,y,ctl)
              
            end
          end
        end
      end
    end    
  
  end

  function GUI_DrawControlBackG(obj, gui)

    gfx.dest = 1004
    --gfx.clear=256
    if resize_display then
      if surface_size.w == -1 then
        gfx.setimgdim(1000,obj.sections[10].w, obj.sections[10].h)
        gfx.setimgdim(1004,obj.sections[10].w, obj.sections[10].h)
        --f_Get_SSV('0 0 0')
        --gfx.rect(0,0,obj.sections[10].w,obj.sections[10].h)
      end
    end

    gfx.a = 1
    f_Get_SSV(backcol)
    gfx.rect(0,
             0, 
             surface_size.w,
             surface_size.h, 1, 1)  
                 
    if tracks and tracks[track_select] and strips[tracks[track_select].strip] and strips[tracks[track_select].strip][page] then
    
      if #strips[tracks[track_select].strip][page].graphics > 0 then
      
        for i = 1, #strips[tracks[track_select].strip][page].graphics do

          gfx.a = 1
        
          local gfxx = strips[tracks[track_select].strip][page].graphics[i]
          local hidden = Switcher_CtlsHidden(gfxx.switcher, gfxx.grpid)
        
          if gfxx.hide == nil and hidden == false then
            local gtype = gfxx.gfxtype
            local x = gfxx.x
            local y = gfxx.y
            if not surface_size.limit then
              x = x + surface_offset.x 
              y = y + surface_offset.y 
            end
            
            if gtype == gfxtype.img then
              local w = gfxx.w
              local h = gfxx.h
              local sw = gfxx.stretchw
              local sh = gfxx.stretchh
              local imageidx = gfxx.imageidx
              
              local yoff = 0
              local xoff = 0
              
              if (gfxx.bright and gfxx.bright ~= 0.5) or (gfxx.contr and gfxx.contr ~= 0.5) 
                 or (gfxx.rmult and gfxx.rmult ~= 0.5) or (gfxx.gmult and gfxx.gmult ~= 0.5) or (gfxx.bmult and gfxx.bmult ~= 0.5) 
                 or (gfxx.alpha and gfxx.alpha ~= 1) then
                iidx = 899
                local ba = -F_limit((0.5-gfxx.bright)*2,-1,1)
                local bc = gfxx.contr
                
                if bc > 0.5 then
                  bc = 1+(bc-0.5)*10
                else
                  bc = bc*2
                end

                local mr = gfxx.rmult
                local mg = gfxx.gmult
                local mb = gfxx.bmult
                if mr > 0.5 then
                  mr = 1+(mr-0.5)*10
                else
                  mr = mr*2
                end
                if mg > 0.5 then
                  mg = 1+(mg-0.5)*10
                else
                  mg = mg*2
                end
                if mb > 0.5 then
                  mb = 1+(mb-0.5)*10
                else
                  mb = mb*2
                end

                local ma = gfxx.alpha
                
                gfx.setimgdim(iidx, -1, -1)
                gfx.setimgdim(iidx, sw, sh)
                gfx.dest = iidx
                if gfxx.stretchmode == 1 then
                  gfx.blit(imageidx,1,0, xoff, yoff, w, h-yoff, 0, 0, sw, sh)
                else
                  local edge = gfxx.edgesz
                  --corners
                  gfx.blit(imageidx,1,0, 0, 0, edge, edge, 0, 0)
                  gfx.blit(imageidx,1,0, w-edge, 0, edge, edge, sw-edge, 0)
                  gfx.blit(imageidx,1,0, w-edge, h-edge, edge, edge, sw-edge, sh-edge)
                  gfx.blit(imageidx,1,0, 0, h-edge, edge, edge, 0, sh-edge)
                  --sides
                  gfx.blit(imageidx,1,0, edge, 0, w-edge-edge, edge, edge, 0, sw-edge-edge, edge)
                  gfx.blit(imageidx,1,0, w-edge, edge, edge, h-edge-edge, sw-edge, edge, edge, sh-edge-edge)
                  gfx.blit(imageidx,1,0, edge, h-edge, w-edge-edge, edge, edge, sh-edge, sw-edge-edge, edge)
                  gfx.blit(imageidx,1,0, 0, edge, edge, h-edge-edge, 0, edge, edge, sh-edge-edge)
                  --middle
                  gfx.blit(imageidx,1,0, edge, edge, w-edge-edge, h-edge-edge, edge, edge, sw-edge-edge, sh-edge-edge)                  
                end
                
                gfx.muladdrect(0,0,sw,sh,bc*mr,bc*mg,bc*mb,1,ba,ba,ba)
                gfx.dest = 1004
                gfx.a = ma
                gfx.blit(iidx,1,0, 0, 0, sw, sh, x+xoff, y+yoff)            
              else
                --gfx.blit(imageidx,1,0, xoff, yoff, w, h-yoff, x+xoff, y+yoff, sw, sh)            
                if gfxx.stretchmode == 1 then
                  gfx.blit(imageidx,1,0, xoff, yoff, w, h-yoff, x+xoff, y+yoff, sw, sh)
                else
                  local edge = gfxx.edgesz
                  --cornersh
                  gfx.blit(imageidx,1,0, 0, 0, edge, edge, x+0, y+0)
                  gfx.blit(imageidx,1,0, w-edge, 0, edge, edge, x+sw-edge, y+0)
                  gfx.blit(imageidx,1,0, w-edge, h-edge, edge, edge, x+sw-edge, y+sh-edge)
                  gfx.blit(imageidx,1,0, 0, h-edge, edge, edge, x+0, y+sh-edge)
                  --sides
                  gfx.blit(imageidx,1,0, edge, 0, w-edge-edge, edge, x+edge, y+0, sw-edge-edge, edge)
                  gfx.blit(imageidx,1,0, w-edge, edge, edge, h-edge-edge, x+sw-edge, y+edge, edge, sh-edge-edge)
                  gfx.blit(imageidx,1,0, edge, h-edge, w-edge-edge, edge, x+edge, y+sh-edge, sw-edge-edge, edge)
                  gfx.blit(imageidx,1,0, 0, edge, edge, h-edge-edge, x+0, y+edge, edge, sh-edge-edge)
                  --middle
                  gfx.blit(imageidx,1,0, edge, edge, w-edge-edge, h-edge-edge, x+edge, y+edge, sw-edge-edge, sh-edge-edge)                  
                end
              end
                          
            elseif gtype == gfxtype.txt then
              --local w = gfxx.w
              --local h = gfxx.h
              local text = gfxx.text
              local textcol = gfxx.text_col
              
              local flagb,flagi,flagu = 0,0,0
              if gfxx.font.bold then
                flagb = 98
              end
              if gfxx.font.italics then
                flagi = 105
              end
              if gfxx.font.underline then
                flagu = 117
              end
              local flags = flagb + (flagi*256) + (flagu*(256^2))
              gfx.setfont(1,gfxx.font.name,
                            gfxx.font.size,flags)
              local w, h = gfx.measurestr(text)
              gfxx.w = w
              gfxx.h = h            
              gfxx.stretchw = w
              gfxx.stretchh = h            
              if gfxx.font.shadow then
              
                local shada = nz(gfxx.font.shadow_a,0.6)
                local shadx = nz(gfxx.font.shadow_x,1)
                local shady = nz(gfxx.font.shadow_y,1)
                --local shadoff = F_limit(math.ceil((gfxx.font.size/250)*10),1,15)
              
                f_Get_SSV(gui.color.black)
                --gfx.a = math.max(shada-(1-backalpha),0)
                gfx.a = shada
                gfx.x, gfx.y = x+shadx,y+shady
                gfx.drawstr(text)
              end
              
              gfx.a = 1
              --gfx.a = backalpha
              gfx.x, gfx.y = x,y
              f_Get_SSV(textcol)
              
              gfx.drawstr(text)
            
            end
          end          
        end
      end      
    end

    if settings_showgrid and mode ~= 0 then
      local gs = settings_gridsize
      if gs == 1 then gs = ogrid end
      f_Get_SSV('0 0 0')
      gfx.a = 0.9
      for i = 0, surface_size.w, gs do
        gfx.line(i,0,i,surface_size.h)
      end
      for i = 0, surface_size.h, gs do
        gfx.line(0,i,surface_size.h,i)
      end
    end
    local ba = math.max(backalpha - backalpha2,0)
    gfx.muladdrect(0,0,surface_size.w,surface_size.h,ba,ba,ba)
    --gfx.muladdrect(0,0,surface_size.w,surface_size.h,1,1,1,1,1,1,1,1)
    
    GUI_DrawGauge()

    gfx.dest = 1    
  end

  ------------------------------------------------------------

  function GUI_DrawCycleOptions(obj, gui)
  
    gfx.dest = 1

    local xywh = {x = obj.sections[100].x,
                  y = obj.sections[100].y-butt_h,
                  w = obj.sections[100].w,
                  h = obj.sections[100].h+butt_h}
    GUI_DrawPanel(xywh,true,'CYCLE OPTS')

    f_Get_SSV('0 0 0')
    gfx.a = 1  

    local p = F_limit(math.floor(cycle_select.val*(defctls[def_knob].frames-1)),0,defctls[def_knob].frames-1)
    local kw, _ = gfx.getimgdim(0)
    local kh = defctls[def_knob].cellh
    gfx.blit(def_knob,1,0,0,p*kh,kw,kh,obj.sections[101].x,obj.sections[101].y)
    
    GUI_DrawButton(gui, cycle_select.statecnt, obj.sections[102], gui.color.white, gui.color.black, true, 'STATES')
    GUI_DrawButton(gui, 'AUTO', obj.sections[104], gui.color.white, gui.color.black, true)
    GUI_DrawSliderH(gui, 'SENS', obj.sections[110], gui.color.black, gui.color.white, F_limit(auto_delay/10,0,1))
    GUI_textC(gui,obj.sections[110],auto_delay,gui.color.red,-2)
    
    GUI_DrawTick(gui, 'POS TO FRAME', obj.sections[107], gui.color.white, nz(cycle_select.mapptof, false))
    GUI_DrawTick(gui, 'DRAGGABLE', obj.sections[108], gui.color.white, nz(cycle_select.draggable, false))
    GUI_DrawTick(gui, 'EVEN SPREAD', obj.sections[109], gui.color.white, nz(cycle_select.spread, false))
    GUI_DrawButton(gui, 'SAVE', obj.sections[106], gui.color.white, gui.color.black, true)

    local c

    f_Get_SSV('16 16 16')
    gfx.rect(obj.sections[103].x-2,
             obj.sections[103].y-2-butt_h, 
             obj.sections[103].w+4,
             obj.sections[103].h+4+butt_h, 1 )

    --[[f_Get_SSV('64 64 64')
    gfx.rect(obj.sections[105].x-2,
             obj.sections[105].y, 
             obj.sections[105].w+4,
             obj.sections[105].h, 1 )]]

    f_Get_SSV('0 0 0')
    local xywh = {x = obj.sections[105].x,
                  y = obj.sections[105].y,
                  w = obj.sections[105].w,
                  h = butt_h}
    GUI_DrawBar(gui,'',xywh,skin.barUD,true,gui.color.black,nil,-2)
    gfx.line(xywh.x+xywh.w/2,xywh.y,xywh.x+xywh.w/2,xywh.y+xywh.h)
    local w, h = gfx.getimgdim(skin.arrowup)
    gfx.blit(skin.arrowup,1,0,0,0,w,h,xywh.x+xywh.w/4-w/2,xywh.y+xywh.h/2-h/2)
    gfx.blit(skin.arrowdn,1,0,0,0,w,h,xywh.x+xywh.w*0.75-w/2,xywh.y+xywh.h/2-h/2)

    --[[f_Get_SSV('0 0 0')
    gfx.rect(obj.sections[105].x+obj.sections[105].w/2,
             obj.sections[105].y, 
             2,
             obj.sections[105].h, 1 )]]
    
    if cycle_select.statecnt > 0 then
      
      f_Get_SSV('0 0 0')
      gfx.rect(obj.sections[103].x,
               obj.sections[103].y, 
               obj.sections[103].w,
               butt_h*F_limit(cycle_select.statecnt,0,8), 1 )
      if cycle_select.selected and cycle_select.selected-cyclist_offset <= 8 and cycle_select.selected-cyclist_offset > 0 then
        f_Get_SSV(gui.color.white)
        gfx.rect(obj.sections[103].x,
                 obj.sections[103].y+(cycle_select.selected-cyclist_offset-1)*butt_h, 
                 obj.sections[103].w,
                 butt_h, 1)
      end
      for i = 1, 8 do
      
        xywh = {x = obj.sections[103].x,
                y = obj.sections[103].y+(i-1)*butt_h,
                w = obj.sections[103].w,
                h = butt_h}
        if cycle_select[i+cyclist_offset] and i+cyclist_offset <= cycle_select.statecnt then
          c = gui.color.white
          if cycle_select.selected and cycle_select.selected == i+cyclist_offset then
            c = gui.color.black
          end
          
          GUI_textsm_LJ(gui,xywh,math.floor(i+cyclist_offset),c,-5)
          xywh.x = xywh.x + 20
          GUI_textsm_LJ(gui,xywh,cycle_select[i+cyclist_offset].dispval,c,-5,xywh.w-20)
        end
                
      end
    end  
  end

  ------------------------------------------------------------

  function GUI_DrawLblOptions(obj, gui)

    gfx.dest = 1

    local xywh = {x = obj.sections[49].x,
                  y = obj.sections[49].y,
                  w = obj.sections[49].w,
                  h = obj.sections[49].h}

    GUI_DrawPanel(xywh, true, 'LABEL OPTS')
    
    xywh.h = butt_h     
    f_Get_SSV(gui.color.white)
    gfx.a = 1 

    GUI_DrawButton(gui, 'EDIT LABEL', obj.sections[140], gui.color.white, gui.color.black, true)
    GUI_DrawButton(gui, gfx_font_select.name, obj.sections[147], gui.color.white, gui.color.black, true)
    GUI_DrawSliderH(gui, 'F SIZE', obj.sections[141], gui.color.black, gui.color.white, F_limit(gfx_font_select.size/250,0,1))
    GUI_DrawColorBox(gui, 'LBL COL', obj.sections[142], gui.color.white, gfx_textcol_select)
    GUI_DrawTick(gui, 'BOLD', obj.sections[143], gui.color.white, gfx_font_select.bold)
    GUI_DrawTick(gui, 'ITALIC', obj.sections[144], gui.color.white, gfx_font_select.italics)
    GUI_DrawTick(gui, 'U/LINE', obj.sections[145], gui.color.white, gfx_font_select.underline)
    GUI_DrawTick(gui, 'SHADOW', obj.sections[146], gui.color.white, gfx_font_select.shadow)
    GUI_DrawSliderH(gui, 'SHAD X', obj.sections[148], gui.color.black, gui.color.white, F_limit((gfx_font_select.shadow_x+15)/30,0,1))
    GUI_DrawSliderH(gui, 'SHAD Y', obj.sections[149], gui.color.black, gui.color.white, F_limit((gfx_font_select.shadow_y+15)/30,0,1))
    GUI_DrawSliderH(gui, 'SHAD A', obj.sections[150], gui.color.black, gui.color.white, F_limit(gfx_font_select.shadow_a,0,1))

  end

  ------------------------------------------------------------

  function GUI_DrawGFXOptions(obj, gui)

    gfx.dest = 1

    local xywh = {x = obj.sections[49].x,
                  y = obj.sections[49].y,
                  w = obj.sections[49].w,
                  h = obj.sections[49].h}

    GUI_DrawPanel(xywh, true, 'GRAPHICS OPTS')
    
    xywh.h = butt_h     
    f_Get_SSV(gui.color.white)
    gfx.a = 1 
    GUI_DrawSliderH(gui, 'BRIGHTNESS', obj.sections[910], gui.color.black, gui.color.white, F_limit(gfxbright_select,0,1))
    GUI_DrawSliderH(gui, 'CONTRAST', obj.sections[911], gui.color.black, gui.color.white, F_limit(gfxcontr_select,0,1))
    GUI_DrawSliderH(gui, 'R', obj.sections[913], gui.color.black, gui.color.white, F_limit(gfxr_select,0,1))
    GUI_DrawSliderH(gui, 'G', obj.sections[914], gui.color.black, gui.color.white, F_limit(gfxg_select,0,1))
    GUI_DrawSliderH(gui, 'B', obj.sections[915], gui.color.black, gui.color.white, F_limit(gfxb_select,0,1))
    GUI_DrawSliderH(gui, 'A', obj.sections[916], gui.color.black, gui.color.white, F_limit(gfxa_select,0,1))
    GUI_DrawButton(gui, 'RESET', obj.sections[912], gui.color.white, gui.color.black, true)

    GUI_DrawButton(gui, gfxstretch_table[gfxstretchmode_select], obj.sections[917], gui.color.white, gui.color.black, true, 'STRETCH')
    GUI_DrawButton(gui, gfxedgesz_select, obj.sections[918], gui.color.white, gui.color.black, true, 'EDGE SIZE')
  
  end
  
  ------------------------------------------------------------

  function GUI_DrawCtlOptions(obj, gui)

    gfx.dest = 1011
    --if resize_display then
      --gfx.setimgdim(1011,obj.sections[45].w, obj.sections[45].h)
    --end

    GUI_DrawPanel(obj.sections[45],nil,'CTL OPTIONS')

    local xywh = {x = 0,
                  y = 2,
                  w = obj.sections[45].w,
                  h = obj.sections[45].h}
    
    --[[f_Get_SSV('0 0 0')
    gfx.a = 1  
    gfx.rect(xywh.x,
     xywh.y, 
     xywh.w,
     xywh.h, 1 )

    f_Get_SSV('64 64 64')
    gfx.a = 1  
    gfx.rect(xywh.x,
     xywh.y, 
     xywh.w,
     xywh.h, 0 )]]
    
    xywh.h = butt_h     
    f_Get_SSV(gui.color.white)
    gfx.a = 1 
    --[[gfx.rect(xywh.x,
     xywh.y, 
     xywh.w,
     xywh.h, 1 )]]

    --GUI_textC(gui,xywh,'CTL OPTIONS',gui.color.black,-2)
    xywh.x = xywh.x+xywh.w-20
    xywh.w = 20
    GUI_textC(gui,xywh,ctl_page+1,gui.color.black,-2)
    
    if ctl_page == 0 then
      xywh = {x = 0,
              y = butt_h,
              w = obj.sections[45].w,
              h = obj.sections[45].h}
      
      local iidx = 1023
  
      if knob_select > -1 then
        if ctl_files[knob_select].imageidx ~= nil then
          iidx = ctl_files[knob_select].imageidx
        else
          gfx.loadimg(1023, controls_path..ctl_files[knob_select].fn)
        end
        local w, _ = gfx.getimgdim(iidx)
        local h = ctl_files[knob_select].cellh
        gfx.a = 1
        local scale_select = 1
        
        if w > h then
          if w > 125 then
            scale_select = 125 / w
          end
        else
          if h > 125 then
            scale_select = 125 / h
          end        
        end
        
        gfx.blit(iidx,scale_select,0, 0, h*math.ceil((ctl_files[knob_select].frames-1)*0.55), w, h, xywh.x + (xywh.w/2-(w*scale_select)/2), xywh.y + (62.5 - (h*scale_select)/2))
        xywh = {x = 0,
                y = butt_h,
                w = obj.sections[45].w,
                h = butt_h}
        gfx.a = 0.75
        
        f_Get_SSV('0 0 0')
        gfx.rect(xywh.x+2,
                 xywh.y+3,
                 xywh.w-4,
                 xywh.h-3,1)        
        GUI_textC(gui,xywh,ctl_files[knob_select].fn,gui.color.white,-5)
  
      end

      GUI_DrawButton(gui, '<', obj.sections[90], gui.color.white, gui.color.black, true)
      GUI_DrawButton(gui, '>', obj.sections[91], gui.color.white, gui.color.black, true)
          
      GUI_DrawSliderH(gui, 'SCALE', obj.sections[50], gui.color.black, gui.color.white, (scale_select-0.5)*2)
      local xywh = {x = obj.sections[52].x-10, y = obj.sections[52].y-butt_h, w = obj.sections[52].w, h = obj.sections[52].h}
      GUI_textC(gui,xywh,'SHOW',gui.color.white,-5)
      GUI_DrawTick(gui, 'NAME', obj.sections[52], gui.color.white, show_paramname)
      GUI_DrawTick(gui, 'VALUE', obj.sections[53], gui.color.white, show_paramval)
      local xywh = {x = obj.sections[54].x, y = obj.sections[54].y-butt_h, w = obj.sections[54].w, h = obj.sections[54].h}
      GUI_textC(gui,xywh,'COL',gui.color.white,-5)
      GUI_DrawColorBox(gui, '', obj.sections[54], gui.color.white, textcol_select)
      GUI_DrawColorBox(gui, '', obj.sections[850], gui.color.white, textcolv_select)
      GUI_DrawButton(gui, ctltype_table[ctltype_select], obj.sections[55], gui.color.white, gui.color.black, true)
      GUI_DrawButton(gui, 'LINK', obj.sections[852], -4, gui.color.black, textoptlink_select)

      local off, valoff
      if toffY then 
        off = textoff_select
        valoff = textoffval_select
      else
        off = textoff_selectx
        valoff = textoffval_selectx      
      end
      GUI_DrawSliderH(gui, 'OFFSET', obj.sections[56], gui.color.black, gui.color.white, F_limit((off+150)/300,0,1))
      GUI_DrawSliderH(gui, 'VAL OFF', obj.sections[65], gui.color.black, gui.color.white, F_limit((valoff+150)/300,0,1))

      GUI_DrawButton(gui, ctlfont_select, obj.sections[48], gui.color.white, gui.color.black, true, 'FONT', true)
      local xywh = {x = obj.sections[58].x-10, y = obj.sections[58].y-butt_h, w = obj.sections[58].w, h = obj.sections[52].h}
      GUI_textC(gui,xywh,'F SIZE',gui.color.white,-5)

      GUI_DrawSliderH(gui, '', obj.sections[58], gui.color.black, gui.color.white, (textsize_select+2)/35)
      GUI_DrawSliderH(gui, '', obj.sections[851], gui.color.black, gui.color.white, (textsizev_select+2)/35)
      GUI_DrawSliderH(gui, 'DEF VAL', obj.sections[57], gui.color.black, gui.color.white, F_limit(defval_select,0,1))
      GUI_DrawButton(gui, 'SET IMAGE', obj.sections[51], gui.color.white, gui.color.black, true)
      GUI_DrawButton(gui, 'EDIT NAME', obj.sections[59], gui.color.white, gui.color.black, true)

      if ctl_select and ctl_select[1].ctl then
        local ctl = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl]
        if ctl and ctl.ctlcat == ctlcats.midictl then
          local midiset = false
          if ctl.midiout then
            midiset = true
          end      
          GUI_DrawButton(gui, 'SET MIDI', obj.sections[960], gui.color.blue, gui.color.black, midiset)
        end
      end
      
      local dir
      if toffY then dir = 'Y' else dir = 'X' end
      GUI_DrawButton(gui, dir, obj.sections[68], gui.color.white, gui.color.black, true)
      
      if ctltype_select == 4 then
        if show_cycleoptions then
          GUI_DrawButton(gui, '>>', obj.sections[67], gui.color.white, gui.color.black, true)
        else
          GUI_DrawButton(gui, '<<', obj.sections[67], gui.color.white, gui.color.black, true)
        end  
      end
      
      local mdptxt = maxdp_select
      if maxdp_select < 0 then
        mdptxt = 'OFF'
      end
      GUI_DrawButton(gui, mdptxt, obj.sections[66], gui.color.white, gui.color.black, true, 'MAX DP')
      
      local v = false
      if gauge_select then
        v = true
      end
      GUI_DrawButton(gui, 'GAUGE', obj.sections[99], gui.color.white, gui.color.black, v)

    elseif ctl_page == 1 then

      GUI_DrawButton(gui, dvaloff_select, obj.sections[125], gui.color.white, gui.color.black, true, 'VDISP OFF')

      local min, max = GetParamMinMax_ctlselect()
      if minov_select == nil then
        minov_select = min
      end
      if maxov_select == nil then
        maxov_select = max
      end
      GUI_DrawButton(gui, minov_select, obj.sections[126], gui.color.white, gui.color.black, true, 'MIN OV', true)
      GUI_DrawButton(gui, maxov_select, obj.sections[127], gui.color.white, gui.color.black, true, 'MAX OV', true)
      GUI_DrawButton(gui, nz(ov_disp,''), obj.sections[130], -3, gui.color.white, true, '')
      GUI_DrawButton(gui, scalemode_preset_table[knob_scalemode_select], obj.sections[131], gui.color.white, gui.color.black, true, 'SCALE PSET')
      GUI_DrawButton(gui, scalemode_dtable[scalemode_select], obj.sections[132], gui.color.white, gui.color.black, true, 'SCALE MOD')
      GUI_DrawButton(gui, framemode_table[framemode_select], obj.sections[133], gui.color.white, gui.color.black, true, 'FRAME MOD')
      GUI_DrawTick(gui, 'HORIZ SLIDER', obj.sections[134], gui.color.white, horiz_select)
      GUI_DrawTick(gui, 'PAGE SNAP EXCLUDE', obj.sections[139], gui.color.white, noss_select)

      xywh = {x = 0,
              y = obj.sections[135].y-butt_h-5,
              w = obj.sections[45].w,
              h = butt_h}
      GUI_textC(gui,xywh,'KNOB SENSITIVITY',gui.color.white,-2)
      GUI_DrawSliderH(gui, 'NORMAL', obj.sections[135], gui.color.black, gui.color.white, ((knobsens_select.norm)/20)*2)
      local txt = string.format('%i',round(knobsens_select.norm*2))
      if txt == '0' then txt = 'GLOBAL' end
      GUI_textC(gui,obj.sections[135],txt,gui.color.red,-2)
      GUI_DrawSliderH(gui, 'FINE', obj.sections[136], gui.color.black, gui.color.white, ((knobsens_select.fine)/20)*100)
      txt = string.format('%i',round(knobsens_select.fine*100))
      if txt == '0' then txt = 'GLOBAL' end
      GUI_textC(gui,obj.sections[136],txt,gui.color.red,-2)
      GUI_DrawSliderH(gui, 'WHEEL', obj.sections[137], gui.color.black, gui.color.white, ((knobsens_select.wheel)/20)*100)
      txt = string.format('%i',round(knobsens_select.wheel*100))
      if txt == '0' then txt = 'GLOBAL' end
      GUI_textC(gui,obj.sections[137],txt,gui.color.red,-2)
      GUI_DrawSliderH(gui, 'WHEEL FINE', obj.sections[138], gui.color.black, gui.color.white, ((knobsens_select.wheelfine)/20)*1000)
      txt = string.format('%i',round(knobsens_select.wheelfine*1000))
      if txt == '0' then txt = 'GLOBAL' end
      GUI_textC(gui,obj.sections[138],txt,gui.color.red,-2)

      local pmin, pmax = 0, 0
      if min and max then
        pmin = normalize(min, max, minov_select)
        pmax = normalize(min, max, maxov_select)
      end
      local w, _ = gfx.getimgdim(def_knobsm)
      gfx.blit(def_knobsm,1,0, 0, defctls[def_knobsm].cellh*math.floor((defctls[def_knobsm].frames-1)*pmin), w, defctls[def_knobsm].cellh, obj.sections[128].x, obj.sections[128].y)
      gfx.blit(def_knobsm,1,0, 0, defctls[def_knobsm].cellh*math.floor((defctls[def_knobsm].frames-1)*pmax), w, defctls[def_knobsm].cellh, obj.sections[129].x, obj.sections[129].y)
    
    elseif ctl_page == 2 then

      GUI_DrawTick(gui, 'BYPASS BG CTL', obj.sections[860], gui.color.white, bypass_bgdraw_c_select)
      GUI_DrawTick(gui, 'BYPASS BG NAME', obj.sections[861], gui.color.white, bypass_bgdraw_n_select)
      GUI_DrawTick(gui, 'BYPASS BG VAL', obj.sections[862], gui.color.white, bypass_bgdraw_v_select)
      
      GUI_DrawTick(gui, 'CLICK THROUGH', obj.sections[863], gui.color.white, clickthrough_select)

    end
    
    gfx.dest = 1
  end
 
  function GUI_DrawSliderH(gui, t, b, colb, cols, v)

    local xywh = {x=b.x-10,y=b.y-2,w=1,h=b.h}
    GUI_textsm_RJ(gui,xywh,t,cols,-4)

    local w, h = gfx.getimgdim(skin.slider_fg)
    --gfx.blit(skin.slider_bg, 1, 0, 0, 0, w, h, b.x, b.y, b.w, b.h) 
    --gfx.blit(skin.slider_bg, 1, 0, w-1, 0, 1, h, b.x+b.w-1, b.y, 1, b.h) 
    f_Get_SSV(cols)
    gfx.a = 1 
    gfx.rect(b.x,
             b.y, 
             b.w,
             b.h, 0)
    
    local iw = math.min(math.ceil(w * v),w)
    local vw = math.min(math.ceil((b.w-4) * v))
    gfx.blit(skin.slider_fg, 1, 0, 0, 0, iw, h, b.x+2, b.y+2, vw, b.h-4) 


    --[[
    f_Get_SSV(colb)
    gfx.a = 1
    local w = math.floor((b.w-2) - (b.w-2) * v)
    if w > 0 then
      gfx.rect(b.x+1 + (b.w-2)-w,
               b.y+1, 
               w,
               b.h-2, 1 )
    end]]
    
  end

  function GUI_DrawButton(gui, t, b, colb, colt, v, opttxt, limit)

    if opttxt then
      local xywh = {x=b.x-10,y=b.y-2,w=1,h=b.h}
      local c = colb
      if tonumber(c) ~= nil then
        c = gui.color.white
      end
      GUI_textsm_RJ(gui,xywh,opttxt,c,-4)
    end

    local f = 1
    if v == nil or v == false then
      f = 0
      colb = -3
    end
    
    local sl, sr, sm, wl ,hl, wr, hr, wm, hm, w, h
    if colb == -1 then
      w, h = gfx.getimgdim(skin.butt18G)
      sl = skin.butt18G
    elseif colb == -2 then
      w, h = gfx.getimgdim(skin.butt18R)
      sl = skin.butt18R
    elseif colb == -3 then
      w, h = gfx.getimgdim(skin.butt18T)
      sl = skin.butt18T
    elseif colb == -4 then
      w, h = gfx.getimgdim(skin.butt18Y)
      sl = skin.butt18Y
    else
      w, h = gfx.getimgdim(skin.butt18)
      sl = skin.butt18
    end

    local corner = 6
    local corner2 = 12
    --TL
    gfx.blit(sl, 1, 0, 0, 0, corner, corner, b.x, b.y) 
    --TR
    gfx.blit(sl, 1, 0, w-corner, 0, corner, corner, b.x+b.w-corner, b.y) 
    --BL
    gfx.blit(sl, 1, 0, 0, h-corner, corner, corner, b.x, b.y+b.h-corner) 
    --BR
    gfx.blit(sl, 1, 0, w-corner, h-corner, corner, corner, b.x+b.w-corner, b.y+b.h-corner) 
    --T
    gfx.blit(sl, 1, 0, corner, 0, w-corner2, corner, b.x+corner, b.y, b.w-corner2, corner) 
    --B
    gfx.blit(sl, 1, 0, corner, h-corner, w-corner2, corner, b.x+corner, b.y+b.h-corner, b.w-corner2, corner) 
    --L
    gfx.blit(sl, 1, 0, 0, corner, corner, h-corner2, b.x, b.y+corner, corner, b.h-corner2) 
    --R
    gfx.blit(sl, 1, 0, w-corner, corner, corner, h-corner2, b.x+b.w-corner, b.y+corner, corner, b.h-corner2) 
    --M
    gfx.blit(sl, 1, 0, corner, corner, w-corner2, h-corner2, b.x+corner, b.y+corner, b.w-corner2, b.h-corner2) 
    

    --[[f_Get_SSV(colb)
    gfx.a = 1 
    gfx.rect(b.x,
             b.y, 
             b.w,
             b.h, f)]]
    if f == 0 or tonumber(colb) ~= nil then
      if tonumber(colb) ~= nil and colb == -1 or colb == -3 then
        colt = gui.color.white
      elseif tonumber(colb) ~= nil and colb == -2 or colb == -4 then
        colt = gui.color.black
      else
        colt = colb
      end
    end
    local xywh = {x=b.x,y=b.y-1,w=b.w,h=b.h}
    if limit~=nil and limit==true then
      GUI_textsm_LJ(gui,xywh,t,colt,-4,b.w)
    else
      GUI_textC(gui,xywh,t,colt,-4)
    end
  end
  
  function GUI_DrawTick(gui, t, b, col, v)
  
    local xywh = {x=b.x-10,y=b.y-2,w=1,h=b.h}
    GUI_textsm_RJ(gui,xywh,t,col,-4)

    local f = 1
    if v == nil or v == false then
      f = 0
    end
    f_Get_SSV(col)
    gfx.a = 1 
    gfx.rect(b.x,
             b.y, 
             b.w,
             b.h, f)
    f_Get_SSV(gui.color.black)
    gfx.line(b.x,b.y,b.x+b.w,b.y+b.h)
    gfx.line(b.x,b.y+b.h,b.x+b.w,b.y)
  
  end

  function GUI_DrawColorBox(gui, t, b, col, cols)
  
    local xywh = {x=b.x-10,y=b.y-2,w=1,h=b.h}
    GUI_textsm_RJ(gui,xywh,t,col,-4)

    local f = 1
    f_Get_SSV(cols)
    gfx.a = 1 
    gfx.rect(b.x,
             b.y, 
             b.w,
             b.h, f)
    f_Get_SSV(col)
    gfx.a = 1 
    gfx.rect(b.x,
             b.y, 
             b.w,
             b.h, 0)
  
  end
    
  ------------------------------------------------------------
  function round(num, idp)
    --num = tonumber(num)
    --if num then
      if tonumber(num) == nil then return num end
      
      local mult = 10^(idp or 0)
      return math.floor(num * mult + 0.5) / mult
    --else
    --  return nz(num,'')
    --end
  end

  function roundX(num, idp, suffix, abbrev)
    local s, e = string.find(num,'%d+.%d+')
    if s and e then  
      local n = string.sub(num,s,e)
      if n and tonumber(n) then
        local mult = 10^(idp or 0)
        local res = math.floor(n * mult + 0.5) / mult
        if idp == 0 then
          res = string.match(tostring(res),'%d+')
          if abbrev == true then
            if tonumber(res) >= 1000 then
              res = string.gsub(tonumber(res)/1000,'%.','k')
              if tonumber(string.match(res, 'k(.*)')) == 0 then
                res = string.match(res, '(.-k).*')
              end
            end
          end
        end
        if suffix then
          local pfx = ''
          if string.sub(num,s-2,s-1) == '-' and tonumber(res) ~= 0 then
            pfx = '-'
          end
          return pfx..res..suffix
        else
          return string.sub(num,1,s-1) .. res .. string.sub(num,e+1)
        end
      else
        return num
      end
    else
      return num
    end
  end

  function GetNumericPart(num)
    local s, e = string.find(num,'%-%d+.%d+')
    if s == nil then
      s, e = string.find(num,'%d+.%d+')
    end
    if s and e then  
      local n = string.sub(num,s,e)
      if n and tonumber(n) then
        res = tonumber(n)
        return res
      else
        return num
      end
    else
      local s, e = string.find(num,'%-%d+')
      if s == nil then
        s, e = string.find(num,'%d+')
      end
      if s and e then  
        local n = string.sub(num,s,e)
        if n and tonumber(n) then
          res = tonumber(n)
          return res
        else
          return num
        end
      else
        return num
      end
    end
  end

  function dvaloffset(num, dvoff)
    dvoff = tonumber(dvoff)
    if dvoff ~= nil and dvoff ~= 0 then
      local s, e = string.find(num,'%-%d+.%d+')
      if s == nil then
        s, e = string.find(num,'%d+.%d+')
      end
      if s and e then  
        local n = string.sub(num,s,e)
        if n and tonumber(n) then
          res = tonumber(n) + dvoff
          return string.sub(num,1,s-1) .. res .. string.sub(num,e+1)
        else
          return num
        end
      else
        local s, e = string.find(num,'%-%d+')
        if s == nil then
          s, e = string.find(num,'%d+')
        end
        if s and e then  
          local n = string.sub(num,s,e)
          if n and tonumber(n) then
            res = tonumber(n) + dvoff
            return string.sub(num,1,s-1) .. res .. string.sub(num,e+1)
          else
            return num
          end
        else
          return num
        end
      end
    else
      return num
    end
  end
  
  function nz(val, d)
    if val == nil then return d else return val end
  end
  function zn(val, d)
    if val == '' or val == nil then return d else return val end
  end
  
  ------------------------------------------------------------

local function inQuart(t, b, c, d)
  t = t / d
  return c * t^4 + b
end

function outCubic(t, b, c, d)
  t = t / d - 1
  return c * ((t^3) + 1) + b
end

function outQuart(t, b, c, d)
  t = t / d - 1
  return -c * (t^4 - 1) + b
end

function outQuint(t, b, c, d)
  t = t / d - 1
  return c * ((t^5) + 1) + b
end

function inExpo(t, b, c, d)
  if t == 0 then
    return b
  else
    return c * 2^(10 * (t / d - 1)) + b - c * 0.001
  end
end

function outExpo(t, b, c, d)
  if t == d then
    return b + c
  else
    return c * 1.001 * -2^((-10 * t / d) + 1) + b
  end
end

function outCirc(t, b, c, d)
  if t < 0 then t = 0 end
  t = t - 1
  return(math.sqrt(1 - t^2)) 
end

  function SetColor2(c)
    local r = (c & 255)/255
    local g = (c >> 8 & 255)/255
    local b = (c >> 16 & 255)/255
    gfx.r, gfx.g, gfx.b = r, g, b
  end

  function GetColor(c)
    return gfx.r + (gfx.g << 8) + (gfx.b << 16)
  end

  function GUI_DrawCtlBitmap()

    if settings_usectlbitmap then
      gfx.setimgdim(ctl_bitmap,-1,-1)
      gfx.setimgdim(ctl_bitmap,surface_size.w, surface_size.h)
      gfx.dest = ctl_bitmap
    
      if tracks[track_select] and strips[tracks[track_select].strip] then
      
        local strip = tracks[track_select].strip
        
        if #strips[strip][page].controls > 0 then
  
          gfx.a = 1
  
          for i = 1, #strips[strip][page].controls do
  
            local ctl = strips[strip][page].controls[i]

            --local scale = ctl.scale
            local px = ctl.xsc
            local py = ctl.ysc
            local w = ctl.wsc --ctl.w
            local h = ctl.hsc --ctl_info.cellh
    
            local hidden = Switcher_CtlsHidden(ctl.switcher, ctl.grpid)
            
            SetColor2(i)
            if hidden == false then
              if (mode == 1 or (ctl.hidden ~= true and ctl.clickthrough ~= true)) then
                --gfx.rect(px,py,w*scale,h*scale,1)
                gfx.rect(px,py,w,h,1)
              end
            end
          end
  
        end
      end    
      
      gfx.dest = 1
    end
      
  end
  
  function GUI_DrawControls(obj, gui)

    gfx.dest = 1000
    gfx.a = 1
    xywharea = {}
    
    if update_gfx or update_bg then
      gfx.blit(1004,1,0,0,0,surface_size.w,surface_size.h,0,0)    
    end    
        
    if tracks[track_select] and strips[tracks[track_select].strip] then
    
      local strip = tracks[track_select].strip
      
      if #strips[strip][page].controls > 0 then

        local trackM = GetTrack(strips[strip].track.tracknum)
        if trackM == nil then 
          if CheckTrack(strips[strip].track, tracks[track_select].strip) then
            trackM = GetTrack(strips[strip].track.tracknum)
          else
            return 
          end 
        end
      
        for i = 1, #strips[strip][page].controls do

          local ctl = strips[strip][page].controls[i]
          local hidden = Switcher_CtlsHidden(ctl.switcher, ctl.grpid)

          if not ctl.hide and hidden ~= true and (mode == 1 or ctl.hidden ~= true or macro_lrn_mode == true or snaplrn_mode == true) then
            local ctlcat = ctl.ctlcat
            
            if update_gfx or ctl.dirty or force_gfx_update or (ctlcat == ctlcats.snapshot and (update_snaps or update_fsnaps)) then
              ctl.dirty = false
              
              local scale = ctl.scale
              local x = ctl.x 
              local y = ctl.y
              local px = ctl.xsc
              local py = ctl.ysc
              local w = ctl.w
              local h = ctl.ctl_info.cellh
    
              local visible = true
              if surface_size.limit == false then
                if x+w < obj.sections[10].x or x > obj.sections[10].x + obj.sections[10].w or y+h < obj.sections[10].y or y > obj.sections[10].y + obj.sections[10].h then
                  visible = false
                end
              end
              
              if visible then
                local gh = h
                local val = math.floor(100*nz(ctl.val,0))
                local fxnum = nz(ctl.fxnum,-1)
                local param = ctl.param
                local pname = ctl.param_info.paramname
                local iidx = ctl.ctl_info.imageidx
                local spn = ctl.show_paramname
                local spv = ctl.show_paramval
                local tc = ctl.textcol
                local tc2 = ctl.textcolv
                local toff = math.floor(ctl.textoff)
                local toffv = math.floor(ctl.textoffval)
                local toffx = math.floor(ctl.textoffx)
                local toffvx = math.floor(ctl.textoffvalx)
                local tsz = nz(ctl.textsize,0)
                local tsz2 = nz(ctl.textsizev,0)
                local frames = math.floor(ctl.ctl_info.frames)
                local ctltype = ctl.ctltype
                local ctlnmov = ctl.ctlname_override
                local found = ctl.fxfound
                local maxdp = nz(ctl.maxdp,-1)
                local dvoff = ctl.dvaloffset
                local tnum = ctl.tracknum
                local font = ctl.font
  
                if fxnum == nil then return end
      
                local track = trackM
                if tnum ~= nil then
                  track = GetTrack(tnum)
                  if track == nil then return end
                else
                  tnum = strips[strip].track.tracknum
                end
      
                --[[gfx.setfont(1, font, gui.fontsz_knob +tsz-4)
                local _, th_a = gfx.measurestr('|')
                gfx.setfont(1, font, gui.fontsz_knob +tsz2-4)
                local _, th_a2 = gfx.measurestr('|')
                th_a, th_a2 = th_a+1, th_a2+1
                local to = th_a2]]
  
                local Disp_ParamV
                local Disp_Name
                local v2, val2 = 0, 0
                --[[DBG(settings_UCV)
                if ctlcat == ctlcats.fxparam and settings_UCV then
                  _, ctl.dval = reaper.TrackFX_GetFormattedParamValue(track, fxnum, param, "")
                  --strips[strip][page].controls[i] = ctl.dval
                  DBG('setitigng: '..tostring(ctl.dval))
                end]]
                
                if ctlcat == ctlcats.fxparam or ctlcat == ctlcats.trackparam or ctlcat == ctlcats.tracksend or ctlcat == ctlcats.pkmeter then
                  v2 = nz(frameScale(ctl.framemode, GetParamValue2(ctlcat,track,fxnum,param,i)),0)
                  val2 = F_limit(round(frames*v2),0,frames-1)
                elseif ctlcat == ctlcats.fxoffline or ctlcat == ctlcats.macro or ctlcat == ctlcats.midictl then
                  v2 = ctl.val                  
                  val2 = F_limit(round(frames*v2),0,frames-1)
                end
                  
                local DVOV
                if ctltype == 3 then
                  --invert button
                  val2 = 1-val2
                elseif ctltype == 4 then
                  --cycle button
                  if ctl.cycledata.mapptof then
                    --override val2
                    --prelim code for single state notify
                    if ctl.cycledata.statecnt == 1 then
                      local v3 = ctl.val
                      --must convert to string to compare               
                      if tostring(v3) ~= tostring(ctl.cycledata[1].val) then
                        --not selected
                        val2 = frames-1
                      else
                        --selected
                        val2 = 0
                      end
                    else
                    
                      Disp_ParamV = GetParamDisp(ctlcat, tnum, fxnum, param, dvoff, i)
                      local p = ctl.cycledata.pos
                      
                      if ctl.cycledata[p] and
                         Disp_ParamV ~= ctl.cycledata[p].dv then
                        for p = 1, ctl.cycledata.statecnt do
                          local vc = ctl.cycledata[p].val
                          if p < ctl.cycledata.statecnt then
                            vc = vc + (ctl.cycledata[p+1].val - vc)/2
                          end
                          
                          if Disp_ParamV == ctl.cycledata[p].dv or 
                             (ctl.val and ctl.val <= vc) then
                            ctl.cycledata.pos = p
                            break
                          end
                        end
                      end
                      
                      if ctl.cycledata.spread then
                        val2 = F_limit(math.floor(((nz(ctl.cycledata.pos,0)-1) / 
                                  (ctl.cycledata.statecnt-1)) * (frames-1)),0,frames-1)
                      else
                        val2 = F_limit(nz(ctl.cycledata.pos,0)-1,0,frames-1)
                      end
                      if ctl.cycledata and 
                         ctl.cycledata[nz(ctl.cycledata.pos,0)] then
                        DVOV = nz(ctl.cycledata[nz(ctl.cycledata.pos,0)].dispval,'')
                      end
                    end
                  else
                    if ctl.cycledata and 
                       ctl.cycledata[nz(ctl.cycledata.pos,0)] then
                      DVOV = nz(ctl.cycledata[nz(ctl.cycledata.pos,0)].dispval,'')
                    end                  
                  end
                elseif ctltype == 6 then
                  --mem button
                  if ctl.membtn == nil then
                    ctl.membtn = {state = false, mem = 0}
                  end
                  local v3 = GetParamValue_Ctl(i)
                  if tostring(v3) ~= tostring(ctl.defval) then
                    ctl.membtn = {state = false, mem = v3}
                  end
                  if ctl.membtn.state == true then
                    val2 = frames-1
                  else
                    val2 = 0                
                  end
                elseif ctltype == 7 or ctltype == 9 then
                  val2 = ctl.val
                elseif ctltype == 8 or ctltype == 10 then
                  if ctl.val then
                    val2 = 1-ctl.val
                  end
                end
                
                if not found then
                  gfx.a = 0.2
                end
                if ctlcat == ctlcats.fxparam then
                  if not found then
                    Disp_Name = CropFXName(ctl.fxname)
                    Disp_ParamV = 'PLUGIN NOT FOUND'
                    tc = gui.color.red
                    val2 = 0
                  else
                    if nz(ctlnmov,'') == '' then
                      _, Disp_Name = reaper.TrackFX_GetParamName(track, fxnum, param, "")
                    else
                      Disp_Name = ctlnmov
                    end
                    _, Disp_ParamV = reaper.TrackFX_GetFormattedParamValue(track, fxnum, param, "")
                   --DBG(Disp_Name..'  '..Disp_ParamV..'  '..fxnum..' '..param)
                    if dvoff and dvoff ~= 0 then
                      Disp_ParamV = dvaloffset(Disp_ParamV, ctl.dvaloffset)  
                    end
                    if maxdp > -1 then
                      Disp_ParamV = roundX(Disp_ParamV, maxdp)                  
                    end
                    --DBG(Disp_Name..'  '..Disp_ParamV..'  '..fxnum..' '..param)
                  end
                elseif ctlcat == ctlcats.trackparam or ctlcat == ctlcats.tracksend then
                  if nz(ctlnmov,'') == '' then
                    Disp_Name = pname
                  else
                    Disp_Name = ctlnmov                  
                  end
                  Disp_ParamV = GetParamDisp(ctlcat, tnum, nil, param, dvoff, i)
                  if maxdp > -1 then
                    Disp_ParamV = roundX(Disp_ParamV, maxdp)                  
                  end                  
                elseif ctlcat == ctlcats.action then
                  if nz(ctlnmov,'') == '' then
                    Disp_Name = pname
                  else
                    Disp_Name = ctlnmov
                  end
                  if DVOV and DVOV ~= '' and cycle_editmode == false then
                  else
                    spv = false  
                  end
                elseif ctlcat == ctlcats.pkmeter then
                  if nz(ctlnmov,'') == '' then
                    Disp_Name = pname
                  else
                    Disp_Name = ctlnmov
                  end
                  if param < 64 then
                    Disp_ParamV = GetParamDisp(ctlcat, tnum, nil, param, dvoff, i)
                    if tonumber(Disp_ParamV) ~= nil and tonumber(Disp_ParamV) < -120 then
                      Disp_ParamV = '-inf'
                    end
                  else
                    Disp_ParamV = ''
                  end
                elseif ctlcat == ctlcats.snapshot then
                  if nz(ctlnmov,'') == '' then
                    Disp_Name = pname
                  else
                    Disp_Name = ctlnmov
                  end
                  local v = nz(ctl.val,-1)
                  Disp_ParamV = ''
                  if v > -1 then
                    if snapshots and snapshots[strip] and snapshots[strip][page][param] and snapshots[strip][page][param].selected then
                      if param == 1 then 
                        if snapshots[strip][page][param][snapshots[strip][page][param].selected] then
                          Disp_ParamV = snapshots[strip][page][param][snapshots[strip][page][param].selected].name
                        end
                      else
                        if snapshots[strip][page][param].snapshot[snapshots[strip][page][param].selected] then
                          Disp_ParamV = snapshots[strip][page][param].snapshot[snapshots[strip][page][param].selected].name
                        end
                      end
                    end
                  end
                elseif ctlcat == ctlcats.xy or ctlcat == ctlcats.snapshotrand or ctlcat == ctlcats.fxgui then
                  if nz(ctlnmov,'') == '' then
                    Disp_Name = pname
                  else
                    Disp_Name = ctlnmov
                  end
                elseif ctlcat == ctlcats.fxoffline then
                  spv = false
                  if nz(ctlnmov,'') == '' then
                    Disp_Name = pname
                  else
                    Disp_Name = ctlnmov
                  end
                elseif ctlcat == ctlcats.rcm_switch then
                  if nz(ctlnmov,'') == '' then
                    Disp_Name = pname
                  else
                    Disp_Name = ctlnmov
                  end
                  if ctl.rcmdata and ctl.val and ctl.rcmdata[ctl.val] then
                    Disp_ParamV = ctl.rcmdata[ctl.val].name
                  else
                    Disp_ParamV = ''
                  end
                  
                elseif ctlcat == ctlcats.midictl then
                  --spv = false
                  local ctv = ctl.val
                  if ctl.midiout then
                    ctv = math.floor((ctl.midiout.vmax - ctl.midiout.vmin)*ctv)+ctl.midiout.vmin
                    --[[if ctl.midiout.msgtype <= 6 then
                      ctv = math.floor(ctv * 127)
                    else
                      ctv = math.floor(ctv * 16383)
                    end
                    ctv = roundX(ctv,0)]]
                  end
                  Disp_ParamV = ctv
                  if nz(ctlnmov,'') == '' then
                    Disp_Name = pname
                  else
                    Disp_Name = ctlnmov
                  end
                  
                elseif ctlcat == ctlcats.macro then
                  --spv = false
                  Disp_ParamV = round(ctl.val,2)
                  if nz(ctlnmov,'') == '' then
                    Disp_Name = pname
                  else
                    Disp_Name = ctlnmov
                  end
                elseif ctlcat == ctlcats.eqcontrol then
                  spv = false
                  if nz(ctlnmov,'') == '' then
                    Disp_Name = pname
                  else
                    Disp_Name = ctlnmov
                  end
                 elseif ctlcat == ctlcats.switcher then
                  spv = false
                  --if nz(ctlnmov,'') == '' then
                    Disp_Name = pname
                  --else
                  --  Disp_Name = ctlnmov
                  --end
                  
                 end
  
                if ctltype == 4 and cycle_editmode == false then
                  if DVOV and DVOV ~= '' then
                    if ctl.cycledata.posdirty == false then 
                      Disp_ParamV = DVOV
                      
                      if maxdp > -1 then
                        Disp_ParamV = roundX(Disp_ParamV, maxdp)                  
                      end
                    end
                  --else
                  end
                end

                local offl = false
                if ctlcat == ctlcats.fxparam and ctl.offline then
                  offl = true
                  if settings_showparamnamelabelwhenoffline == false then
                    Disp_Name = 'Offline'
                  end
                  Disp_ParamV = ''
                end
                  
                local mid = x+(w/2)
  
                gfx.setfont(1, font, gui.fontsz_knob +tsz-4)
                local text_len1x, text_len1y = gfx.measurestr(Disp_Name)
                gfx.setfont(1, font, gui.fontsz_knob +tsz2-4)
                local text_len2x, text_len2y = gfx.measurestr(Disp_ParamV)
  
                local tl1 = nz(ctl.tl1,text_len1x)
                local tl2 = nz(ctl.tl2,text_len2x)
                --DBG(tostring(ctl.th1)..'  '..text_len1y)
                local th1 = nz(ctl.th1,text_len1y)
                --DBG(th1)f
                local th2 = nz(ctl.th2,text_len2y)

                local xywh1 = {x = math.floor(mid-(text_len1x/2))-toffx, y = math.floor(y+(h/2)-toff-1), w = text_len1x, h = 1}
                local xywh2 = {x = math.floor(mid-(text_len2x/2))+toffx+toffvx, y = math.floor(y+(h/2)+toff+toffv-1), w = text_len2x, h = 1}
                
                local tx1, tx2 = math.floor(mid-(tl1/2))-toffx,
                                     math.floor(mid-(tl2/2))+toffx+toffvx --gui.fontsz_knob+tsz-4
                                     
                gfx.a=1
                if not update_gfx and not update_bg and ctlcat ~= ctlcats.xy then
                  if ctl.bypassbg_c ~= true then
                    gfx.blit(1004,1,0, px,
                                       py,
                                       w*scale,
                                       h*scale,
                                       px,
                                       py)
                  end
                  if spn and ctl.bypassbg_n ~= true then                   
                    gfx.blit(1004,1,0, tx1,
                                       xywh1.y-math.floor(th1/2),
                                       tl1,
                                       --[[th_a]]th1,
                                       tx1,
                                       xywh1.y-math.floor(th1/2))
                  end
                  if spv and ctl.bypassbg_v ~= true then                
                    gfx.blit(1004,1,0, tx2,
                                       xywh2.y-math.floor(th2/2),
                                       tl2,
                                       --[[th_a2]]th2,
                                       tx2,
                                       xywh2.y-math.floor(th2/2))
                  end
                  gfx.a=1
                end
  
                gfx.a=1
                if ctlcat == ctlcats.fxparam and ((not reaper.TrackFX_GetEnabled(track, fxnum) and pname ~= 'Bypass') or strips[strip][page].controls[i].offline) then
                  gfx.a = 0.5
                elseif (mode == 1 and submode == 1) or ctl.hidden then
                  gfx.a = 0.5
                end
                gfx.blit(iidx,_,0, 0, val2*gh, w, h, px, py, math.floor(w*scale), math.floor(h*scale))
                if ctlcat == ctlcats.xy then
                
                  --draw pos
                  local ppw, pph = gfx.getimgdim(def_xytarget)
                  local ppx = 12+px+math.floor(ctl.xydata.x * (w-24)) - math.floor(ppw/2)
                  local ppy = 12+py+math.floor(ctl.xydata.y * (h-34-24)) - math.floor(pph/2)

                  gfx.blit(def_xytarget,1,0, 0, 0, ppw, pph, ppx, ppy)
                
                end
                
                ctl.tl1 = text_len1x
                ctl.tl2 = text_len2x
                ctl.th1 = text_len1y
                ctl.th2 = text_len2y                
                
                  local alpha = 1
                  if settings_hideofflinelabel and offl then
                    spn = false
                  elseif offl or ctl.hidden then
                    alpha = 0.4
                  end
                  --[[if tsz ~= tsz2 then
                    DBG(tsz..'  '..tsz2)
                  end]]
                  if spn then
                    gfx.setfont(1, font, gui.fontsz_knob +tsz-4)                    
                    GUI_textCtl(gui,xywh1, Disp_Name,tc,-4 + tsz, alpha)
                  end
                  if spv then
                    gfx.setfont(1, font, gui.fontsz_knob +tsz2-4)                    
                    GUI_textCtl(gui,xywh2, Disp_ParamV,tc2,-4 + tsz2, alpha)          
                  end
  
                if setting_reddotindicator == true and ctltype == 4 and DVOV and DVOV ~= '' and cycle_editmode == false then
                  if ctl.cycledata.posdirty == true then 
                    gfx.a = 0.8
                    f_Get_SSV(gui.color.red)
                    gfx.circle(x+4,y+4,2,1,1)              
                  end
                end
                            
                if mode == 1 and submode == 2 then
                  if tnum and tnum ~= tracks[track_select].tracknum then
                  
                    gfx.a = 0.8
                    f_Get_SSV(gui.color.red)
                    gfx.circle(x,y,2,1,1)              
                  
                  end
                end
                
                if not update_gfx and not update_bg and update_ctls then
                
                  --just blit control area to main backbuffer - create area table
                  local al = math.min(px, xywh1.x, xywh2.x, tx1, tx2)
                  local ar = math.max(px+w*scale, tx1+tl1, tx2+tl2, xywh1.x+xywh1.w, xywh2.x+xywh2.w)
                  local at = math.min(py, xywh1.y-math.floor(th1/2), xywh2.y-math.floor(th2/2))
                  local ab = math.max(py+(h)*scale,xywh1.y+math.floor(th1/2), xywh2.y+math.floor(th2/2))
                  xywharea[#xywharea+1] = {x=al,y=at,w=ar-al,h=ab-at,r=ar,b=ab}
                end
              end
            end
          end
        end
        
        if not update_gfx and not update_bg and update_ctls then
          --loop through blit area table - blit to backbuffer
          gfx.a=1
          local ox, oy = 0,0
          if surface_offset.x < 0 then ox=-1 end
          if surface_offset.y < 0 then oy=-1 end
          if #xywharea > 0 then
            gfx.dest = 1
            for i = 1, #xywharea do
              local xx = (xywharea[i].x + obj.sections[10].x - surface_offset.x + ox)
              local yy = (xywharea[i].y + obj.sections[10].y - surface_offset.y + oy)
              if xx+xywharea[i].w < obj.sections[10].x or yy+xywharea[i].h < obj.sections[10].y
                 or yy > obj.sections[10].y+obj.sections[10].h or xx > obj.sections[10].x+obj.sections[10].w then
              else
                if xx < obj.sections[10].x then
                  xywharea[i].x = xywharea[i].x + (obj.sections[10].x - xx)
                  xywharea[i].w = xywharea[i].w  - (obj.sections[10].x - xx)
                  xx = obj.sections[10].x
                end
                if xx + xywharea[i].w > obj.sections[10].x+obj.sections[10].w then
                  xywharea[i].w = (obj.sections[10].x+obj.sections[10].w)-xx
                end
                if yy < obj.sections[10].y then
                  xywharea[i].y = xywharea[i].y + (obj.sections[10].y - yy)
                  xywharea[i].h = xywharea[i].h  - (obj.sections[10].y - yy)
                  yy = obj.sections[10].y
                end
                if yy + xywharea[i].h > obj.sections[10].y+obj.sections[10].h then
                  xywharea[i].h = (obj.sections[10].y+obj.sections[10].h)-yy
                end

                gfx.blit(1000,1,0, xywharea[i].x,
                                   xywharea[i].y,
                                   xywharea[i].w,
                                   xywharea[i].h,
                                   xx ,
                                   yy)
              end
            end
          end
        end
        
      end
    end
    force_gfx_update = false
    
  end
  
  ------------------------------------------------------------

  function CalcSelRect()
  
    if strips and tracks[track_select] and strips[tracks[track_select].strip] and strips[tracks[track_select].strip][page] then
      if #strips[tracks[track_select].strip][page].controls > 0 then
        local i = ctl_select[1].ctl
        local ctl = strips[tracks[track_select].strip][page].controls[i]
    
        local x = ctl.x 
        local y = ctl.y
        local w = ctl.w
        local h = ctl.ctl_info.cellh
        
        local xsc = ctl.xsc 
        local ysc = ctl.ysc
        local wsc = ctl.wsc
        local hsc = ctl.hsc
        
        local rx, ry = x+w, y+h
        local rxsc, rysc = xsc+wsc, ysc+hsc

        if #ctl_select > 1 then
          for i = 2, #ctl_select do
            j = ctl_select[i].ctl
            local ctlj = strips[tracks[track_select].strip][page].controls[j]
    
            x = math.min(x, ctlj.x)
            y = math.min(y, ctlj.y)
            rx = math.max(rx, ctlj.x + ctlj.w)
            ry = math.max(ry, ctlj.y + ctlj.ctl_info.cellh)
            xsc = math.min(xsc, ctlj.xsc)
            ysc = math.min(ysc, ctlj.ysc)
            rxsc = math.max(rxsc, ctlj.xsc + ctlj.wsc)
            rysc = math.max(rysc, ctlj.ysc + ctlj.hsc)
      
          end
        end
        if gfx3_select and #gfx3_select > 0 then
          for i = 1, #gfx3_select do
            j = gfx3_select[i].ctl
    
            x = math.min(x, strips[tracks[track_select].strip][page].graphics[j].x)
            y = math.min(y, strips[tracks[track_select].strip][page].graphics[j].y)
            rx = math.max(rx, strips[tracks[track_select].strip][page].graphics[j].x + strips[tracks[track_select].strip][page].graphics[j].stretchw)
            ry = math.max(ry, strips[tracks[track_select].strip][page].graphics[j].y + strips[tracks[track_select].strip][page].graphics[j].stretchh)
            
          end
        end

        local selrect = {x = x, y = y, w = rx-x, h = ry-y}
        local selrect_sc = {x = xsc, y = ysc, w = rxsc-xsc, h = rysc-ysc}
        return selrect, selrect_sc
      end
    end
    
    return nil
    
  end

  function CalcCtlRect()

    local rect = nil  
    if strips and tracks[track_select] and strips[tracks[track_select].strip] and strips[tracks[track_select].strip][page] then
      if #strips[tracks[track_select].strip][page].controls > 0 then
        local i = 1
        local x = strips[tracks[track_select].strip][page].controls[i].x 
        local y = strips[tracks[track_select].strip][page].controls[i].y
        local w = strips[tracks[track_select].strip][page].controls[i].w
        local h = strips[tracks[track_select].strip][page].controls[i].ctl_info.cellh
        local rx, ry = x+w, y+h
        if #strips[tracks[track_select].strip][page].controls > 1 then
          for j = 2, #strips[tracks[track_select].strip][page].controls do
    
            x = math.min(x, strips[tracks[track_select].strip][page].controls[j].x)
            y = math.min(y, strips[tracks[track_select].strip][page].controls[j].y)
            rx = math.max(rx, strips[tracks[track_select].strip][page].controls[j].x + strips[tracks[track_select].strip][page].controls[j].w)
            ry = math.max(ry, strips[tracks[track_select].strip][page].controls[j].y + strips[tracks[track_select].strip][page].controls[j].ctl_info.cellh)
            
          end
        end
        
        rect = {x = x, y = y, w = rx-x, h = ry-y}
      end
    end 

    return rect     
  end

  function CalcGFXSelRect()

    if strips and tracks[track_select] and strips[tracks[track_select].strip] and strips[tracks[track_select].strip][page] then
      if #strips[tracks[track_select].strip][page].graphics > 0 then

        local i = gfx2_select
        local x = strips[tracks[track_select].strip][page].graphics[i].x 
        local y = strips[tracks[track_select].strip][page].graphics[i].y
        local w = strips[tracks[track_select].strip][page].graphics[i].stretchw
        local h = strips[tracks[track_select].strip][page].graphics[i].stretchh
        local rx, ry = x+w, y+h
        local selrect = {x = x-4, y = y-4, w = w+8, h = h+8}
        return selrect
      end
    end

    return nil
      
  end
  
  ------------------------------------------------------------
  
    function GUI_DrawParamLearn(obj, gui)
    
      gfx.a=1
      
      GUI_DrawPanel(obj.sections[115],true,'PARAM LEARN')
      
      --[[f_Get_SSV(gui.color.black)
      gfx.rect(obj.sections[115].x,
               obj.sections[115].y, 
               obj.sections[115].w,
               obj.sections[115].h, 1, 1)
      f_Get_SSV('64 64 64')
      gfx.rect(obj.sections[115].x,
               obj.sections[115].y, 
               obj.sections[115].w,
               obj.sections[115].h, 0, 1)]]
      
      xywh = {x = obj.sections[115].x,
              y = obj.sections[115].y,
              w = obj.sections[115].w,
              h = butt_h}
      
      --[[f_Get_SSV(gui.color.white)
      gfx.a = 1 
      gfx.rect(xywh.x,
               xywh.y, 
               xywh.w,
               butt_h, 1 )]]
      
      --GUI_textC(gui,xywh,'PARAM LEARN',gui.color.black,-2)
      
      xywh.y = obj.sections[116].y
      local iidx = 1023
      
      if knob_select > -1 then
        if ctl_files[knob_select].imageidx ~= nil then
          iidx = ctl_files[knob_select].imageidx
        else
          gfx.loadimg(1023, controls_path..ctl_files[knob_select].fn)
        end
        local w, _ = gfx.getimgdim(iidx)
        gfx.a = 1
        local sx,sy = 1,1
        if w > obj.sections[115].w then
          sx = obj.sections[115].w/w
        end
        if ctl_files[knob_select].cellh > 128 then
          sy = 128/ctl_files[knob_select].cellh
        end
        local sc = F_limit(math.min(sx, sy),0,1)
        gfx.blit(iidx,sc,0, 0, 
                            ctl_files[knob_select].cellh*math.floor(ctl_files[knob_select].frames*0.75), 
                            w, 
                            ctl_files[knob_select].cellh, xywh.x + (xywh.w/2-(w*sc)/2), 
                            xywh.y + (62.5 - (ctl_files[knob_select].cellh*sc)/2))
        
      end
      
      if last_touch_fx then
      
        GUI_textsm_LJ(gui,obj.sections[117],last_touch_fx.tracknum..': '..last_touch_fx.trname,gui.color.white,-5,obj.sections[117].w)
        GUI_textsm_LJ(gui,obj.sections[118],last_touch_fx.fxname,gui.color.white,-5,obj.sections[117].w)
        GUI_textsm_LJ(gui,obj.sections[119],last_touch_fx.prname,gui.color.white,-5,obj.sections[117].w)    
      
      end
      
    end
    
  ------------------------------------------------------------
  
  function GUI_DrawPanel(objPanel, tobgd, tit)

    gfx.a=1
    local x,y = 0,0
    if tobgd then
      x,y = objPanel.x, objPanel.y
    end
    local wt, ht = gfx.getimgdim(skin.panela_top)
    local wb, hb = gfx.getimgdim(skin.panela_bot)
    local hh = ht + hb
    local pw = objPanel.w
    local ph = objPanel.h
    if hh > ph then ht = ph - hb end
    local edge = 10
    gfx.blit(skin.panela_top, 1, 0, 0, 0, edge, ht, x, y) 
    gfx.blit(skin.panela_top, 1, 0, wt-edge, 0, edge, ht, x+(pw-edge), y) 
    gfx.blit(skin.panela_top, 1, 0, 10, 0, wt-(2*edge), ht, x+edge, y, pw-(2*edge)) 
    local th = ht
    gfx.blit(skin.panela_bot, 1, 0, 0, 0, edge, hb, x, y+ph-hb) 
    gfx.blit(skin.panela_bot, 1, 0, wt-edge, 0, edge, hb, x+(pw-edge), y+ph-hb) 
    gfx.blit(skin.panela_bot, 1, 0, 10, 0, wb-(2*edge), hb, x+edge, y+ph-hb, pw-(2*edge)) 
    local sh = ph - hh
    if sh > 0 then
      local w, h = gfx.getimgdim(skin.panela_mid)
      gfx.blit(skin.panela_mid, 1, 0, 0, 0, edge, h, x, y+th, edge, sh) 
      gfx.blit(skin.panela_mid, 1, 0, w-edge, 0, edge, h, x+(pw-edge), y+th, edge, sh) 
      gfx.blit(skin.panela_mid, 1, 0, 10, 0, w-(2*edge), h, x+edge, y+th, pw-(2*edge), sh) 
    end
    if tit then
      xywh = {x = x,
              y = y+2,
              w = pw,
              h = butt_h}
      GUI_textC(gui,xywh,tit,gui.color.black,-2)
    end
    
  end

  function GUI_DrawSnapshots(obj, gui)

    gfx.dest = 1003
    
    gfx.a=1

    GUI_DrawPanel(obj.sections[160], nil, 'SNAPSHOTS')
    
    local sstypestr = 'PAGE'
    if sstype_select > 1 then
      if tracks[track_select] and tracks[track_select].strip and snapshots[tracks[track_select].strip] and 
         snapshots[tracks[track_select].strip][page][sstype_select] then
        sstypestr = snapshots[tracks[track_select].strip][page][sstype_select].subsetname
      else
        sstypestr = ''
      end
    end
      
    GUI_DrawButton(gui, sstypestr, obj.sections[161], gui.color.white, gui.color.black, true, '', false)
    GUI_DrawButton(gui, '', obj.sections[168], gui.color.white, gui.color.black, true, '', false)
    local xywh = {x = obj.sections[168].x, 
                  y = obj.sections[168].y+3,
                  w = obj.sections[168].w,
                  h = obj.sections[168].h}
    GUI_textC(gui,xywh,'*',gui.color.black,9)
    GUI_DrawButton(gui, 'RANDOMIZE', obj.sections[169], gui.color.white, gui.color.black, true, '', false)
    if settings_savefaderboxassinsnapshots then
      GUI_DrawButton(gui, 'CAPTURE (+FB)', obj.sections[162], gui.color.white, gui.color.black, true, '', false)
    else
      GUI_DrawButton(gui, 'CAPTURE', obj.sections[162], gui.color.white, gui.color.black, true, '', false)
    end
    GUI_DrawButton(gui, 'NEW SUBSET', obj.sections[166], gui.color.white, gui.color.black, true, '', false)
    local bc, bc2 = gui.color.white, gui.color.white
    if sstype_select == 1 then
      bc = -1
      bc2 = -1
    elseif snaplrn_mode then
      bc = -2
    end
    GUI_DrawButton(gui, 'RENAME SUB', obj.sections[164], bc2, gui.color.black, true, '', false)
    GUI_DrawButton(gui, 'LEARN CTLS', obj.sections[167], bc, gui.color.black, true, '', false)
    GUI_DrawButton(gui, 'META LITE XY', obj.sections[224], bc2, gui.color.black, true, '', false)
    
    xywh = {x = obj.sections[163].x,
            y = obj.sections[163].y,
            w = obj.sections[163].w,
            h = obj.sections[163].h}
    f_Get_SSV('64 64 64')
    gfx.a = 1 
    gfx.rect(xywh.x,
             xywh.y, 
             xywh.w,
             xywh.h, 0 )
    
    
    xywh.h = butt_h
    GUI_DrawBar(gui,'',xywh,skin.barUD,true,gui.color.black,nil,-2)
    gfx.line(xywh.x+xywh.w/2,xywh.y,xywh.x+xywh.w/2,xywh.y+xywh.h)
    gfx.triangle(xywh.x+xywh.w/4,xywh.y+4,xywh.x+xywh.w/4-6,xywh.y+xywh.h-4,xywh.x+xywh.w/4+6,xywh.y+xywh.h-4,1)
    gfx.triangle(xywh.x+xywh.w*0.75,xywh.y+xywh.h-4,xywh.x+xywh.w*0.75-6,xywh.y+4,xywh.x+xywh.w*0.75+6,xywh.y+4,1)
    
    gfx.a = 1
    
    SS_butt_cnt = math.floor(obj.sections[163].h / butt_h) - 1
    if snaplrn_mode == false then
      
      local strip = tracks[track_select].strip
      if strip and snapshots and snapshots[strip] and snapshots[strip][page][sstype_select] then

        if sstype_select == 1 then
          if #snapshots[strip][page][sstype_select] > 0 then
            for i = 1,SS_butt_cnt do
            
              xywh.y = obj.sections[163].y + i*butt_h
              local c = gui.color.white
              if ss_select == ssoffset+i then
                f_Get_SSV(gui.color.white)
                gfx.rect(xywh.x,
                 xywh.y, 
                 xywh.w,
                 xywh.h, 1 )
                c = gui.color.black
              end
              if snapshots[strip][page][sstype_select][i+ssoffset] then
                GUI_textsm_LJ(gui,xywh,roundX(i+ssoffset,0)..': '..snapshots[strip][page][sstype_select][i+ssoffset].name,c,-2,xywh.w)
              end
          
              if snap_move and snap_move.epos == i+ssoffset and snap_move.epos ~= snap_move.spos and snap_move.epos ~= snap_move.spos+1 then
                f_Get_SSV(gui.color.red)
                gfx.rect(xywh.x,
                 xywh.y-1, 
                 xywh.w,
                 2, 1)              
              end
            end
        
          end
        elseif sstype_select > 1 then
          if #snapshots[strip][page][sstype_select].snapshot > 0 then
            for i = 1,SS_butt_cnt do
            
              xywh.y = obj.sections[163].y + i*butt_h
              local c = gui.color.white
              if ss_select == ssoffset+i then
                f_Get_SSV(gui.color.white)
                gfx.rect(xywh.x,
                 xywh.y, 
                 xywh.w,
                 xywh.h, 1 )
                c = gui.color.black
              end
              if snapshots[strip][page][sstype_select].snapshot[i+ssoffset] then
                GUI_textsm_LJ(gui,xywh,roundX(i+ssoffset,0)..': '..snapshots[strip][page][sstype_select].snapshot[i+ssoffset].name,c,-2,xywh.w)
              end

              if snap_move and snap_move.epos == i+ssoffset and snap_move.epos ~= snap_move.spos and snap_move.epos ~= snap_move.spos+1 then
                f_Get_SSV(gui.color.red)
                gfx.rect(xywh.x,
                 xywh.y-1, 
                 xywh.w,
                 2, 1)              
              end
          
            end
        
          end
        
        
        
        end

      end
    else
      --learn mode
      
    end    
    
    gfx.dest = 1    
  end

  function GUI_DrawFSnapshots(obj, gui)
    
    gfx.dest = 1005
    local w, h = gfx.getimgdim(1005)
    if obj.sections[180].w ~= w then
      gfx.setimgdim(1005, obj.sections[180].w, h)
    end
    
    gfx.a=1
    f_Get_SSV(gui.color.black)
    gfx.rect(0,
             0, 
             obj.sections[180].w,
             obj.sections[180].h, 1, 1)
    f_Get_SSV('8 8 8')
    --[[gfx.rect(0,
             0, 
             obj.sections[180].w,
             obj.sections[180].h, 0, 1)
    ]]
    f_Get_SSV(fsstype_color)
    gfx.a = 1 
    gfx.rect(obj.sections[182].x,
             obj.sections[182].y, 
             obj.sections[182].w,
             obj.sections[182].h, 1 )
    
          
    xywh = {x = obj.sections[181].x,
            y = obj.sections[181].y,
            w = obj.sections[181].w,
            h = obj.sections[181].h}
    --f_Get_SSV('64 64 64')
    f_Get_SSV(settings_snaplistbgcol)
    gfx.a = 1 
    gfx.rect(xywh.x,
             xywh.y, 
             xywh.w,
             xywh.h, 1 )
    f_Get_SSV('64 64 64')
    gfx.rect(xywh.x,
             xywh.y, 
             xywh.w,
             xywh.h, 0 )
    
    xywh.h = butt_h+1
    gfx.rect(xywh.x,
     xywh.y-1, 
     xywh.w,
     xywh.h, 1 )
    gfx.a = 0.5
    f_Get_SSV(gui.color.black)
    gfx.a = 1
    gfx.rect(xywh.x,xywh.y+xywh.h-1,xywh.x+xywh.w,2)
    gfx.rect(xywh.x+xywh.w/2,
     xywh.y-1, 
     2,
     xywh.h, 1 )
    gfx.triangle(xywh.x+xywh.w/4,xywh.y+4,xywh.x+xywh.w/4-6,xywh.y+xywh.h-4,xywh.x+xywh.w/4+6,xywh.y+xywh.h-4,1)     
    gfx.triangle(xywh.x+xywh.w*0.75,xywh.y+xywh.h-4,xywh.x+xywh.w*0.75-6,xywh.y+4,xywh.x+xywh.w*0.75+6,xywh.y+4,1)
    
    gfx.a = 1
    
    FSS_butt_cnt = math.floor(obj.sections[181].h / butt_h) - 1
    if snaplrn_mode == false then
      
      local strip = tracks[track_select].strip
      if strip and snapshots and snapshots[strip] and snapshots[strip][page][fsstype_select] then

        if fsstype_select == 1 then
          if #snapshots[strip][page][fsstype_select] > 0 then
            for i = 1,FSS_butt_cnt do
            
              xywh.y = obj.sections[181].y + i*butt_h
              local c = fsstype_color
              if fss_select == fssoffset+i then
                f_Get_SSV(fsstype_color)
                gfx.rect(xywh.x,
                 xywh.y, 
                 xywh.w,
                 xywh.h, 1 )
                c = settings_snaplistbgcol
              end
              if snapshots[strip][page][fsstype_select][i+fssoffset] then
                GUI_textsm_LJ(gui,xywh,roundX(i+fssoffset,0)..': '..snapshots[strip][page][fsstype_select][i+fssoffset].name,c,-2,xywh.w)
              end
          
            end
        
          end
        elseif fsstype_select > 1 then
          if #snapshots[strip][page][fsstype_select].snapshot > 0 then
            for i = 1,FSS_butt_cnt do
            
              xywh.y = obj.sections[181].y + i*butt_h
              local c = fsstype_color
              if fss_select == fssoffset+i then
                f_Get_SSV(fsstype_color)
                gfx.rect(xywh.x,
                 xywh.y, 
                 xywh.w,
                 xywh.h, 1 )
                c = settings_snaplistbgcol
              end
              if snapshots[strip][page][fsstype_select].snapshot[i+fssoffset] then
                GUI_textsm_LJ(gui,xywh,roundX(i+fssoffset,0)..': '..snapshots[strip][page][fsstype_select].snapshot[i+fssoffset].name,c,-2,xywh.w)
              end
          
            end
        
          end
        
        end

      end
    end        
    
    gfx.dest = 1    
  end
  
  ------------------------------------------------------------

  function GUI_DrawActionChooser(obj, gui)

    gfx.a=1
    f_Get_SSV(gui.color.black)
    gfx.rect(obj.sections[170].x,
             obj.sections[170].y, 
             obj.sections[170].w,
             obj.sections[170].h, 1, 1)
    f_Get_SSV('64 64 64')
    gfx.rect(obj.sections[170].x,
             obj.sections[170].y, 
             obj.sections[170].w,
             obj.sections[170].h, 0, 1)
    
    xywh = {x = obj.sections[170].x,
            y = obj.sections[170].y, 
            w = obj.sections[170].w,
            h = butt_h}
    
    f_Get_SSV(gui.color.white)
    gfx.a = 1 
    gfx.rect(xywh.x,
             xywh.y, 
             xywh.w,
             butt_h, 1)
    gfx.rect(obj.sections[171].x,
             obj.sections[171].y, 
             obj.sections[171].w,
             obj.sections[171].h, 0)
    
    GUI_textC(gui,xywh,'CUSTOM ACTION CHOOSER',gui.color.black,-2)
    
    AL_butt_cnt = math.floor((obj.sections[171].h) / butt_h)-1
    xywh = {x = obj.sections[171].x+2,
            y = obj.sections[171].y, 
            w = obj.sections[171].w-4,
            h = butt_h}

    for i = 1, AL_butt_cnt+1 do
    
      if action_tblF[i+al_offset] then
      
        xywh.y = obj.sections[171].y + butt_h*(i-1)
        local c = gui.color.white
        if al_select == i+al_offset then

          f_Get_SSV(gui.color.white)
          gfx.rect(xywh.x,
                   xywh.y, 
                   xywh.w,
                   butt_h, 1)
          c = gui.color.black
        
        end
      
        GUI_textsm_LJ(gui,xywh,action_tblF[i+al_offset].command_desc,c,-2,obj.sections[171].w-4)
      
      end
    
    end

    GUI_DrawButton(gui, 'FILTER ACTION LIST', obj.sections[172], gui.color.white, gui.color.black, true, '', false)
    GUI_DrawButton(gui, 'CLEAR FILTER', obj.sections[173], gui.color.white, gui.color.black, true, '', false)
    GUI_DrawButton(gui, 'SELECT', obj.sections[174], gui.color.white, gui.color.black, true, '', false)
    GUI_DrawButton(gui, 'CANCEL', obj.sections[175], gui.color.white, gui.color.black, true, '', false)

  end
    
  ------------------------------------------------------------
  function PopulateCtlBrowser_Imgs()
  
    cbi = {}
    local icnt = ctl_browser_image+1
    local it = 0
    cbi_cnt = 0
    local cbof = 0
    for i = 0, #ctl_files do
      if ctl_files[i].ctltype == cbi_filter or cbi_filter == -1 then
        cbi_cnt = cbi_cnt + 1
      end
      if cbi_cnt == cbi_offset then
        cbof = i+1
      end
    end
    
    for i = 0, math.min(ctl_browser_size.slots_x*ctl_browser_size.slots_y-1,maximg_browse) do
    
      local fnd = false

      repeat
        
        local ii = cbof + i + it
      
        if ctl_files[ii] then


          if cbi_filter == -1 or ctl_files[ii].ctltype == cbi_filter then
            
            fnd = true
            cbi[i] = {idx = ii,
                      fn = ctl_files[ii].fn,
                      imageidx = ctl_files[ii].imageidx,
                      cellh = ctl_files[ii].cellh,
                      frames = ctl_files[ii].frames,
                      ctltype = ctl_files[ii].ctltype}
            
            if cbi[i].imageidx ~= nil then
              --iidx = cbi[i].imageidx
            else
              gfx.loadimg(icnt, controls_path..cbi[i].fn)
              cbi[i].imageidx = icnt
              icnt = icnt + 1
            end
          else
            it = it + 1
          end
        else
          cbi[i] = nil
          gfx.loadimg(icnt,'')
          fnd = true
        end      

      until fnd == true

    end
    
    
  end
  
  function SetCbiSelect()
  
    local ii = cbi_select
    if ctl_files[ii] then
    
      cbi_select_inf = {idx = ii,
                        fn = ctl_files[ii].fn,
                        imageidx = ctl_files[ii].imageidx,
                        cellh = ctl_files[ii].cellh,
                        frames = ctl_files[ii].frames,
                        ctltype = ctl_files[ii].ctltype}    
      if cbi_select_inf.imageidx ~= nil then
      else
        gfx.loadimg(991, controls_path..ctl_files[ii].fn)
        cbi_select_inf.imageidx = 991
      end
    end  
  end
  
  function GUI_DrawCtlBrowser(obj, gui)

    gfx.a=1
    f_Get_SSV(gui.color.black)
    f_Get_SSV('32 32 32')
    gfx.rect(obj.sections[200].x,
             obj.sections[200].y, 
             obj.sections[200].w,
             obj.sections[200].h, 1, 1)
    f_Get_SSV('64 64 64')
    gfx.rect(obj.sections[200].x,
             obj.sections[200].y, 
             obj.sections[200].w,
             obj.sections[200].h, 0, 1)

    f_Get_SSV('64 64 64')
    gfx.rect(obj.sections[210].x-2,
             obj.sections[210].y-2, 
             obj.sections[210].w+4,
             obj.sections[210].h+4, 1, 1)
    f_Get_SSV('0 0 0')
    gfx.rect(obj.sections[210].x-2,
             obj.sections[210].y-2, 
             obj.sections[210].w+4,
             obj.sections[210].h+4, 0, 1)
    
    xywh = {x = obj.sections[200].x,
            y = obj.sections[200].y, 
            w = obj.sections[200].w,
            h = butt_h}
    
    f_Get_SSV(gui.color.white)
    gfx.a = 1 
    gfx.rect(xywh.x,
             xywh.y, 
             xywh.w,
             butt_h, 1)
    
    GUI_textC(gui,xywh,'CONTROL BROWSER',gui.color.black,-2)
    
    GUI_DrawButton(gui, 'ALL', obj.sections[201], gui.color.white, gui.color.black, true, '', false)
    GUI_DrawButton(gui, 'KNOBS', obj.sections[202], gui.color.white, gui.color.black, true, '', false)
    GUI_DrawButton(gui, 'SLIDERS', obj.sections[203], gui.color.white, gui.color.black, true, '', false)
    GUI_DrawButton(gui, 'BUTTONS', obj.sections[204], gui.color.white, gui.color.black, true, '', false)
    GUI_DrawButton(gui, 'METERS', obj.sections[205], gui.color.white, gui.color.black, true, '', false)
    GUI_DrawButton(gui, 'MISC', obj.sections[206], gui.color.white, gui.color.black, true, '', false)

    GUI_DrawButton(gui, '<<', obj.sections[211], gui.color.white, gui.color.black, true, '', false)
    GUI_DrawButton(gui, '>>', obj.sections[212], gui.color.white, gui.color.black, true, '', false)
    
    
    xywh = {x = obj.sections[212].x+obj.sections[212].w+20,
            y = obj.sections[212].y, 
            w = 20,
            h = butt_h}
    local p = math.floor(cbi_offset / math.min(ctl_browser_size.slots_x*ctl_browser_size.slots_y,maximg_browse))+1
    local p2 = math.floor(cbi_cnt / math.min(ctl_browser_size.slots_x*ctl_browser_size.slots_y,maximg_browse))+1 
    GUI_textsm_LJ(gui,xywh,'PAGE '..p..'/'..p2,gui.color.white,-2)
    

    for cg = 0, math.min(ctl_browser_size.slots_x*ctl_browser_size.slots_y-1,maximg_browse) do
      if cbi[cg] then
      
        iidx = cbi[cg].imageidx
          
        local w, _ = gfx.getimgdim(iidx)
        local h = cbi[cg].cellh
        gfx.a = 1
        local scale_select = 1
        xywh = {x = obj.sections[210].x + (cg % ctl_browser_size.slots_x)*ctl_browser_size.slotsz,
                y = obj.sections[210].y + math.floor(cg / ctl_browser_size.slots_x)*ctl_browser_size.slotsz,
                w = ctl_browser_size.slotsz,
                h = ctl_browser_size.slotsz}
        if w > h then
          if w > ctl_browser_size.slotsz then
            scale_select = ctl_browser_size.slotsz / w
          end
        else
          if h > ctl_browser_size.slotsz then
            scale_select = ctl_browser_size.slotsz / h
          end        
        end
        gfx.blit(iidx,scale_select,0, 0, h*math.ceil((cbi[cg].frames-1)*0.55), w, h,
                 xywh.x + (xywh.w/2-(w*scale_select)/2), xywh.y + ((xywh.h - (h*scale_select))/2))
        gfx.a = 0.75
        
        if cbi[cg].idx == cbi_select then
          f_Get_SSV(gui.color.yellow)
          gfx.roundrect(xywh.x+1,
                   xywh.y,
                   xywh.w-2,
                   xywh.h,8,0,1)        
        --GUI_textC(gui,xywh,ctl_files[cg].fn,gui.color.white,-5)]]
        end
        
      else
        break
      end
    end

    gfx.a = 1
    if cbi_select_inf and cbi_select_inf.imageidx then
      local scale_selecta, scale_selectb = 1,1
      local w, _ = gfx.getimgdim(cbi_select_inf.imageidx)
      local h = cbi_select_inf.cellh
      if w > obj.sections[213].w then
        scale_selecta = obj.sections[213].w / w
      end
      if h > obj.sections[213].h then
        scale_selectb = obj.sections[213].h / h
      end
      local scale_select = F_limit(math.min(scale_selecta,scale_selectb),0,1)    
      
      local xywh = {x = obj.sections[213].x,
                    y = obj.sections[213].y,
                    w = obj.sections[213].w,
                    h = butt_h}
      if xywh.y + h*scale_select > obj.sections[200].y + obj.sections[200].h then
        xywh.y = obj.sections[200].y + obj.sections[200].h - h*scale_select-2
      end       
      if xywh.y < obj.sections[200].y + obj.sections[200].h then
        gfx.blit(cbi_select_inf.imageidx,scale_select,0, 0, h*math.ceil((cbi_select_inf.frames-1)*0.55), w, h,
                 xywh.x + (xywh.w/2-(w*scale_select)/2), xywh.y)-- + ((obj.sections[213].h/2) - (h*scale_select))/2)
      end
                     
      local xywh = {x = obj.sections[213].x,
                    y = obj.sections[213].y-butt_h*6,
                    w = obj.sections[213].w,
                    h = butt_h}
      GUI_textsm_LJ(gui,xywh,cbi_select_inf.fn,gui.color.white,-5,xywh.w)
      xywh.y = xywh.y + butt_h
      GUI_textsm_LJ(gui,xywh,'W = '..w,gui.color.white,-5,xywh.w)
      xywh.y = xywh.y + butt_h
      GUI_textsm_LJ(gui,xywh,'H = '..h,gui.color.white,-5,xywh.w)
      xywh.y = xywh.y + butt_h
      GUI_textsm_LJ(gui,xywh,'Frames = '..cbi_select_inf.frames,gui.color.white,-5,xywh.w)
      xywh.y = xywh.y + butt_h
      GUI_textsm_LJ(gui,xywh,'Type = '..ctlfile_type_table[cbi_select_inf.ctltype+1],gui.color.white,-5,xywh.w)      
      xywh.y = xywh.y + butt_h
            
    end

  end

  ------------------------------------------------------------
  
  function GUI_DrawMsgX(obj, gui, txt, c, max, bar)
    
    gfx.mode = gmode
    if gui == nil then
      gui = GetGUI_vars()
    end

    local msgwinw, msgwinh = 500, 200
    xywh1 = {x = gfx1.main_w/2-msgwinw/2,
              y = gfx1.main_h/2-msgwinh/2,
              w = msgwinw,
              h = msgwinh}
    xywh2 = {x = gfx1.main_w/2-msgwinw/2,
              y = gfx1.main_h/2-msgwinh/2 + butt_h*2,
              w = msgwinw,
              h = butt_h}

    xywh3 = {x = gfx1.main_w/2-msgwinw/2 + 20,
              y = gfx1.main_h/2-msgwinh/2 + butt_h*4,
              w = msgwinw-40,
              h = butt_h}

    gfx.dest = 1
    f_Get_SSV('0 0 0')
    gfx.a = 1 
    gfx.rect(xywh1.x,
             xywh1.y, 
             xywh1.w,
             xywh1.h, 1)
    f_Get_SSV(gui.color.white)
    gfx.rect(xywh1.x,
             xywh1.y, 
             xywh1.w,
             xywh1.h, 0)
    GUI_textC(gui,xywh2,nz(txt,''),gui.color.white,-2)         

    if c and max then
    
      gfx.rect(xywh3.x,
               xywh3.y, 
               xywh3.w,
               xywh3.h, 0)
      xywh3.w = (c/max)*xywh3.w
      gfx.rect(xywh3.x,
               xywh3.y, 
               xywh3.w,
               xywh3.h, 1)
      xywh3.w = msgwinw
      GUI_textC(gui,xywh3,string.format('%i',round((c/max)*100))..'%',gui.color.black,-2)         
      xywh3.x = xywh3.x + 1      
      xywh3.y = xywh3.y + 1
      GUI_textC(gui,xywh3,string.format('%i',round((c/max)*100))..'%',gui.color.white,-2)         
    elseif bar then
    
      
      local t = (reaper.time_precise()*1000) % 2000
      gfx.rect(xywh3.x,
               xywh3.y, 
               xywh3.w,
               xywh3.h, 0)
      local lw = math.floor((t/2000)*(xywh3.w-100))
      gfx.rect(xywh3.x+lw,
               xywh3.y, 
               100,
               xywh3.h, 1)      
    
    end

    gfx.dest = -1
    gfx.a = 1
    gfx.blit(1, 1, 0, 
      0,0, gfx1.main_w,gfx1.main_h,
      0,0, gfx1.main_w,gfx1.main_h, 0,0)
    gfx.update()
    
  end

  function GUI_DrawStateWin(obj, gui, txt, reset)
    
    gfx.mode = gmode
    if gui == nil then
      gui = GetGUI_vars()
    end

    local lineh = 20
    if reset or statewin_txtpos == nil then
      statewin_txtpos = -1
    end
    statewin_txtpos = statewin_txtpos + 1
    
    local msgwinw, msgwinh = obj.sections[10].w - 100 - obj.sections[10].x, obj.sections[10].h-100
    xywh1 = {x = gfx1.main_w/2-msgwinw/2,
              y = gfx1.main_h/2-msgwinh/2,
              w = msgwinw,
              h = msgwinh}
    xywh2 = {x = gfx1.main_w/2-msgwinw/2,
              y = gfx1.main_h/2-msgwinh/2+lineh,
              w = msgwinw,
              h = msgwinh-lineh-1}

    xywh3 = {x = gfx1.main_w/2-msgwinw/2+5,
              y = gfx1.main_h/2-msgwinh/2 +math.min(statewin_txtpos*lineh,msgwinh-lineh),
              w = msgwinw-10,
              h = lineh}

    gfx.dest = 1
    if reset then
      f_Get_SSV('0 0 0')
      gfx.a = 1 
      gfx.rect(xywh1.x,
               xywh1.y, 
               xywh1.w,
               xywh1.h, 1)
    end
    if statewin_txtpos*lineh > msgwinh-lineh then
      gfx.blit(1,1,0,xywh2.x,xywh2.y,xywh2.w,xywh2.h,xywh1.x,xywh1.y)
      f_Get_SSV('0 0 0')
      gfx.a = 1 
      gfx.rect(xywh3.x,
               xywh3.y, 
               xywh3.w,
               xywh3.h, 1)      
    end
    GUI_textsm_LJ(gui,xywh3,nz(txt,''),'128 128 128',-2,msgwinw-10)         

    f_Get_SSV(gui.color.white)
    gfx.rect(xywh1.x,
             xywh1.y, 
             xywh1.w,
             xywh1.h, 0)

    gfx.dest = -1
    gfx.a = 1
    gfx.blit(1, 1, 0, 
      0,0, gfx1.main_w,gfx1.main_h,
      0,0, gfx1.main_w,gfx1.main_h, 0,0)
    gfx.update()

  end

  function calc_eqgraph_getmin(tr, fx, param, freq)
  
    if param then
      local sldiv = 40
      local track = GetTrack(tr)
      local bkp = reaper.TrackFX_GetParamNormalized(track, fx, param)
      reaper.TrackFX_SetParamNormalized(track, fx, param, 0)
      local del = 0
      os.sleep(auto_delay/sldiv)
      local _, d = reaper.TrackFX_GetFormattedParamValue(track, fx, param, '')
      local mult = 1
      if freq then
        local s = string.find(string.lower(d), 'k')
        if s and s>0 then mult = 1000 end
      end
      if d and d~= '' then
        rd = tonumber(GetNumericPart(d))
        if rd then rd = rd * mult else rd = d end
        
        reaper.TrackFX_SetParamNormalized(track, fx, param, bkp)
      end
      return rd
    end
      
  end

  function calc_eqgraph_getmax(tr, fx, param, freq)
  
    if param then
      local sldiv = 40
      local track = GetTrack(tr)
      local bkp = reaper.TrackFX_GetParamNormalized(track, fx, param)
      reaper.TrackFX_SetParamNormalized(track, fx, param, 1)
      local del = 0
      os.sleep(auto_delay/sldiv)
      local _, d = reaper.TrackFX_GetFormattedParamValue(track, fx, param, '')
      local mult = 1
      if freq then
        local s = string.find(string.lower(d), 'k')
        if s and s>0 then mult = 1000 end
      end
      if d and d~= '' then
        rd = tonumber(GetNumericPart(d))
        if rd then rd = rd * mult else rd = d end

        reaper.TrackFX_SetParamNormalized(track, fx, param, bkp)
      end    
      return rd
    end
      
  end
  
  function calc_eqgraph(tr, fx, param, min, max, khz, param2, min2, max2)
  
    --DBG('mm'..min..'  '..max)
    --local ad = auto_delay*100000
    local track = GetTrack(tr)
    --pixmap = {}
    local lookmap = {}
    local gmap = {}
    local mult = 1
    local sldiv = 400
    if khz then
      mult = 1000
      min = min * mult
      max = max * mult
    end
    if min == 0 then min = 10 end
    --if min2 == 0 then min2 = 10 end
    
    local inc = math.min(10^math.floor(math.log(min,10)),1000)
    local look = (math.floor(min/inc)+1)*inc
    --local look = min
    local inc2 = 3
    local look2 = min2
    if param then
      bkp = reaper.TrackFX_GetParam(track, fx, param)
      reaper.TrackFX_SetParam(track, fx, param, 0)
    end
    if param2 then
      bkp2 = reaper.TrackFX_GetParamNormalized(track, fx, param2)
      reaper.TrackFX_SetParamNormalized(track, fx, param2, 0)
    end
    local del = 0
    --for dx = 1, ad do del = del + 1 end
    os.sleep((auto_delay/sldiv)*10)
    local fnd, fnd2 = false, false
    
    for p = 0, 2010 do        
      GUI_DrawMsgX(obj, gui, 'Calculating Graph Data...',p,2000)
      local pp = p/(2000)
      if param then
        reaper.TrackFX_SetParamNormalized(track, fx, param, pp)
      end
      if param2 then
        reaper.TrackFX_SetParamNormalized(track, fx, param2, pp)
      end
      os.sleep(auto_delay/sldiv)
      local d, d2
      if param then
        _, d = reaper.TrackFX_GetFormattedParamValue(track, fx, param, '')
      end
      if param2 then
        _, d2 = reaper.TrackFX_GetFormattedParamValue(track, fx, param2, '')
      end
      
      if not khz then
        local s = string.find(string.lower(d), 'k')
        if s and s>0 then mult = 1000 end
      end
      d = tonumber(GetNumericPart(nz(d,'')))*mult
      --if p%100 == 0 then
        --DBG(d..'  '..look)
      --end
      if d and d >= look and not fnd then
        lookmap[#lookmap+1] = {pix = math.min(p,2000),
                               hz = look}
        
        if look >= max then fnd = true end
        --DBG(max..'  '..tostring(fnd)..'  '..p..'  '..look)   
        local inc = math.min(10^math.floor(math.log(look,10)),1000)
        look = look + inc
      end
      
      d2 = tonumber(GetNumericPart(nz(d2,'')))
      --DBG(tostring(d2)..' '..look2)
      if tonumber(look2) == nil then
        if d2 then look2 = d2 end
      else
        if d2 and d2 >= look2 and not fnd2 then
          gmap[#gmap+1] = {pix = math.min(p,2000),
                           db = look2}
          if look2 >= max2 then fnd2 = true end
          look2 = math.floor((look2 + inc2)/inc2)*inc2
          if look2 > max2 then look2 = max2 end
        end
      end      
    end
    if param then
      reaper.TrackFX_SetParamNormalized(track, fx, param, bkp)
    end
    if param2 then
      reaper.TrackFX_SetParamNormalized(track, fx, param2, bkp2)
    end
    
    return lookmap, gmap
  end
  
  function logspace(start, stop, n, N)
    if n and stop and N then
    return math.log(n,10)*(N/math.log(stop,10))
    end
    --return math.log(1+(n/stop)*400,10) * N
  end
  
  function logspaceinv(start, stop, v, N)
    return 10^(v / (N/math.log(stop,10)))
    --return ((((10^(v/N)) / 400.0) * stop) -1.0)
  end
  
  function GUI_DrawEQBands(obj, gui)
  
    local bands = strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands
    if bands then
    
      for bb = 1, #bands+1 do

        if bb ~= eqcontrolband_select then
          local b = bb
          if b == #bands+1 then
            b = eqcontrolband_select
          end
          
          if bands[b] and (eq_single == false or b == eqcontrolband_select) then
            local track = GetTrack(tracks[track_select].tracknum)
    
            local pmin = bands[b].posmin
            local pmax = bands[b].posmax
            local gmin = bands[b].gmin
            local gmax = bands[b].gmax
            local fxnum = bands[b].fxnum
            local freq_param = bands[b].freq_param
            local khz = bands[b].khz
            local gain_param = bands[b].gain_param
            local q_param = bands[b].q_param
            local c1_param = bands[b].c1_param
            local c2_param = bands[b].c2_param
            local c3_param = bands[b].c3_param
            local c4_param = bands[b].c4_param
            local c5_param = bands[b].c5_param
            local bypass_param = bands[b].bypass_param
            local col = bands[b].col
            local xoff = obj.sections[300].x + obj.sections[302].x
            local yoff = obj.sections[300].y + obj.sections[302].y
            local bn = bands[b].bandname
            local bt = bands[b].bandtype
            
            if eq_scale == false then
              pmin = 0
              pmax = 1
              gmin = 0
              gmax = 1
            end

            if eq_edit == false then
              f_Get_SSV(gui.color.black)
              local xywh = {x = obj.sections[300].x + obj.sections[326].x,
                            y = obj.sections[300].y + obj.sections[326].y,
                            w = obj.sections[326].w,
                            h = obj.sections[326].h}
              gfx.rect(xywh.x,
                       xywh.y,
                       xywh.w,
                       xywh.h, 1)
              local xywh = {x = obj.sections[300].x + obj.sections[325].x,
                            y = obj.sections[300].y + obj.sections[325].y,
                            w = obj.sections[325].w,
                            h = obj.sections[325].h}
              gfx.rect(xywh.x,
                       xywh.y,
                       xywh.w,
                       xywh.h, 1)
              local xywh = {x = obj.sections[300].x + obj.sections[327].x,
                            y = obj.sections[300].y + obj.sections[327].y,
                            w = obj.sections[327].w,
                            h = obj.sections[327].h}
              gfx.rect(xywh.x,
                       xywh.y,
                       xywh.w,
                       xywh.h, 1)
            end
                    
            local freq_val, gain_val, q_val, bypass_val, c1_val, c2_val, c3_val = 0, 0.5, nil, 0, 0, 0, 0
            local freq_d, gain_d, q_d, c1_d, c2_d, c3_d
            if freq_param then
              freq_val = reaper.TrackFX_GetParamNormalized(track,fxnum,freq_param)
              _, freq_d = reaper.TrackFX_GetFormattedParamValue(track,fxnum,freq_param,'')
              if khz == true then
                freq_d = GetNumericPart(freq_d)
                local dd = tonumber(dd)
                if dd then
                  freq_d = freq_d*1000
                end
              end
              
              if eq_edit == false and b == eqcontrolband_select then
                local xywh = {x = obj.sections[300].x + obj.sections[325].x,
                              y = obj.sections[300].y + obj.sections[325].y,
                              w = obj.sections[325].w,
                              h = obj.sections[325].h}
                local w = gfx.getimgdim(def_eqcknobf)
                local h = ctl_files[def_eqcknobfctl].cellh
                local frames = ctl_files[def_eqcknobfctl].frames-1
                local v = math.floor(freq_val*frames)
                gfx.blit(def_eqcknobf, 1, 0, 0, v* h, w, h, xywh.x, xywh.y)
                xywh.y = xywh.y + 30
                local suffix = ' Hz'
                if khz then
                  suffix = ' kHz'
                else
                  local s = string.find(string.lower(freq_d), 'k')
                  if s and s>0 then suffix = ' kHz' end
                end
                GUI_textC(gui,xywh,roundX(freq_d,1, suffix),gui.color.white,-2)
              end              
            end
            if gain_param then
              gain_val = reaper.TrackFX_GetParamNormalized(track,fxnum,gain_param)
              _, gain_d = reaper.TrackFX_GetFormattedParamValue(track,fxnum,gain_param,'')

              if eq_edit == false and b == eqcontrolband_select then
                local xywh = {x = obj.sections[300].x + obj.sections[326].x,
                              y = obj.sections[300].y + obj.sections[326].y,
                              w = obj.sections[326].w,
                              h = obj.sections[326].h}
                local w = gfx.getimgdim(def_eqcknobg)
                local h = ctl_files[def_eqcknobgctl].cellh
                local frames = ctl_files[def_eqcknobgctl].frames-1
                local v = math.floor(gain_val*frames)
                gfx.blit(def_eqcknobg, 1, 0, 0, v* h, w, h, xywh.x, xywh.y)
                xywh.y = xywh.y + 30
                GUI_textC(gui,xywh,round(GetNumericPart(gain_d),2)..' dB',gui.color.white,-2)
              end
            end

            if q_param then
              q_val = reaper.TrackFX_GetParamNormalized(track,fxnum,q_param)
              _, q_d = reaper.TrackFX_GetFormattedParamValue(track,fxnum,q_param,'')

              if eq_edit == false and b == eqcontrolband_select then
                local xywh = {x = obj.sections[300].x + obj.sections[327].x,
                              y = obj.sections[300].y + obj.sections[327].y,
                              w = obj.sections[327].w,
                              h = obj.sections[327].h}
                local w = gfx.getimgdim(def_eqcknobg)
                local h = ctl_files[def_eqcknobgctl].cellh
                local frames = ctl_files[def_eqcknobgctl].frames-1
                local v = math.floor(q_val*frames)
                gfx.blit(def_eqcknobg, 1, 0, 0, v* h, w, h, xywh.x, xywh.y)
                xywh.y = xywh.y + 30
                GUI_textC(gui,xywh,roundX(q_d,2),gui.color.white,-2)
              end
            end

            if c1_param then
              c1_val = reaper.TrackFX_GetParamNormalized(track,fxnum,c1_param)
              _, c1_d = reaper.TrackFX_GetFormattedParamValue(track,fxnum,c1_param,'')

              if eq_edit == false and b == eqcontrolband_select then
                local xywh = {x = obj.sections[300].x + obj.sections[328].x,
                              y = obj.sections[300].y + obj.sections[328].y,
                              w = obj.sections[328].w,
                              h = obj.sections[328].h}
                local w = gfx.getimgdim(def_knobsm)
                local h = ctl_files[def_knobsmctl].cellh
                local frames = ctl_files[def_knobsmctl].frames-1
                local v = math.floor(c1_val*frames)
                gfx.blit(def_knobsm, 1, 0, 0, v* h, w, h, xywh.x, xywh.y)
                xywh.y = xywh.y + 30
                GUI_textC(gui,xywh,roundX(c1_d,2),gui.color.white,-2)
              end
            end

            if c2_param then
              c2_val = reaper.TrackFX_GetParamNormalized(track,fxnum,c2_param)
              _, c2_d = reaper.TrackFX_GetFormattedParamValue(track,fxnum,c2_param,'')

              if eq_edit == false and b == eqcontrolband_select then
                local xywh = {x = obj.sections[300].x + obj.sections[329].x,
                              y = obj.sections[300].y + obj.sections[329].y,
                              w = obj.sections[329].w,
                              h = obj.sections[329].h}
                local w = gfx.getimgdim(def_knobsm)
                local h = ctl_files[def_knobsmctl].cellh
                local frames = ctl_files[def_knobsmctl].frames-1
                local v = math.floor(c2_val*frames)
                gfx.blit(def_knobsm, 1, 0, 0, v* h, w, h, xywh.x, xywh.y)
                xywh.y = xywh.y + 30
                GUI_textC(gui,xywh,roundX(c2_d,2),gui.color.white,-2)
              end
            end

            if c3_param then
              c3_val = reaper.TrackFX_GetParamNormalized(track,fxnum,c3_param)
              _, c3_d = reaper.TrackFX_GetFormattedParamValue(track,fxnum,c3_param,'')

              if eq_edit == false and b == eqcontrolband_select then
                local xywh = {x = obj.sections[300].x + obj.sections[330].x,
                              y = obj.sections[300].y + obj.sections[330].y,
                              w = obj.sections[330].w,
                              h = obj.sections[330].h}
                local w = gfx.getimgdim(def_knobsm)
                local h = ctl_files[def_knobsmctl].cellh
                local frames = ctl_files[def_knobsmctl].frames-1
                local v = math.floor(c3_val*frames)
                gfx.blit(def_knobsm, 1, 0, 0, v* h, w, h, xywh.x, xywh.y)
                xywh.y = xywh.y + 30
                GUI_textC(gui,xywh,roundX(c3_d,2),gui.color.white,-2)
              end
            end

            if c4_param then
              c4_val = reaper.TrackFX_GetParamNormalized(track,fxnum,c4_param)
              _, c4_d = reaper.TrackFX_GetFormattedParamValue(track,fxnum,c4_param,'')

              if eq_edit == false and b == eqcontrolband_select then
                local xywh = {x = obj.sections[300].x + obj.sections[334].x,
                              y = obj.sections[300].y + obj.sections[334].y,
                              w = obj.sections[334].w,
                              h = obj.sections[334].h}
                local w = gfx.getimgdim(def_knobsm)
                local h = ctl_files[def_knobsmctl].cellh
                local frames = ctl_files[def_knobsmctl].frames-1
                local v = math.floor(c4_val*frames)
                gfx.blit(def_knobsm, 1, 0, 0, v* h, w, h, xywh.x, xywh.y)
                xywh.y = xywh.y + 30
                GUI_textC(gui,xywh,roundX(c4_d,2),gui.color.white,-2)
              end
            end

            if c5_param then
              c5_val = reaper.TrackFX_GetParamNormalized(track,fxnum,c5_param)
              _, c5_d = reaper.TrackFX_GetFormattedParamValue(track,fxnum,c5_param,'')

              if eq_edit == false and b == eqcontrolband_select then
                local xywh = {x = obj.sections[300].x + obj.sections[335].x,
                              y = obj.sections[300].y + obj.sections[335].y,
                              w = obj.sections[335].w,
                              h = obj.sections[335].h}
                local w = gfx.getimgdim(def_knobsm)
                local h = ctl_files[def_knobsmctl].cellh
                local frames = ctl_files[def_knobsmctl].frames-1
                local v = math.floor(c5_val*frames)
                gfx.blit(def_knobsm, 1, 0, 0, v* h, w, h, xywh.x, xywh.y)
                xywh.y = xywh.y + 30
                GUI_textC(gui,xywh,roundX(c5_d,2),gui.color.white,-2)
              end
            end

            if bypass_param then
              bypass_val = reaper.TrackFX_GetParamNormalized(track,fxnum,bypass_param)
              bands[b].bypass_val = bypass_val
            end

            bands[b].freq_val = freq_val
            bands[b].gain_val = gain_val
            bands[b].q_val = q_val
            bands[b].c1_val = c1_val
            bands[b].c2_val = c2_val
            bands[b].c3_val = c3_val
            bands[b].c4_val = c4_val
            bands[b].c5_val = c5_val
            
            local xp = (freq_val * (pmax-pmin)*obj.sections[302].w)+(pmin*obj.sections[302].w)
            if bands[b].gain_inv then
              gain_val = 1-gain_val
            end
            local yp = obj.sections[302].h-(gmin*obj.sections[302].h) - (gain_val * (gmax-gmin)*obj.sections[302].h)
        
            if bypass_val and bypass_val == 1 then
              gfx.a = 0.3
            else
              gfx.a = 1
            end                     
            
            f_Get_SSV(col)
            if q_val and b == eqcontrolband_select then
              --[[local xywh = {x = (xp+xoff)-(q_val*50)-25,
                            y = yp+yoff-1,
                            w = 50+(q_val*50)*2,
                            h = 3}]]
              local qv = q_val
              if bands[b].q_inv then
                qv=1-qv
              end
              qv=qv*100
              
              gfx.triangle((xp+xoff)-qv-12, yp+yoff-4,
                           (xp+xoff)-qv-12, yp+yoff+4,
                           (xp+xoff)-qv-17, yp+yoff)
              gfx.triangle((xp+xoff)+qv+12, yp+yoff-4,
                           (xp+xoff)+qv+12, yp+yoff+4,
                           (xp+xoff)+qv+17, yp+yoff)
                       
            end
            
            gfx.circle(xp+xoff,yp+yoff,6,1,1)
            f_Get_SSV(gui.color.black)        
            gfx.circle(xp+xoff,yp+yoff,6,0,1)
            if b == eqcontrolband_select then
              f_Get_SSV(gui.color.white)
              gfx.circle(xp+xoff,yp+yoff,7,0,1)
            end

            gfx.a = 1

            if eqcdrag == nil or b == eqcontrolband_select then
              if bt or bn then
                txt = ''
                if bt then
                  txt = bt
                end
                if bn then
                  if txt ~= '' then
                    txt = txt .. ': '
                  end
                  txt = txt .. bn
                end            
                gfx.setfont(1, gui.fontname, gui.fontsz_knob -5)
                local text_len = gfx.measurestr(txt)
  
                local xywh = {x = xp+xoff-(text_len/2)-8,
                              y = yp+yoff-30,
                              w = text_len+16,
                              h = 12+6}
                local cc = '160 160 200'
                if b ~= eqcontrolband_select then
                  cc = '64 64 80'
                end
                gfx.a = 0.1
                f_Get_SSV(gui.color.black)
                gfx.rect(xywh.x,xywh.y,xywh.w,xywh.h,1,1)
                f_Get_SSV(cc)
                gfx.rect(xywh.x,xywh.y,xywh.w,xywh.h,0,1)
                xywh.y = xywh.y - 1
                GUI_textC(gui,xywh,txt,cc,-5)
                gfx.a = 1
              end
  
  
              local hh = 0
              if freq_d then
                hh = hh + 12
              end
              if gain_d then
                hh = hh + 12
              end
              if q_d then
                hh = hh + 12
              end
              
              
              if b == eqcontrolband_select then
                gfx.a = 0.1
                if hh > 0 then
                  local xywh = {x = xp+xoff-40,
                                y = yp+yoff+20,
                                w = 80,
                                h = hh+6}
                  local cc = '160 160 200'
                  f_Get_SSV(gui.color.black)
                  gfx.rect(xywh.x,xywh.y,xywh.w,xywh.h,1,1)
                  f_Get_SSV(cc)
                  gfx.rect(xywh.x,xywh.y,xywh.w,xywh.h,0,1)
                  xywh.h = 12
                  xywh.y = xywh.y + 2
                  if freq_d then
                    local suffix = ' Hz'
                    if khz then
                      suffix = ' kHz'
                    else
                      local s = string.find(string.lower(freq_d), 'k')
                      if s and s>0 then suffix = ' kHz' end
                    end
                    
                    GUI_textC(gui,xywh,roundX(freq_d,1,suffix),cc,-5)
                  end
                  if gain_d then
                    xywh.y = xywh.y + 12
                    GUI_textC(gui,xywh,round(GetNumericPart(gain_d),2)..' dB',cc,-5)
                  end
                  if q_d then
                    xywh.y = xywh.y + 12
                    GUI_textC(gui,xywh,round(q_d,2),cc,-5)
                  end
                end
                gfx.a = 1
              end
            end                
          end
        end
      end
      
    end
  
  end
  
  function GUI_DrawEQControl(obj, gui)
  
    local bands = strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands
    gfx.dest = 1009
    local w, h = gfx.getimgdim(1009)
    if obj.sections[300].w ~= w or obj.sections[300].h ~= h or update_gfx then
      gfx.setimgdim(1009, obj.sections[300].w, obj.sections[300].h)

      f_Get_SSV(gui.color.black)
      gfx.rect(0,
               0, 
               obj.sections[300].w,
               obj.sections[300].h, 1)
      f_Get_SSV(gui.color.white)
      gfx.rect(0,
               0, 
               obj.sections[300].w,
               obj.sections[300].h, 0)
      gfx.rect(obj.sections[351].x,
               obj.sections[351].y, 
               obj.sections[351].w,
               obj.sections[351].h, 1)
      local xywh = {x = obj.sections[351].x+8,
                    y = obj.sections[351].y+8,
                    w = obj.sections[351].w-16,
                    h = obj.sections[351].h-16}
      GUI_DrawBar(gui,'',obj.sections[351],skin.bar,true,gui.color.black,nil,-2)               
      f_Get_SSV(gui.color.black)
      gfx.line(xywh.x,xywh.y,xywh.x+xywh.w,xywh.y+xywh.h,1)
      gfx.line(xywh.x+xywh.w,xywh.y,xywh.x,xywh.y+xywh.h,1)
      
      GUI_DrawBar(gui,'ADD',obj.sections[304],skin.bar,true,gui.color.black,nil,-2)               

      f_Get_SSV(gui.color.white)
      local c = gui.color.white    
      local f = skin.barG
      if eq_edit then
        c = gui.color.black    
        f = skin.bar
      end
      GUI_DrawBar(gui,'EDIT',obj.sections[311],f,true,c,nil,-2)               

      f_Get_SSV(gui.color.white)
      local c = gui.color.white    
      local f = skin.barG
      if eq_single == true then
        c = gui.color.black    
        f = skin.bar
      end
      GUI_DrawBar(gui,'',obj.sections[320],f,true,c,nil,-2)
      xywh = {x = obj.sections[320].x,
              y = obj.sections[320].y-6,
              w = obj.sections[320].w,
              h = obj.sections[320].h}
      GUI_textC(gui,xywh,'SINGLE',c,-8)               
      xywh.y = xywh.y + 8
      GUI_textC(gui,xywh,'BAND',c,-8)               

      f_Get_SSV(gui.color.white)
      local c = gui.color.white    
      local f = skin.barG
      if eq_scale == true then
        c = gui.color.black    
        f = skin.bar
      end
      GUI_DrawBar(gui,'',obj.sections[321],f,true,c,nil,-2)
      xywh = {x = obj.sections[321].x,
              y = obj.sections[321].y-1,
              w = obj.sections[321].w,
              h = obj.sections[321].h}
      GUI_textC(gui,xywh,'SCALE',c,-8)               

      f_Get_SSV(gui.color.white)
      f = skin.bar
      c = gui.color.black    
      GUI_DrawBar(gui,'',obj.sections[345],f,true,c,nil,-2)

      xywh = {x = obj.sections[345].x,
              y = obj.sections[345].y-6,
              w = obj.sections[345].w,
              h = obj.sections[345].h}
      GUI_textC(gui,xywh,'OPEN',c,-8)               
      xywh.y = xywh.y + 8
      GUI_textC(gui,xywh,'FX',c,-8)               
      
      f_Get_SSV(gui.color.white)
      --gfx.line(obj.sections[303].x,obj.sections[303].y,obj.sections[303].x+obj.sections[303].w,obj.sections[303].y,1)
      --gfx.line(obj.sections[303].x,obj.sections[303].y+obj.sections[303].h,obj.sections[303].x+obj.sections[303].w,obj.sections[303].y+obj.sections[303].h,1)
      local bandsn = 20
      local track = GetTrack(tracks[track_select].tracknum)
      for l = 1, bandsn do
        local x = math.floor(obj.sections[303].w / bandsn) * (l-1)
        f_Get_SSV(gui.color.white)

        local xywh = {x = obj.sections[303].x+x,
                      y = obj.sections[303].y,
                      w = obj.sections[303].w / bandsn,
                      h = obj.sections[303].h}
        if l < bandsn then
          local c = '32 32 32'
          
          local byp = 0
          if bands and bands[l] then
            local p_byp = bands[l].bypass_param
            local fxnum = bands[l].fxnum
            
            if bands[l].bypass_param then
              byp = reaper.TrackFX_GetParamNormalized(track, fxnum, p_byp)
              bands[l].bypass_val = byp
            end
          end
                    
          if byp == 1 then            
            f_Get_SSV('64 0 0')
          else
            f_Get_SSV('32 32 32')
          end
          
          gfx.rect(xywh.x+2,xywh.y,xywh.w-4,xywh.h+1,1,1)

          if eqcontrolband_select == l then
            f_Get_SSV(gui.color.white)
            gfx.rect(xywh.x+2,
                     xywh.y, 
                     xywh.w-4,
                     xywh.h+1, 0)
            c = gui.color.black                        
            if bands and l <= #bands then
              c = bands[l].col          
            end
          else
            if bands and l <= #bands then
              c = bands[l].col          
            end
          end
          f_Get_SSV(c)
          gfx.circle(xywh.x+math.floor(xywh.w/2),xywh.y+math.floor(xywh.h/2),6,1,1)
          f_Get_SSV(gui.color.black)
          gfx.circle(xywh.x+math.floor(xywh.w/2),xywh.y+math.floor(xywh.h/2),7,0,1)
          gfx.circle(xywh.x+math.floor(xywh.w/2),xywh.y+math.floor(xywh.h/2),8,0,1)
          xywh.y = xywh.y - 1
                
          GUI_textC(gui,xywh,string.format('%i',l),c,-4)
        end
      end
      
      if eqcontrolband_select and bands and 
        bands[eqcontrolband_select] then
        if eq_edit then
  
          gfx.a=1
  
          GUI_DrawBar(gui,'SAVE BAND',obj.sections[312],skin.bar,true,gui.color.black,nil,-5)                 
          GUI_DrawBar(gui,'DEL BAND',obj.sections[315],skin.bar,true,gui.color.black,nil,-5)               
          GUI_DrawBar(gui,'SAVE EQ',obj.sections[340],skin.bar,true,gui.color.black,nil,-5)               
   
          local f = skin.barG
          local c = gui.color.white
          local txt = 'FOLDER'
          if bands[eqcontrolband_select].bandtype then
            f = skin.bar
            c = gui.color.black
            txt = bands[eqcontrolband_select].bandtype
          end
          GUI_DrawBar(gui,txt,obj.sections[313],f,true,c,nil,-5)               

          GUI_DrawColorBox(gui, '', obj.sections[355], gui.color.white, bands[eqcontrolband_select].col)
          local xywh = {x = obj.sections[355].x,
                        y = obj.sections[355].y-5,
                        w = obj.sections[355].w,
                        h = obj.sections[355].h}
          GUI_textC(gui,xywh,'BAND',gui.color.black,-5) 
          xywh.y = xywh.y + 10        
          GUI_textC(gui,xywh,'COLOUR',gui.color.black,-5)                   
  
          local f = skin.barG
          local c = gui.color.white
          local txt = 'BAND NAME'
          if bands[eqcontrolband_select].bandname then
            f = skin.bar
            c = gui.color.black
            txt = bands[eqcontrolband_select].bandname
          end
          GUI_DrawBar(gui,txt,obj.sections[314],f,true,c,nil,-5)               
                
          local f = skin.barG
          local c = gui.color.white
          local txt = 'SELECT PLUGIN'
          if bands[eqcontrolband_select].fxnum then
            f = skin.bar
            c = gui.color.black
            if bands[eqcontrolband_select].fxname then
              txt = string.format('%i',bands[eqcontrolband_select].fxnum+1)..': '..
                    bands[eqcontrolband_select].fxname
            else
              txt = string.format('%i',bands[eqcontrolband_select].fxnum+1)..': '
            end
          end
          GUI_DrawBar(gui,txt,obj.sections[305],f,true,c,nil,-5)               

          if bands[eqcontrolband_select].fxnum then
          
            f = skin.barG
            c = gui.color.white
            txt = 'SELECT FREQ PARAM'
            if bands[eqcontrolband_select].freq_param then
              f = skin.bar
              c = gui.color.black
              txt = bands[eqcontrolband_select].freq_param_name
            end
            GUI_DrawBar(gui,txt,obj.sections[306],f,true,c,nil,-5)               
            GUI_DrawBar(gui,'',obj.sections[309],f,true,c,nil,-5)
            GUI_DrawBar(gui,'',obj.sections[336],f,true,c,nil,-5)

            local xywh = {x = obj.sections[337].x-6,
                          y = obj.sections[337].y-13,
                          w = 1,
                          h = butt_h}
            GUI_textsm_RJ(gui,xywh,'DETECTION   ',gui.color.white,-5)
            xywh.y = xywh.y + 10
            GUI_textsm_RJ(gui,xywh,'SENSITIVITY',gui.color.white,-5)
                          
            GUI_DrawSliderH(gui, '', obj.sections[337], gui.color.black, gui.color.white, F_limit(auto_delay/10,0,1))
            GUI_textC(gui,obj.sections[337],auto_delay,gui.color.red,-2)

            local xywh = {x = obj.sections[338].x,
                          y = obj.sections[338].y+3,
                          w = obj.sections[338].w,
                          h = 10}
            
            GUI_textsm_LJ(gui,xywh,'FREQ MIN:',gui.color.red,-5)
            xywh.y = xywh.y + 12
            GUI_textsm_LJ(gui,xywh,'FREQ MAX:',gui.color.red,-5)
            xywh.y = xywh.y + 15
            GUI_textsm_LJ(gui,xywh,'GAIN MIN:',gui.color.red,-5)
            xywh.y = xywh.y + 12
            GUI_textsm_LJ(gui,xywh,'GAIN MAX:',gui.color.red,-5)

            xywh.x = obj.sections[338].x
            xywh.y = obj.sections[338].y+3
            
            GUI_textsm_RJ(gui,xywh,nz(bands[eqcontrolband_select].freq_min,''),gui.color.red,-5)
            xywh.y = xywh.y + 12
            GUI_textsm_RJ(gui,xywh,nz(bands[eqcontrolband_select].freq_max,''),gui.color.red,-5)
            xywh.y = xywh.y + 15
            GUI_textsm_RJ(gui,xywh,nz(bands[eqcontrolband_select].gain_min,''),gui.color.red,-5)
            xywh.y = xywh.y + 12
            GUI_textsm_RJ(gui,xywh,nz(bands[eqcontrolband_select].gain_max,''),gui.color.red,-5)
  
            f = skin.barG
            c = gui.color.white
            txt = 'SELECT BAND BYPASS'
            if bands[eqcontrolband_select].bypass_param then
              f = skin.bar
              c = gui.color.black
              txt = bands[eqcontrolband_select].bypass_param_name
            end
            GUI_DrawBar(gui,txt,obj.sections[322],f,true,c,nil,-5)               

            f = skin.barG
            c = gui.color.white
            txt = 'SELECT CTL 1'
            if bands[eqcontrolband_select].c1_param then
              f = skin.bar
              c = gui.color.black
              txt = bands[eqcontrolband_select].c1_param_name
            end
            GUI_DrawBar(gui,txt,obj.sections[323],f,true,c,nil,-5)               

            f = skin.barG
            c = gui.color.white
            txt = 'SELECT CTL 2'
            if bands[eqcontrolband_select].c2_param then
              f = skin.bar
              c = gui.color.black
              txt = bands[eqcontrolband_select].c2_param_name
            end
            GUI_DrawBar(gui,txt,obj.sections[324],f,true,c,nil,-5)               
            
            f = skin.barG
            c = gui.color.white
            txt = 'SELECT CTL 3'
            if bands[eqcontrolband_select].c3_param then
              f = skin.bar
              c = gui.color.black
              txt = bands[eqcontrolband_select].c3_param_name
            end
            GUI_DrawBar(gui,txt,obj.sections[331],f,true,c,nil,-5)               

            f = skin.barG
            c = gui.color.white
            txt = 'SELECT CTL 4'
            if bands[eqcontrolband_select].c4_param then
              f = skin.bar
              c = gui.color.black
              txt = bands[eqcontrolband_select].c4_param_name
            end
            GUI_DrawBar(gui,txt,obj.sections[332],f,true,c,nil,-5)               

            f = skin.barG
            c = gui.color.white
            txt = 'SELECT CTL 5'
            if bands[eqcontrolband_select].c5_param then
              f = skin.bar
              c = gui.color.black
              txt = bands[eqcontrolband_select].c5_param_name
            end
            GUI_DrawBar(gui,txt,obj.sections[333],f,true,c,nil,-5)               

            f = skin.bar
            c = gui.color.black
            GUI_DrawBar(gui,'CAPTURE CURRENT VALUES AS DEFAULT',obj.sections[356],f,true,c,nil,-5)               
            
            c = gui.color.black
            if bands[eqcontrolband_select].lookmap then
              GUI_textC(gui,obj.sections[309],'ALIGN GRAPH',c,-5)         
            else      
              GUI_textC(gui,obj.sections[309],'CALC GRAPH',c,-5)         
            end
            GUI_textC(gui,obj.sections[336],'CLEAR GRAPH',c,-5)         

            xywh = {x = obj.sections[357].x,
                    y = obj.sections[357].y+10, 
                    w = obj.sections[357].w,
                    h = butt_h}
            GUI_DrawBar(gui,'',obj.sections[357],skin.bar,true,c,nil,-5)
            
            GUI_textC(gui,xywh,'ALIGN',c,-5)
            xywh.y = xywh.y + 14         
            GUI_textC(gui,xywh,'ALL',c,-5)         
            xywh.y = xywh.y + 14         
            GUI_textC(gui,xywh,'BANDS',c,-5)         
            
            f_Get_SSV(gui.color.white)
            f = skin.barG
            c = gui.color.white
            if strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqgraph then
              f = skin.bar
              c = gui.color.black
            end          
            GUI_DrawBar(gui,'',obj.sections[310],f,true,c,nil,-5)               
            GUI_textC(gui,obj.sections[310],'SET',c,-6,nil,-5)         
            GUI_textC(gui,obj.sections[310],'DEFAULT',c,-6,nil,4)         
  
            f_Get_SSV(gui.color.white)
            f = skin.bar
            c = gui.color.black
            local txt = 'Hz/kHz'
            if bands[eqcontrolband_select].khz == true then
              txt = 'kHz'
            end          
            GUI_DrawBar(gui,txt,obj.sections[316],f,true,c,nil,-5)               
          
            f = skin.barG
            c = gui.color.white
            txt = 'SELECT GAIN PARAM'
            if bands[eqcontrolband_select].gain_param then
              f = skin.bar
              c = gui.color.black
              txt = bands[eqcontrolband_select].gain_param_name
            end
            GUI_DrawBar(gui,txt,obj.sections[307],f,true,c,nil,-5)               
  
            f = skin.barG
            c = gui.color.white
            if bands[eqcontrolband_select].gain_inv then
              f = skin.bar
              c = gui.color.black
            end
            GUI_DrawBar(gui,'INVERT',obj.sections[317],f,true,c,nil,-5)               
  
            f = skin.barG
            c = gui.color.white
            txt = 'SELECT Q PARAM'
            if bands[eqcontrolband_select].q_param then
              f = skin.bar
              c = gui.color.black
              txt = bands[eqcontrolband_select].q_param_name
            end
            GUI_DrawBar(gui,txt,obj.sections[308],f,true,c,nil,-5)               
  
            f = skin.barG
            c = gui.color.white
            if bands[eqcontrolband_select].q_inv then
              f = skin.bar
              c = gui.color.black
            end
            GUI_DrawBar(gui,'INVERT',obj.sections[318],f,true,c,nil,-5)               
          
          end
        else
       
          local xywh = {x = obj.sections[325].x,
                        y = obj.sections[325].y-20,
                        w = obj.sections[325].w,
                        h = 10}
          if bands[eqcontrolband_select].freq_param then
            GUI_textC(gui,xywh,'FREQ',gui.color.white,-2)         
          end
          if bands[eqcontrolband_select].gain_param then
            xywh.x = obj.sections[326].x
            GUI_textC(gui,xywh,'GAIN',gui.color.white,-2)                      
          end
          if bands[eqcontrolband_select].q_param then          
            xywh.x = obj.sections[327].x
            GUI_textC(gui,xywh,'Q',gui.color.white,-2)                      
          end
          xywh.x = obj.sections[328].x
          xywh.w = obj.sections[328].w
          local txt = bands[eqcontrolband_select].c1_param_name
          if txt then
            GUI_textC(gui,xywh,txt,gui.color.white,-4)                      
          end
          local ofs = 15
          xywh.y = xywh.y - ofs
          xywh.x = obj.sections[329].x
          local txt = bands[eqcontrolband_select].c2_param_name
          if txt then
            GUI_textC(gui,xywh,txt,gui.color.white,-4)                      
          end
          xywh.y = xywh.y + ofs
          xywh.x = obj.sections[330].x
          local txt = bands[eqcontrolband_select].c3_param_name
          if txt then
            GUI_textC(gui,xywh,txt,gui.color.white,-4)                      
          end
          xywh.y = xywh.y - ofs
          xywh.x = obj.sections[334].x
          local txt = bands[eqcontrolband_select].c4_param_name
          if txt then
            GUI_textC(gui,xywh,txt,gui.color.white,-4)                      
          end
          xywh.y = xywh.y + ofs
          xywh.x = obj.sections[335].x
          local txt = bands[eqcontrolband_select].c5_param_name
          if txt then
            GUI_textC(gui,xywh,txt,gui.color.white,-4)                      
          end
        end
      end
    end
    
    local mp = math.floor(obj.sections[302].y+(obj.sections[302].h/2))
    
    if strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqgraph and eq_scale == true then
      local eqg = strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqgraph
      
      if type(eqg) == 'table' and eqg.gmap and eqg.lookmap then

        local pmin = eqg.posmin
        local pmax = eqg.posmax
        local gmin = eqg.gmin
        local gmax = eqg.gmax
        
        if eq_scale == false then
          pmin = 0
          pmax = 1
          gmin = 0
          gmax = 1
        end
        
        local xywh = {x = obj.sections[302].x + pmin*obj.sections[302].w,
                      y = obj.sections[302].y,
                      w = (pmax-pmin)*obj.sections[302].w,
                      h = obj.sections[302].h}
        f_Get_SSV('8 8 48')
        gfx.rect(xywh.x,
                 xywh.y, 
                 xywh.w,
                 xywh.h, 1)
        --gfx.a = 0.3
        --gfx.gradrect(xywh.x,xywh.y,xywh.w,xywh.h, 0,0,1.6,0.5, 0,0,0.0008,0.00005, 0,0,0,-0.0005)
        --gfx.a = 1
        
        local pmin2, pmax2, gmin2, gmax2 = 0,1,0,1
        if bands and eqcontrolband_select 
           and bands[eqcontrolband_select] then
          pmin2 = bands[eqcontrolband_select].posmin
          pmax2 = bands[eqcontrolband_select].posmax
          gmin2 = bands[eqcontrolband_select].gmin
          gmax2 = bands[eqcontrolband_select].gmax

          gmap2 = bands[eqcontrolband_select].gmap
        end
                
        if eq_scale == false then
          pmin2 = 0
          pmax2 = 1
          gmin2 = 0
          gmax2 = 1
        end

        local gmap = eqg.gmap
        
        f_Get_SSV('16 16 48')
        local prevx = 0
        gfx.setfont(1, gui.fontname, gui.fontsz_knob -5)
        local h = (gmax - gmin) * obj.sections[302].h
        
        if gmap2 and #gmap2 > 1 then
          local g1 = obj.sections[302].y + obj.sections[302].h -(gmap2[1].pix/2000)*h - (gmin2 * obj.sections[302].h)+5
          local g2 = obj.sections[302].y + obj.sections[302].h -((gmap2[#gmap2].pix/2000)*h - (gmin2 * obj.sections[302].h))-5 
  
          if gmap then
            for l = 1, #gmap do
              local y = obj.sections[302].y + obj.sections[302].h - (gmap[l].pix/2000)*h - (gmin * obj.sections[302].h)
              f_Get_SSV('0 0 32')
              
              if (y > g1
                 or y < g2) or draggraph then
                if gmap[l].db % 6 == 0 then
                  --gfx.line( obj.sections[302].x, y, obj.sections[302].x + obj.sections[302].w, y)
                  xywh = {x = obj.sections[302].x-4,
                          y = y,
                          w = 1,
                          h = 1}
                  local txt = gmap[l].db
                  GUI_textsm_RJ(gui, xywh, txt, '128 0 0', -5)    
                end
              end
            end
          end
        end
                
        local lookmap = eqg.lookmap
        f_Get_SSV('16 16 48')
        if lookmap then
          for l = 1, #lookmap do
            local w = (pmax - pmin) * obj.sections[302].w
            local x = (lookmap[l].pix/2000)*w + (pmin * obj.sections[302].w)
            local yinc = 0
            if (x < pmin2 * obj.sections[302].w or x > pmax2 * obj.sections[302].w) or draggraph then
              if 10^math.floor(math.log(lookmap[l].hz,10)) == lookmap[l].hz then
                local xywh = {x = obj.sections[302].x + x-4,
                            y = obj.sections[302].y + obj.sections[302].h+1,
                            w = 1,
                            h = 10}
                  
                if draggraph then
                  yinc = 10
                  GUI_textsm_RJ(gui, xywh, string.format('%i',lookmap[l].hz), gui.color.white, -5)    
                end
                f_Get_SSV('64 64 128')
              else
                f_Get_SSV('32 32 96')  
              end
              if draggraph == nil then
                gfx.a = 0.3          
              end
              gfx.line(obj.sections[302].x + x, obj.sections[302].y, obj.sections[302].x + x, obj.sections[302].y + obj.sections[302].h-1 + yinc)    
              gfx.a = 1
            end
          end
        end
      end
    
    end
    
    if bands then
    
      if bands[eqcontrolband_select] and 
         bands[eqcontrolband_select].lookmap then
      
        local pmin = bands[eqcontrolband_select].posmin
        local pmax = bands[eqcontrolband_select].posmax
        local gmin = bands[eqcontrolband_select].gmin
        local gmax = bands[eqcontrolband_select].gmax
        
        if eq_scale == false then
          pmin = 0
          pmax = 1
          gmin = 0
          gmax = 1
        end
        
        local xywh = {x = obj.sections[302].x + pmin*obj.sections[302].w,
                      y = obj.sections[302].y+obj.sections[302].h - gmax*obj.sections[302].h,
                      w = (pmax-pmin)*obj.sections[302].w,
                      h = (gmax-gmin)*obj.sections[302].h}
        f_Get_SSV('24 24 96')
        if draggraph then
          gfx.a = 0.2
        end
        gfx.rect(xywh.x,
                 xywh.y, 
                 xywh.w,
                 xywh.h, 1)    
        gfx.a = 1
        local lookmap = bands[eqcontrolband_select].lookmap
        local gmap = bands[eqcontrolband_select].gmap
        f_Get_SSV('16 16 48')
        local prevx = 0
        gfx.setfont(1, gui.fontname, gui.fontsz_knob -5)

        if gmap then
          for l = 1, #gmap do
            local h = (gmax - gmin) * obj.sections[302].h
            local y = obj.sections[302].y + obj.sections[302].h - (gmap[l].pix/2000)*h - (gmin * obj.sections[302].h)
            f_Get_SSV('16 16 60')
            if gmap[l].db % 6 == 0 then
              gfx.line( obj.sections[302].x, y, obj.sections[302].x + obj.sections[302].w, y)
              xywh = {x = obj.sections[302].x-4,
                      y = y,
                      w = 1,
                      h = 1}
              local txt = gmap[l].db
              GUI_textsm_RJ(gui, xywh, txt, gui.color.white, -5)    
            end
          end
        end


        for l = 1, #lookmap do
          local w = (pmax - pmin) * obj.sections[302].w
          local x = (lookmap[l].pix/2000)*w + (pmin * obj.sections[302].w)
          local yinc = 0
          if 10^math.floor(math.log(lookmap[l].hz,10)) == lookmap[l].hz then
            local txt = string.format('%i',lookmap[l].hz)
            local tw = gfx.measurestr(txt)
            local xywh = {x = obj.sections[302].x + x-4,
                          y = obj.sections[302].y + obj.sections[302].h+1,
                          w = 1,
                          h = 10}
            if xywh.x - tw > prevx +10 then
              yinc = 10
              GUI_textsm_RJ(gui, xywh, txt, gui.color.white, -5)    
              prevx = xywh.x           
            end
            f_Get_SSV('48 48 96')
          else
            local txt = string.format('%i',lookmap[l].hz)
            local tw = gfx.measurestr(txt)
            local xywh = {x = obj.sections[302].x + x-4,
                          y = obj.sections[302].y + obj.sections[302].h+1,
                          w = 1,
                          h = 10}
            if xywh.x - tw > prevx +10 then
              yinc = 10
              GUI_textsm_RJ(gui, xywh, txt, gui.color.white, -5)                
              prevx = xywh.x           
            end
            f_Get_SSV('16 16 64') 

          end
          --DBG(x)
          gfx.line( obj.sections[302].x + x, obj.sections[302].y, obj.sections[302].x + x, obj.sections[302].y + obj.sections[302].h-1 + yinc)
          if yinc > 0 then
            f_Get_SSV('64 64 128')
            gfx.line( obj.sections[302].x + x, obj.sections[302].y + obj.sections[302].h-1, obj.sections[302].x + x, obj.sections[302].y + obj.sections[302].h-1 + yinc)
            
          end    
        end
      end
      
      if bands[eqcontrolband_select] then
        local bn = bands[eqcontrolband_select].bandname
        local bt = bands[eqcontrolband_select].bandtype
        if bt or bn then
          local txt = ''
          if bt then
            txt = bt
          end
          if bn then
            if txt ~= '' then
              txt = txt .. ' : '
            end
            txt = txt .. bn
          end
          
          local xywh = {x = obj.sections[302].x + 10,
                        y = obj.sections[302].y + 10,
                        w = 2,
                        h = 14}
          GUI_textsm_LJ(gui, xywh, txt, '64 64 128', 4)
        end  
      end
    end    
    
    f_Get_SSV('128 128 128')
    gfx.line(obj.sections[302].x, mp, obj.sections[302].x + obj.sections[302].w-1, mp, 1)
    f_Get_SSV('64 64 64')
    gfx.rect(obj.sections[302].x,
             obj.sections[302].y, 
             obj.sections[302].w,
             obj.sections[302].h, 0)
    
    if bands and
       bands[eqcontrolband_select] and 
       bands[eqcontrolband_select].freq_param then

      local pmin = bands[eqcontrolband_select].posmin
      local pmax = bands[eqcontrolband_select].posmax
      
      --[[if eq_scale == false then
        pmin = 0
        pmax = 1
      end]]
       
      local x = obj.sections[302].x + pmin * obj.sections[302].w
      f_Get_SSV('0 255 0')
      if eq_edit then
        xywh = {x = x-4,
                y = obj.sections[302].y+obj.sections[302].h + 2,
                w = 8,
                h = 8}
        gfx.rect(xywh.x,
                 xywh.y, 
                 xywh.w,
                 xywh.h, 1)
        gfx.line(x, obj.sections[302].y, x, obj.sections[302].y+obj.sections[302].h, 1)
      else
        f_Get_SSV('64 64 240')    
      end
            
      x = obj.sections[302].x + pmax * obj.sections[302].w
      f_Get_SSV('255 0 0')
      if eq_edit then
        xywh = {x = x-4,
                y = obj.sections[302].y+obj.sections[302].h + 2,
                w = 8,
                h = 8}
        gfx.rect(xywh.x,
                 xywh.y, 
                 xywh.w,
                 xywh.h, 1)
        gfx.line(x, obj.sections[302].y, x, obj.sections[302].y+obj.sections[302].h, 1)
      else
        f_Get_SSV('64 64 240')    
      end
                    
    end    

    if bands and
       bands[eqcontrolband_select] and 
       bands[eqcontrolband_select].gain_param then

      local gmin = bands[eqcontrolband_select].gmin
      local gmax = bands[eqcontrolband_select].gmax
      
      --[[if eq_scale == false then
        pmin = 0
        pmax = 1
      end]]
       
      local y = obj.sections[302].y + obj.sections[302].h  - (gmin * obj.sections[302].h)
      f_Get_SSV('0 255 255')
      if eq_edit then
        xywh = {x = obj.sections[302].x-10,
                y = y-4,
                w = 8,
                h = 8}
        gfx.rect(xywh.x,
                 xywh.y, 
                 xywh.w,
                 xywh.h, 1)
        gfx.line(obj.sections[302].x-2, y, obj.sections[302].x + obj.sections[302].w-1, y, 1)
      else
        f_Get_SSV('64 64 240')    
      end
            
      y = obj.sections[302].y + obj.sections[302].h - gmax * obj.sections[302].h
      f_Get_SSV('0 255 255')
      if eq_edit then
        xywh = {x = obj.sections[302].x-10,
                y = y-4,
                w = 8,
                h = 8}
        gfx.rect(xywh.x,
                 xywh.y, 
                 xywh.w,
                 xywh.h, 1)
        gfx.line(obj.sections[302].x-2, y, obj.sections[302].x + obj.sections[302].w-1, y, 1)
      else
        f_Get_SSV('64 64 240')    
      end
                    
    end    

    gfx.dest = 1
  
  end
  
  ------------------------------------------------------------

  function GUI_DrawMacroEdit(obj, gui)

    local macro = strips[tracks[track_select].strip][page].controls[macroctl_select].macroctl
    gfx.dest = 1008
    local w, h = gfx.getimgdim(1008)
    local update_size
    if obj.sections[300].w ~= w or obj.sections[300].h ~= h then update_size = true update_gfx = true end
    if update_gfx or update_surface or update_macroedit or update_macrobutt then
      if update_size then
        gfx.setimgdim(1008, obj.sections[300].w, obj.sections[300].h)
      end
      
      if update_gfx then --or update_surface then
        f_Get_SSV(gui.color.black)
        gfx.rect(0,
                 0, 
                 obj.sections[300].w,
                 obj.sections[300].h, 1)
  
        local xywh = {x = obj.sections[408].x,
                      y = obj.sections[408].y - obj.sections[408].h,
                      w = obj.sections[408].w,
                      h = obj.sections[408].h}
                      
        GUI_textC(gui,xywh,'AUTOMATION',gui.color.white,-2)
        local macrofader = strips[tracks[track_select].strip][page].controls[macroctl_select].macrofader
        if macrofader then
          GUI_DrawButton(gui, 'FADER '..string.format('%i',macrofader), obj.sections[408], gui.color.white, gui.color.black, true, '', false)      
        else
          GUI_DrawButton(gui, 'NONE', obj.sections[408], -3, gui.color.black, false, '', false)
        end
        GUI_DrawButton(gui, 'ADD PARAMETERS', obj.sections[409], '160 160 160', gui.color.black, true, '', false)      
        GUI_DrawButton(gui, 'CAPTURE A', obj.sections[411], '160 160 160', gui.color.black, true, '', false)      
        GUI_DrawButton(gui, 'CAPTURE B', obj.sections[412], '160 160 160', gui.color.black, true, '', false)      
        if settings_macroeditmonitor == true then
          GUI_DrawBar(gui, 'MONITOR', obj.sections[413], skin.butt18Y, true, gui.color.black, nil, -2)     
        else
          GUI_DrawBar(gui, 'MONITOR', obj.sections[413], skin.butt18, true, gui.color.black, nil, -2)              
        end      
      end
  
      local w = gfx.getimgdim(def_eqcknobf)
      local h = ctl_files[def_eqcknobfctl].cellh
      local frames = ctl_files[def_eqcknobfctl].frames-1
      local v = math.floor(strips[tracks[track_select].strip][page].controls[macroctl_select].val*frames)
      f_Get_SSV(gui.color.black)
      gfx.rect(obj.sections[410].x,
               obj.sections[410].y,
               obj.sections[410].w,
               obj.sections[410].h,1)          
      
      gfx.blit(def_eqcknobf, 1, 0, 0, v* h, w, h, obj.sections[410].x, obj.sections[410].y)
      --xywh.y = xywh.y + 30
      --GUI_textC(gui,xywh,roundX(freq_d,1, suffix),gui.color.white,-2)    
    
      for m = 1, macroedit.pcnt do
      
        local mm = m-1
        
        if macro and macro[m+macroedit_poffs] then

          local ctl = strips[tracks[track_select].strip][page].controls[macro[m+macroedit_poffs].ctl]
          if ctl then
            if update_gfx then --or update_surface then
              local xywh = {x = obj.sections[402].x,
                            y = obj.sections[402].y + mm*macroedit.sech +2,
                            w = obj.sections[402].w+6,
                            h = macroedit.sech-4}          
              f_Get_SSV('32 32 32')              
              gfx.rect(xywh.x,
                       xywh.y, 
                       xywh.w,
                       xywh.h, 1)
    
              local xywh = {x = obj.sections[405].x,
                            y = obj.sections[405].y + mm*macroedit.sech +2,
                            w = obj.sections[405].w,
                            h = macroedit.sech-4}
              f_Get_SSV('32 32 32')              
              gfx.rect(xywh.x,
                       xywh.y, 
                       xywh.w,
                       xywh.h, 1)
              GUI_textC(gui, xywh, macroscale_table[macro[m+macroedit_poffs].shape], gui.color.white, -2)          
              
              xywh = {x = obj.sections[402].x+30,
                      y = obj.sections[402].y + mm*macroedit.sech,
                      w = obj.sections[402].w,
                      h = macroedit.sech}
              GUI_textsm_LJ(gui, xywh, ctl.param_info.paramname, gui.color.white, -2, xywh.w)
            end
            
            if update_gfx or update_macrobutt then
              xywh = {x = obj.sections[406].x,
                      y = obj.sections[406].y + mm*macroedit.sech + 0.5*macroedit.sech - 10,
                      w = obj.sections[406].w,
                      h = 20}
              if macro[m+macroedit_poffs].mute then
                GUI_DrawBar(gui,'M',xywh,skin.butt18R,true,gui.color.black,gui.color.black,-2)
              else
                GUI_DrawBar(gui,'M',xywh,skin.butt18,true,gui.color.black,gui.color.black,-2)
              end
    
              xywh = {x = obj.sections[414].x,
                      y = obj.sections[414].y + mm*macroedit.sech + 0.5*macroedit.sech - 10,
                      w = obj.sections[414].w,
                      h = 20}
              if macro[m+macroedit_poffs].bi then
                GUI_DrawBar(gui,'BI',xywh,skin.butt18Y,true,gui.color.black,gui.color.black,-5)
              else
                GUI_DrawBar(gui,'BI',xywh,skin.butt18,true,gui.color.black,gui.color.black,-5)
              end

              xywh = {x = obj.sections[416].x,
                      y = obj.sections[416].y + mm*macroedit.sech + 0.5*macroedit.sech - 10,
                      w = obj.sections[416].w,
                      h = 20}
              if macro[m+macroedit_poffs].relative then
                GUI_DrawBar(gui,'REL',xywh,skin.butt18Y,true,gui.color.black,gui.color.black,-5)
              else
                GUI_DrawBar(gui,'REL',xywh,skin.butt18,true,gui.color.black,gui.color.black,-5)
              end
    
              xywh = {x = obj.sections[415].x,
                      y = obj.sections[415].y + mm*macroedit.sech + 0.5*macroedit.sech - 10,
                      w = obj.sections[415].w,
                      h = 20}
              if macro[m+macroedit_poffs].inv then
                GUI_DrawBar(gui,'INV',xywh,skin.butt18Y,true,gui.color.black,gui.color.black,-6)
              else
                GUI_DrawBar(gui,'INV',xywh,skin.butt18,true,gui.color.black,gui.color.black,-6)
              end
    
              xywh = {x = obj.sections[407].x,
                      y = obj.sections[407].y + mm*macroedit.sech + 0.5*macroedit.sech - 10,
                      w = obj.sections[407].w,
                      h = 20}
              GUI_DrawBar(gui,'X',xywh,skin.butt18,true,gui.color.black,gui.color.black,-2)
    
            end
  
  
  
            local w, h = macroedit.sliderw, macroedit.sliderh
            
            local p = macro[m+macroedit_poffs].A_val           
            local p2 = macro[m+macroedit_poffs].B_val           
  
            local py = (obj.sections[403].y + mm*macroedit.sech) + math.floor(macroedit.sech/2)-1
  
            local xywh = {x = obj.sections[403].x - macroedit.sliderw*0.5-6,
                          y = obj.sections[403].y + mm*macroedit.sech +2,
                          w = obj.sections[403].w + macroedit.sliderw+12,
                          h = macroedit.sech-4}          
            f_Get_SSV('32 32 32')              
            gfx.rect(xywh.x,
                     xywh.y, 
                     xywh.w,
                     xywh.h, 1)
  
            local xywh = {x = obj.sections[404].x - macroedit.sliderw*0.5-6,
                          y = obj.sections[404].y + mm*macroedit.sech +2,
                          w = obj.sections[404].w + macroedit.sliderw+12,
                          h = macroedit.sech-4}          
            f_Get_SSV('32 32 32')              
            gfx.rect(xywh.x,
                     xywh.y, 
                     xywh.w,
                     xywh.h, 1)
  
            xywh = {x = obj.sections[403].x,
                    y = (obj.sections[403].y + mm*macroedit.sech) + math.floor(macroedit.sech/2)-1,
                    w = obj.sections[403].w,
                    h = 2}
            f_Get_SSV('16 16 16')              
            gfx.rect(xywh.x,
                     xywh.y, 
                     xywh.w,
                     xywh.h, 1)
            
            xywh.x = obj.sections[404].x
            gfx.rect(xywh.x,
                     xywh.y, 
                     xywh.w,
                     xywh.h, 1)
            
            xywh = {x = obj.sections[403].x + p*obj.sections[403].w - (w/2),
                    y = (obj.sections[403].y + mm*macroedit.sech) + math.floor(macroedit.sech/2) - (h/2),
                    w = w,
                    h = h}
            if macro[m+macroedit_poffs].mute == true then
              f_Get_SSV(gui.color.red)          
            else
              f_Get_SSV(gui.color.blue)
            end
            gfx.a = 0.6
            if macro[m+macroedit_poffs].relative == false then
              if macro[m+macroedit_poffs].bi == true then
                x1 = F_limit(p*obj.sections[403].w - p2*obj.sections[403].w,0,obj.sections[403].w)
                x2 = F_limit(p*obj.sections[403].w + p2*obj.sections[403].w,0,obj.sections[403].w)
                gfx.line(obj.sections[403].x + x1,py,obj.sections[403].x + x2,py)          
              else
                gfx.line(obj.sections[403].x + p*obj.sections[403].w,py,obj.sections[403].x + p2*obj.sections[403].w,py)
              end
            end
              
            gfx.a = 1
            if macro[m+macroedit_poffs].relative ~= true then
              GUI_DrawBar(gui,'',xywh,skin.slidbutt,true,gui.color.black,gui.color.black,-2)
            end
            
            if macro[m+macroedit_poffs].mute == nil or macro[m+macroedit_poffs].mute == false then
              f_Get_SSV(gui.color.yellow)
              xywh.x = obj.sections[403].x + ctl.val*obj.sections[403].w
              xywh.w = 1
              xywh.y = xywh.y + 2
              xywh.h = xywh.h - 4
              gfx.rect(xywh.x,
                       xywh.y, 
                       xywh.w,
                       xywh.h, 1)
            end
  
            xywh = {x = obj.sections[404].x + p2*obj.sections[404].w - (w/2),
                    y = (obj.sections[404].y + mm*macroedit.sech) + math.floor(macroedit.sech/2) - (h/2),
                    w = w,
                    h = h}
            if macro[m+macroedit_poffs].mute == true then
              f_Get_SSV(gui.color.red)          
            else
              f_Get_SSV(gui.color.blue)
            end
            gfx.a = 0.6
            if macro[m+macroedit_poffs].bi == true or macro[m+macroedit_poffs].relative == true then
              gfx.line(obj.sections[404].x,py,obj.sections[404].x + p2*obj.sections[404].w,py)
            else
              gfx.line(obj.sections[404].x + p*obj.sections[404].w,py,obj.sections[404].x + p2*obj.sections[404].w,py)
            end
            gfx.a = 1
            GUI_DrawBar(gui,'',xywh,skin.slidbutt,true,gui.color.black,gui.color.black,-2)
          end
        end      
      end
      
      if update_gfx then --or update_surface then
        local xywh = {x = obj.sections[401].x+2,
                      y = obj.sections[401].y+2,
                      w = obj.sections[401].w-4,
                      h = obj.sections[401].h-4}
        f_Get_SSV(gui.color.white)              
        gfx.rect(obj.sections[401].x,
                 obj.sections[401].y, 
                 obj.sections[401].w,
                 obj.sections[401].h, 1)
        f_Get_SSV(gui.color.black)
        gfx.line(xywh.x,xywh.y,xywh.x+xywh.w,xywh.y+xywh.h,1)
        gfx.line(xywh.x+xywh.w,xywh.y,xywh.x,xywh.y+xywh.h,1)

      end      

      
    end
    
    gfx.dest = 1
  
  end

  ------------------------------------------------------------
  
  function GUI_draw(obj, gui)
    gfx.mode = gmode
    
    if show_xxy == false and (update_gfx or update_surface or update_sidebar or update_topbar or update_ctlopts or update_ctls or update_bg or 
       update_settings or update_snaps or update_msnaps or update_actcho or update_fsnaps or update_mfsnaps or update_eqcontrol or update_macroedit or
       update_macrobutt) then    
      local p = 0
        
      gfx.dest = 1
      if update_gfx or resize_display then
        gfx.setimgdim(1, -1, -1)  
        gfx.setimgdim(1, gfx1.main_w,gfx1.main_h)
      end
            
      if resize_display then
        --gfx.setimgdim(1002,obj.sections[45].w, obj.sections[45].h)
        gfx.setimgdim(1003,obj.sections[160].w, obj.sections[160].h)
        gfx.setimgdim(1005,obj.sections[180].w, obj.sections[180].h)
        gfx.setimgdim(1006,obj.sections[221].w, obj.sections[221].h)
        gfx.setimgdim(1007,obj.sections[220].w, obj.sections[220].h)
        gfx.setimgdim(1011,obj.sections[45].w, obj.sections[45].h)        
      elseif resize_snaps then
        gfx.setimgdim(1003,-1,-1)
        gfx.setimgdim(1003,obj.sections[160].w, obj.sections[160].h)      
      elseif resize_fsnaps then
        gfx.setimgdim(1005,obj.sections[180].w, obj.sections[180].h)      
      end
      
      if mode == 0 then
        --Live
        if (macro_edit_mode == false or macro_lrn_mode == true) then
          if update_gfx or (surface_size.limit == false and update_surface) then
            GUI_DrawControlBackG(obj, gui)
            GUI_DrawControls(obj, gui)
            if show_snapshots then
              GUI_DrawSnapshots(obj, gui)
            end
            if show_fsnapshots or show_xysnapshots then
              GUI_DrawFSnapshots(obj, gui)
            end
          elseif update_snaps or (update_msnaps and resize_snaps) then  
            GUI_DrawSnapshots(obj, gui)
            if update_fsnaps then
              GUI_DrawFSnapshots(obj, gui)        
            end
            if update_ctls then
              GUI_DrawControls(obj, gui)          
            end
          elseif update_fsnaps or (update_mfsnaps and resize_fsnaps) then        
            GUI_DrawFSnapshots(obj, gui)
            if update_ctls then
              GUI_DrawControls(obj, gui)          
            end
          elseif update_ctls then        
            GUI_DrawControls(obj, gui)
          end
          if update_gfx or update_sidebar or resize_display then        
            --GUI_DrawTracks(obj, gui)
            GUI_DrawSidebar(obj, gui)
          end
        end
                
        gfx.dest = 1        
        
        if (macro_edit_mode == false or macro_lrn_mode == true) and (update_gfx or update_surface or update_bg or update_msnaps or update_mfsnaps) then
          --local w, h = obj.sections[10].w, lockh
          --local x, y = obj.sections[10].x + obj.sections[10].w/2 - w/2, obj.sections[10].y + (obj.sections[10].h/2) - h/2
          if show_bitmap == false then
            gfx.blit(1000,1,0,surface_offset.x,
                              surface_offset.y,
                              obj.sections[10].w,
                              obj.sections[10].h,
                              obj.sections[10].x,
                              obj.sections[10].y)
          else
            f_Get_SSV(gui.color.white)
            gfx.rect(obj.sections[10].x,
                     obj.sections[10].y,
                     obj.sections[10].w,
                     obj.sections[10].h)
            
            gfx.blit(ctl_bitmap,1,0,surface_offset.x,
                              surface_offset.y,
                              obj.sections[10].w,
                              obj.sections[10].h,
                              obj.sections[10].x,
                              obj.sections[10].y)          
          end
        end
        
        --[[if plist_w > 0 then                  
          gfx.blit(1001,1,0,0,0,obj.sections[43].w,obj.sections[43].h,0,butt_h)
        end]]

        if lasso ~= nil then
          gfx.a = 0.2
          f_Get_SSV(gui.color.blue)
          local l = {l = lasso.l, r = lasso.r, t = lasso.t, b = lasso.b}
          if lasso.r < lasso.l then
            l.l = lasso.r
            l.r = lasso.l
          end
          if lasso.b < lasso.t then
            l.b = lasso.t
            l.t = lasso.b          
          end
          gfx.rect(l.l,
                   l.t, 
                   l.r-l.l,
                   l.b-l.t, 1, 1)
          if ctl_select ~= nil then
            
            gfx.a = 0.8
            f_Get_SSV(gui.color.green)
            local ls = 4
            for c = 1, #ctl_select do

              local cx = ctl_select[c].ctl

              if strips[tracks[track_select].strip][page].controls[cx].ctlcat == ctlcats.fxparam or 
                 strips[tracks[track_select].strip][page].controls[cx].ctlcat == ctlcats.trackparam or 
                 strips[tracks[track_select].strip][page].controls[cx].ctlcat == ctlcats.tracksend or 
                 strips[tracks[track_select].strip][page].controls[cx].ctlcat == ctlcats.fxoffline then 

                local x = strips[tracks[track_select].strip][page].controls[cx].xsc+4
                local y = strips[tracks[track_select].strip][page].controls[cx].ysc+4
                local w = strips[tracks[track_select].strip][page].controls[cx].wsc-8
                local h = strips[tracks[track_select].strip][page].controls[cx].hsc-8
                x=x-surface_offset.x+obj.sections[10].x
                y=y-surface_offset.y+obj.sections[10].y
                gfx.line(x,y,x+ls,y,1)
                gfx.line(x,y,x,y+ls,1)
  
                gfx.line(x+w,y,x+w-ls,y,1)
                gfx.line(x+w,y,x+w,y+ls,1)
  
                gfx.line(x+w,y+h-ls,x+w,y+h,1)
                gfx.line(x+w,y+h,x+w-ls,y+h,1)
                
                gfx.line(x,y+h-ls,x,y+h,1)
                gfx.line(x,y+h,x+ls,y+h,1)
              end              
            end
          end
        end
        
        if snaplrn_mode == true then
          local strip = tracks[track_select].strip
          local scnt = #snapshots[strip][page][sstype_select].ctls
          if scnt > 0 then
            for ssc = 1, scnt do
              local ctl = snapshots[strip][page][sstype_select].ctls[ssc].ctl
              if ctl then
                if nz(snapshots[strip][page][sstype_select].ctls[ssc].delete,false) == false then
                  local x = strips[strip][page].controls[ctl].xsc
                  local y = strips[strip][page].controls[ctl].ysc
                  local w = strips[strip][page].controls[ctl].wsc
                  local h = strips[strip][page].controls[ctl].hsc
                  x=x-surface_offset.x+obj.sections[10].x
                  y=y-surface_offset.y+obj.sections[10].y
                  f_Get_SSV(gui.color.green)
                  gfx.a = 1
                  gfx.roundrect(x, y, w, h, 5, 1)
                end
              end           
            end
          end
        end

        --[[if trackfxparam_select then
          local strip = tracks[track_select].strip
          local ctl = strips[strip][page].controls[trackfxparam_select]
          if ctl then
            local x = ctl.xsc
            local y = ctl.ysc
            local w = ctl.wsc
            local h = ctl.hsc
            x=x-surface_offset.x+obj.sections[10].x
            y=y-surface_offset.y+obj.sections[10].y
            f_Get_SSV(gui.color.green)
            gfx.a = 0.5
            gfx.roundrect(x, y, w, h, 5, 1)
          end
        end]]
        
        --[[gfx.a = 1
        f_Get_SSV(gui.color.black)
        gfx.rect(0,
                 obj.sections[11].y, 
                 gfx1.main_w,
                 obj.sections[11].h+2, 1, 1)]]

        if update_gfx or update_surface or update_msnaps then
          if lockh > 0 or lockw > 0 or surface_size.exceed == true then
            UpdateLEdges()
          end
        end

        if insertstrip ~= nil then
          local x, y = insertstrip.x, insertstrip.y+math.floor(insertstrip.dy/settings_gridsize)*settings_gridsize
          local w, h = gfx.getimgdim(1022)
          gfx.a = 0.5
          
          gfx.blit(1022,1,0,0,0,w,h,x,y)          
        end

        if macro_lrn_mode == true and (update_gfx or update_surface or update_ctls) then
          gfx.a = 1
          GUI_DrawButton(gui,'EXIT MACRO LRN',obj.sections[250],-2,gui.color.white,true)
          
          local strip = tracks[track_select].strip
          if strips[strip][page].controls[macroctl_select].macroctl then
            local mcnt = #strips[strip][page].controls[macroctl_select].macroctl
            if mcnt > 0 then
              for mc = 1, mcnt do
                local ctl = strips[strip][page].controls[macroctl_select].macroctl[mc].ctl
                if ctl then
                  if nz(strips[strip][page].controls[macroctl_select].macroctl[mc].delete,false) == false then
                    local x = strips[strip][page].controls[ctl].xsc
                    local y = strips[strip][page].controls[ctl].ysc
                    local w = strips[strip][page].controls[ctl].wsc
                    local h = strips[strip][page].controls[ctl].hsc
                    x=x-surface_offset.x+obj.sections[10].x
                    y=y-surface_offset.y+obj.sections[10].y
                    f_Get_SSV(gui.color.blue)
                    gfx.a = 1
                    gfx.roundrect(x, y, w, h, 5, 1)
                    --gfx.roundrect(x+1, y+1, w-2, h-2, 5, 1)
                  end
                end           
              end
            end
          end          
        end

        if plist_w > 0 then                  
          gfx.blit(1001,1,0,0,0,obj.sections[43].w,obj.sections[43].h,0,0)
        end
        
        if show_snapshots and macro_lrn_mode ~= true then
          gfx.blit(1003,1,0,0,0,obj.sections[160].w,obj.sections[160].h,obj.sections[160].x,obj.sections[160].y)        
        
          if dragparam ~= nil then
            local x, y = dragparam.x, dragparam.y
            gfx.a = 0.7
            local iidx = ctl_files[knob_select].imageidx
            if iidx == nil or ksel_loaded == false then
              ksel_loaded = true
              gfx.loadimg(1023, controls_path..ctl_files[knob_select].fn)
              iidx = 1023
            elseif iidx == nil then
              iidx = 1023
            end
            local w, _ = gfx.getimgdim(iidx)
            local h = ctl_files[knob_select].cellh
            gfx.blit(iidx,scale_select,0,0,p*h,w,ctl_files[knob_select].cellh,x+ w/2-w*scale_select/2,y+ h/2-h*scale_select/2 )
            f_Get_SSV(gui.color.yellow)
            gfx.a = 1
            gfx.roundrect(x, y ,w, h, 8, 1, 0)
          end        
        end
        
        if show_fsnapshots or show_xysnapshots then
          gfx.blit(1005,1,0,0,0,obj.sections[180].w,obj.sections[180].h,obj.sections[180].x,obj.sections[180].y)                
        end
        
        if show_eqcontrol then
          if update_gfx or update_surface then
            GUI_DrawEQControl(obj, gui)
          end
          gfx.a=1
          
          gfx.blit(1009,1,0,0,0,obj.sections[300].w,obj.sections[300].h,obj.sections[300].x,obj.sections[300].y)  
          GUI_DrawEQBands(obj, gui)              
        end

        if macro_edit_mode == true and macro_lrn_mode == false then
          if update_surface or update_gfx or update_macrobutt or update_macroedit then
            GUI_DrawMacroEdit(obj, gui)
          end
          gfx.a=1

          gfx.blit(1008,1,0,0,0,obj.sections[300].w,obj.sections[300].h,obj.sections[300].x,obj.sections[300].y) 
        
        end
        
      elseif mode == 1 then        
        --Edit
        
        if submode == 0 then

          if update_gfx or (surface_size.limit == false and update_surface) or update_bg then
            GUI_DrawControlBackG(obj, gui)
            GUI_DrawControls(obj, gui)
          elseif update_ctls then        
            GUI_DrawControls(obj, gui)
          end
          if update_gfx or update_sidebar or resize_display then        
            --GUI_DrawFXParams(obj, gui)
            GUI_DrawSidebar(obj, gui)
          end
          
          if show_ctloptions and ctl_select ~= nil and (update_gfx or update_ctlopts) then
            GUI_DrawCtlOptions(obj, gui)            
          end

          gfx.dest = 1
          gfx.a = 1
          gfx.blit(1000,1,0,surface_offset.x,
                            surface_offset.y,
                            obj.sections[10].w,
                            obj.sections[10].h,
                            obj.sections[10].x,
                            obj.sections[10].y)
          --gfx.blit(1001,1,0,0,0,obj.sections[43].w,obj.sections[43].h,0,butt_h+2)
          if ctl_select ~= nil then
            selrect, selrect_sc = CalcSelRect()
            if dragctl ~= nil then 
              local x, y = selrect.x - surface_offset.x + obj.sections[10].x -b_sz, selrect.y - surface_offset.y + obj.sections[10].y-b_sz
              local w, h = gfx.getimgdim(1022)
              gfx.a = 1
              
              gfx.blit(1022,1,0,0,0,w,h,x,y) 

            end
          
            if newgrp ~= nil then
              local cx = newgrp.switchid         
              local x = strips[tracks[track_select].strip][page].controls[cx].x+1
              local y = strips[tracks[track_select].strip][page].controls[cx].y+1
              local w = strips[tracks[track_select].strip][page].controls[cx].w-2
              local h = strips[tracks[track_select].strip][page].controls[cx].ctl_info.cellh-2
              
              gfx.a = 0.5
              f_Get_SSV(gui.color.red)
              gfx.rect(x - surface_offset.x + obj.sections[10].x, y - surface_offset.y + obj.sections[10].y, w, h, 1, 1)            
            end
            
            --selrect = CalcSelRect()
            if selrect then
              f_Get_SSV(gui.color.blue)
              
              gfx.a = 0.8
              local ls = 4
              for c = 1, #ctl_select do
                local cx = ctl_select[c].ctl
                local x = strips[tracks[track_select].strip][page].controls[cx].xsc+4
                local y = strips[tracks[track_select].strip][page].controls[cx].ysc+4
                local w = strips[tracks[track_select].strip][page].controls[cx].wsc-8
                local h = strips[tracks[track_select].strip][page].controls[cx].hsc-8
                x=x-surface_offset.x+obj.sections[10].x
                y=y-surface_offset.y+obj.sections[10].y
                gfx.line(x,y,x+ls,y,1)
                gfx.line(x,y,x,y+ls,1)

                gfx.line(x+w,y,x+w-ls,y,1)
                gfx.line(x+w,y,x+w,y+ls,1)

                gfx.line(x+w,y+h-ls,x+w,y+h,1)
                gfx.line(x+w,y+h,x+w-ls,y+h,1)
                
                gfx.line(x,y+h-ls,x,y+h,1)
                gfx.line(x,y+h,x+ls,y+h,1)
                
              end

              if gfx3_select then
                for c = 1, #gfx3_select do
                  local cx = gfx3_select[c].ctl
                  local x = strips[tracks[track_select].strip][page].graphics[cx].x+4
                  local y = strips[tracks[track_select].strip][page].graphics[cx].y+4
                  local w = strips[tracks[track_select].strip][page].graphics[cx].stretchw-8
                  local h = strips[tracks[track_select].strip][page].graphics[cx].stretchh-8
                  x=x-surface_offset.x+obj.sections[10].x
                  y=y-surface_offset.y+obj.sections[10].y
                  gfx.line(x,y,x+ls,y,1)
                  gfx.line(x,y,x,y+ls,1)
  
                  gfx.line(x+w,y,x+w-ls,y,1)
                  gfx.line(x+w,y,x+w,y+ls,1)
  
                  gfx.line(x+w,y+h-ls,x+w,y+h,1)
                  gfx.line(x+w,y+h,x+w-ls,y+h,1)
                  
                  gfx.line(x,y+h-ls,x,y+h,1)
                  gfx.line(x,y+h,x+ls,y+h,1)
                  
                end
              end
                            
              gfx.a = 1
              f_Get_SSV(gui.color.yellow)
              gfx.roundrect(selrect_sc.x - surface_offset.x + obj.sections[10].x, selrect_sc.y - surface_offset.y + obj.sections[10].y, selrect_sc.w, selrect_sc.h, 8, 1, 0)
            end
          end
                    
          gfx.blit(1001,1,0,0,0,obj.sections[43].w,obj.sections[43].h,0,0)
          
          if lasso ~= nil then
            gfx.a = 0.2
            f_Get_SSV(gui.color.blue)
            local l = {l = lasso.l, r = lasso.r, t = lasso.t, b = lasso.b}
            if lasso.r < lasso.l then
              l.l = lasso.r
              l.r = lasso.l
            end
            if lasso.b < lasso.t then
              l.b = lasso.t
              l.t = lasso.b          
            end
            gfx.rect(l.l,
                     l.t, 
                     l.r-l.l,
                     l.b-l.t, 1, 1)
          end
          
          if update_gfx or update_surface or lasso ~= nil then
            if lockh > 0 or lockw > 0 or surface_size.exceed == true then
              UpdateLEdges()
            end
          end
                    
          if show_ctloptions and ctl_select ~= nil then
            
            local w,h = gfx.getimgdim(1021)
            gfx.a = 0.5
            gfx.blit(1021,1,0,0,0,w,h,obj.sections[60].x,obj.sections[60].y)
            --GUI_DrawCtlOptions(obj, gui)

            gfx.a = 1
            local w,h = gfx.getimgdim(1011)
            gfx.blit(1011,1,0,0,0,w,h,obj.sections[45].x,obj.sections[45].y)
            
            if show_cycleoptions then
              GUI_DrawCycleOptions(obj, gui)
            end            
          end
          
          if show_paramlearn and fxmode == 0 then
            GUI_DrawParamLearn(obj,gui)
          end        

          if dragparam ~= nil then
            if reass_param == nil then
              local x, y = dragparam.x, dragparam.y
              gfx.a = 0.7
              local iidx,w,h,bc 
              if dragparam.type == 'reassplugin' then
                iidx = 998
                w,h = gfx.getimgdim(iidx)
                if w == 0 or h == 0 then
                  w, h = ksel_size.w*2, ksel_size.h*2
                end
                bc = '160 160 160'
                gfx.a=0.6
                f_Get_SSV(gui.color.black)
                gfx.rect(x,y,w,h,1)
                local xywh = {x=x+w/2,y=y+h/2-butt_h,w=1,h=1}
                GUI_textC(gui,xywh,'Reassign Plugin',bc,-2)
                xywh.y = xywh.y + butt_h
                GUI_textC(gui,xywh,CropFXName(trackfx[trackfx_select].name),bc,-4)                
              else
                iidx = ctl_files[knob_select].imageidx
                if iidx == nil or ksel_loaded == false then
                  ksel_loaded = true
                  gfx.loadimg(1023, controls_path..ctl_files[knob_select].fn)
                  iidx = 1023
                elseif iidx == nil then
                  iidx = 1023
                end
                w, _ = gfx.getimgdim(iidx)
                h = ctl_files[knob_select].cellh
                bc = gui.color.yellow
              end
              gfx.blit(iidx,scale_select,0,0,p*h,w,ctl_files[knob_select].cellh,x+ w/2-w*scale_select/2,y+ h/2-h*scale_select/2 )
              f_Get_SSV(bc)
              gfx.a = 1
              gfx.roundrect(x, y ,w, h, 8, 1, 0)
            else
              local x, y = dragparam.x, dragparam.y
              local iidx,w,h,bc 
              if dragparam.type == 'reassplugin' then              
                iidx = 998
                w,h = gfx.getimgdim(iidx)
                if w == 0 or h == 0 then
                  w, h = ksel_size.w*2, ksel_size.h*2
                end              
                bc = dragparam.bc
                gfx.a=0.6
                f_Get_SSV(gui.color.black)
                gfx.rect(x,y,w,h,1)
                local xywh = {x=x+w/2,y=y+h/2-butt_h,w=1,h=1}
                GUI_textC(gui,xywh,'Reassign Plugin',bc,-2)
                xywh.y = xywh.y + butt_h
                GUI_textC(gui,xywh,CropFXName(trackfx[trackfx_select].name),bc,-4)                
              else
                local iidx = ctl_files[knob_select].imageidx
                if iidx == nil or ksel_loaded == false then
                  ksel_loaded = true
                  gfx.loadimg(1023, controls_path..ctl_files[knob_select].fn)
                  iidx = 1023
                elseif iidx == nil then
                  iidx = 1023
                end
                w, _ = gfx.getimgdim(iidx)
                h = ctl_files[knob_select].cellh
                bc = gui.color.red
              end
              f_Get_SSV(bc)
              gfx.a = 1
              gfx.roundrect(x, y ,w, h, 8, 1, 0)              
            end
          end        
        
          if show_actionchooser then
            GUI_DrawActionChooser(obj, gui)
          end
        
          if show_ctlbrowser then
            GUI_DrawCtlBrowser(obj, gui)          
          end
          
          if show_gaugeedit == true then
            GUI_DrawGaugeEdit(obj, gu)
          end
          
        elseif submode == 1 then
        
          if update_gfx or (surface_size.limit == false and update_surface) or update_bg then
            GUI_DrawControlBackG(obj, gui)
            GUI_DrawControls(obj, gui)
          elseif update_ctls then        
            GUI_DrawControls(obj, gui)
          end
                    
          if update_gfx or update_sidebar or resize_display then        
            --GUI_DrawGraphicsChooser(obj, gui)
            GUI_DrawSidebar(obj, gui)
          end
          
          gfx.dest = 1
          gfx.a = 1
          gfx.blit(1000,1,0,surface_offset.x,
                            surface_offset.y,
                            obj.sections[10].w,
                            obj.sections[10].h,
                            obj.sections[10].x,
                            obj.sections[10].y)
          
          --gfx.blit(1001,1,0,0,0,obj.sections[43].w,obj.sections[43].h,0,butt_h)

          if update_gfx or update_surface then
            if lockh > 0 or lockw > 0 or surface_size.exceed == true then
              UpdateLEdges()
            end
          end

          if draggfx ~= nil then
            local x, y = draggfx.x, draggfx.y
            local w, h = gfx.getimgdim(1023)
            gfx.a = 0.5
            
            gfx.blit(1023,1,0,0,0,w,h,x,y)          
          end

          if gfx2_select ~= nil then
          
            selrect = CalcGFXSelRect()
            if selrect then
              if draggfx2 ~= nil then 
                local x, y = selrect.x - surface_offset.x + obj.sections[10].x+4, selrect.y - surface_offset.y + obj.sections[10].y+4
                local w, h = gfx.getimgdim(1022)
                gfx.a = 1
                gfx.blit(1022,1,0,0,0,w,h,x,y) 
              end

              if poslock_select == true then
                f_Get_SSV(gui.color.red)
              else
                f_Get_SSV(gui.color.yellow)
              end
              gfx.a = 1
              selrect.x = selrect.x - surface_offset.x + obj.sections[10].x
              selrect.y = selrect.y - surface_offset.y + obj.sections[10].y
              
              gfx.roundrect(selrect.x, selrect.y, selrect.w, selrect.h, 8, 1, 0)
              if show_lbloptions == false then
                gfx.circle(selrect.x+selrect.w,selrect.y+selrect.h/2,4,1,1)
                gfx.circle(selrect.x+selrect.w,selrect.y+selrect.h,4,1,1)
                gfx.circle(selrect.x+selrect.w/2,selrect.y+selrect.h,4,1,1)              
              end
            end            
          
          end
          gfx.blit(1001,1,0,0,0,obj.sections[43].w,obj.sections[43].h,0,0)

          if show_lbloptions and gfx2_select ~= nil then            
            GUI_DrawLblOptions(obj, gui)
          end

          if show_gfxoptions and gfx2_select ~= nil then            
            GUI_DrawGFXOptions(obj, gui)
          end

          if gfx_select ~= nil then
            local w,h = gfx.getimgdim(1021)
            gfx.a = 0.5
            gfx.blit(1021,1,0,0,0,w,h,obj.sections[60].x,obj.sections[60].y)           
          end
                  
        elseif submode == 2 then

          if update_gfx or (surface_size.limit == false and update_surface) or update_bg then
            GUI_DrawControlBackG(obj, gui)
            GUI_DrawControls(obj, gui)
          elseif update_ctls then        
            GUI_DrawControls(obj, gui)
          end
          --GUI_DrawStripChooser(obj, gui)
          GUI_DrawSidebar(obj, gui)
          
          gfx.dest = 1
          gfx.a = 1
          gfx.blit(1000,1,0,surface_offset.x,
                            surface_offset.y,
                            obj.sections[10].w,
                            obj.sections[10].h,
                            obj.sections[10].x,
                            obj.sections[10].y)
          --gfx.blit(1001,1,0,0,0,obj.sections[43].w,obj.sections[43].h,0,butt_h)          

          if update_gfx or update_surface then
            if lockh > 0 or lockw > 0 or surface_size.exceed == true then
              UpdateLEdges()
            end
          end
                    
          if dragstrip ~= nil then
            local x, y = dragstrip.x, dragstrip.y
            local w, h = gfx.getimgdim(1022)
            gfx.a = 0.5
            
            gfx.blit(1022,1,0,0,0,w,h,x,y)          
          end

          if ctl_select ~= nil then
            selrect = CalcSelRect()
            if dragctl ~= nil then 
              local x, y = selrect.x - surface_offset.x + obj.sections[10].x -b_sz, selrect.y - surface_offset.y + obj.sections[10].y-b_sz
              local w, h = gfx.getimgdim(1022)
              gfx.a = 1
              
              gfx.blit(1022,1,0,0,0,w,h,x,y) 

            end
            
            if newgrp ~= nil then
              local cx = newgrp.switchid         
              local x = strips[tracks[track_select].strip][page].controls[cx].x+1
              local y = strips[tracks[track_select].strip][page].controls[cx].y+1
              local w = strips[tracks[track_select].strip][page].controls[cx].w-2
              local h = strips[tracks[track_select].strip][page].controls[cx].ctl_info.cellh-2
              
              gfx.a = 0.5
              f_Get_SSV(gui.color.red)
              gfx.rect(x - surface_offset.x + obj.sections[10].x, y - surface_offset.y + obj.sections[10].y, w, h, 1, 1)            
            end
            
            if selrect then
              f_Get_SSV(gui.color.yellow)
              gfx.a = 1
              gfx.roundrect(selrect.x - surface_offset.x+obj.sections[10].x, selrect.y - surface_offset.y + obj.sections[10].y, selrect.w, selrect.h, 8, 1, 0)
            end
          end

          gfx.blit(1001,1,0,0,0,obj.sections[43].w,obj.sections[43].h,0,0)          

          gfx.a=1
          --[[f_Get_SSV(gui.color.white)
          gfx.rect(obj.sections[511].x,
                   obj.sections[511].y, 
                   obj.sections[511].w,
                   obj.sections[511].h, 1, 1)
          GUI_textC(gui,obj.sections[511],'SAVE STRIP',gui.color.black,-2)  ]]      

          if ctl_select ~= nil then
            --gfx.dest = 1
            local w,h = gfx.getimgdim(1021)
            gfx.a = 0.5
            gfx.blit(1021,1,0,0,0,w,h,obj.sections[60].x,obj.sections[60].y)          
          end
        
        end

        --[[if surface_size.exceed == true then
          if update_gfx or update_surface then
            f_Get_SSV(gui.color.red)            
            gfx.rect(obj.sections[10].x,obj.sections[10].y,obj.sections[10].w+1,obj.sections[10].h+1,0)
          end        
        end]]

      end
      
      local xywh = {x = obj.sections[43].w-2,
                    y = obj.sections[43].y,
                    w = 1,
                    h = obj.sections[43].h}
      f_Get_SSV(gui.color.cbobg2)
      gfx.a = 1 
      gfx.rect(xywh.x,
               xywh.y, 
               xywh.w,
               xywh.h, 1 )
      f_Get_SSV(gui.color.black)
      gfx.line(obj.sections[43].w-1,0,obj.sections[43].w-1,gfx1.main_h)
    
      
--[[      if resize_display or update_gfx then
        gfx.setimgdim(999,-1,-1)
        gfx.setimgdim(999,gfx1.main_w-plist_w, butt_h)         
      end]]
      if resize_display or update_gfx or update_topbar then
        gfx.setimgdim(999,-1,-1)
        gfx.setimgdim(999,gfx1.main_w-plist_w, butt_h+1)         
        GUI_DrawTopBar(gui,obj)
      end
      gfx.dest=1
      if hide_topbar == false or settings_showminimaltopbar == true then
        gfx.a = 1
        if topbarheight == 0 then
          if show_eqcontrol ~= true and macro_edit_mode ~= true then
            gfx.blit(1,1,0,plist_w,--surface_offset.x,
                              0,--surface_offset.y,
                              obj.sections[18].w,
                              obj.sections[18].h,
                              obj.sections[18].x+plist_w,
                              obj.sections[18].y)
            gfx.blit(1,1,0,(obj.sections[21].x+plist_w),--surface_offset.x+(obj.sections[21].x+plist_w-obj.sections[10].x),
                              0,--surface_offset.y+(obj.sections[21].y-obj.sections[10].y),
                              obj.sections[21].w,
                              obj.sections[21].h,
                              obj.sections[21].x+plist_w,
                              obj.sections[21].y)
          end
        end
        local w,h = gfx.getimgdim(999)
        gfx.blit(999,1,0,0,0,w,h,plist_w,0)                
      end
      
      --if update_surfaceedge then
      --  UpdateEdges()
      --end
      
      if settings_showbars and (update_gfx or update_surface) then
        GUI_DrawBars(gui, obj)
      end

      if show_settings then
        GUI_DrawSettings(gui, obj)
      end      
      
      --[[if lockw > 0 or lockh > 0 then
        UpdateLEdges()
      end]]
 
      --[[DBG('gfx'..tostring(update_gfx))
      DBG('surface'..tostring(update_surface))
      DBG('sidebar'..tostring(update_sidebar))
      DBG('topbar'..tostring(update_topbar))
      DBG('ctlopts'..tostring(update_ctlopts))
      DBG('ctls'..tostring(update_ctls))
      DBG('bg'..tostring(update_bg))
      DBG('settings'..tostring(update_settings))
      DBG('snaps'..tostring(update_snaps))
      DBG('msnaps'..tostring(update_msnaps))
      DBG('actcho'..tostring(update_actcho))
      DBG('fsnaps'..tostring(update_fsnaps))
      DBG('mfsnaps'..tostring(update_mfsnaps))
      DBG('eqcontrol'..tostring(update_eqcontrol))
      DBG('macroedit'..tostring(update_macroedit))
      DBG('macrobutt'..tostring(update_macrobutt))]]
   --DBG('*')
      --update_gfx or update_surface or update_sidebar or update_topbar or update_ctlopts or update_ctls or update_bg or 
       --update_settings or update_snaps or update_msnaps or update_actcho or update_fsnaps or update_mfsnaps or update_eqcontrol or update_macroedit or
       --update_macrobutt 
      if show_trackfxorder then
       --DBG('fghf')
        GUI_DrawTrackFXOrder(gui, obj)
       
      end
 
      if show_midiout then
        GUI_DrawMIDIOut(gui, obj)
      end
      
      if lbx_midilrnctl then
        GUI_DrawMIDILrn(gui, obj)
      end
      
    elseif show_xxy and (update_gfx or update_xxy or update_xxypos or update_surface or update_snaps or update_msnaps or resize_snaps or resize_display) then
    
      gfx.dest = 1
      if update_gfx or resize_display then
        gfx.setimgdim(1, -1, -1)  
        gfx.setimgdim(1, gfx1.main_w,gfx1.main_h)
      end
            
      if resize_display or resize_snaps then
        --gfx.setimgdim(1002,obj.sections[45].w, obj.sections[45].h)
        gfx.setimgdim(1003,obj.sections[160].w, obj.sections[160].h)
        gfx.setimgdim(1005,obj.sections[180].w, obj.sections[180].h)
        gfx.setimgdim(1006,obj.sections[221].w, obj.sections[221].h)
        gfx.setimgdim(1007,obj.sections[220].w, obj.sections[220].h)  
      end

      --Edges
      if update_gfx or update_xxypos then
        f_Get_SSV(gui.color.black)
        local xywh = {x = obj.sections[220].x,
                      y = 0, 
                      w = obj.sections[220].w,
                      h = obj.sections[220].y}
        gfx.rect(xywh.x,
                 xywh.y, 
                 xywh.w,
                 xywh.h, 1, 1)
        local xywh = {x = obj.sections[220].x,
                      y = obj.sections[220].y+obj.sections[220].h, 
                      w = obj.sections[220].w,
                      h = gfx1.main_h - (obj.sections[220].y+obj.sections[220].h)}
        gfx.rect(xywh.x,
                 xywh.y, 
                 xywh.w,
                 xywh.h, 1, 1)
        local xywh = {x = 0,
                      y = obj.sections[220].y, 
                      w = obj.sections[220].x,
                      h = obj.sections[220].y+obj.sections[220].h}
        gfx.rect(xywh.x,
                 xywh.y, 
                 xywh.w,
                 xywh.h, 1, 1)
        local xywh = {x = obj.sections[220].x+obj.sections[220].w,
                      y = obj.sections[220].y, 
                      w = obj.sections[221].x-(obj.sections[220].x+obj.sections[220].w),
                      h = obj.sections[220].y+obj.sections[220].h}
        gfx.rect(xywh.x,
                 xywh.y, 
                 xywh.w,
                 xywh.h, 1, 1)
        
        f_Get_SSV(gui.color.white)
        gfx.rect(obj.sections[230].x,
                 obj.sections[230].y, 
                 obj.sections[230].w,
                 obj.sections[230].h, 0, 1)
      end

      if update_gfx or resize_display then
        local xywh = {x = obj.sections[222].x,
                      y = obj.sections[222].y, 
                      w = obj.sections[222].w,
                      h = obj.sections[222].h}
        GUI_DrawBar(gui,'EXIT',xywh,skin.bar,true,gui.color.black,nil,-2)
        --GUI_textC(gui,xywh,'EXIT',c,-2)
  
      end

    
      if update_gfx or update_xxy or update_surface then
        GUI_DrawXXY(gui,obj)
      end

      if update_gfx or update_snaps or update_surface then
        GUI_DrawXXYSnaps(gui,obj)
      end
    
      gfx.blit(1006,1,0,0,0,obj.sections[221].w,obj.sections[221].h,obj.sections[221].x,obj.sections[221].y)        
      gfx.blit(1007,1,0,0,0,obj.sections[220].w,obj.sections[220].h,obj.sections[220].x,obj.sections[220].y)        
      
      GUI_DrawXXYSSLabels(gui,obj)
      
      --POS
      local strip = tracks[track_select].strip
      if xxy and xxy[strip] and xxy[strip][page] and xxy[strip][page][sstype_select] then
        local x,y = xxy[strip][page][sstype_select].x*obj.sections[220].w + obj.sections[220].x, xxy[strip][page][sstype_select].y*obj.sections[220].h + obj.sections[220].y
        f_Get_SSV(gui.color.yellow)
        gfx.line(x-16,y,x+16,y,1)
        gfx.line(x,y-16,x,y+16,1)    
      end      
      
      if dragsnap ~= nil then
      
        local ppw, pph = gfx.getimgdim(def_xytarget)
        gfx.blit(def_xytarget,1,0, 0, 0, ppw, pph, dragsnap.x-ppw/2, dragsnap.y-pph/2)
      
      end

      if show_midiout then
        GUI_DrawMIDIOut(gui, obj)
      end
      
    end    
    
    if show_dd == true then
      if update_gfx == true or update_dd == true then
        GUI_DrawDropdown(gui, obj)
      end
      --gfx.blit(1,1,0,ddlist.x,ddlist.y,ddlist.w+6,ddlist.h+6,ddlist.x,ddlist.y)
      --if update_surface or update_gfx or update_dd then
        gfx.blit(996,1,0,0,0,ddlist.w+2,ddlist.h+2,ddlist.x,ddlist.y)
      --end
    end
    
    if MS_Open > 0 then
      GUI_DrawMsg(gui, obj)
      
    elseif EB_Open > 0 then
      editbox_draw(gui, editbox)    
    
    end
    
    if show_midioutind and midimsg == true then
      f_Get_SSV(gui.color.red)
      gfx.rect(5,0,5,5,1,1)
      --f_Get_SSV(gui.color.black)
      --gfx.rect(6,6,8,8,0,1)
    end
    if touch_trigger == true then
      f_Get_SSV('0 0 255')
      gfx.rect(0,0,5,5,1)    
    end
    if touch_timer then
      f_Get_SSV('255 255 255')
      gfx.rect(0,0,5,5,1)
    end
    
    gfx.dest = -1
    gfx.a = 1
    gfx.blit(1, 1, 0, 
      0,0, gfx1.main_w,gfx1.main_h,
      0,0, gfx1.main_w,gfx1.main_h, 0,0)
      
    update_gfx = false
    update_surface = false
    update_surfaceedge = false
    update_sidebar = false
    update_topbar = false
    update_ctlopts = false
    resize_display = false
    update_ctls = false
    update_bg = false
    update_settings = false
    update_snaps = false
    update_msnaps = false
    update_fsnaps = false
    update_fmsnaps = false
    update_actcho = false
    resize_snaps = false
    resize_fsnaps = false
    update_xxy = false
    update_xxypos = false
    update_eqcontrol = false
    update_macrobutt = false
    update_trackfxorder = false
    update_dd = false
    
  end
  
  function DrawMD(gui, obj)
    gfx.dest = -1
    gfx.a = 1
    f_Get_SSV('0 0 255')
    gfx.rect(0,0,5,5,1)    
    gfx.update()
    gfx.dest = 1
  end
  
  function GUI_DrawXXYSnaps(gui, obj)
    gfx.dest = 1006
    
    gfx.a=1
    f_Get_SSV(gui.color.black)
    gfx.rect(0,
             0, 
             obj.sections[221].w,
             obj.sections[221].h, 1, 1)
    f_Get_SSV('64 64 64')
    gfx.rect(0,
             0, 
             obj.sections[221].w,
             obj.sections[221].h, 0, 1)
    
    xywh = {x = 0,
            y = 0,
            w = obj.sections[221].w,
            h = butt_h}
    
    GUI_DrawBar(gui,xxymode_table[xxymode+1],xywh,skin.bar,true,gui.color.black,nil,-2)
    
    --GUI_textC(gui,xywh,xxymode_table[xxymode+1],gui.color.black,-2)

    if xxymode == 0 then
      local sstypestr = 'PAGE'
      if sstype_select > 1 then
        if tracks[track_select] and tracks[track_select].strip and snapshots[tracks[track_select].strip] and 
           snapshots[tracks[track_select].strip][page][sstype_select] then
          sstypestr = snapshots[tracks[track_select].strip][page][sstype_select].subsetname
        else
          sstypestr = ''
        end
      end
        
      GUI_DrawButton(gui, sstypestr, obj.sections[226], gui.color.white, gui.color.black, true, '', false)
      GUI_DrawSliderH(gui, 'GRAVITY', obj.sections[225], gui.color.black, gui.color.white, ((xxy_gravity-1)/3))

      local strip = tracks[track_select].strip
      local xywh = {x = obj.sections[232].x,
                    y = obj.sections[232].y - obj.sections[232].h,
                    w = obj.sections[232].w,
                    h = obj.sections[232].h}
      GUI_textC(gui,xywh,'AUTOMATION',gui.color.white,-2)
      if xxy and xxy[strip] and xxy[strip][page][sstype_select] and xxy[strip][page][sstype_select].xfader then
        GUI_DrawButton(gui, 'FADER '..string.format('%i',xxy[strip][page][sstype_select].xfader), obj.sections[232], gui.color.white, gui.color.black, true, 'X', false)      
      else
        GUI_DrawButton(gui, 'NONE', obj.sections[232], -3, gui.color.black, false, 'X', false)
      end
      if xxy and xxy[strip] and xxy[strip][page][sstype_select] and xxy[strip][page][sstype_select].yfader then
        GUI_DrawButton(gui, 'FADER '..string.format('%i',xxy[strip][page][sstype_select].yfader), obj.sections[233], gui.color.white, gui.color.black, true, 'Y', false)      
      else
        GUI_DrawButton(gui, 'NONE', obj.sections[233], -3, gui.color.black, true, 'Y', false)
      end
      local txt = 'RECORD MODE OFF'
      local bt = -3
      if xxyrecord then
        txt = 'RECORD MODE ON'
        bt = -2
      end
      GUI_DrawButton(gui, txt, obj.sections[235], bt, gui.color.black, true, '', false)
      
      local bc, bc2 = gui.color.white, gui.color.white
      if sstype_select == 1 then
        bc = '64 64 64'
        bc2 = '64 64 64'
      elseif snaplrn_mode then
        bc = '255 0 0'
      end
      
      xywh = {x = obj.sections[223].x,
              y = obj.sections[223].y,
              w = obj.sections[223].w,
              h = obj.sections[223].h}
      f_Get_SSV('64 64 64')
      gfx.a = 1 
      gfx.rect(xywh.x,
               xywh.y, 
               xywh.w,
               xywh.h, 0 )
      
      
      xywh.h = butt_h
      GUI_DrawBar(gui,'',xywh,skin.barUD,true,gui.color.black,nil,-2)
      gfx.line(xywh.x+xywh.w/2,xywh.y,xywh.x+xywh.w/2,xywh.y+xywh.h)
      local w, h = gfx.getimgdim(skin.arrowup)
      gfx.blit(skin.arrowup,1,0,0,0,w,h,xywh.x+xywh.w/4-w/2,xywh.y+xywh.h/2-h/2)
      gfx.blit(skin.arrowdn,1,0,0,0,w,h,xywh.x+xywh.w*0.75-w/2,xywh.y+xywh.h/2-h/2)
      
      gfx.a = 1
      
      SSXXY_butt_cnt = math.floor(obj.sections[223].h / butt_h) - 1
      --if snaplrn_mode == false then
        
        local strip = tracks[track_select].strip
        if strip and snapshots and snapshots[strip] and snapshots[strip][page][sstype_select] then
  
          if sstype_select == 1 then
            if #snapshots[strip][page][sstype_select] > 0 then
              for i = 1,SSXXY_butt_cnt do
              
                xywh.y = obj.sections[223].y + i*butt_h
                local c = gui.color.white
                if ss_select == xxylist_offset+i then
                  f_Get_SSV(gui.color.white)
                  gfx.rect(xywh.x,
                   xywh.y, 
                   xywh.w,
                   xywh.h, 1 )
                  c = gui.color.black
                end
                if snapshots[strip][page][sstype_select][i+xxylist_offset] then
                  GUI_textsm_LJ(gui,xywh,roundX(i+xxylist_offset,0)..': '..snapshots[strip][page][sstype_select][i+xxylist_offset].name,c,-2,xywh.w)
                end
            
              end
          
            end
          elseif sstype_select > 1 then
            if #snapshots[strip][page][sstype_select].snapshot > 0 then
              for i = 1,SSXXY_butt_cnt do
              
                xywh.y = obj.sections[223].y + i*butt_h
                local c = gui.color.white
                if ss_select == xxylist_offset+i then
                  f_Get_SSV(gui.color.white)
                  gfx.rect(xywh.x,
                   xywh.y, 
                   xywh.w,
                   xywh.h, 1 )
                  c = gui.color.black
                end
                if snapshots[strip][page][sstype_select].snapshot[i+xxylist_offset] then
                  GUI_textsm_LJ(gui,xywh,roundX(i+xxylist_offset,0)..': '..snapshots[strip][page][sstype_select].snapshot[i+xxylist_offset].name,c,-2,xywh.w)
                end
            
              end
          
            end
          
          end
  
        end
      
    elseif xxymode == 1 then

      GUI_DrawButton(gui, 'EDIT', obj.sections[227], gui.color.white, gui.color.black, xxypath_edit, '', false)
      GUI_DrawButton(gui, 'SAVE META PATH', obj.sections[228], gui.color.white, gui.color.black, true, '', false)
      GUI_DrawButton(gui, 'LOAD META PATH', obj.sections[229], gui.color.white, gui.color.black, true, '', false)
      
      local strip = tracks[track_select].strip
      local xywh = {x = obj.sections[231].x,
                    y = obj.sections[231].y - obj.sections[231].h,
                    w = obj.sections[231].w,
                    h = obj.sections[231].h}
      GUI_textC(gui,xywh,'AUTOMATION',gui.color.white,-2)
      if xxy and xxy[strip] and xxy[strip][page][sstype_select] and xxy[strip][page][sstype_select].pathfader then
        GUI_DrawButton(gui, 'FADER '..string.format('%i',xxy[strip][page][sstype_select].pathfader), obj.sections[231], gui.color.white, gui.color.black, true, '', false)      
      else
        GUI_DrawButton(gui, 'NONE', obj.sections[231], -3, gui.color.black, false, '', false)
      end
      local txt = 'RECORD MODE OFF'
      if xxyrecord then
        txt = 'RECORD MODE ON'
      end
      GUI_DrawButton(gui, txt, obj.sections[235], gui.color.white, gui.color.black, xxyrecord, '', false)
      
    end    
    
    gfx.dest = 1    

  end
    
  function GUI_DrawXXYSSLabels(gui, obj)
  
    gfx.dest = 1
    gfx.a=1
    
    local strip = tracks[track_select].strip
    if xxy and xxy[strip] and xxy[strip][page] and xxy[strip][page][sstype_select] then
      if #xxy[strip][page][sstype_select].points > 0 then
        for p = 1, #xxy[strip][page][sstype_select].points do
          local x,y = xxy[strip][page][sstype_select].points[p].x, xxy[strip][page][sstype_select].points[p].y
          x = obj.sections[220].x + x*obj.sections[220].w 
          y = obj.sections[220].y + y*obj.sections[220].h 
          local xywh = {x = x, y = y-butt_h, w = 1, h = 1}
          local sstxt = snapshots[strip][page][sstype_select].snapshot[xxy[strip][page][sstype_select].points[p].ss].name
          local c = gui.color.white
          local dist = xxy[strip][page][sstype_select].points[p].distance
          local dfnd = false
          if dist then
            local gx = 0
            if tostring(dist) == tostring(xxy_mindist) then
              gx = F_limit((192-dist*1000),0,255)
              dfnd = true
            end
            dist = (dist^(1/(xxy_gravity)))^(5-xxy_gravity)
            local rx = F_limit(255-(dist*800),0,255)
            local bx = F_limit((dist*1000),0,255)
            c = rx..' '..gx..' '..bx            
          end
          local alpha = 1
          if xxy[strip][page][sstype_select].points[p].inactive == true then
            alpha = 0.2
            c = '128 128 128'
          end
          --f_Get_SSV(gui.color.black)
          --gfx.rect(xywh.x,xywh.y,xywh.w,xywh.h,1)          
          GUI_textC(gui,xywh,sstxt,c,-2,alpha)
        end
      end
    end
    gfx.a = 1  
  end

  function GUI_DrawXXY(gui, obj)
  
    gfx.dest = 1007
    gfx.a=1
    
    --gfx.a=0.5
    f_Get_SSV(gui.color.black)
    gfx.rect(0,
             0, 
             obj.sections[220].w,
             obj.sections[220].h, 1, 1)

    --gfx.a=1
    f_Get_SSV(gui.color.white)
    gfx.rect(0,
             0, 
             obj.sections[220].w,
             obj.sections[220].h, 0, 1)
    
    local ppw, pph = gfx.getimgdim(def_xytarget)
    
    local strip = tracks[track_select].strip
    if xxy and xxy[strip] and xxy[strip][page] and xxy[strip][page][sstype_select] then
      if #xxy[strip][page][sstype_select].points > 0 then
        for p = 1, #xxy[strip][page][sstype_select].points do
          local x,y = xxy[strip][page][sstype_select].points[p].x, xxy[strip][page][sstype_select].points[p].y
          x = x*obj.sections[220].w 
          y = y*obj.sections[220].h
          if xxy[strip][page][sstype_select].points[p].inactive == true then
            gfx.a = 0.2
          else
            gfx.a = 1
          end
          gfx.blit(def_xytarget,1,0, 0, 0, ppw, pph, x-ppw/2, y-pph/2)
        end
      end
    end
    gfx.a = 1
    --if xxymode == 1 then
    
      if xxypath[xxypath_select] then
        local pcnt = #xxypath[xxypath_select].points
        if pcnt > 1 then
      
          --yyy
          for p = 1, pcnt-1 do
            draw_curve(xxypath[xxypath_select].points[p].x, xxypath[xxypath_select].points[p].y, p, pcnt-1)
          end
          
        elseif pcnt == 1 then
      
          draw_curve(xxypath[xxypath_select].points[pcnt].x, xxypath[xxypath_select].points[pcnt].y, p, 1)        
      
        end

      end
    --end

    gfx.dest = 1      
      
  end

  function GUI_DrawTopBarMin(gui, obj)

    if not settings_showminimaltopbar then return end

    local xywh = {x = obj.sections[18].x,
                  y = obj.sections[18].y,
                  w = obj.sections[18].w,
                  h = obj.sections[18].h}
    gfx.a = 0.6
    if mode == 0 then
      if show_editbar then
        GUI_DrawBar(gui,'<',obj.sections[18],skin.bar,true,gui.color.black,nil,-2)
      else
        GUI_DrawBar(gui,'>',obj.sections[18],skin.bar,true,gui.color.black,nil,-2)      
      end
    else
      GUI_DrawBar(gui,'<>',obj.sections[18],skin.bar,true,gui.color.black,nil,-2)
    end
    gfx.line(obj.sections[18].x+obj.sections[18].w,obj.sections[18].y,obj.sections[18].x+obj.sections[18].w,obj.sections[18].y+obj.sections[18].h-1)
    gfx.line(obj.sections[18].x,obj.sections[18].y+obj.sections[18].h-1,obj.sections[18].x+obj.sections[18].w,obj.sections[18].y+obj.sections[18].h-1)
    
    if show_eqcontrol ~= true and macro_edit_mode ~= true then
      gfx.a = 0.6
      GUI_DrawBar(gui,'...',obj.sections[21],skin.bar,true,gui.color.black,nil,-2)
      gfx.line(obj.sections[21].x-1,obj.sections[21].y,obj.sections[21].x-1,obj.sections[21].y+obj.sections[21].h-1)
      gfx.line(obj.sections[21].x,obj.sections[21].y+obj.sections[21].h-1,obj.sections[21].x+obj.sections[21].w,obj.sections[21].y+obj.sections[21].h-1)
    end
    gfx.dest = 1
  end
    
  function GUI_DrawTopBar(gui, obj)

    gfx.dest = 999
    if topbarheight == 0 then GUI_DrawTopBarMin(gui, obj) return end
  
    gfx.a=1
    f_Get_SSV(gui.color.black)
    local w, h = gfx.getimgdim(999)
    gfx.rect(0,0,w,h,1)

    local xywh = {x = obj.sections[18].x,
                  y = obj.sections[18].y,
                  w = obj.sections[18].w,
                  h = obj.sections[18].h}
    GUI_DrawBar(gui,'',obj.sections[12],skin.bar,true,gui.color.black,nil,-2)
    
    if xywh.w > 0 then
      GUI_DrawBar(gui,'',xywh,skin.bar,true,gui.color.black,nil,-2)
    end
    if mode == 0 then
      if show_editbar then
        GUI_DrawBar(gui,'<',obj.sections[18],skin.bar,true,gui.color.black,nil,-2)
      else
        GUI_DrawBar(gui,'>',obj.sections[18],skin.bar,true,gui.color.black,nil,-2)      
      end
    else
      GUI_DrawBar(gui,'<>',obj.sections[18],skin.bar,true,gui.color.black,nil,-2)
    end    
    
    local t
    if c == gui.color.black then
      f_Get_SSV(gui.color.black)
      gfx.rect(obj.sections[20].x,obj.sections[20].y,obj.sections[20].w,obj.sections[20].h,1)
    end              
    for i = 0, 3 do
      local xywh = {x = obj.sections[20].x + i*(obj.sections[20].w/4),
                    y = obj.sections[20].y, 
                    w = obj.sections[20].w/4-1,
                    h = obj.sections[20].h}
      if i == 0 and lockx == false then 
        GUI_DrawBar(gui,'',xywh,skin.bar,true,gui.color.black,nil,-2)
        f_Get_SSV(gui.color.white)
        c = gui.color.black
        t = 'X'
      elseif i == 0 then
        f_Get_SSV(gui.color.black)
        c = gui.color.white
        t = 'X'
      elseif i == 1 and locky == false then         
        GUI_DrawBar(gui,'',xywh,skin.bar,true,gui.color.black,nil,-2)
        f_Get_SSV(gui.color.white)
        c = gui.color.black
        t = 'Y'
      elseif i == 1 then
        f_Get_SSV(gui.color.black)
        c = gui.color.white
        t = 'Y'
      elseif i == 2 then
        GUI_DrawBar(gui,'',xywh,skin.bar,true,gui.color.black,nil,-2)
        f_Get_SSV(gui.color.white)
        c = gui.color.black
        t = ''
      elseif i == 3 then
        GUI_DrawBar(gui,'',xywh,skin.bar,true,gui.color.black,nil,-2)
        f_Get_SSV(gui.color.white)
        c = gui.color.black        
        t = ''
      end

      GUI_textC(gui,xywh,t,c,-2)
      if i == 2 then
        gfx.triangle(xywh.x+xywh.w/2,xywh.y+6,xywh.x+xywh.w/2-4,xywh.y+xywh.h-6,xywh.x+xywh.w/2+4,xywh.y+xywh.h-6,1)
      elseif i == 3 then
        gfx.triangle(xywh.x+xywh.w/2,xywh.y+xywh.h-6,xywh.x+xywh.w/2-4,xywh.y+6,xywh.x+xywh.w/2+4,xywh.y+6,1)
      end
    end      
    
    if obj.sections[12].w > 0 then
      if infomsg ~= nil then
        GUI_textC_LIM(gui,obj.sections[12],infomsg,gui.color.black,-2)
        infomsg = nil        
      elseif tracks and tracks[track_select] then
        local trn = tracks[track_select].name
        if trn == LBX_GTRACK_NAME then
          trn = '[LBX GLOBAL]'
        elseif trn == LBX_CTL_TRNAME then
          trn = '[LBX CTL]'
        elseif trn == '' then
          trn = '[unnamed track]'
        end
        GUI_textC_LIM(gui,obj.sections[12],GetProjectName()..' - '..STRIPSET..' - TRACK: ' .. tracks[track_select].tracknum+1 .. ' - '.. trn,gui.color.black,-2)
      end
    end  

    local xywh = {x = obj.sections[21].x-1,
                  y = obj.sections[1000].y, 
                  w = obj.sections[21].w+obj.sections[1000].w+obj.sections[14].w,
                  h = obj.sections[1000].h}
    f_Get_SSV(gui.color.black)
    gfx.rect(xywh.x,
             xywh.y, 
             xywh.w,
             xywh.h, 1, 1)                  

    GUI_DrawBar(gui,'...',obj.sections[21],skin.bar,true,gui.color.black,nil,-2)
    if obj.sections[17].x > obj.sections[20].x+obj.sections[20].w then
      local sb = skin.bar
      if g_savedirty then
        sb = skin.barR
      else
      end
      GUI_DrawBar(gui,'SAVE',obj.sections[17],sb,true,gui.color.black,nil,-2)
      f_Get_SSV(gui.color.black)
      gfx.line(obj.sections[17].x,obj.sections[17].y,obj.sections[17].x,obj.sections[17].y+obj.sections[17].h)
    else
    end

    local gflag = false
    local c
    local xywh = {x = obj.sections[1000].x+2,
                  y = obj.sections[1000].y, 
                  w = obj.sections[1000].w-1,
                  h = obj.sections[1000].h}
    if gpage == true or track_select == LBX_GTRACK then
      f_Get_SSV(gui.color.white)
      GUI_DrawBar(gui,'GLOBAL',xywh,skin.barR,true,gui.color.black,nil,-5)
      gflag = true                 
    else
      c = gui.color.white
      GUI_textC(gui,xywh,'GLOBAL',c,-5)    
    end
    for i = 0, 3 do
      local xywh = {x = obj.sections[14].x+2 + i*(obj.sections[14].w/4),
                    y = obj.sections[14].y, 
                    w = obj.sections[14].w/4-2,
                    h = obj.sections[14].h}
      if gpage == false and page == i+1 and gflag == false then
        f_Get_SSV(gui.color.white)
        GUI_DrawBar(gui,i+1,xywh,skin.bar,true,gui.color.black,nil,-2)
        
      else
        f_Get_SSV(gui.color.black)
        c = gui.color.white
        --[[gfx.rect(xywh.x,
                 xywh.y, 
                 xywh.w,
                 xywh.h, 1, 1)]]
        GUI_textC(gui,xywh,i+1,c,-2)
      end
    end
      
  end
  
  function GUI_DrawBars(gui, obj)
  
    local ww = gfx1.main_w - (plist_w)
    local bw = F_limit((obj.sections[10].w / surface_size.w),0,1)*(ww-4)
    local bx = F_limit(F_limit(((surface_offset.x) / surface_size.w),0,1)*(ww-4),0,ww-4-bw)

    local hh = gfx1.main_h - (topbarheight+2)
    local bh = F_limit((obj.sections[10].h / surface_size.h),0,1)*(hh-4)
    local by = F_limit(F_limit(((surface_offset.y) / surface_size.h),0,1)*(hh-4),0,hh-4-bh)

    local xywh = {x = obj.sections[10].x,
                  y = obj.sections[10].y,
                  w = ww,
                  h = sb_size+2}
    f_Get_SSV(gui.color.black)
    gfx.a = 1  
    gfx.rect(xywh.x,
             xywh.y, 
             xywh.w,
             xywh.h, 1 )

    local xywh = {x = (obj.sections[10].x),
                  y = (obj.sections[10].y),
                  w = sb_size+4,
                  h = hh}
    f_Get_SSV(gui.color.black)
    gfx.a = 1
    gfx.rect(xywh.x,
             xywh.y, 
             xywh.w,
             xywh.h, 1 )

    local xywh = {x = obj.sections[10].x+obj.sections[10].w,
                      y = obj.sections[10].y,
                      w = 5,
                      h = hh}
    gfx.a = 1
    gfx.rect(xywh.x,
             xywh.y, 
             xywh.w,
             xywh.h, 1 )

    local xywh = {x = obj.sections[10].x,
                      y = obj.sections[10].y+obj.sections[10].h,
                      w = ww,
                      h = 5}
    gfx.a = 1
    gfx.rect(xywh.x,
             xywh.y, 
             xywh.w,
             xywh.h, 1 )
                      
                      

    local xywh = {x = (obj.sections[10].x+2)+2 +bx,
                  y = obj.sections[10].y,
                  w = bw,
                  h = sb_size}
    f_Get_SSV(gui.color.white)
    gfx.a = 1
    gfx.rect(xywh.x,
             xywh.y, 
             xywh.w,
             xywh.h, 1 )

    local xywh = {x = (obj.sections[10].x+2),
                  y = (obj.sections[10].y+2) + by,
                  w = sb_size,
                  h = bh}
    f_Get_SSV(gui.color.white)
    gfx.a = 1
    gfx.rect(xywh.x,
             xywh.y, 
             xywh.w,
             xywh.h, 1 )
    gfx.dest = 1
    
  end
  
  function GUI_DrawSettings(gui, obj)
  
    f_Get_SSV('0 0 0')
    gfx.a = 1 
    gfx.rect(obj.sections[70].x,
             obj.sections[70].y, 
             obj.sections[70].w,
             obj.sections[70].h, 1)
    f_Get_SSV(gui.color.white)
    gfx.rect(obj.sections[70].x,
             obj.sections[70].y, 
             obj.sections[70].w,
             obj.sections[70].h, 0)

    GUI_DrawTick(gui, 'Follow selected track', obj.sections[71], gui.color.white, settings_followselectedtrack)             
    GUI_DrawTick(gui, 'Disable send checks', obj.sections[72], gui.color.white, settings_disablesendchecks)             
    GUI_DrawTick(gui, 'Save all track fx with strip', obj.sections[73], gui.color.white, settings_saveallfxinststrip)
    GUI_DrawSliderH(gui, 'Control refresh rate', obj.sections[74], gui.color.black, gui.color.white, (1-(settings_updatefreq*10)))
    GUI_DrawTick(gui, 'Lock control window width', obj.sections[75], gui.color.white, lockx)
    GUI_DrawTick(gui, 'Lock control window height', obj.sections[76], gui.color.white, locky)
    GUI_DrawButton(gui, lockw, obj.sections[77], -3, gui.color.black, lockx)
    GUI_DrawButton(gui, lockh, obj.sections[78], -3, gui.color.black, locky)
    
    GUI_DrawTick(gui, 'Show grid / grid size', obj.sections[80], gui.color.white, settings_showgrid)
    GUI_DrawButton(gui, settings_gridsize, obj.sections[79], gui.color.white, gui.color.black, true)
    GUI_DrawTick(gui, 'Can mousewheel on knob', obj.sections[81], gui.color.white, settings_mousewheelknob)
    GUI_DrawTick(gui, 'Swap ctrl click and dbl click actions', obj.sections[82], gui.color.white, settings_swapctrlclick)
    GUI_DrawTick(gui, 'Insert default strip on every track', obj.sections[83], gui.color.white, settings_insertdefaultoneverytrack)
    GUI_DrawTick(gui, '...and on every page', obj.sections[84], gui.color.white, settings_insertdefaultoneverypage)
    GUI_DrawTick(gui, 'Display scroll bars', obj.sections[85], gui.color.white, settings_showbars)
    GUI_DrawColorBox(gui, 'Snapshot list background colour', obj.sections[86], gui.color.white, settings_snaplistbgcol)
    GUI_DrawTick(gui, 'Save script data in project folder', obj.sections[87], gui.color.white, settings_savedatainprojectfolder)
    GUI_DrawTick(gui, 'Use bitmap mask control detection', obj.sections[88], gui.color.white, settings_usectlbitmap)
    GUI_DrawTick(gui, 'Show minimal top bar when hidden', obj.sections[89], gui.color.white, settings_showminimaltopbar)
    GUI_DrawTick(gui, 'Hide edit bar on new projects', obj.sections[96], gui.color.white, settings_hideeditbaronnewproject)
    GUI_DrawTick(gui, 'Lock surface on new projects', obj.sections[97], gui.color.white, settings_locksurfaceonnewproject)
    GUI_DrawTick(gui, 'Create backup when manually saving', obj.sections[98], gui.color.white, settings_createbackuponmanualsave)
    
    GUI_DrawButton(gui, nz(save_subfolder,''), obj.sections[95], gui.color.white, gui.color.white, false, 'Save subfolder', true)  

    --column2
    
    local abs, rel = GetMOFaders()
    if abs then
      GUI_DrawButton(gui, 'FADER '..abs, obj.sections[700], gui.color.white, gui.color.black, true, 'Global mouseover fader (absolute)')
    else
      GUI_DrawButton(gui, 'NO FADER', obj.sections[700], gui.color.white, gui.color.black, false, 'Global mouseover fader (absolute)')    
    end
    --[[if rel then
      GUI_DrawButton(gui, 'FADER '..rel, obj.sections[701], gui.color.white, gui.color.black, true, 'Global mouseover fader (relative)')
    else
      GUI_DrawButton(gui, 'NO FADER', obj.sections[701], gui.color.white, gui.color.black, false, 'Global mouseover fader (relative)')    
    end]]

    GUI_DrawColorBox(gui, 'Main background colour', obj.sections[702], gui.color.white, backcol)
    local sb = false
    local sbt = 'NOT SET'
    if neb_scanboot_tab then
      sb = true
      sbt = 'SET'
    end
    GUI_DrawButton(gui, sbt, obj.sections[703], gui.color.white, gui.color.black, sb, 'Nebula scanboot location')
    GUI_DrawTick(gui, 'Touch feedback indicator', obj.sections[704], gui.color.white, settings_touchFB)
    GUI_DrawTick(gui, 'Send MIDI feedback on track change', obj.sections[705], gui.color.white, settings_trackchangemidi)
    
  end
  
  function GetMOFaders()
    local abs, rel
    if LBX_CTL_TRACK then    

      for i = 1, LBX_FB_CNT*LBX_CTL_TRACK_INF.count do
        if faders[i].targettype == 3 then
          if faders[i].mode == 0 then
            abs = i
          else
            rel = i        
          end
        end
      end

    end
    return abs, rel  
  end
  
  function UpdateLEdges()

    f_Get_SSV('0 0 0')
    if lockw > 0 or surface_size.exceed == true then

      local xx = plist_w
      
      if obj.sections[10].x > xx then
        local xywh = {x = xx,
                      y = topbarheight,
                      w = obj.sections[10].x - xx,
                      h = gfx1.main_h - topbarheight}
        gfx.a = 1 
        gfx.rect(xywh.x,
                 xywh.y, 
                 xywh.w,
                 xywh.h, 1 )
      end
      
      if obj.sections[10].x + obj.sections[10].w < gfx1.main_w then
        xx = obj.sections[10].x + obj.sections[10].w
        local xywh = {x = xx,
                      y = topbarheight,
                      w = gfx1.main_w - xx+1,
                      h = gfx1.main_h - topbarheight}
        gfx.a = 1 
        gfx.rect(xywh.x,
                 xywh.y, 
                 xywh.w,
                 xywh.h, 1 )
        
      end
    
    end
    if lockh > 0 or surface_size.exceed == true then
    
      local yy = obj.sections[10].y
      
      if yy > topbarheight then
        local xywh = {x = obj.sections[10].x,
                      y = topbarheight,
                      w = obj.sections[10].w,
                      h = obj.sections[10].y - topbarheight}
        gfx.a = 1 
        gfx.rect(xywh.x,
                 xywh.y, 
                 xywh.w,
                 xywh.h, 1 )
      end
      
      yy = obj.sections[10].y + obj.sections[10].h
      if yy < gfx1.main_h then  
        local xywh = {x = obj.sections[10].x,
                      y = yy,
                      w = obj.sections[10].w,
                      h = gfx1.main_h - yy}
        gfx.a = 1 
        gfx.rect(xywh.x,
                 xywh.y, 
                 xywh.w,
                 xywh.h, 1 )
        
      end
    
    end

    if mode == 1 and surface_size.exceed == true then
      if update_gfx or update_surface or lasso ~= nil then
        f_Get_SSV(gui.color.red)            
        gfx.rect(obj.sections[10].x,obj.sections[10].y,obj.sections[10].w+1,obj.sections[10].h+1,0)
      end        
    end
    
  end
  
  function UpdateEdges()
  
    local winw, winh = obj.sections[10].w , obj.sections[10].h
    
    f_Get_SSV('0 0 0')
    if surface_offset.x < 0 then
      local xywh = {x = obj.sections[10].x,
                    y = obj.sections[10].y,
                    w = -surface_offset.x-1,
                    h = winh}
      gfx.a = 1 
      gfx.rect(xywh.x,
               xywh.y, 
               xywh.w,
               xywh.h, 1 )
    end
    if surface_offset.y < 0 then
      local xywh = {x = obj.sections[10].x,
                    y = obj.sections[10].y,
                    w = winw,
                    h = -surface_offset.y-1}
      gfx.a = 1 
      gfx.rect(xywh.x,
               xywh.y, 
               xywh.w,
               xywh.h, 1 )
    end
    if surface_offset.x > surface_size.w-winw then
      local xywh = {x = obj.sections[10].x+winw-(surface_offset.x - (surface_size.w-winw))-1,
                    y = obj.sections[10].y,
                    w = surface_offset.x - (surface_size.w-winw),
                    h = winh}
      gfx.a = 1 
      gfx.rect(xywh.x,
               xywh.y, 
               xywh.w,
               xywh.h, 1 )    
    end
    if surface_offset.y > surface_size.h-winh then
      local xywh = {x = obj.sections[10].x,
                    y = obj.sections[10].y+winh-(surface_offset.y - (surface_size.h-winh))-1,
                    w = winw,
                    h = surface_offset.y - (surface_size.h-winh)}
      gfx.a = 1 
      gfx.rect(xywh.x,
               xywh.y, 
               xywh.w,
               xywh.h, 1 )    
    end
  
  end
  
  function GUI_DrawMsg(gui, obj)
  
    f_Get_SSV('0 0 0')
    gfx.a = 1 
    gfx.rect(obj.sections[61].x,
             obj.sections[61].y, 
             obj.sections[61].w,
             obj.sections[61].h, 1)
    f_Get_SSV(gui.color.white)
    gfx.rect(obj.sections[61].x,
             obj.sections[61].y, 
             obj.sections[61].w,
             obj.sections[61].h, 0)
    gfx.rect(obj.sections[62].x,
             obj.sections[62].y, 
             obj.sections[62].w,
             obj.sections[62].h, 1)
    if msgbox then
      if msgbox.b == 2 then
        f_Get_SSV(gui.color.white)
        gfx.rect(obj.sections[64].x,
                 obj.sections[64].y, 
                 obj.sections[64].w,
                 obj.sections[64].h, 1)
        GUI_textC(gui,obj.sections[62],'Yes',gui.color.black,-2)
        GUI_textC(gui,obj.sections[64],'No',gui.color.black,-2)
      else
        GUI_textC(gui,obj.sections[62],'OK',gui.color.black,-2)  
      end         
      GUI_textC(gui,obj.sections[63],nz(msgbox.text1,''),gui.color.white,-2)
      if msgbox.text2 then
        local xywh = {x = obj.sections[63].x,
                      y = obj.sections[63].y + butt_h,
                      w = obj.sections[63].w,
                      h = obj.sections[63].h}
        GUI_textC(gui,xywh,nz(msgbox.text2,''),gui.color.white,-2)    
      end         
    else
      GUI_textC(gui,obj.sections[62],'OK',gui.color.black,-2)  
    end
    
  end
  
  ------------------------------------------------------------
  
  function Lokasenna_Window_At_Center (w, h, x, y)
    -- thanks to Lokasenna 
    -- http://forum.cockos.com/showpost.php?p=1689028&postcount=15    
    local l, t, r, b = 0, 0, w, h    
    local __, __, screen_w, screen_h = reaper.my_getViewport(l, t, r, b, l, t, r, b, 1)    
    if x == nil or y == nil then  
      x, y = (screen_w - w) / 2, (screen_h - h) / 2
    end
    gfx.init("- LBX Stripper -", w, h, 0, x, y)  
  end

 -------------------------------------------------------------     
      
  function F_limit(val,min,max)
      if val == nil or min == nil or max == nil then return end
      local val_out = val
      if val < min then val_out = min end
      if val > max then val_out = max end
      return val_out
    end   
  ------------------------------------------------------------
  
  function MOUSE_sliderHBar(b)
    if mouse.mx > b.x-200 and mouse.mx < b.x+b.w+200
       and mouse.LB then
      local mx = mouse.mx - (b.x)
     return (mx) / (b.w)
    end 
  end
    
  function MOUSE_slider(b,yoff)
    if mouse.LB then
      if yoff == nil then yoff = 0 end
      local my = mouse.my - (b.y-200) + yoff
     return (my) / (b.h+400)
      --local my = mouse.my - b.y - yoff
      --return (my+200) / 400
    end 
  end
  
  function MOUSE_sliderX(b,yoff)
    if mouse.LB then
      if yoff == nil then yoff = 0 end
      local my = mouse.my - b.y + yoff
     return (my+200) / (400)
    end 
  end
  
  function MOUSE_slider_horiz(b,xoff)
    if mouse.LB then
      if xoff == nil then xoff = 0 end
      local mx = mouse.mx - (b.x-200) + xoff
     return (mx) / (b.w+400)
    end 
  end

  function MOUSE_sliderRB(b)
    if mouse.RB then
      local my = mouse.my - (b.y-200)
     return (my) / (b.h+400)
    end 
  end
  
  function MOUSE_surfaceX(b)
    if mouse.LB then
      local mx = mmx - mouse.mx
     return (mx)
    end 
  end

  function MOUSE_surfaceY(b)
    if mouse.LB then
      local my = mmy - mouse.my
     return (my)
    end 
  end
    
  function MOUSE_click(b)
    if mouse.mx > b.x and mouse.mx < b.x+b.w
      and mouse.my > b.y and mouse.my < b.y+b.h 
      and mouse.LB 
      and not mouse.last_LB then
     return true 
    end
    --return nil
  end

  function MOUSE_clickXY(b,xoff,yoff)
    if mouse.mx > b.x+xoff and mouse.mx < b.x+xoff+b.w
      and mouse.my > b.y+yoff and mouse.my < b.y+yoff+b.h 
      and mouse.LB 
      and not mouse.last_LB then
     return true 
    end 
  end
  
  function MOUSE_click_RB(b)
    if mouse.mx > b.x and mouse.mx < b.x+b.w
      and mouse.my > b.y and mouse.my < b.y+b.h 
      and mouse.RB 
      and not mouse.last_RB then
     return true 
    end 
  end

  function MOUSE_over(b, mx, my)
    if mx == nil then mx = mouse.mx end
    if my == nil then my = mouse.my end
    
    if mx > b.x and mx < b.x+b.w
      and my > b.y and my < b.y+b.h then
     return true 
    end 
    --return nil
  end
      
  ------------------------------------------------------------

  function GetParamDisp_Val(c, val, sleep)

    local strip = tracks[track_select].strip
    local ctl = strips[strip][page].controls[c]
    local oval = ctl.val
    
    local tracknum = strips[strip].track.tracknum
    if ctl.tracknum ~= nil then
      tracknum = ctl.tracknum
    end
    local cc = ctl.ctlcat
    local fxnum = ctl.fxnum
    local param = ctl.param
    local dvoff = ctl.dvaloffset
    local sldiv = 400
    
    SetParam3(strip,page,c,ctl,val)
    if sleep then
      os.sleep((auto_delay/sldiv)*10)
    end
    local dval = GetParamDisp(cc, tracknum, fxnum, param, dvoff, c)
    --SetParam3(strip,page,c,ctl,oval)

    return dval    
    
  end

  function GetParamDisp_Ctl(c)
    local t = strips[tracks[track_select].strip].track.tracknum
    if strips[tracks[track_select].strip][page].controls[c].tracknum ~= nil then
      t = strips[tracks[track_select].strip][page].controls[c].tracknum
    end
    
    local cc = strips[tracks[track_select].strip][page].controls[c].ctlcat
    if cc == ctlcats.fxparam then
      local f = strips[tracks[track_select].strip][page].controls[c].fxnum
      local p = strips[tracks[track_select].strip][page].controls[c].param
      local dvoff = strips[tracks[track_select].strip][page].controls[c].dvaloffset
      local dval = GetParamDisp(cc, t, f, p, dvoff,c)
      return dval
      
    elseif cc == ctlcats.trackparam then
      local p = strips[tracks[track_select].strip][page].controls[c].param    
      local dvoff = strips[tracks[track_select].strip][page].controls[c].dvaloffset
      local dval = GetParamDisp(cc, t, nil, p, dvoff,c)
      return dval

    elseif cc == ctlcats.tracksend then
      local p = strips[tracks[track_select].strip][page].controls[c].param    
      local dvoff = strips[tracks[track_select].strip][page].controls[c].dvaloffset
      local dval = GetParamDisp(cc, t, nil, p, dvoff,c)
      return dval

    elseif cc == ctlcats.action then
      return ''
    end
    
  end
    
  function GetParamDisp(ctlcat,tracknum,fxnum,paramnum, dvoff,c)
    track = GetTrack(tracknum)
    if ctlcat == ctlcats.fxparam then
      local _, d = reaper.TrackFX_GetFormattedParamValue(track, fxnum, paramnum, "")
      if dvoff then
        d = dvaloffset(d, dvoff)
      end
      return d

    elseif ctlcat == ctlcats.trackparam then
      local d
      if paramnum == 1 then
        --volume
        d = reaper.mkvolstr('', reaper.GetMediaTrackInfo_Value(track, trctls_table[paramnum].parmname))
      elseif paramnum == 2 or paramnum == 4 or paramnum == 5 then
        --pan
        d = reaper.mkpanstr('', reaper.GetMediaTrackInfo_Value(track, trctls_table[paramnum].parmname))
      else
        d = round(reaper.GetMediaTrackInfo_Value(track, trctls_table[paramnum].parmname),2)
      end

      if dvoff then
        d = dvaloffset(d, dvoff)
      end
      return d

    elseif ctlcat == ctlcats.tracksend then
      local d
      local paramidx = strips[tracks[track_select].strip][page].controls[c].param_info.paramidx
      local paramstr = strips[tracks[track_select].strip][page].controls[c].param_info.paramstr
      local tidx = ((paramnum-1) % 3) +1
      if paramnum % 3 == 1 then
        --volumes
        --d = reaper.mkvolstr('', reaper.GetTrackSendInfo_Value(track, 0, paramidx, paramstr))
        retval, vOut, pOut = reaper.GetTrackSendUIVolPan(track, paramidx)
        d = reaper.mkvolstr('', vOut)
      elseif paramnum % 3 == 2 then
        --pan
        --d = reaper.mkpanstr('', reaper.GetTrackSendInfo_Value(track, 0, paramidx, paramstr))
        retval, vOut, pOut = reaper.GetTrackSendUIVolPan(track, paramidx)
        d = reaper.mkpanstr('', pOut)
      else
        d = round(reaper.GetTrackSendInfo_Value(track, 0, paramidx, paramstr),2)
      end

      if dvoff then
        d = dvaloffset(d, dvoff)
      end
      return d

    elseif ctlcat == ctlcats.action then
      return ''
    elseif ctlcat == ctlcats.pkmeter then
      if paramnum <=64 and peak_info[tracknum] and peak_info[tracknum][paramnum] then
        return round(peak_info[tracknum][paramnum].ch_d,1)
      elseif paramnum > 64 then
        return ''
      else
        return '-inf'       
      end
    end
  end

  function GetParamValue_Ctl(c)
    if c then
      local t = strips[tracks[track_select].strip].track.tracknum
      if strips[tracks[track_select].strip][page].controls[c].tracknum ~= nil then
        t = strips[tracks[track_select].strip][page].controls[c].tracknum
      end
      local cc = strips[tracks[track_select].strip][page].controls[c].ctlcat
      if cc == ctlcats.fxparam then
        local f = strips[tracks[track_select].strip][page].controls[c].fxnum
        local p = strips[tracks[track_select].strip][page].controls[c].param
        track = GetTrack(t)
        
        local v, min, max = reaper.TrackFX_GetParam(track, f, p)
        if strips[tracks[track_select].strip][page].controls[c].minov then
          min = strips[tracks[track_select].strip][page].controls[c].minov
        end
        if strips[tracks[track_select].strip][page].controls[c].maxov then
          max = strips[tracks[track_select].strip][page].controls[c].maxov
        end
        return normalize(min, max, v)

      elseif cc == ctlcats.trackparam then
        local p = strips[tracks[track_select].strip][page].controls[c].param
        local min, max = GetParamMinMax(cc,nil,nil,p,true,c)
        return GMTI_norm(track, p, min, max)

      elseif cc == ctlcats.tracksend then
        local p = strips[tracks[track_select].strip][page].controls[c].param
        local min, max = GetParamMinMax(cc,nil,nil,p,true,c)
        return GTSI_norm(track, p, min, max,c)
        
      elseif cc == ctlcats.action then
        return 0
      elseif cc == ctlcats.pkmeter then
        local tracknum = strips[tracks[track_select].strip].track.tracknum
        if strips[tracks[track_select].strip][page].controls[c].tracknum ~= nil then
          tracknum = strips[tracks[track_select].strip][page].controls[c].tracknum
        end
        local p = strips[tracks[track_select].strip][page].controls[c].param
        if p <= 64 and peak_info[tracknum] and peak_info[tracknum][p] then
          return peak_info[tracknum][p].ch
        else
          return 0
        end
      elseif cc == ctlcats.macro then
        return strips[tracks[track_select].strip][page].controls[c].val
      end
    else
      return 0
    end
  end
  
  function GMTI_norm(track,trctl_idx,min,max)
  
    if trctls_table[trctl_idx].parmname == 'B_MUTE' then
      local retval, muteOut = reaper.GetTrackUIMute(track)
      local mo
      if muteOut then mo = 1 else mo = 0 end
      return mo
    elseif trctls_table[trctl_idx].parmname == 'I_SOLO' then
      local trn = reaper.GetMediaTrackInfo_Value(track, 'IP_TRACKNUMBER')
      if trn == -1 then
        local flags = reaper.GetMasterMuteSoloFlags()
        local soloOut = flags&2==2
        if soloOut then so = 1 else so = 0 end
        return so
      else
        return normalize(min,max,reaper.GetMediaTrackInfo_Value(track, trctls_table[trctl_idx].parmname))
      end
    
    else
      return normalize(min,max,reaper.GetMediaTrackInfo_Value(track, trctls_table[trctl_idx].parmname))
    end
    
  end

  function GTSI_norm(track,trctl_idx,min,max,c)

    local idx = strips[tracks[track_select].strip][page].controls[c].param_info.paramidx
    local paramstr = strips[tracks[track_select].strip][page].controls[c].param_info.paramstr

    --if paramstr == nil then return 0 end
    
    if track == nil then
      track = GetTrack(nz(strips[tracks[track_select].strip][page].controls[c].tracknum,strips[tracks[track_select].strip].track.tracknum))
    end
    
    if paramstr == 'D_VOL' then
      local retval, vOut, pOut = reaper.GetTrackSendUIVolPan(track, idx)
      return normalize(min, max, vOut)
    elseif paramstr == 'D_PAN' then
      local retval, vOut, pOut = reaper.GetTrackSendUIVolPan(track, idx)
      return normalize(min, max, pOut)
    elseif paramstr == 'B_MUTE' then
      local retval, muteOut = reaper.GetTrackSendUIMute(track, idx)
      local mo
      if muteOut then mo = 1 else mo = 0 end
      return mo
    --else    
    --  return normalize(min,max,reaper.GetTrackSendInfo_Value(track, 0, idx, paramstr))
    end
    
  end

  function GTSI_norm_XX(track,trctl_idx,min,max,c,strip,page)

    local idx = strips[strip][page].controls[c].param_info.paramidx
    local paramstr = strips[strip][page].controls[c].param_info.paramstr

    --if paramstr == nil then return 0 end
    
    if track == nil then
      track = GetTrack(nz(strips[strip][page].controls[c].tracknum,strips[strip].track.tracknum))
    end
    
    if paramstr == 'D_VOL' then
      local retval, vOut, pOut = reaper.GetTrackSendUIVolPan(track, idx)
      return normalize(min, max, vOut)
    elseif paramstr == 'D_PAN' then
      local retval, vOut, pOut = reaper.GetTrackSendUIVolPan(track, idx)
      return normalize(min, max, pOut)
    elseif paramstr == 'B_MUTE' then
      local retval, muteOut = reaper.GetTrackSendUIMute(track, idx)
      local mo
      if muteOut then mo = 1 else mo = 0 end
      return mo
    --else    
    --  return normalize(min,max,reaper.GetTrackSendInfo_Value(track, 0, idx, paramstr))
    end
    
  end

  function SMTI_norm(track,trctl_idx,v,min,max)
  
    local val = DenormalizeValue(min,max,v)
    reaper.SetMediaTrackInfo_Value(track, trctls_table[trctl_idx].parmname, val)
    
  end

  function SMTI_denorm(track,trctl_idx,v)
  
      reaper.SetMediaTrackInfo_Value(track, trctls_table[trctl_idx].parmname, v)

  end

  function STSI_norm(track,trctl_idx,v,min,max,c)
  
    local idx = strips[tracks[track_select].strip][page].controls[c].param_info.paramidx
    local paramstr = strips[tracks[track_select].strip][page].controls[c].param_info.paramstr

    local val = DenormalizeValue(min,max,v)
    if paramstr == 'D_VOL' then
      reaper.SetTrackSendUIVol(track, idx, val, 0)
    elseif paramstr == 'D_PAN' then
      reaper.SetTrackSendUIPan(track, idx, val, 0)
    elseif paramstr == 'B_MUTE' then
      reaper.ToggleTrackSendUIMute(track, idx)
    else
      reaper.SetTrackSendInfo_Value(track, 0, idx, paramstr, val)
    end
  end

  function STSI_denorm(track,trctl_idx,val,c, strip, page)
  
    local idx = strips[strip][page].controls[c].param_info.paramidx
    local paramstr = strips[strip][page].controls[c].param_info.paramstr
    if paramstr == 'D_VOL' then
      reaper.SetTrackSendUIVol(track, idx, val, 0)
    elseif paramstr == 'D_PAN' then
      reaper.SetTrackSendUIPan(track, idx, val, 0)
    elseif paramstr == 'B_MUTE' then
      local v = strips[strip][page].controls[c].val
      if v ~= val then
        reaper.ToggleTrackSendUIMute(track, idx)
      end
    else
      reaper.SetTrackSendInfo_Value(track, 0, idx, paramstr, val)
    end
  end
    
  function GetParamValue(ctlcat,tracknum,fxnum,paramnum,c)
    track = GetTrack(tracknum)
    if ctlcat == ctlcats.fxparam then
      local v, min, max = reaper.TrackFX_GetParam(track, fxnum, paramnum)
      if c then
        if strips[tracks[track_select].strip][page].controls[c].minov then
          min = strips[tracks[track_select].strip][page].controls[c].minov
        end
        if strips[tracks[track_select].strip][page].controls[c].maxov then
          max = strips[tracks[track_select].strip][page].controls[c].maxov
        end
      end
      return normalize(min, max, v)

    elseif ctlcat == ctlcats.trackparam then
      local min, max = GetParamMinMax(ctlcat,nil,nil,paramnum,true,c)
      return GMTI_norm(track, paramnum, min, max)

    elseif ctlcat == ctlcats.tracksend then
      local min, max = GetParamMinMax(ctlcat,nil,nil,paramnum,true,c)
      return GTSI_norm(track, paramnum, min, max,c)

    elseif ctlcat == ctlcats.action then
      return 0
    elseif ctlcat == ctlcats.pkmeter then
      if peak_info[tracknum] and peak_info[tracknum][paramnum % 64] then
        if paramnum < 64 then
          return peak_info[tracknum][paramnum].ch
        else
          return peak_info[tracknum][paramnum-64].pk
        end
      else
        return 0
      end
    end
  end

  function GetParamValue_XX(ctlcat,tracknum,fxnum,paramnum,c,strip,page)
    track = GetTrack(tracknum)
    if ctlcat == ctlcats.fxparam then
      local v, min, max = reaper.TrackFX_GetParam(track, fxnum, paramnum)
      if c then
        if strips[strip][page].controls[c].minov then
          min = strips[strip][page].controls[c].minov
        end
        if strips[strip][page].controls[c].maxov then
          max = strips[strip][page].controls[c].maxov
        end
      end
      return normalize(min, max, v)

    elseif ctlcat == ctlcats.trackparam then
      local min, max = GetParamMinMax_XX(ctlcat,nil,nil,paramnum,true,c,strip,page)
      return GMTI_norm(track, paramnum, min, max)

    elseif ctlcat == ctlcats.tracksend then
      local min, max = GetParamMinMax_XX(ctlcat,nil,nil,paramnum,true,c,strip,page)
      return GTSI_norm_XX(track, paramnum, min, max,c, strip, page)

    elseif ctlcat == ctlcats.macro then
      return strips[strip][page].controls[c].val
      
    elseif ctlcat == ctlcats.action then
      return 0
    elseif ctlcat == ctlcats.pkmeter then
      if peak_info[tracknum] and peak_info[tracknum][paramnum % 64] then
        if paramnum < 64 then
          return peak_info[tracknum][paramnum].ch
        else
          return peak_info[tracknum][paramnum-64].pk
        end
      else
        return 0
      end
    end
  end

  function GetParamValue2(ctlcat,track,fxnum,paramnum,c)
    if ctlcat == ctlcats.fxparam then
      local v, min, max = reaper.TrackFX_GetParam(track, fxnum, paramnum)
      if c then
        if strips[tracks[track_select].strip][page].controls[c].minov then
          min = strips[tracks[track_select].strip][page].controls[c].minov
        end
        if strips[tracks[track_select].strip][page].controls[c].maxov then
          max = strips[tracks[track_select].strip][page].controls[c].maxov
        end
      end  
      return normalize(min, max, v)

    elseif ctlcat == ctlcats.trackparam then
      local min, max = GetParamMinMax(ctlcat,nil,nil,paramnum,true,c)
      return GMTI_norm(track, paramnum, min, max)

    elseif ctlcat == ctlcats.tracksend then
      local min, max = GetParamMinMax(ctlcat,nil,nil,paramnum,true,c)
      return GTSI_norm(track, paramnum, min, max,c)
      
    elseif ctlcat == ctlcats.action then
      return 0
    elseif ctlcat == ctlcats.pkmeter then
      local tracknum = strips[tracks[track_select].strip].track.tracknum
      if strips[tracks[track_select].strip][page].controls[c].tracknum ~= nil then
        tracknum = strips[tracks[track_select].strip][page].controls[c].tracknum
      end
      if peak_info[tracknum] and peak_info[tracknum][paramnum % 64] then
        if paramnum < 64 then
          return peak_info[tracknum][paramnum].ch
        else
          return peak_info[tracknum][paramnum-64].pk
        end
      else
        return 0
      end
    end
  end
  
  function A_GetParamMinMax(ctlcat,track,ctl,fxnum,paramnum,checkov,c)
    if ctlcat == ctlcats.fxparam then    
      if track == nil then return end
      local _, min, max = reaper.TrackFX_GetParam(track, fxnum, paramnum)
      if checkov and checkov == true and c then
        if ctl.minov then
          min = ctl.minov
        end
        if ctl.maxov then
          max = ctl.maxov
        end      
      end
      return min, max  
    
    elseif ctlcat == ctlcats.trackparam then
      local min, max = trctls_table[paramnum].min, trctls_table[paramnum].max
      if checkov and checkov == true and c then
        if ctl.minov then
          min = ctl.minov
        end
        if ctl.maxov then
          max = ctl.maxov
        end      
      end
      return tonumber(min), tonumber(max)  
      
    elseif ctlcat == ctlcats.tracksend then
      local idx = math.floor((paramnum-1) % 3)+1
      local min, max = trsends_mmtable[idx].min, trsends_mmtable[idx].max
      if checkov and checkov == true and c then
        if ctl.minov then
          min = ctl.minov
        end
        if ctl.maxov then
          max = ctl.maxov
        end      
      end
      return tonumber(min), tonumber(max)  
    else 
      return 0, 1
    end
  end

  function GetParamMinMax(ctlcat,track,fxnum,paramnum,checkov,c)
    if ctlcat == ctlcats.fxparam then    
      if track == nil then return end
      local _, min, max = reaper.TrackFX_GetParam(track, fxnum, paramnum)
      if checkov and checkov == true and c then
        if strips[tracks[track_select].strip][page].controls[c].minov then
          min = strips[tracks[track_select].strip][page].controls[c].minov
        end
        if strips[tracks[track_select].strip][page].controls[c].maxov then
          max = strips[tracks[track_select].strip][page].controls[c].maxov
        end      
      end
      return min, max  
    
    elseif ctlcat == ctlcats.trackparam then
      local min, max = trctls_table[paramnum].min, trctls_table[paramnum].max
      if checkov and checkov == true and c then
        if strips[tracks[track_select].strip][page].controls[c].minov then
          min = strips[tracks[track_select].strip][page].controls[c].minov
        end
        if strips[tracks[track_select].strip][page].controls[c].maxov then
          max = strips[tracks[track_select].strip][page].controls[c].maxov
        end      
      end
      return tonumber(min), tonumber(max)  
      
    elseif ctlcat == ctlcats.tracksend then
      local idx = math.floor((paramnum-1) % 3)+1
      local min, max = trsends_mmtable[idx].min, trsends_mmtable[idx].max
      if checkov and checkov == true and c then
        if strips[tracks[track_select].strip][page].controls[c].minov then
          min = strips[tracks[track_select].strip][page].controls[c].minov
        end
        if strips[tracks[track_select].strip][page].controls[c].maxov then
          max = strips[tracks[track_select].strip][page].controls[c].maxov
        end      
      end
      return tonumber(min), tonumber(max)  
    else 
      return 0, 1
    end
  end

  function GetParamMinMax_XX(ctlcat,track,fxnum,paramnum,checkov,c, strip, page)
    if ctlcat == ctlcats.fxparam then    
      if track == nil then return end
      local _, min, max = reaper.TrackFX_GetParam(track, fxnum, paramnum)
      if checkov and checkov == true and c then
        if strips[strip][page].controls[c].minov then
          min = strips[strip][page].controls[c].minov
        end
        if strips[strip][page].controls[c].maxov then
          max = strips[strip][page].controls[c].maxov
        end      
      end
      return min, max  
    
    elseif ctlcat == ctlcats.trackparam then
      local min, max = trctls_table[paramnum].min, trctls_table[paramnum].max
      if checkov and checkov == true and c then
        if strips[strip][page].controls[c].minov then
          min = strips[strip][page].controls[c].minov
        end
        if strips[strip][page].controls[c].maxov then
          max = strips[strip][page].controls[c].maxov
        end      
      end
      return tonumber(min), tonumber(max)  
      
    elseif ctlcat == ctlcats.tracksend then
      local idx = math.floor((paramnum-1) % 3)+1
      local min, max = trsends_mmtable[idx].min, trsends_mmtable[idx].max
      if checkov and checkov == true and c then
        if strips[strip][page].controls[c].minov then
          min = strips[strip][page].controls[c].minov
        end
        if strips[strip][page].controls[c].maxov then
          max = strips[strip][page].controls[c].maxov
        end      
      end
      return tonumber(min), tonumber(max)  
    else 
      return 0, 1
    end
  end

  function GetParamMinMax_ctlselect()
    if ctl_select and #ctl_select >= 1 then
      trackfxparam_select = ctl_select[1].ctl
      local track
      if strips[tracks[track_select].strip][page].controls[trackfxparam_select].tracknum == nil then
        track = GetTrack(strips[tracks[track_select].strip].track.tracknum)
      else
        track = GetTrack(strips[tracks[track_select].strip][page].controls[trackfxparam_select].tracknum)
      end
      local cc = strips[tracks[track_select].strip][page].controls[trackfxparam_select].ctlcat 
      if cc == ctlcats.fxparam then
        local fxnum = strips[tracks[track_select].strip][page].controls[trackfxparam_select].fxnum      
        local paramnum = strips[tracks[track_select].strip][page].controls[trackfxparam_select].param
        
        local _, min, max = reaper.TrackFX_GetParam(track, fxnum, paramnum)
        return min, max
      elseif cc == ctlcats.trackparam then
        local param = strips[tracks[track_select].strip][page].controls[trackfxparam_select].param
        return tonumber(trctls_table[param].min), tonumber(trctls_table[param].max)
      elseif cc == ctlcats.tracksend then
        local param = strips[tracks[track_select].strip][page].controls[trackfxparam_select].param
        local idx = math.floor((param-1) % 3)+1
        return tonumber(trsends_mmtable[idx].min), tonumber(trsends_mmtable[idx].max)
      else 
        return 0, 1
      end
    else
      return nil, nil
    end
  end
  
  function GetParamMinMax_ctl(c, checkov)
    
    if checkov == nil then checkov = true end
    
    local t = strips[tracks[track_select].strip].track.tracknum
    if strips[tracks[track_select].strip][page].controls[c].tracknum ~= nil then
      t = strips[tracks[track_select].strip][page].controls[c].tracknum
    end

    local cc = strips[tracks[track_select].strip][page].controls[c].ctlcat 
    if cc == ctlcats.fxparam then
      local f = strips[tracks[track_select].strip][page].controls[c].fxnum
      local p = strips[tracks[track_select].strip][page].controls[c].param
      local cc = strips[tracks[track_select].strip][page].controls[c].ctlcat
      
      local track = GetTrack(t)
      local min, max = GetParamMinMax(cc,track,nz(f,-1),p,checkov,c)
      return min, max

    elseif cc == ctlcats.trackparam then
      local param = strips[tracks[track_select].strip][page].controls[c].param
      local min, max = trctls_table[param].min, trctls_table[param].max
      if checkov then    
        if strips[tracks[track_select].strip][page].controls[c].minov then
          min = strips[tracks[track_select].strip][page].controls[c].minov
        end
        if strips[tracks[track_select].strip][page].controls[c].maxov then
          max = strips[tracks[track_select].strip][page].controls[c].maxov
        end
      end
      return tonumber(min), tonumber(max)

    elseif cc == ctlcats.tracksend then
      local param = strips[tracks[track_select].strip][page].controls[c].param
      local idx = math.floor((param-1) % 3)+1
      local min, max = trsends_mmtable[idx].min, trsends_mmtable[idx].max
      if checkov then
        if strips[tracks[track_select].strip][page].controls[c].minov then
          min = strips[tracks[track_select].strip][page].controls[c].minov
        end
        if strips[tracks[track_select].strip][page].controls[c].maxov then
          max = strips[tracks[track_select].strip][page].controls[c].maxov
        end      
      end
      return tonumber(min), tonumber(max)  
    else 
      return 0, 1
    end
  end
  
  function normalize(min, max, val)
    if min and max and val then
      return (val - min)/(max - min)
    else
      return 0
    end
  end
  
  --nv*(max - min) + min = val
  function DenormalizeValue(min, max, val)
    if min and max and val then
      return val*(max - min) + min
    else
      return 0
    end
  end
  
  ------------------------------------------------------------
  
  function A_SetParam(strip, page, c, ctl)
  
    if strips and strips[strip] and ctl then
      local val = ctl.val
      ctl.mval = val
      local track 
      if ctl.tracknum == nil then
        track = GetTrack(strips[strip].track.tracknum)
      else
        track = GetTrack(ctl.tracknum)
      end
      local cc = ctl.ctlcat

      if cc == ctlcats.fxparam then
        local fxnum = ctl.fxnum
        local param = ctl.param
        if fxnum == nil then fxnum = -1 end
        ctl.dirty = true
        local min, max = A_GetParamMinMax(cc,track,ctl,fxnum,param,true,c)
        reaper.TrackFX_SetParam(track, fxnum, param, DenormalizeValue(min, max, val))
        
      elseif cc == ctlcats.trackparam then
        local param = ctl.param
        ctl.dirty = true
        local min, max = A_GetParamMinMax(cc,track,ctl,nil,param,true,c)
        SMTI_norm(track,param,val,min,max)

      elseif cc == ctlcats.tracksend then
        local param = ctl.param
        ctl.dirty = true
        local min, max = A_GetParamMinMax(cc,track,ctl,nil,param,true,c)
        STSI_norm(track,param,val,min,max,c)

      elseif cc == ctlcats.action then
      
        local dcmd = ctl.param_info.paramnum
        if dcmd ~= nil then
          reaper.Main_OnCommand(dcmd, 0)
        else
          local cmd = ctl.param_info.paramidx
          if cmd ~= nil then
            if string.sub(cmd,1,1) ~= '_' then
              cmd = '_'..cmd
            end
            reaper.Main_OnCommand(reaper.NamedCommandLookup(cmd), 0)
          end
        end        
      elseif cc == ctlcats.fxoffline then
        ToggleFXOffline(strip, page, c, strips[strip].track.tracknum)
        
      elseif cc == ctlcats.macro then
        SetMacro(strip, page, c)

      elseif cc == ctlcats.snapshotrand then
        
        local sst = ctl.param
        if sst then
          Snapshot_RANDOMIZE(strip, page, sst, true)
        end
      
      elseif cc == ctlcats.fxgui then
      
        OpenFXGUI(ctl)
        
      end
      if ctl.midiout then SendMIDIMsg(ctl.midiout,val) end
      if ctl.macrofader then
        SetFader(ctl.macrofader, ctl.val)
      end
    end
      
  end
  
  function SetFader(f, val)
    if LBX_CTL_TRACK then 
      local track = GetTrack(LBX_CTL_TRACK) 
      if track then
        local fxnum = math.floor((f-1) / 32)
        local p = (f-1) % 32
        reaper.TrackFX_SetParam(track, fxnum, p, val)
        faders[f].oval = round(val,5)
      end
    end
  end
  
  function OpenFXGUI(ctl)
    local track
    if ctl.tracknum == nil then
      track = GetTrack(tracks[track_select].tracknum)
    else
      track = GetTrack(ctl.tracknum)                      
    end
    local fxnum = ctl.fxnum
    reaper.TrackFX_Show(track, fxnum, 3)  
  end
  
------------------------------------------------------------
--replace with A_SetParam
  function SetParam()
  
    if strips and strips[tracks[track_select].strip] and strips[tracks[track_select].strip][page].controls[trackfxparam_select] then
      local val = strips[tracks[track_select].strip][page].controls[trackfxparam_select].val
      local track 
      if strips[tracks[track_select].strip][page].controls[trackfxparam_select].tracknum == nil then
        track = GetTrack(strips[tracks[track_select].strip].track.tracknum)
      else
        track = GetTrack(strips[tracks[track_select].strip][page].controls[trackfxparam_select].tracknum)
      end
      local cc = strips[tracks[track_select].strip][page].controls[trackfxparam_select].ctlcat
      if cc == ctlcats.fxparam then
        --DBG(val)
        local fxnum = strips[tracks[track_select].strip][page].controls[trackfxparam_select].fxnum
        local param = strips[tracks[track_select].strip][page].controls[trackfxparam_select].param
        strips[tracks[track_select].strip][page].controls[trackfxparam_select].dirty = true
        local min, max = GetParamMinMax(cc,track,nz(fxnum,-1),param,true,trackfxparam_select)
        --reaper.Undo_BeginBlock2(0)
        reaper.TrackFX_SetParam(track, nz(fxnum,-1), param, DenormalizeValue(min, max, val))
        --reaper.Undo_EndBlock2(0,"RRR",-1)
      elseif cc == ctlcats.trackparam then
        local param = strips[tracks[track_select].strip][page].controls[trackfxparam_select].param
        strips[tracks[track_select].strip][page].controls[trackfxparam_select].dirty = true
        local min, max = GetParamMinMax(cc,track,nil,param,true,trackfxparam_select)
        SMTI_norm(track,param,val,min,max)

      elseif cc == ctlcats.tracksend then
        local param = strips[tracks[track_select].strip][page].controls[trackfxparam_select].param
        strips[tracks[track_select].strip][page].controls[trackfxparam_select].dirty = true
        local min, max = GetParamMinMax(cc,track,nil,param,true,trackfxparam_select)
        STSI_norm(track,param,val,min,max,trackfxparam_select)

      elseif cc == ctlcats.action then
      
        local dcmd = strips[tracks[track_select].strip][page].controls[trackfxparam_select].param_info.paramnum
        if dcmd ~= nil then
          reaper.Main_OnCommand(dcmd, 0)
        else
          local cmd = strips[tracks[track_select].strip][page].controls[trackfxparam_select].param_info.paramidx
          if cmd ~= nil then
            if string.sub(cmd,1,1) ~= '_' then
              cmd = '_'..cmd
            end
            reaper.Main_OnCommand(reaper.NamedCommandLookup(cmd), 0)
          end
        end        
      elseif cc == ctlcats.fxoffline then
        ToggleFXOffline(tracks[track_select].strip, page, trackfxparam_select, tracks[track_select].tracknum)
      elseif cc == ctlcats.macro then
        SetMacro(tracks[track_select].strip, page, trackfxparam_select)
      end
    end
      
  end
  
------------------------------------------------------------
  
  function SetParam2(force)
  
    if strips and strips[tracks[track_select].strip] and strips[tracks[track_select].strip][page].controls[trackfxparam_select] then
      local val = strips[tracks[track_select].strip][page].controls[trackfxparam_select].val
      if strips[tracks[track_select].strip][page].controls[trackfxparam_select].tracknum == nil then
        track = GetTrack(strips[tracks[track_select].strip].track.tracknum)
      else
        track = GetTrack(strips[tracks[track_select].strip][page].controls[trackfxparam_select].tracknum)
      end
      local cc = strips[tracks[track_select].strip][page].controls[trackfxparam_select].ctlcat
      if cc == ctlcats.fxparam then
        local fxnum = strips[tracks[track_select].strip][page].controls[trackfxparam_select].fxnum
        local param = strips[tracks[track_select].strip][page].controls[trackfxparam_select].param
        --local cc = strips[tracks[track_select].strip][page].controls[trackfxparam_select].ctlcat
        strips[tracks[track_select].strip][page].controls[trackfxparam_select].dirty = true
        local min, max = GetParamMinMax(cc,track,nz(fxnum,-1),param,true,trackfxparam_select)
        if force and force == true then
          reaper.TrackFX_SetParam(track, nz(fxnum,-1), param, DenormalizeValue(min, max, 1-math.abs(val-0.1)))
        end
        reaper.TrackFX_SetParam(track, nz(fxnum,-1), param, DenormalizeValue(min, max, val))

      elseif cc == ctlcats.trackparam then
        local param = strips[tracks[track_select].strip][page].controls[trackfxparam_select].param
        strips[tracks[track_select].strip][page].controls[trackfxparam_select].dirty = true
        local min, max = GetParamMinMax(cc,track,nil,param,true,trackfxparam_select)
        if force and force == true then
          SMTI_norm(track,param,1-math.abs(val-0.1),min,max)
        end      
        SMTI_norm(track,param,val,min,max)

      elseif cc == ctlcats.tracksend then
        local param = strips[tracks[track_select].strip][page].controls[trackfxparam_select].param
        strips[tracks[track_select].strip][page].controls[trackfxparam_select].dirty = true
        local min, max = GetParamMinMax(cc,track,nil,param,true,trackfxparam_select)
        if force and force == true then
          STSI_norm(track,param,1-math.abs(val-0.1),min,max,trackfxparam_select)
        end      
        STSI_norm(track,param,val,min,max,trackfxparam_select)
      end
    end
      
  end

------------------------------------------------------------
  
  function SetParam3(strip,page,c,ctl,v)
  
    if strips and strips[strip] and ctl then
      if ctl.tracknum == nil then
        track = GetTrack(strips[strip].track.tracknum)
      else
        track = GetTrack(ctl.tracknum)
      end
      local cc = ctl.ctlcat
      if cc == ctlcats.fxparam then
        local fxnum = nz(ctl.fxnum,-1)
        local param = ctl.param
        local min, max = A_GetParamMinMax(cc,track,ctl,fxnum,param,true,c)
        reaper.TrackFX_SetParam(track, fxnum, param, DenormalizeValue(min, max, v))

      elseif cc == ctlcats.trackparam then
        local param = ctl.param
        ctl.dirty = true
        local min, max = A_GetParamMinMax(cc,track,ctl,nil,param,true,c)
        SMTI_norm(track,param,v,min,max)

      elseif cc == ctlcats.tracksend then
        local param = ctl.param
        ctl.dirty = true
        local min, max = A_GetParamMinMax(cc,track,ctl,nil,param,true,c)
        STSI_norm(track,param,v,min,max,c)
      end
      if ctl.midiout then SendMIDIMsg(ctl.midiout,v) end    
    end
      
  end

  function SetParam3_Denorm2_Safe(track, v, strip, page)
  
    local ctl = strips[strip][page].controls[trackfxparam_select]
    if strips and strips[strip] and ctl then
      local cc = ctl.ctlcat
      if cc == ctlcats.fxparam then
        local fxnum = ctl.fxnum
        local param = ctl.param
        reaper.TrackFX_SetParam(track, nz(fxnum,-1), param, v)

      elseif cc == ctlcats.trackparam then
        local param = ctl.param
        ctl.dirty = true
        SMTI_denorm(track,param,v)

      elseif cc == ctlcats.tracksend then
        local param = strips[strip][page].controls[trackfxparam_select].param
        ctl.dirty = true
        STSI_denorm(track,param,v,trackfxparam_select,strip,page)
      end    
      if ctl.midiout then SendMIDIMsg(ctl.midiout,v) end
    end
      
  end

  function SetParam3_Denorm2_Safe2(track, v, strip, page, reaper, c)
  
    local ctl = strips[strip][page].controls[c]
    if strips and strips[strip] and ctl then
      local cc = ctl.ctlcat
      if cc == ctlcats.fxparam then
        local fxnum = ctl.fxnum
        local param = ctl.param
        reaper.TrackFX_SetParam(track, nz(fxnum,-1), param, v)
        ctl.val = v
        ctl.dirty = true
        
      elseif cc == ctlcats.trackparam then
        local param = ctl.param
        ctl.dirty = true
        SMTI_denorm(track,param,v)

      elseif cc == ctlcats.tracksend then
        local param = ctl.param
        ctl.dirty = true
        STSI_denorm(track,param,v,c,strip,page)
      
      elseif cc == ctlcats.fxoffline then
        SetFXOffline2(strip, page, c, track, v)
      elseif cc == ctlcats.midictl then
        ctl.val = v
        ctl.dirty = true
      end    
      if ctl.midiout then SendMIDIMsg(ctl.midiout,v) end

    end
      
  end
  
  function SetParam4(v)
    
    if strips and strips[tracks[track_select].strip] and strips[tracks[track_select].strip][page].controls[trackfxparam_select] then
      if strips[tracks[track_select].strip][page].controls[trackfxparam_select].tracknum == nil then
        track = GetTrack(strips[tracks[track_select].strip].track.tracknum)
      else
        track = GetTrack(strips[tracks[track_select].strip][page].controls[trackfxparam_select].tracknum)
      end
      local cc = strips[tracks[track_select].strip][page].controls[trackfxparam_select].ctlcat
      if cc == ctlcats.fxparam then
        local fxnum = strips[tracks[track_select].strip][page].controls[trackfxparam_select].fxnum
        local param = strips[tracks[track_select].strip][page].controls[trackfxparam_select].param
        local cc = strips[tracks[track_select].strip][page].controls[trackfxparam_select].ctlcat
        local min, max = GetParamMinMax(cc,track,nz(fxnum,-1),param)
        reaper.TrackFX_SetParam(track, nz(fxnum,-1), param, DenormalizeValue(min, max, v))

      elseif cc == ctlcats.trackparam then
        local param = strips[tracks[track_select].strip][page].controls[trackfxparam_select].param
        strips[tracks[track_select].strip][page].controls[trackfxparam_select].dirty = true
        --local min, max = trctls_table[param].min,trctls_table[param].max
        SMTI_norm(track,param,v,0,1)

      elseif cc == ctlcats.tracksend then
        local param = strips[tracks[track_select].strip][page].controls[trackfxparam_select].param
        strips[tracks[track_select].strip][page].controls[trackfxparam_select].dirty = true
        --local min, max = trctls_table[param].min,trctls_table[param].max
        STSI_norm(track,param,v,0,1,trackfxparam_select)
      end        
    end
      
  end

------------------------------------------------------------
  --ignore internal minmax 
  function SetParam5(v)
  
    local strip = tracks[track_select].strip
    local ctl = strips[strip][page].controls[trackfxparam_select]    
    if strips and strips[strip] and ctl then
      if ctl.tracknum == nil then
        track = GetTrack(strips[strip].track.tracknum)
      else
        track = GetTrack(ctl.tracknum)
      end
      local cc = ctl.ctlcat
      if cc == ctlcats.fxparam then
        local fxnum = ctl.fxnum
        local param = ctl.param
        local min, max = GetParamMinMax(cc,track,nz(fxnum,-1),param,false,trackfxparam_select)
        reaper.TrackFX_SetParam(track, nz(fxnum,-1), param, DenormalizeValue(min, max, v))

      elseif cc == ctlcats.trackparam then
        local param = ctl.param
        ctl.dirty = true
        local min, max = GetParamMinMax(cc,track,nil,param,false,trackfxparam_select)
        SMTI_norm(track,param,v,min,max)

      elseif cc == ctlcats.tracksend then
        local param = ctl.param
        ctl.dirty = true
        local min, max = GetParamMinMax(cc,track,nil,param,false,trackfxparam_select)
        STSI_norm(track,param,v,min,max,trackfxparam_select)
      end    
      if ctl.midiout then SendMIDIMsg(ctl.midiout,v) end
    end
      
  end
    
  ------------------------------------------------------------    

  function Lasso_Select(shift)
  
    ctl_select = nil
    gfx3_select = nil

    local l = {l = lasso.l, r = lasso.r, t = lasso.t, b = lasso.b}
    if lasso.r < lasso.l then
      l.l = lasso.r
      l.r = lasso.l
    end
    if lasso.b < lasso.t then
      l.b = lasso.t
      l.t = lasso.b
    end

    if strips and strips[tracks[track_select].strip] then
      if #strips[tracks[track_select].strip][page].controls > 0 then
      
        for i = 1, #strips[tracks[track_select].strip][page].controls do
          local ctl
          local cctl = strips[tracks[track_select].strip][page].controls[i]
          ctl = {x = cctl.xsc - surface_offset.x + obj.sections[10].x,
                     y = cctl.ysc - surface_offset.y + obj.sections[10].y,
                     w = cctl.wsc,
                     h = cctl.hsc}
          if ((l.l <= ctl.x and l.r >= ctl.x+ctl.w) or (l.l <= ctl.x+ctl.w and l.r >= ctl.x)) and ((l.t <= ctl.y and l.b >= ctl.y+ctl.h) or (l.t <= ctl.y+ctl.h and l.b >= ctl.y)) then 
            
            if Switcher_CtlsHidden(cctl.switcher, cctl.grpid) == false then
              if ctl_select == nil then
                ctl_select = {} 
                ctl_select[1] = {ctl = i}
              else
                local cs = #ctl_select+1
                ctl_select[cs] = {}
                ctl_select[cs].ctl = i
                ctl_select[cs].relx = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].x - strips[tracks[track_select].strip][page].controls[i].x
                ctl_select[cs].rely = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].y - strips[tracks[track_select].strip][page].controls[i].y
              end
            end
          end
        end
      end
      
      if shift and ctl_select then

        if #strips[tracks[track_select].strip][page].graphics > 0 then
        
          for i = 1, #strips[tracks[track_select].strip][page].graphics do
            local g
            local gfxx = strips[tracks[track_select].strip][page].graphics[i]
            g = {x = gfxx.x - surface_offset.x + obj.sections[10].x,
                       y = gfxx.y - surface_offset.y + obj.sections[10].y,
                       w = gfxx.stretchw,
                       h = gfxx.stretchh}
            if ((l.l <= g.x and l.r >= g.x+g.w) or (l.l <= g.x+g.w and l.r >= g.x)) and ((l.t <= g.y and l.b >= g.y+g.h) or (l.t <= g.y+g.h and l.b >= g.y)) then 

              if Switcher_CtlsHidden(gfxx.switcher, gfxx.grpid) == false then
                if gfx3_select == nil then
                  gfx3_select = {}
                end 
                local cs = #gfx3_select+1
                gfx3_select[cs] = {}
                gfx3_select[cs].ctl = i
                gfx3_select[cs].relx = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].x - strips[tracks[track_select].strip][page].graphics[i].x
                gfx3_select[cs].rely = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].y - strips[tracks[track_select].strip][page].graphics[i].y
              end
            end
          end
        end
      
      
      end
    end
  end

  ------------------------------------------------------------    
  
  function CheckDataTables()
  
    Snapshots_Check(tracks[track_select].strip,page)
    Macros_Check(tracks[track_select].strip,page)
    Faders_Check(tracks[track_select].strip,page)
    CheckFaders()
    Switcher_Check()
    SetCtlBitmapRedraw()
    update_gfx = true
    update_bg = true
    
  end

  function DeleteSelectedCtls()
    local i
    local switchdel = false
    local delswitches = {}
    if ctl_select then
      local cnt = #strips[tracks[track_select].strip][page].controls
      for i = 1, #ctl_select do
        local ctl = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl]
        if ctl.ctlcat == ctlcats.switcher then
          if switchers[ctl.switcherid] then
            switchdel = true
            switchers[ctl.switcherid].grpids = {}
            switchers[ctl.switcherid].current = -1
            switchers[ctl.switcherid].deleted = true
          end
        end
        strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl] = nil
      end
      local tbl = {}
      for i = 1, cnt do
        if strips[tracks[track_select].strip][page].controls[i] ~= nil then
          table.insert(tbl, strips[tracks[track_select].strip][page].controls[i])
        end
      end
      strips[tracks[track_select].strip][page].controls = tbl
      
     -- Snapshots_Check(tracks[track_select].strip,page)
     -- Macros_Check(tracks[track_select].strip,page)
     -- Faders_Check(tracks[track_select].strip,page)
      
      ctl_select = nil
      
     -- SetCtlBitmapRedraw()
      
    end  
    
    if gfx3_select then
      local cnt = #strips[tracks[track_select].strip][page].graphics
      for i = 1, #gfx3_select do
        strips[tracks[track_select].strip][page].graphics[gfx3_select[i].ctl] = nil
      end
      local tbl = {}
      for i = 1, cnt do
        if strips[tracks[track_select].strip][page].graphics[i] ~= nil then
          table.insert(tbl, strips[tracks[track_select].strip][page].graphics[i])
        end
      end
      strips[tracks[track_select].strip][page].graphics = tbl
      gfx3_select = nil
    end  

    if gfx2_select then
      local cnt = #strips[tracks[track_select].strip][page].graphics
      strips[tracks[track_select].strip][page].graphics[gfx2_select] = nil
      local tbl = {}
      for i = 1, cnt do
        if strips[tracks[track_select].strip][page].graphics[i] ~= nil then
          table.insert(tbl, strips[tracks[track_select].strip][page].graphics[i])
        end
      end
      strips[tracks[track_select].strip][page].graphics = tbl
      gfx2_select = nil
    end  

    if switchdel == true then
    
      local ret = reaper.MB('Delete all child controls of removed strip switcher?', 'Remove Child Controls', 4)
      if ret == 6 then
        --yes
        local cnt = #strips[tracks[track_select].strip][page].controls
        for c = 1, cnt do
          local ctl = strips[tracks[track_select].strip][page].controls[c]
          _, deleted = Switcher_CtlsDeleted(ctl.switcher,ctl.grpid)
          --DBG(c..'  '..tostring(deleted))
          if deleted == true then
            strips[tracks[track_select].strip][page].controls[c] = nil
          end
        end
        
        local tbl = {}
        for i = 1, cnt do
          if strips[tracks[track_select].strip][page].controls[i] ~= nil then
            table.insert(tbl, strips[tracks[track_select].strip][page].controls[i])
          end
        end
        strips[tracks[track_select].strip][page].controls = tbl

        local cnt = #strips[tracks[track_select].strip][page].graphics
        for c = 1, cnt do
          local ctl = strips[tracks[track_select].strip][page].graphics[c]
          _, deleted = Switcher_CtlsDeleted(ctl.switcher,ctl.grpid)
          if deleted == true then
            strips[tracks[track_select].strip][page].graphics[c] = nil
          end
        end
        
        local tbl = {}
        for i = 1, cnt do
          if strips[tracks[track_select].strip][page].graphics[i] ~= nil then
            table.insert(tbl, strips[tracks[track_select].strip][page].graphics[i])
          end
        end
        strips[tracks[track_select].strip][page].graphics = tbl
        
        
      else
        --no - check switcher controls first
        local cnt = #strips[tracks[track_select].strip][page].controls
        for c = 1, cnt do
          local ctl = strips[tracks[track_select].strip][page].controls[c]
          if ctl.ctlcat == ctlcats.switcher then
            _, deleted = Switcher_CtlsDeleted(ctl.switcher,ctl.grpid)
            if deleted == true then
              strips[tracks[track_select].strip][page].controls[c].switcher = nil
            end
          end
        end
        -- check rest of controls
        local cnt = #strips[tracks[track_select].strip][page].controls
        for c = 1, cnt do
          local ctl = strips[tracks[track_select].strip][page].controls[c]
          _, deleted = Switcher_CtlsDeleted(ctl.switcher,ctl.grpid)
          if deleted == true then
            strips[tracks[track_select].strip][page].controls[c].switcher = nil
          end
        end
        local cnt = #strips[tracks[track_select].strip][page].graphics
        for c = 1, cnt do
          local ctl = strips[tracks[track_select].strip][page].graphics[c]
          _, deleted = Switcher_CtlsDeleted(ctl.switcher,ctl.grpid)
          if deleted == true then
            strips[tracks[track_select].strip][page].graphics[c].switcher = nil
          end
        end        
      end
    end

    CheckDataTables()
    
  end

  ------------------------------------------------------------    

  --[[function EditSSName(eb)
  
    local sizex,sizey = 400,200
    editbox={title = 'Please enter new snapshot name:',
      x=400, y=100, w=120, h=20, l=4, maxlen=20,
      fgcol=0x000000, fgfcol=0x00FF00, bgcol=0x808080,
      txtcol=0x000000, curscol=0x000000,
      font=1, fontsz=14, caret=0, sel=0, cursstate=0,
      text="", 
      hasfocus=true
    }
    
    EB_Open = eb  
  
  end]]

  function EditSubName(txt)
  
    if sstype_select > 1 then
      if snapshots and snapshots[tracks[track_select].strip] and snapshots[tracks[track_select].strip][page][sstype_select] then
        snapshots[tracks[track_select].strip][page][sstype_select].subsetname = txt
        snapsubsets_table[sstype_select] = txt
      end    
    end
  
  end
  
  function EditSSName2(txt)

    if sstype_select == 1 then
      if ss_select and snapshots and snapshots[tracks[track_select].strip] and snapshots[tracks[track_select].strip][page][sstype_select][ss_select] then
        snapshots[tracks[track_select].strip][page][sstype_select][ss_select].name = txt
      end
    elseif sstype_select > 1 then
      if ss_select and snapshots and snapshots[tracks[track_select].strip] and snapshots[tracks[track_select].strip][page][sstype_select].snapshot[ss_select] then
        snapshots[tracks[track_select].strip][page][sstype_select].snapshot[ss_select].name = txt
      end    
    end
  end
  
  function DeleteSS()
  
    if sstype_select == 1 then
      if ss_select and snapshots and snapshots[tracks[track_select].strip] and snapshots[tracks[track_select].strip][page][sstype_select][ss_select] then
      
        local cnt = #snapshots[tracks[track_select].strip][page][sstype_select]
        snapshots[tracks[track_select].strip][page][sstype_select][ss_select] = nil
        local tbl = {}
        for i = 1, cnt do
          if snapshots[tracks[track_select].strip][page][sstype_select][i] ~= nil then
            table.insert(tbl, snapshots[tracks[track_select].strip][page][sstype_select][i])
          end
        end
        snapshots[tracks[track_select].strip][page][sstype_select] = tbl
        ss_select = nil
        
      end
    elseif sstype_select > 1 then
      if ss_select and snapshots and snapshots[tracks[track_select].strip] and snapshots[tracks[track_select].strip][page][sstype_select].snapshot[ss_select] then
      
        local cnt = #snapshots[tracks[track_select].strip][page][sstype_select].snapshot
        snapshots[tracks[track_select].strip][page][sstype_select].snapshot[ss_select] = nil
        local tbl = {}
        for i = 1, cnt do
          if snapshots[tracks[track_select].strip][page][sstype_select].snapshot[i] ~= nil then
            table.insert(tbl, snapshots[tracks[track_select].strip][page][sstype_select].snapshot[i])
          end
        end
        snapshots[tracks[track_select].strip][page][sstype_select].snapshot = tbl
        DeleteXXY(ss_select)
        ss_select = nil
        
      end    
    end    
  end
  
  function DeleteXXY(ss)
    
      if sstype_select == 1 then
        
      elseif sstype_select > 1 then
        local strip = tracks[track_select].strip
        if xxy and xxy[strip] and xxy[strip][page] and xxy[strip][page][sstype_select] then
        
          local cnt = #xxy[strip][page][sstype_select].points
          local tbl = {}
          for i = 1, cnt do
            if xxy[strip][page][sstype_select].points[i].ss ~= ss then
              if xxy[strip][page][sstype_select].points[i].ss > ss then
                xxy[strip][page][sstype_select].points[i].ss = xxy[strip][page][sstype_select].points[i].ss-1
              end
              table.insert(tbl, xxy[strip][page][sstype_select].points[i])
            else
              --DBG('deleted')
            end
          end
          xxy[strip][page][sstype_select].points = tbl
          --ss_select = nil
          
        end    
      end    
    end

  function XXY_PtToggleActive(pt)
  
    if sstype_select == 1 then
      
    elseif sstype_select > 1 then
      local strip = tracks[track_select].strip
      if xxy and xxy[strip] and xxy[strip][page] and xxy[strip][page][sstype_select] then
      
        xxy[strip][page][sstype_select].points[pt].inactive = not nz(xxy[strip][page][sstype_select].points[pt].inactive,false)
        XXY_Set(strip, page, sstype_select)
        update_xxypos = true 
      end
    end  
  
  end
  
  function DeleteXXY_pt(pt)
    
    if sstype_select == 1 then
      
    elseif sstype_select > 1 then
      local strip = tracks[track_select].strip
      if xxy and xxy[strip] and xxy[strip][page] and xxy[strip][page][sstype_select] then
      
        local cnt = #xxy[strip][page][sstype_select].points
        local tbl = {}
        for i = 1, cnt do
          if i ~= pt then
            table.insert(tbl, xxy[strip][page][sstype_select].points[i])
          end
        end
        xxy[strip][page][sstype_select].points = tbl
        ss_select = nil
        
      end    
    end    
  end
    
  ------------------------------------------------------------    
  
  function OpenEB(eb, t, def)

    local sizex,sizey = 400,200
    
    if def == nil then
      def = ""
    end
    
    editbox={title = t,
      x=400, y=100, w=120, h=20, l=4, maxlen=99,
      fgcol=0x000000, fgfcol=0x00FF00, bgcol=0x808080,
      txtcol=0x000000, curscol=0x000000,
      font=1, fontsz=14, caret=string.len(def), sel=-string.len(def), cursstate=0,
      text=def, 
      hasfocus=true
    }
    
    EB_Open = eb
  
  end
  
  ------------------------------------------------------------    
  
  function EditValue2(txt)

    if strips[tracks[track_select].strip][page].controls[trackfxparam_select].ctlcat == ctlcats.snapshot then
    
      local sst = strips[tracks[track_select].strip][page].controls[trackfxparam_select].param
      
      txt = string.upper(txt)..' '
  
      local temp_t = {}
      for word in string.gmatch(txt, '(.-)[%s]') do table.insert(temp_t, word) end
      local fnd_ss = -1
      if sst == 1 then
        if snapshots[tracks[track_select].strip][page][sst] and #snapshots[tracks[track_select].strip][page][sst] > 0 then
          for i = 1, #snapshots[tracks[track_select].strip][page][sst] do

            local nm = string.upper(snapshots[tracks[track_select].strip][page][sst][i].name)
            local match = true
            for w = 1, #temp_t do            
              local m = string.match(nm,temp_t[w])
              if m == nil then
                match = false
                break
              end
            end
                      
            if match then
              fnd_ss = i
              break
            end
          
          end
          if fnd_ss > -1 then
            if sst == sstype_select then 
              sstype_select = sst
              ss_select = fnd_ss
            end
            Snapshot_Set(tracks[track_select].strip, page, sst, fnd_ss)
            update_gfx = true
          end
        end
      elseif sst > 1 then
        if snapshots[tracks[track_select].strip][page][sst] and #snapshots[tracks[track_select].strip][page][sst].snapshot > 0 then
          for i = 1, #snapshots[tracks[track_select].strip][page][sst].snapshot do

            local nm = string.upper(snapshots[tracks[track_select].strip][page][sst].snapshot[i].name)
            local match = true
            for w = 1, #temp_t do
              local m = string.match(nm,temp_t[w])
              if m == nil then
                match = false
                break
              end
            end
                      
            if match then
              fnd_ss = i
              break
            end
          
          end
          if fnd_ss > -1 then
            if sst == sstype_select then 
              sstype_select = sst
              ss_select = fnd_ss
            end
            Snapshot_Set(tracks[track_select].strip, page, sst, fnd_ss)
            update_gfx = true
          end
        end
      
      end
    
    elseif strips[tracks[track_select].strip][page].controls[trackfxparam_select].ctlcat == ctlcats.macro then
      local v = tonumber(txt)
      if v then
        strips[tracks[track_select].strip][page].controls[trackfxparam_select].val = F_limit(v,0,1)
        strips[tracks[track_select].strip][page].controls[trackfxparam_select].dirty = true
        SetParam()
      end
          
    else
      if strips[tracks[track_select].strip][page].controls[trackfxparam_select].ctltype == 4 then
        --cycle
        if strips[tracks[track_select].strip][page].controls[trackfxparam_select].cycledata.statecnt > 0 then
          for i = 1, strips[tracks[track_select].strip][page].controls[trackfxparam_select].cycledata.statecnt do
          
            if string.upper(txt) == string.sub(string.upper(strips[tracks[track_select].strip][page].controls[trackfxparam_select].cycledata[i].dispval),1,string.len(txt)) then
            
              strips[tracks[track_select].strip][page].controls[trackfxparam_select].cycledata.pos = i
              strips[tracks[track_select].strip][page].controls[trackfxparam_select].val = 
                  strips[tracks[track_select].strip][page].controls[trackfxparam_select].cycledata[i].val
              SetParam()
              strips[tracks[track_select].strip][page].controls[trackfxparam_select].dirty = true
              update_ctls = true
              break
            end
          
          end
        
        end
      else
        local mo = tonumber(txt)
        if mo then
          local nval = GetValFromDVal(trackfxparam_select,txt)
          --for i = 1, #ctl_select do 
          strips[tracks[track_select].strip][page].controls[trackfxparam_select].val = nval
          strips[tracks[track_select].strip][page].controls[trackfxparam_select].dirty = true
          SetParam()
          --end
        end  
      end
    end

  end

  function EditCycleDV(txt)

    cycle_select[cycle_select.selected].dispval = txt

  end

  function EditMinDVal2(txt)

    local mo = tonumber(txt)
    if mo then
      --local test = GetValFromDVal(ctl_select[1].ctl,txt,true)
      minov_select = mo
      for i = 1, #ctl_select do 
        strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].minov = minov_select
      end
    end  
  end

  function EditMaxDVal2(txt)

    local mo = tonumber(txt)
    if mo then
      --local test = GetValFromDVal(ctl_select[1].ctl,txt,false)
      maxov_select = mo
      for i = 1, #ctl_select do 
        strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].maxov = maxov_select
      end
    end  
  end

  function EditDValOffset2(txt)

    local dv = tonumber(txt)
    if dv then
      dvaloff_select = dv
      if ctl_select then
        for i = 1, #ctl_select do 
          strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].dvaloffset = dv
        end
      end
    else
      dvaloff_select = ''
      if ctl_select then
        for i = 1, #ctl_select do 
          strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].dvaloffset = nil
        end    
      end
    end  
  end

  function EditCtlName2(txt)

    for i = 1, #ctl_select do
      strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ctlname_override = txt
    end
    
  end
  
  function SaveStrip()
  
    if strips and strips[tracks[track_select].strip] then
  
      local verify = true
      if strips[tracks[track_select].strip][page].controls and #strips[tracks[track_select].strip][page].controls > 0 then
      
        for i = 1, #strips[tracks[track_select].strip][page].controls do
          if strips[tracks[track_select].strip][page].controls[i].fxfound == false then
            verify = false
            break
          end
        end
        
          OpenEB(1,'Please enter a filename for the strip:')
          
      else
        OpenMsgBox(1, 'No controls on strip.', 1)
      end
    else
      OpenMsgBox(1, 'No controls on strip.', 1)
    end
    
  end

  --new version
  function SaveStrip3(fn)

    --test
    
    if fn and string.len(fn)>0 then
      local save_path=strips_path..strip_folders[stripfol_select].fn..'/'
      local fn=save_path..fn..".strip"  
      local file
      file=io.open(fn,"w")


      local tr = GetTrack(strips[tracks[track_select].strip].track.tracknum)
      local i, j
      local fxcnt = 1
      local fxtbl = {}
      local _, chunk = reaper.GetTrackStateChunk(tr,'',false)
      for i = 0, reaper.TrackFX_GetCount(tr)-1 do
        if settings_saveallfxinststrip then 
          --local _, fxname = reaper.TrackFX_GetFXName(tr, i, '')
          local _, fxchunk = GetFXChunkFromTrackChunk(chunk, i+1)
          --local fxn = GetPlugNameFromChunk(fxchunk)
          fxtbl[i+1] = {fxname = nil,
                        fxchunk = fxchunk,
                        fxguid = convertguid(reaper.TrackFX_GetFXGUID(tr, i)),
                        fxenabled = reaper.TrackFX_GetEnabled(tr, i)
                        }
        else
          --check fx has controls in strip
          local instrip = false
          for j = 1, #strips[tracks[track_select].strip][page].controls do
            if reaper.TrackFX_GetFXGUID(tr, i) == strips[tracks[track_select].strip][page].controls[j].fxguid then
              instrip = true
              break
            end
            if strips[tracks[track_select].strip][page].controls[j].ctlcat == ctlcats.eqcontrol then
              local bands = strips[tracks[track_select].strip][page].controls[j].eqbands
              if bands and #bands > 0 then
                for b = 1, #bands do
                
                  if reaper.TrackFX_GetFXGUID(tr, i) == bands[b].fxguid then
                    instrip = true
                    break                  
                  end
                
                end
                if instrip then
                  break
                end
              end
            end
          end
          if instrip then
            --local _, fxname = reaper.TrackFX_GetFXName(tr, i, '')
            local _, fxchunk = GetFXChunkFromTrackChunk(chunk, i+1)
            --local fxn = GetPlugNameFromChunk(fxchunk)
            fxtbl[fxcnt] = {fxname = nil,
                            fxchunk = fxchunk,
                            fxguid = convertguid(reaper.TrackFX_GetFXGUID(tr, i)),
                            fxenabled = reaper.TrackFX_GetEnabled(tr, i)
                            }          
            fxcnt = fxcnt + 1
          end
        end
      end
    
      --check tracknums
      for j = 1, #strips[tracks[track_select].strip][page].controls do
        local ctl = strips[tracks[track_select].strip][page].controls[j]
        if ctl.tracknum and ctl.tracknum == strips[tracks[track_select].strip].track.tracknum then
          ctl.tracknum = nil
        end
      end
    
      local savestrip = {}
      local switchtab = {}
      local saveswitchers = {}
      local switchcnt = 1
      
      for j = 1, #strips[tracks[track_select].strip][page].controls do
        local ctl = strips[tracks[track_select].strip][page].controls[j]
        if ctl.ctlcat == ctlcats.pkmeter then
          ctl.val = -150
        end
        
        if ctl.ctlcat == ctlcats.switcher then
          switchtab[ctl.switcherid] = switchcnt
          saveswitchers[switchcnt] = switchers[ctl.switcherid]
          --savestrip.strip.controls[i].switcherid = switchcnt -- eek
          switchcnt = switchcnt + 1    
        end
      end
      
      savestrip.switchers = saveswitchers
      savestrip.switchconvtab = switchtab
      savestrip.fx = fxtbl
      local pickledfx = pickle(savestrip)
    
      file:write('[STRIPFILE_VERSION]5\n')
      file:write('[FXDATA]\n'..pickledfx..'\n[\\FXDATA]\n')
      file:write('[STRIPDATA]\n')      
      local t = GenStripSaveData2(strips[tracks[track_select].strip][page],nil,file)
      file:write('[\\STRIPDATA]\n')      
      
      if snapshots and snapshots[tracks[track_select].strip] then
        file:write('[SNAPSHOTDATA]\n')      
        SaveSnapshotDataX(tracks[track_select].strip,page,nil,file)
        file:write('[\\SNAPSHOTDATA]\n')      
      end
      --if t then
      --  DBG(t)
      --end
      file:close()

      OpenMsgBox(1,'Strip saved.',1)
      
    else
      return nil
    end
    PopulateStrips()

  end
      
    --OLD NEVER RUNS
--[[
    if fn and string.len(fn)>0 then
      local tr = GetTrack(strips[tracks[track_select].strip].track.tracknum)
      local i, j
      local fxcnt = 1
      local fxtbl = {}
      local _, chunk = reaper.GetTrackStateChunk(tr,'',false)
      for i = 0, reaper.TrackFX_GetCount(tr)-1 do
        if settings_saveallfxinststrip then 
          --local _, fxname = reaper.TrackFX_GetFXName(tr, i, '')
          local _, fxchunk = GetFXChunkFromTrackChunk(chunk, i+1)
          --local fxn = GetPlugNameFromChunk(fxchunk)
          fxtbl[i+1] = {fxname = nil,
                        fxchunk = fxchunk,
                        fxguid = convertguid(reaper.TrackFX_GetFXGUID(tr, i)),
                        fxenabled = reaper.TrackFX_GetEnabled(tr, i)
                        }
        else
          --check fx has controls in strip
          local instrip = false
          for j = 1, #strips[tracks[track_select].strip][page].controls do
            if reaper.TrackFX_GetFXGUID(tr, i) == strips[tracks[track_select].strip][page].controls[j].fxguid then
              instrip = true
              break
            end
            if strips[tracks[track_select].strip][page].controls[j].ctlcat == ctlcats.eqcontrol then
              local bands = strips[tracks[track_select].strip][page].controls[j].eqbands
              if bands and #bands > 0 then
                for b = 1, #bands do
                
                  if reaper.TrackFX_GetFXGUID(tr, i) == bands[b].fxguid then
                    instrip = true
                    break                  
                  end
                
                end
                if instrip then
                  break
                end
              end
            end
          end
          if instrip then
            --local _, fxname = reaper.TrackFX_GetFXName(tr, i, '')
            local _, fxchunk = GetFXChunkFromTrackChunk(chunk, i+1)
            --local fxn = GetPlugNameFromChunk(fxchunk)
            fxtbl[fxcnt] = {fxname = nil,
                            fxchunk = fxchunk,
                            fxguid = convertguid(reaper.TrackFX_GetFXGUID(tr, i)),
                            fxenabled = reaper.TrackFX_GetEnabled(tr, i)
                            }          
            fxcnt = fxcnt + 1
          end
        end
      end

      --check tracknums
      for j = 1, #strips[tracks[track_select].strip][page].controls do
        local ctl = strips[tracks[track_select].strip][page].controls[j]
        if ctl.tracknum and ctl.tracknum == strips[tracks[track_select].strip].track.tracknum then
          ctl.tracknum = nil
        end
      end
    
      savestrip = {}
      savestrip.version = 3
      savestrip.strip = strips[tracks[track_select].strip][page]
      savestrip.fx = fxtbl
      if snapshots and snapshots[tracks[track_select].strip] then
        savestrip.snapshots = snapshots[tracks[track_select].strip][page]
      end
      
      local t = reaper.time_precise()
      
      local switchtab = {}
      local saveswitchers = {}
      local switchcnt = 1
      
      --Pickle doesn't like {} in strings (much) - remove before pickling
      for i = 1, #savestrip.strip.controls do
        savestrip.strip.controls[i].fxguid = convertguid(savestrip.strip.controls[i].fxguid)
        if savestrip.strip.controls[i].ctlcat == ctlcats.pkmeter then
          savestrip.strip.controls[i].val = -150
        end
        
        if savestrip.strip.controls[i].ctlcat == ctlcats.switcher then
          switchtab[savestrip.strip.controls[i].switcherid] = switchcnt
          saveswitchers[switchcnt] = switchers[savestrip.strip.controls[i].switcherid]
          --savestrip.strip.controls[i].switcherid = switchcnt -- eek
          switchcnt = switchcnt + 1    
        end
      end
      savestrip.switchers = saveswitchers
      savestrip.switchconvtab = switchtab
  
      local save_path=strips_path..strip_folders[stripfol_select].fn..'/'
      local fn=save_path..fn..".strip"
    
      local DELETE=true
      local file
      
      if reaper.file_exists(fn) then
      
      end
      
      if DELETE then
        file=io.open(fn,"w")
        local pickled_table=pickle(savestrip)
        file:write(pickled_table)
        file:close()
      end

      --reinstate {} after pickling
      for i = 1, #savestrip.strip.controls do
        if savestrip.strip.controls[i].fxguid then
          savestrip.strip.controls[i].fxguid = '{'..savestrip.strip.controls[i].fxguid..'}'
        end
      end

      --DBG('pickke time: '..reaper.time_precise()-t)
      OpenMsgBox(1,'Strip saved.',1)

    end
    PopulateStrips()]]
    
  --end

  --[[function SaveStrip2(fn)

    if fn and string.len(fn)>0 then
      local tr = GetTrack(strips[tracks[track_select].strip].track.tracknum)
      local i, j
      local fxcnt = 1
      local fxtbl = {}
      local _, chunk = reaper.GetTrackStateChunk(tr,'',false)
      for i = 0, reaper.TrackFX_GetCount(tr)-1 do
        if settings_saveallfxinststrip then 
          --local _, fxname = reaper.TrackFX_GetFXName(tr, i, '')
          local fxchunk = GetChunkPresetData(chunk, i)
          local fxn = GetPlugNameFromChunk(fxchunk)
          fxtbl[i+1] = {fxname = fxn,
                        fxchunk = fxchunk,
                        fxguid = convertguid(reaper.TrackFX_GetFXGUID(tr, i)),
                        fxenabled = reaper.TrackFX_GetEnabled(tr, i)
                        }
        else
          --check fx has controls in strip
          local instrip = false
          for j = 1, #strips[tracks[track_select].strip][page].controls do
            if reaper.TrackFX_GetFXGUID(tr, i) == strips[tracks[track_select].strip][page].controls[j].fxguid then
              instrip = true
              break
            end
          end
          if instrip then
            --local _, fxname = reaper.TrackFX_GetFXName(tr, i, '')
            local fxchunk = GetChunkPresetData(chunk, i)
            local fxn = GetPlugNameFromChunk(fxchunk)
            fxtbl[fxcnt] = {fxname = fxn,
                            fxchunk = fxchunk,
                            fxguid = convertguid(reaper.TrackFX_GetFXGUID(tr, i)),
                            fxenabled = reaper.TrackFX_GetEnabled(tr, i)
                            }          
            fxcnt = fxcnt + 1
          end
        end
      end
    
      savestrip = {}
      savestrip.strip = strips[tracks[track_select].strip][page]
      savestrip.fx = fxtbl
      if snapshots and snapshots[tracks[track_select].strip] then
        savestrip.snapshots = snapshots[tracks[track_select].strip][page]
      end
      
      --Pickle doesn't like {} in strings (much) - remove before pickling
      for i = 1, #savestrip.strip.controls do
        savestrip.strip.controls[i].fxguid = convertguid(savestrip.strip.controls[i].fxguid)
        if savestrip.strip.controls[i].ctlcat == ctlcats.pkmeter then
          savestrip.strip.controls[i].val = -150
        end
      end
  
      local save_path=strips_path..strip_folders[stripfol_select].fn..'/'
      local fn=save_path..fn..".strip"
    
      local DELETE=true
      local file
      
      if reaper.file_exists(fn) then
      
      end
      
      if DELETE then
        file=io.open(fn,"w")
        local pickled_table=pickle(savestrip)
        file:write(pickled_table)
        file:close()
      end

      --reinstate {} after pickling
      for i = 1, #savestrip.strip.controls do
        if savestrip.strip.controls[i].fxguid then
          savestrip.strip.controls[i].fxguid = '{'..savestrip.strip.controls[i].fxguid..'}'
        end
      end

      OpenMsgBox(1,'Strip saved.',1)

    end
    PopulateStrips()
    
  end]]
  
  function GetPlugNameFromChunk(fxchunk)

    local fxn
    if string.sub(fxchunk,1,3) == 'VST' then
      fxn = string.match(fxchunk, '.*: (.-) %(')
      if fxn == nil then
        fxn = string.match(fxchunk, '.*: (.-)%"')      
      end
    elseif string.sub(fxchunk,1,2) == 'JS' then
      fxn = string.match(fxchunk, 'JS.*%/+(.-) \"')
      if fxn == nil then
        fxn = string.match(fxchunk, 'JS%s(.-)%s')  -- gets full path of effect
        fxn = string.match(fxn, '([^/]+)$') -- gets filename  
      end
      --remove final " if exists
      if string.sub(fxn,string.len(fxn)) == '"' then
        fxn = string.sub(fxn,1,string.len(fxn)-1)
      end
      
      --[[if fxn == nil then
        --JS \"AB Level Matching JSFX [2.5]/AB_LMLT_cntrl\" \"MSTR /B\"\
        fxn = string.match(fxchunk, 'JS.*%/(.-)%"%\"')
        fxn = string.sub(fxn,1,string.len(fxn)-2)
      end]]
    end
  
    return fxn
    
  end
  
  function GenID()
  
    local l = false
    local id
    while l == false do
      id = math.floor(math.random() * 0xFFFFFFFF)
      if g_cids[id] == nil then
        g_cids[id] = true
        l = true
      end
    end
    --DBG(id)
    return id
    
  end

  function LoadStripShareFN(sfn,ffn)
  
    local content, sharestripdata
    local stripdata = nil
    local load_path, fn
    if ffn == nil then
      load_path=strips_path
      fn=load_path..sfn
    else
      fn = ffn
    end

    if reaper.file_exists(fn) then

      local find = string.find
      local match = string.match
      local file
      file=io.open(fn,"r")
      content=file:read("*a")
      file:close()
      local _,e = find(content,'.-\n')
      local line = string.sub(content,0,e)
      local newvers = string.match(line,'[[STRIPSHAREFILE_VERSION]](%d)')
      if newvers then
      
        --DBG(newvers)
        local sharedata = match(content,'%[SHAREDATA%](.-)%[\\SHAREDATA%]')
        sharestripdata = match(content,'%[SHARESTRIPDATA%]\n(.-)%[\\SHARESTRIPDATA%]')
        
        local fxdata = match(content,'%[FXDATA%](.-)%[\\FXDATA%]')
        local stripcontent = match(sharestripdata,'%[STRIPDATA%](.-)%[\\STRIPDATA%]')
        local snapcontent = match(sharestripdata,'%[SNAPSHOTDATA%](.-)%[\\SNAPSHOTDATA%]')
        
        --SNAPSHOTS --only load if strip imported?
        if fxdata and stripcontent then
          stripdata = unpickle(fxdata)
          stripdata.sharedata = unpickle(sharedata)
          stripdata.version = tonumber(newvers)
          stripdata.snapcontent = snapcontent
          local data = {}
          local cnt = 0          
          local lines = split(stripcontent, "\n")
          if lines and #lines > 0 then
            for ln = 1, #lines do
              local idx, val = match(lines[ln],'%[(.-)%](.*)') 
              if idx then
                data[idx] = val
              end
            end
          end
          stripdata.strip = LoadStripDataX(nil,data)

          if snapcontent then
            local data = {}
            local cnt = 0          
            local lines = split(snapcontent, "\n")
            if lines and #lines > 0 then
              for ln = 1, #lines do
                local idx, val = match(lines[ln],'%[(.-)%](.*)') 
                if idx then
                  data[idx] = val
                end
              end
            end
            stripdata.snapshots = LoadSnapDataX(nil,data)
          end
        end
      
      else
        stripdata = unpickle(content)
      end
      
      if newvers == nil or tonumber(newvers) < 2 then
      
        --DBG('compat a')
        --compatibility
        local ctls = stripdata.strip.controls
        if ctls and #ctls > 0 then
        
          for c = 1, #ctls do
            gfx.setfont(1, ctls[c].font, gui.fontsz_knob + ctls[c].textsize-4)
            local _, th = gfx.measurestr('|')
            ctls[c].textoff = ctls[c].textoff - math.floor(th/2)
          end
        
        end
      
      end
    else
      OpenMsgBox(1,'File not found.',1)
    end
    return stripdata, sharestripdata
  
  end
  
  function LoadStrip(strip_select)
  
    local find = string.find
    local match = string.match
    
    local stripdata = nil
    local load_path=strips_path
    local fn=load_path..strip_folders[stripfol_select].fn..'/'..strip_files[strip_select].fn
    if reaper.file_exists(fn) then
    
      GUI_DrawMsgX(obj, gui, 'Generating Preview...')
    
      local file
      file=io.open(fn,"r")
      local content=file:read("*a")
      file:close()
      local _,e = find(content,'.-\n')
      local line = string.sub(content,0,e)
      local newvers = match(line,'[[STRIPFILE_VERSION]](%d)')
      if newvers then
        --DBG(newvers)
        local pickledcontent = match(content,'%[FXDATA%](.-)%[\\FXDATA%]')
        local stripcontent = match(content,'%[STRIPDATA%](.-)%[\\STRIPDATA%]')
        local snapcontent = match(content,'%[SNAPSHOTDATA%](.-)%[\\SNAPSHOTDATA%]')
        --SNAPSHOTS --only load if strip imported?
        if pickledcontent and stripcontent then
          stripdata = unpickle(pickledcontent)
          stripdata.version = tonumber(newvers)
          stripdata.snapcontent = snapcontent
          local data = {}
          local cnt = 0          
          local lines = split(stripcontent, "\n")
          if lines and #lines > 0 then
            for ln = 1, #lines do
              local idx, val = match(lines[ln],'%[(.-)%](.*)') 
              if idx then
                data[idx] = val
              end
            end
          end
          stripdata.strip = LoadStripDataX(nil,data)
        end
        --return nil --remove
      else
        stripdata = unpickle(content)
      end
      
      if newvers == nil or tonumber(newvers) < 5 then
        --compatibility
        --DBG('compat b')
        
        local ctls = stripdata.strip.controls
        if ctls and #ctls > 0 then
        
          for c = 1, #ctls do
            gfx.setfont(1, ctls[c].font, gui.fontsz_knob + ctls[c].textsize-4)
            local _, th = gfx.measurestr('|')
            ctls[c].textoff = ctls[c].textoff - math.floor(th/2)
          end
        
        end
        
        local gfx = stripdata.strip.graphics
        if gfx and #gfx > 0 then
        
          for g = 1, #gfx do
        
            if gfx[g].stretchmode == nil then gfx[g].stretchmode = 1 end
            if gfx[g].edgesz == nil then gfx[g].edgesz = 8 end              
        
          end
        end
        
      end
    else
      OpenMsgBox(1,'File not found.',1)
    end
    return stripdata
  
  end

  function LoadStripFN(sfn, ffn, skipcompat)
    local find = string.find
    local match = string.match
    
    local content
    local stripdata = nil
    local load_path, fn
    if ffn == nil then
      load_path=strips_path
      fn=load_path..sfn
    else
      fn = ffn
    end

    if reaper.file_exists(fn) then
      local file
      file=io.open(fn,"r")
      content=file:read("*a")
      file:close()
      local _,e = find(content,'.-\n')
      local line = string.sub(content,0,e)
      local newvers = match(line,'[[STRIPFILE_VERSION]](%d)')
      if newvers then
        --DBG(newvers)
        local pickledcontent = match(content,'%[FXDATA%](.-)%[\\FXDATA%]')
        local stripcontent = match(content,'%[STRIPDATA%](.-)%[\\STRIPDATA%]')
        local snapcontent = match(content,'%[SNAPSHOTDATA%](.-)%[\\SNAPSHOTDATA%]')
        --SNAPSHOTS --only load if strip imported?
        if pickledcontent and stripcontent then
          stripdata = unpickle(pickledcontent)
          stripdata.version = tonumber(newvers)
          stripdata.snapcontent = snapcontent
          local data = {}
          local cnt = 0          
          local lines = split(stripcontent, "\n")
          if lines and #lines > 0 then
            for ln = 1, #lines do
              local idx, val = match(lines[ln],'%[(.-)%](.*)') 
              if idx then
                data[idx] = val
              end
            end
          end
          stripdata.strip = LoadStripDataX(nil,data)
        end
        --return nil --remove
      else
        stripdata = unpickle(content)
      end
      
      if nz(skipcompat,false) == false then
      --DBG('sc')
        if newvers == nil or tonumber(newvers) < 5 then
          --compatibility
          --DBG('compat c')
          
          local ctls = stripdata.strip.controls
          if ctls and #ctls > 0 then
          
            for c = 1, #ctls do
              gfx.setfont(1, ctls[c].font, gui.fontsz_knob + ctls[c].textsize-4)
              local _, th = gfx.measurestr('|')
              ctls[c].textoff = ctls[c].textoff - math.floor(th/2)
              
            end
          
          end

          local gfx = stripdata.strip.graphics
          if gfx and #gfx > 0 then
          
            for g = 1, #gfx do
        
              if gfx[g].stretchmode == nil then gfx[g].stretchmode = 1 end
              if gfx[g].edgesz == nil then gfx[g].edgesz = 8 end              
        
            end
          end
        end
      end
    else
      OpenMsgBox(1,'File not found.',1)
    end
    return stripdata, content
  
  end
  
  function Strip_AddStrip(stripdata, x, y, ignoregrid)
    if track_select == nil then return end
    if ignoregrid == nil then ignoregrid = false end
    
    local i, j
    local strip = Strip_INIT()
    
    local tr = GetTrack(strips[strip].track.tracknum)
    
    local fxcnt = reaper.TrackFX_GetCount(tr)
    local fxguids = {}
    
    
    if stripdata.version == nil then
      local retfx
      --create new fx
      local missing = 0
      for i = 1, #stripdata.fx do
    
        local fxn
        if stripdata.fx[i].fxname then
          fxn = stripdata.fx[i].fxname
        else
          fxn = GetPlugNameFromChunk(stripdata.fx[i].fxchunk)
        end
        if fxn then
          retfx = reaper.TrackFX_AddByName(tr, fxn, 0, -1)
        else
          retfx = -1
        end
        
        if retfx ~= -1 then      
          --set guid in stripdata.strip
          nguid = reaper.TrackFX_GetFXGUID(tr, fxcnt+i-1+missing)
          stripdata.fx[i].nfxguid = nguid
        else
          stripdata.fx[i].nfxguid = ''
          missing = missing + 1
        end
        
        for j = 1, #stripdata.strip.controls do
          if stripdata.strip.controls[j].fxguid == stripdata.fx[i].fxguid then
            stripdata.strip.controls[j].fxguid = stripdata.fx[i].nfxguid
            if stripdata.fx[i].nfxguid == '' then
              stripdata.strip.controls[j].fxfound = false
              stripdata.strip.controls[j].fxnum = -1
            else
              stripdata.strip.controls[j].fxfound = true
              stripdata.strip.controls[j].fxnum = fxcnt+(i-1)-missing
            end
          end
        end
        if retfx ~= -1 then
          local fxen = nz(stripdata.fx[i].fxenabled, true)
          reaper.TrackFX_SetEnabled(tr, fxcnt+i-1-missing, fxen)
        end
      end
      
      local _, chunk = reaper.GetTrackStateChunk(tr,'',false)
      missing = 0
      for i = 1, #stripdata.fx do
        if stripdata.fx[i].nfxguid ~= '' then
          chunk = ReplaceChunkPresetData(chunk, i-1+fxcnt-missing, stripdata.fx[i].fxchunk)
        else
          missing = missing + 1
        end
      end
      if chunk ~= nil then
        reaper.SetTrackStateChunk(tr, chunk, false)
      end

    elseif stripdata.version >= 3 then
    
      local rcmflag = false
    
      --V4? - Load snapshot data
      if stripdata.version >= 4 and stripdata.snapcontent then
        local snapcontent = stripdata.snapcontent
        local data = {}
        local cnt = 0          
        local lines = split(snapcontent, "\n")
        if lines and #lines > 0 then
          for ln = 1, #lines do
            local idx, val = string.match(lines[ln],'%[(.-)%](.*)') 
            if idx then
              data[idx] = val
            end
          end
        end
        stripdata.snapshots = LoadSnapDataX(nil,data)
      end
      
      local retfx
      --create new fx
      local missing = 0
      for i = 1, #stripdata.fx do
    
        local _, chunk = reaper.GetTrackStateChunk(tr,'',false)
        --DBG(stripdata.fx[i].fxchunk)
        local nchunk, nfxguid, ofxguid = Chunk_InsertFXChunkAtEndOfFXChain(strips[strip].track.tracknum, chunk, stripdata.fx[i].fxchunk)
        if nchunk ~= nil then
          local retval = reaper.SetTrackStateChunk(tr, nchunk, false)
          if retval == true then
            fxguids[ofxguid] = {guid = nfxguid, found = true, fxnum = fxcnt+i-1-missing}
          end
        end
        
        --check guid
        nguid = reaper.TrackFX_GetFXGUID(tr, fxcnt+i-1+missing)
        if nguid == nil then
          missing = missing + 1
          if fxguids[ofxguid] then
            fxguids[ofxguid].found = false
            fxguids[ofxguid].fxnum = -1
          end 
        end
        
      end
      
      for j = 1, #stripdata.strip.controls do
        if (stripdata.strip.controls[j].ctlcat == ctlcats.fxparam 
            or stripdata.strip.controls[j].ctlcat == ctlcats.fxoffline
            or stripdata.strip.controls[j].ctlcat == ctlcats.fxgui
            or stripdata.strip.controls[j].ctlcat == ctlcats.rcm_switch) 
            and stripdata.strip.controls[j].fxguid then
          if stripdata.version == 3 then
            stripdata.strip.controls[j].fxguid = '{'..stripdata.strip.controls[j].fxguid..'}'
          end
          if fxguids[stripdata.strip.controls[j].fxguid] then
            if fxguids[stripdata.strip.controls[j].fxguid].found then
              stripdata.strip.controls[j].fxfound = true
              stripdata.strip.controls[j].fxnum = fxguids[stripdata.strip.controls[j].fxguid].fxnum
              stripdata.strip.controls[j].fxguid = fxguids[stripdata.strip.controls[j].fxguid].guid
            else
              stripdata.strip.controls[j].fxguid = fxguids[stripdata.strip.controls[j].fxguid].guid
              stripdata.strip.controls[j].fxfound = false
              stripdata.strip.controls[j].fxnum = -1          
            end
          else
            stripdata.strip.controls[j].fxfound = false
            stripdata.strip.controls[j].fxnum = -1                  
          end
        else
          stripdata.strip.controls[j].fxfound = true
          stripdata.strip.controls[j].fxguid = nil
        end
        
        if (stripdata.strip.controls[j].ctlcat == ctlcats.rcm_switch) 
            and stripdata.strip.controls[j].rcmrefresh and stripdata.strip.controls[j].rcmrefresh.guid then
          stripdata.strip.controls[j].rcmrefresh.guid = fxguids[stripdata.strip.controls[j].rcmrefresh.guid].guid
          rcmflag = true
        end        
        
        if stripdata.strip.controls[j].ctlcat == ctlcats.eqcontrol then
          local bands = stripdata.strip.controls[j].eqbands
          if bands and #bands > 0 then
          
            for k = 1, #bands do
            
              if fxguids[bands[k].fxguid].found then
                bands[k].fxnum = fxguids[bands[k].fxguid].fxnum
                bands[k].fxguid = fxguids[bands[k].fxguid].guid
              end
            
            end
          
          end
        end
      end
      
      if rcmflag == true then
        RCM_Neb_UpdateProgIDs(stripdata.strip.controls, false)
      end
      
    end
          
    --time = math.abs(math.sin( -1 + (os.clock() % 2)))
    --;
    local stripid = GenID()
    local grpid = GenID()
    
    local cidtrack = {}
    local gidtrack = {}
    
    --add switchers
    local switchstart
    if stripdata.switchers and #stripdata.switchers > 0 then
      --DBG('A')
      switchstart = #switchers+1
      for s = 1, #stripdata.switchers do
        local scnt = #switchers+1
        switchers[scnt] = stripdata.switchers[s]
      end
    end
    --DBG(switchstart..'  '..#switchers)
        
    local cstart = #strips[strip][page].controls + 1
    for j = 1, #stripdata.strip.controls do
      stripdata.strip.controls[j].x = stripdata.strip.controls[j].x + offsetx + x + surface_offset.x     
      stripdata.strip.controls[j].y = stripdata.strip.controls[j].y + offsety + y + surface_offset.y
      stripdata.strip.controls[j].id = stripid
      
      local cc = #strips[strip][page].controls + 1
      strips[strip][page].controls[cc] = stripdata.strip.controls[j]
      strips[strip][page].controls[cc].xsc = stripdata.strip.controls[j].x + math.floor(stripdata.strip.controls[j].w/2 
                                                                            - stripdata.strip.controls[j].w*stripdata.strip.controls[j].scale/2)
      strips[strip][page].controls[cc].ysc = stripdata.strip.controls[j].y + math.floor(stripdata.strip.controls[j].ctl_info.cellh/2 
                                                                            - stripdata.strip.controls[j].ctl_info.cellh*stripdata.strip.controls[j].scale/2)
      strips[strip][page].controls[cc].wsc = stripdata.strip.controls[j].w*stripdata.strip.controls[j].scale
      strips[strip][page].controls[cc].hsc = stripdata.strip.controls[j].ctl_info.cellh*stripdata.strip.controls[j].scale
      
      local ocid = strips[strip][page].controls[cc].c_id
      strips[strip][page].controls[cc].c_id = GenID() --give a new control id
      if ocid then
        cidtrack[ocid] = {c_id = strips[strip][page].controls[cc].c_id,
                          ctl = cc}
      end
      
      local ogid = strips[strip][page].controls[cc].grpid
      if ogid and strips[strip][page].controls[cc].switcher ~= nil then
      --DBG('B '..ogid)
        if gidtrack[ogid] then
          strips[strip][page].controls[cc].grpid = gidtrack[ogid].grpid
        else
          strips[strip][page].controls[cc].grpid = GenID() --give a new group id
          gidtrack[ogid] = {grpid = strips[strip][page].controls[cc].grpid}
        end
      else
      --DBG('C '..grpid)
        strips[strip][page].controls[cc].grpid = grpid --give main group id
      end      
      
      if switchstart and strips[strip][page].controls[cc].switcher then
      --DBG('D')
        local swid = stripdata.switchconvtab[strips[strip][page].controls[cc].switcher]
        if swid then
          swid = swid + switchstart-1
          strips[strip][page].controls[cc].switcher = swid
        end
      end
      if switchstart and strips[strip][page].controls[cc].switcherid then
      --DBG('E')
        local swid = stripdata.switchconvtab[strips[strip][page].controls[cc].switcherid]
        --DBG(swid..'  '..switchstart)
        if swid then
          swid = swid + switchstart-1
          strips[strip][page].controls[cc].switcherid = swid
        end
      end
            
      --compatibility
      if strips[strip][page].controls[cc].gauge and strips[strip][page].controls[cc].gauge.font == nil then
        strips[strip][page].controls[cc].gauge.font = fontname_def
      end
      if strips[strip][page].controls[cc].font == nil then strips[strip][page].controls[cc].font = fontname_def end
      if strips[strip][page].controls[cc].xydata == nil then strips[strip][page].controls[cc].xydata = {snapa = 1, snapb = 1, snapc = 1, snapd = 1, x = 0.5, y = 0.5} end
      if strips[strip][page].controls[cc].textoffx == nil then strips[strip][page].controls[cc].textoffx = 0 end
      if strips[strip][page].controls[cc].textoffvalx == nil then strips[strip][page].controls[cc].textoffvalx = 0 end      
      if strips[strip][page].controls[cc].poslock == nil then strips[strip][page].controls[cc].poslock = false end
      if strips[strip][page].controls[cc].textsizev == nil then strips[strip][page].controls[cc].textsizev = strips[strip][page].controls[cc].textsize end
      if strips[strip][page].controls[cc].textcolv == nil then strips[strip][page].controls[cc].textcolv = strips[strip][page].controls[cc].textcol end
      if strips[strip][page].controls[cc].scalemode == nil then strips[strip][page].controls[cc].scalemode = 8 end
      if strips[strip][page].controls[cc].framemode == nil then strips[strip][page].controls[cc].framemode = 1 end      
      if strips[strip][page].controls[cc].ctlcat == nil then strips[strip][page].controls[cc].ctlcat = ctlcats.fxparam end
      if strips[strip][page].controls[cc].maxdp == nil then strips[strip][page].controls[cc].maxdp = -1 end
      if strips[strip][page].controls[cc].cycledata == nil then
        strips[strip][page].controls[cc].cycledata = {statecnt = 0,val = 0,mapptof = false,draggable = false,spread = false, {}}
      end
      if strips[strip][page].controls[cc].cycledata.mapptof == nil then strips[strip][page].controls[cc].cycledata.mapptof = false end      
      if strips[strip][page].controls[cc].cycledata.draggable == nil then strips[strip][page].controls[cc].cycledata.draggable = false end
      if strips[strip][page].controls[cc].cycledata.spread == nil then strips[strip][page].controls[cc].cycledata.spread = false end
      
      for k = 1, #strips[strip][page].controls[cc].cycledata do
        if strips[strip][page].controls[cc].cycledata[k].dv == nil then
          strips[strip][page].controls[cc].cycledata[k].dv = strips[strip][page].controls[cc].cycledata[k].dispval
        end
      end
       
      if strips[strip][page].controls[cc].membtn == nil then
        strips[strip][page].controls[cc].membtn = {state = false, mem = 0}
      end
      if strips[strip][page].controls[cc].knobsens == nil then
        strips[strip][page].controls[cc].knobsens = {norm = settings_defknobsens.norm,
                                                     fine = settings_defknobsens.fine,
                                                     wheel = settings_defknobsens.wheel,
                                                     wheelfine = settings_defknobsens.wheelfine}
      end
      
    end
    for j = cstart, #strips[strip][page].controls do

      if strips[strip][page].controls[j].ctlcat == ctlcats.macro then
      
        local macro = strips[strip][page].controls[j].macroctl
        if macro then
          for m = 1, #macro do
          
            if cidtrack[macro[m].c_id] then
              
              macro[m].ctl = cidtrack[macro[m].c_id].ctl
              macro[m].c_id = cidtrack[macro[m].c_id].c_id
            
            end
          
          end
        end      
      end 

    end
    
    local lctl = GetLeftControlInStrip(strips[strip][page].controls, stripid)
    local dx, dy = 0, 0
    if lctl ~= -1 then
      if ignoregrid == false then
        local nx, ny = round(strips[strip][page].controls[lctl].x/settings_gridsize)*settings_gridsize,
                       round(strips[strip][page].controls[lctl].y/settings_gridsize)*settings_gridsize
        dx, dy = strips[strip][page].controls[lctl].x-nx,strips[strip][page].controls[lctl].y-ny
      end
      for j = 1, #strips[strip][page].controls do
        if strips[strip][page].controls[j].id == stripid then
          strips[strip][page].controls[j].x = strips[strip][page].controls[j].x - dx
          strips[strip][page].controls[j].y = strips[strip][page].controls[j].y - dy
          strips[strip][page].controls[j].xsc = strips[strip][page].controls[j].xsc -dx
          strips[strip][page].controls[j].ysc = strips[strip][page].controls[j].ysc -dy
        end
      end
    end
    
    for j = 1, #stripdata.strip.graphics do
      if stripdata.strip.graphics[j].w > 0 and stripdata.strip.graphics[j].h > 0 then
        --if surface_size.limit then
          stripdata.strip.graphics[j].x = stripdata.strip.graphics[j].x + offsetx + x + surface_offset.x -dx
          stripdata.strip.graphics[j].y = stripdata.strip.graphics[j].y + offsety + y + surface_offset.y -dy
        --else
          --stripdata.strip.graphics[j].x = stripdata.strip.graphics[j].x + offsetx + x - surface_offset.x     
          --stripdata.strip.graphics[j].y = stripdata.strip.graphics[j].y + offsety + y - surface_offset.y
        --end
        stripdata.strip.graphics[j].id = stripid
  
        local ogid = stripdata.strip.graphics[j].grpid
        if ogid then
        --DBG('G')
          if gidtrack[ogid] then
            stripdata.strip.graphics[j].grpid = gidtrack[ogid].grpid
          else
            stripdata.strip.graphics[j].grpid = GenID() --give a new group id
            gidtrack[ogid] = {grpid = stripdata.strip.graphics[j].grpid}
          end
        else
        --DBG('H')
          stripdata.strip.graphics[j].grpid = grpid --give main group id
        end      
  
        if switchstart and stripdata.strip.graphics[j].switcher then
        --DBG('D')
          local swid = stripdata.switchconvtab[stripdata.strip.graphics[j].switcher]
          if swid then
            swid = swid + switchstart-1
            stripdata.strip.graphics[j].switcher = swid
          end
        end
  
        --compatibility
        if stripdata.strip.graphics[j].poslock == nil then stripdata.strip.graphics[j].poslock = false end
        if stripdata.strip.graphics[j].stretchw == nil then stripdata.strip.graphics[j].stretchw = w end
        if stripdata.strip.graphics[j].stretchh == nil then stripdata.strip.graphics[j].stretchh = h end      
        if stripdata.strip.graphics[j].bright == nil then stripdata.strip.graphics[j].bright = 0.5 end      
        if stripdata.strip.graphics[j].contr == nil then stripdata.strip.graphics[j].contr = 0.5 end      
        if stripdata.strip.graphics[j].rmult == nil then stripdata.strip.graphics[j].rmult = 0.5 end      
        if stripdata.strip.graphics[j].gmult == nil then stripdata.strip.graphics[j].gmult = 0.5 end      
        if stripdata.strip.graphics[j].bmult == nil then stripdata.strip.graphics[j].bmult = 0.5 end      
        if stripdata.strip.graphics[j].alpha == nil then stripdata.strip.graphics[j].alpha = 1 end      
  
        if stripdata.strip.graphics[j].gfxtype == nil then stripdata.strip.graphics[j].gfxtype = gfxtype.img end
        if stripdata.strip.graphics[j].font == nil then
          stripdata.strip.graphics[j].font = {idx = nil,
                                              name = nil,
                                              size = nil,
                                              bold = nil,
                                              italics = nil,
                                              underline = nil,
                                              shadow = nil
                                              }
          stripdata.strip.graphics[j].text = nil
          stripdata.strip.graphics[j].text_col = nil
        end
        
        strips[strip][page].graphics[#strips[strip][page].graphics + 1] = stripdata.strip.graphics[j]
      end          
    end

    if switchstart then
      for s = switchstart, #switchers do
        if switchers[s].parent then
          local swid = stripdata.switchconvtab[switchers[s].parent.switcherid]
          if swid then
            swid = swid + switchstart-1
            switchers[s].parent.switcherid = swid
          end
          if gidtrack[switchers[s].parent.grpid] then
            switchers[s].parent.grpid = gidtrack[switchers[s].parent.grpid].grpid
          end
        end
        
        for g = 1, #switchers[s].grpids do
          if gidtrack[switchers[s].grpids[g].id] then
            local gid = gidtrack[switchers[s].grpids[g].id].grpid
            if gid then
              switchers[s].grpids[g].id = gid
            end
          end
        
        end
        --DBG(tostring(switchers[s].current)..'  '..tostring(gidtrack[switchers[s].current].grpid))
        switchers[s].current = gidtrack[switchers[s].current].grpid
      end
    end
        
    Snapshots_INIT()
    if stripdata.snapshots and #stripdata.snapshots > 0 then
      local paramchange = {}
      for i = 1, #stripdata.snapshots do

        if stripdata.snapshots[i] then
          if i == 1 then
            --page - convert to subset
            if #stripdata.snapshots[i] > 0 then
              local sstcnt = #snapshots[strip][page] + 1
              if sstcnt == 1 then 
                --skip page snapshots
                sstcnt = 2 
              end
              paramchange[i] = sstcnt 
              snapshots[strip][page][sstcnt] = {subsetname = '##Page Snapshots',
                                                snapshot = {},
                                                ctls = {}}
              for ss = 1, #stripdata.snapshots[i] do
              
                snapshots[strip][page][sstcnt].snapshot[ss] = stripdata.snapshots[i][ss]
                snapshots[strip][page][sstcnt].selected = stripdata.snapshots[i].selected
                
                if snapshots[strip][page][sstcnt].snapshot[ss] then
                  if #snapshots[strip][page][sstcnt].snapshot[ss].data > 0 then
                    for d = 1, #snapshots[strip][page][sstcnt].snapshot[ss].data do
                      local ocid = snapshots[strip][page][sstcnt].snapshot[ss].data[d].c_id
                      if cidtrack[ocid] then
                        snapshots[strip][page][sstcnt].snapshot[ss].data[d].c_id = cidtrack[ocid].c_id
                        snapshots[strip][page][sstcnt].snapshot[ss].data[d].ctl = cidtrack[ocid].ctl
                      else
                        DBG('Erk')
                      end            
                    end
                  end
                
                  if ss == 1 then
                    --do just once
                    if #snapshots[strip][page][sstcnt].snapshot[ss].data > 0 then
                      for d = 1, #snapshots[strip][page][sstcnt].snapshot[ss].data do
                        snapshots[strip][page][sstcnt].ctls[d] = {c_id = snapshots[strip][page][sstcnt].snapshot[ss].data[d].c_id,
                                                                  ctl = snapshots[strip][page][sstcnt].snapshot[ss].data[d].ctl}
                      end
                    end            
                  end
                end
                                       
              end
            end            
          else
            --subset
            local sstcnt = #snapshots[strip][page] + 1
            paramchange[i] = sstcnt 
            snapshots[strip][page][sstcnt] = stripdata.snapshots[i]
            if snapshots[strip][page][sstcnt] and #snapshots[strip][page][sstcnt].ctls > 0 then
              for ctl = 1, #snapshots[strip][page][sstcnt].ctls do
                local ocid = snapshots[strip][page][sstcnt].ctls[ctl].c_id
                if cidtrack[ocid] then
                  snapshots[strip][page][sstcnt].ctls[ctl].c_id = cidtrack[ocid].c_id
                  snapshots[strip][page][sstcnt].ctls[ctl].ctl = cidtrack[ocid].ctl
                else
                  DBG('Erk')
                end            
              end
            end
        
            if snapshots[strip][page][sstcnt] and #snapshots[strip][page][sstcnt].snapshot > 0 then
              for ss = 1, #snapshots[strip][page][sstcnt].snapshot do
                if #snapshots[strip][page][sstcnt].snapshot[ss].data > 0 then
                  for d = 1, #snapshots[strip][page][sstcnt].snapshot[ss].data do
                    local ocid = snapshots[strip][page][sstcnt].snapshot[ss].data[d].c_id
                    if cidtrack[ocid] then
                      snapshots[strip][page][sstcnt].snapshot[ss].data[d].c_id = cidtrack[ocid].c_id
                      snapshots[strip][page][sstcnt].snapshot[ss].data[d].ctl = cidtrack[ocid].ctl
                    else
                      DBG('Erk')
                    end            
                  end
                end
              end
            end
    
          end
        end
      end
      
      for j = cstart, #strips[strip][page].controls do
        if strips[strip][page].controls[j].ctlcat == ctlcats.snapshot then
          --if strips[strip][page].controls[j].param == i then
            strips[strip][page].controls[j].param = paramchange[strips[strip][page].controls[j].param]
            strips[strip][page].controls[j].param_info.paramidx = paramchange[strips[strip][page].controls[j].param]
          --end
        elseif strips[strip][page].controls[j].ctlcat == ctlcats.xy then
            strips[strip][page].controls[j].param = paramchange[strips[strip][page].controls[j].param]
            strips[strip][page].controls[j].param_info.paramidx = paramchange[strips[strip][page].controls[j].param]
        
        elseif strips[strip][page].controls[j].ctlcat == ctlcats.snapshotrand then
          if paramchange[strips[strip][page].controls[j].param] then
            strips[strip][page].controls[j].param = paramchange[strips[strip][page].controls[j].param]
            strips[strip][page].controls[j].param_info.paramidx = paramchange[strips[strip][page].controls[j].param]
          end
        end
      end
    end  
      
    PopulateTrackFX()
    
    GUI_DrawCtlBitmap()
    --DBG('addstrip '..grpid)
    return stripid, strip, grpid
    
  end
  
  function GenStripPreview_CtlsHidden(switchers, swconvtab, swid, ctl_grpid)
    local deleted 
    if switchers and swconvtab and swid then
      local switchid = swconvtab[swid]
      
      if switchid and switchers[switchid] and switchers[switchid].deleted ~= true then
        if switchers[switchid].current ~= ctl_grpid then
          return true
        else
          if switchers[switchid].parent then
            local ret, deleted = Switcher_CtlsHidden(swconvtab[switchers[switchid].parent.switcherid], switchers[switchid].parent.grpid)
            return ret, deleted
          end
        end
      else
        if switchid and switchers[switchid] and switchers[switchid].deleted == true then
          deleted = true
        end
      end
    end
    return false, deleted
  end
  
  function GenStripPreview(gui, strip, switchers, switchconvtab)
  
    if strip then
      local i,j
      image_count_add = image_count    
      local minx, miny, maxx, maxy = nil,nil,nil,nil 
      if #strip.graphics > 0 then
        for i = 1, #strip.graphics do
          if strip.graphics[i].stretchw == nil then strip.graphics[i].stretchw = strip.graphics[i].w end
          if strip.graphics[i].stretchh == nil then strip.graphics[i].stretchh = strip.graphics[i].h end
          
          if strip.graphics[i].stretchw > 0 and strip.graphics[i].stretchh > 0 then
            if minx == nil then
              minx = strip.graphics[i].x
              miny = strip.graphics[i].y
              maxx = strip.graphics[i].x + strip.graphics[i].stretchw
              maxy = strip.graphics[i].y + strip.graphics[i].stretchh
            else
              minx = math.min(minx, strip.graphics[i].x)
              miny = math.min(miny, strip.graphics[i].y)
              maxx = math.max(maxx, strip.graphics[i].x + strip.graphics[i].stretchw)
              maxy = math.max(maxy, strip.graphics[i].y + strip.graphics[i].stretchh)   
            end
          end
          local fnd = false
          if nz(strip.graphics[i].gfxtype,gfxtype.img) == gfxtype.img then
            for j = 0, #graphics_files do
              if graphics_files[j].fn == strip.graphics[i].fn then
              
                local iidx = LoadGraphics(strip.graphics[i].fn)
                if iidx then
                  if iidx > image_count_add  then
                    image_count_add = iidx
                  end
                  strip.graphics[i].imageidx = iidx
                  fnd = true
                end
                
                break
              end
            end
          end
          if not fnd then
          end
        end
      end

      if #strip.controls > 0 then      
        for i = 1, #strip.controls do
          if minx == nil then
            minx = strip.controls[i].x
            miny = strip.controls[i].y
            maxx = strip.controls[i].x + strip.controls[i].w
            maxy = strip.controls[i].y + strip.controls[i].ctl_info.cellh
          else
            minx = math.min(minx, strip.controls[i].x)
            miny = math.min(miny, strip.controls[i].y)
            maxx = math.max(maxx, strip.controls[i].x + strip.controls[i].w)
            maxy = math.max(maxy, strip.controls[i].y + strip.controls[i].ctl_info.cellh)
          end
          local fnd = false
          for j = 0, #ctl_files do
            if ctl_files[j].fn == strip.controls[i].ctl_info.fn then
              if ctl_files[j].imageidx ~= nil then
                fnd = true
                strip.controls[i].ctl_info.imageidx = ctl_files[j].imageidx
                strip.controls[i].knob_select = j
              else
                fnd = true
                image_count_add = F_limit(image_count_add + 1,0,image_max)
                gfx.loadimg(image_count_add, controls_path..strip.controls[i].ctl_info.fn)
                ctl_files[j].imageidx = image_count_add
                strip.controls[i].ctl_info.imageidx = image_count_add
                strip.controls[i].knob_select = j
              end
              break
            end
          end
          if not fnd then
          end
        end
      end
      image_count = image_count_add
      offsetx, offsety = 0, 0
      if minx and miny then
        offsetx = -minx
        offsety = -miny
      elseif minx then
        offsetx = -minx      
      elseif miny then
        offsety = -miny
      end
      
      if gui == nil then
        gui = GetGUI_vars()
      end
      
      gfx.dest = 1022
      gfx.setimgdim(1022,-1,-1)
      gfx.setimgdim(1022,maxx+offsetx,maxy+offsety)

      --draw gfx
      if #strip.graphics > 0 then
      
        for i = 1, #strip.graphics do

          local gfxx = strip.graphics[i]
        
          local hidden = GenStripPreview_CtlsHidden(switchers, switchconvtab, gfxx.switcher, gfxx.grpid)
          if hidden == false then
            if nz(gfxx.gfxtype, gfxtype.img) == gfxtype.img then
  
              local x = gfxx.x+offsetx 
              local y = gfxx.y+offsety
              local w = gfxx.w
              local h = gfxx.h
              local sw = gfxx.stretchw
              local sh = gfxx.stretchh
              local imageidx = gfxx.imageidx
              
              --gfx.blit(imageidx,1,0, 0, 0, w, h, x, y, sw, sh)
              
              if (gfxx.bright and gfxx.bright ~= 0.5) or (gfxx.contr and gfxx.contr ~= 0.5) 
                 or (gfxx.rmult and gfxx.rmult ~= 0.5) or (gfxx.gmult and gfxx.gmult ~= 0.5) or (gfxx.bmult and gfxx.bmult ~= 0.5) 
                 or (gfxx.alpha and gfxx.alpha ~= 1) then
                
                iidx = 899
                local ba = -F_limit((0.5-gfxx.bright)*2,-1,1)
                local bc = gfxx.contr
                if bc > 0.5 then
                  bc = 1+(bc-0.5)*10
                else
                  bc = bc*2
                end
                
                local mr = gfxx.rmult
                local mg = gfxx.gmult
                local mb = gfxx.bmult
                if mr > 0.5 then
                  mr = 1+(mr-0.5)*10
                else
                  mr = mr*2
                end
                if mg > 0.5 then
                  mg = 1+(mg-0.5)*10
                else
                  mg = mg*2
                end
                if mb > 0.5 then
                  mb = 1+(mb-0.5)*10
                else
                  mb = mb*2
                end
                
                local ma = gfxx.alpha
                
                gfx.setimgdim(iidx, -1, -1)
                gfx.setimgdim(iidx, sw, sh)
                gfx.dest = iidx
                gfx.a = 1
                --gfx.blit(imageidx,1,0, 0, 0, w, h, 0, 0, sw, sh)
                if gfxx.stretchmode == 1 then
                  gfx.blit(imageidx,1,0, 0, 0, w, h, 0, 0, sw, sh)
                else
                  local edge = gfxx.edgesz
                  --corners
                  gfx.blit(imageidx,1,0, 0, 0, edge, edge, 0, 0)
                  gfx.blit(imageidx,1,0, w-edge, 0, edge, edge, sw-edge, 0)
                  gfx.blit(imageidx,1,0, w-edge, h-edge, edge, edge, sw-edge, sh-edge)
                  gfx.blit(imageidx,1,0, 0, h-edge, edge, edge, 0, sh-edge)
                  --sides
                  gfx.blit(imageidx,1,0, edge, 0, w-edge-edge, edge, edge, 0, sw-edge-edge, edge)
                  gfx.blit(imageidx,1,0, w-edge, edge, edge, h-edge-edge, sw-edge, edge, edge, sh-edge-edge)
                  gfx.blit(imageidx,1,0, edge, h-edge, w-edge-edge, edge, edge, sh-edge, sw-edge-edge, edge)
                  gfx.blit(imageidx,1,0, 0, edge, edge, h-edge-edge, 0, edge, edge, sh-edge-edge)
                  --middle
                  gfx.blit(imageidx,1,0, edge, edge, w-edge-edge, h-edge-edge, edge, edge, sw-edge-edge, sh-edge-edge)                  
                end
                
                gfx.muladdrect(0,0,sw,sh,bc*mr,bc*mg,bc*mb,1,ba,ba,ba)
                gfx.dest = 1022
                gfx.a = ma
                gfx.blit(iidx,1,0, 0, 0, sw, sh, x, y)            
              else
                --gfx.blit(imageidx,1,0, 0, 0, w, h, x, y, sw, sh)
                if gfxx.stretchmode == 1 then
                  gfx.blit(imageidx,1,0, 0, 0, w, h, x, y, sw, sh)
                else
                  local edge = gfxx.edgesz
                  --corners
                  gfx.blit(imageidx,1,0, 0, 0, edge, edge, x+0, y+0)
                  gfx.blit(imageidx,1,0, w-edge, 0, edge, edge, x+sw-edge, y+0)
                  gfx.blit(imageidx,1,0, w-edge, h-edge, edge, edge, x+sw-edge, y+sh-edge)
                  gfx.blit(imageidx,1,0, 0, h-edge, edge, edge, x+0, y+sh-edge)
                  --sides
                  gfx.blit(imageidx,1,0, edge, 0, w-edge-edge, edge, x+edge, y+0, sw-edge-edge, edge)
                  gfx.blit(imageidx,1,0, w-edge, edge, edge, h-edge-edge, x+sw-edge, y+edge, edge, sh-edge-edge)
                  gfx.blit(imageidx,1,0, edge, h-edge, w-edge-edge, edge, x+edge, y+sh-edge, sw-edge-edge, edge)
                  gfx.blit(imageidx,1,0, 0, edge, edge, h-edge-edge, x+0, y+edge, edge, sh-edge-edge)
                  --middle
                  gfx.blit(imageidx,1,0, edge, edge, w-edge-edge, h-edge-edge, x+edge, y+edge, sw-edge-edge, sh-edge-edge)                  
                end
              end
            
            elseif gfxx.gfxtype == gfxtype.txt then
            
              local x = gfxx.x+offsetx 
              local y = gfxx.y+offsety
            
              local text = gfxx.text
              local textcol = gfxx.text_col
              
              local flagb,flagi,flagu = 0,0,0
              if gfxx.font.bold then flagb = 98 end
              if gfxx.font.italics then flagi = 105 end
              if gfxx.font.underline then flagu = 117 end
              local flags = flagb + (flagi*256) + (flagu*(256^2))
              gfx.setfont(1,gfxx.font.name,
                            gfxx.font.size,flags)
              if gfxx.font.shadow then
              
                local shadx = nz(gfxx.font.shadow_x,1)
                local shady = nz(gfxx.font.shadow_y,1)
              
                f_Get_SSV(gui.color.black)
                gfx.a = 0.5
                gfx.x, gfx.y = x+shadx,y+shady
                gfx.drawstr(text)
              end
              
              gfx.a = 1
              gfx.x, gfx.y = x,y
              f_Get_SSV(textcol)
              
              gfx.drawstr(text)
            
            end
          end      
        end
      end      
      
      --draw controls    
      if #strip.controls > 0 then
      
        for i = 1, #strip.controls do
        
          local hidden = GenStripPreview_CtlsHidden(switchers, switchconvtab, strip.controls[i].switcher, strip.controls[i].grpid)
          if hidden == false then
            local scale = strip.controls[i].scale
            local x = strip.controls[i].x+offsetx 
            local y = strip.controls[i].y+offsety
            local w = strip.controls[i].w
            local h = strip.controls[i].ctl_info.cellh
            local gh = h
            local val = math.floor(100*nz(strip.controls[i].val,0))
            local fxnum = strip.controls[i].fxnum
            local param = strip.controls[i].param
            local iidx = strip.controls[i].ctl_info.imageidx
            local spn = strip.controls[i].show_paramname
            local spv = strip.controls[i].show_paramval
            local ctlnmov = nz(strip.controls[i].ctlname_override,'')
            local tc = strip.controls[i].textcol
            local toff = strip.controls[i].textoff
            local tsze = nz(strip.controls[i].textsize,0)
            local frames = strip.controls[i].ctl_info.frames
            local ctltype = strip.controls[i].ctltype
            local found = strip.controls[i].fxfound
            local gauge = strip.controls[i].gauge
            local font = strip.controls[i].font
            if not font then
              font = fontname_def
            end
            
            if gauge then
              GUI_DrawGauge2(gauge,x+w/2,y+h/2,strip.controls[i])
            end
      
            local v2 = nz(strip.controls[i].val,0)
            local val2 = F_limit(round(frames*v2,0),0,frames-1)
            gfx.a = 1
            
            if ctltype == 3 then
              --invert button
              val2 = 1-val2
            end
            
            gfx.setfont(1, font, gui.fontsz_knob +tsze-4)
            
            --load image
            gfx.blit(iidx,scale,0, 0, (val2)*gh, w, h, x + w/2-w*scale/2, y + h/2-h*scale/2)
            xywh = {x = x, y = y+(h/2)-toff, w = w, h = 1}
            if w > strip.controls[i].w/2 then
              local Disp_ParamV
              local Disp_Name
              if ctlnmov == '' then
                Disp_Name = strip.controls[i].param_info.paramname
              else
                Disp_Name = ctlnmov
              end
              Disp_ParamV = ''
              if spn then
                GUI_textCtl(gui,xywh, tostring(Disp_Name),tc,-4+tsze)
              end
            end
          end          
        end
          
      end
    
    end
    gfx.dest = 1
  
  end
    
  ------------------------------------------------------------    

  function GenGFXDragPreview(gui)

    local strip = tracks[track_select].strip
    local i,j
    local minx, miny, maxx, maxy = nil,nil,nil,nil 
    if gfx2_select then
      --for ii = 1, #gfx3_select do
        local i = gfx2_select
        if minx == nil then
          minx = strips[strip][page].graphics[i].x
          miny = strips[strip][page].graphics[i].y
          maxx = strips[strip][page].graphics[i].x + strips[strip][page].graphics[i].stretchw
          maxy = strips[strip][page].graphics[i].y + strips[strip][page].graphics[i].stretchh
        else
          minx = math.min(minx, strips[strip][page].graphics[i].x)
          miny = math.min(miny, strips[strip][page].graphics[i].y)
          maxx = math.max(maxx, strips[strip][page].graphics[i].x + strips[strip][page].graphics[i].stretchw)
          maxy = math.max(maxy, strips[strip][page].graphics[i].y + strips[strip][page].graphics[i].stretchh)
        end
      --end
    end

    offsetx = -minx
    offsety = -miny
    
    gfx.dest = 1022
    gfx.setimgdim(1022,-1,-1)
    gfx.setimgdim(1022,maxx+offsetx,maxy+offsety)

    --draw gfx
    if gfx2_select then
    
      local i = gfx2_select
      local gfxx = strips[strip][page].graphics[i]
      if nz(strips[strip][page].graphics[i].gfxtype, gfxtype.img) == gfxtype.img then
      
        local x = gfxx.x+offsetx 
        local y = gfxx.y+offsety
        local w = gfxx.w
        local h = gfxx.h
        local sw = gfxx.stretchw
        local sh = gfxx.stretchh
        local imageidx = gfxx.imageidx
        
        --gfx.a = 0.8
        --gfx.blit(imageidx,1,0, 0, 0, w, h, x, y, sw, sh)
      
        if (gfxx.bright and gfxx.bright ~= 0.5) or (gfxx.contr and gfxx.contr ~= 0.5) 
                 or (gfxx.rmult and gfxx.rmult ~= 0.5) or (gfxx.gmult and gfxx.gmult ~= 0.5) or (gfxx.bmult and gfxx.bmult ~= 0.5) 
                 or (gfxx.alpha and gfxx.alpha ~= 1) then
          iidx = 899
          local ba = -F_limit((0.5-gfxx.bright)*2,-1,1)
          local bc = gfxx.contr
          if bc > 0.5 then
            bc = 1+(bc-0.5)*10
          else
            bc = bc*2
          end

          local mr = gfxx.rmult
          local mg = gfxx.gmult
          local mb = gfxx.bmult
          if mr > 0.5 then
            mr = 1+(mr-0.5)*10
          else
            mr = mr*2
          end
          if mg > 0.5 then
            mg = 1+(mg-0.5)*10
          else
            mg = mg*2
          end
          if mb > 0.5 then
            mb = 1+(mb-0.5)*10
          else
            mb = mb*2
          end
          
          local ma = gfxx.alpha
                    
          gfx.setimgdim(iidx, -1, -1)
          gfx.setimgdim(iidx, sw, sh)
          gfx.dest = iidx
          gfx.a = 1
          --gfx.blit(imageidx,1,0, 0, 0, w, h, 0, 0, sw, sh)
          if gfxx.stretchmode == 1 then
            gfx.blit(imageidx,1,0, 0, 0, w, h, 0, 0, sw, sh)
          else
            local edge = gfxx.edgesz
            --corners
            gfx.blit(imageidx,1,0, 0, 0, edge, edge, 0, 0)
            gfx.blit(imageidx,1,0, w-edge, 0, edge, edge, sw-edge, 0)
            gfx.blit(imageidx,1,0, w-edge, h-edge, edge, edge, sw-edge, sh-edge)
            gfx.blit(imageidx,1,0, 0, h-edge, edge, edge, 0, sh-edge)
            --sides
            gfx.blit(imageidx,1,0, edge, 0, w-edge-edge, edge, edge, 0, sw-edge-edge, edge)
            gfx.blit(imageidx,1,0, w-edge, edge, edge, h-edge-edge, sw-edge, edge, edge, sh-edge-edge)
            gfx.blit(imageidx,1,0, edge, h-edge, w-edge-edge, edge, edge, sh-edge, sw-edge-edge, edge)
            gfx.blit(imageidx,1,0, 0, edge, edge, h-edge-edge, 0, edge, edge, sh-edge-edge)
            --middle
            gfx.blit(imageidx,1,0, edge, edge, w-edge-edge, h-edge-edge, edge, edge, sw-edge-edge, sh-edge-edge)                  
          end
          
          gfx.muladdrect(0,0,sw,sh,bc*mr,bc*mg,bc*mb,1,ba,ba,ba)
          gfx.dest = 1022
          gfx.a = 0.8*ma
          gfx.blit(iidx,1,0, 0, 0, sw, sh, x, y)            
        else
          gfx.a = 0.8
          --gfx.blit(imageidx,1,0, 0, 0, w, h, x, y, sw, sh)
          if gfxx.stretchmode == 1 then
            gfx.blit(imageidx,1,0, 0, 0, w, h, x, y, sw, sh)
          else
            local edge = gfxx.edgesz
            --cornersh
            gfx.blit(imageidx,1,0, 0, 0, edge, edge, x+0, y+0)
            gfx.blit(imageidx,1,0, w-edge, 0, edge, edge, x+sw-edge, y+0)
            gfx.blit(imageidx,1,0, w-edge, h-edge, edge, edge, x+sw-edge, y+sh-edge)
            gfx.blit(imageidx,1,0, 0, h-edge, edge, edge, x+0, y+sh-edge)
            --sides
            gfx.blit(imageidx,1,0, edge, 0, w-edge-edge, edge, x+edge, y+0, sw-edge-edge, edge)
            gfx.blit(imageidx,1,0, w-edge, edge, edge, h-edge-edge, x+sw-edge, y+edge, edge, sh-edge-edge)
            gfx.blit(imageidx,1,0, edge, h-edge, w-edge-edge, edge, x+edge, y+sh-edge, sw-edge-edge, edge)
            gfx.blit(imageidx,1,0, 0, edge, edge, h-edge-edge, x+0, y+edge, edge, sh-edge-edge)
            --middle
            gfx.blit(imageidx,1,0, edge, edge, w-edge-edge, h-edge-edge, x+edge, y+edge, sw-edge-edge, sh-edge-edge)                  
          end
        end
      
      elseif gfxx.gfxtype == gfxtype.txt then
      
        local x = gfxx.x+offsetx 
        local y = gfxx.y+offsety
      
        local text = gfxx.text
        local textcol = gfxx.text_col
        
        local flagb,flagi,flagu = 0,0,0
        if gfxx.font.bold then flagb = 98 end
        if gfxx.font.italics then flagi = 105 end
        if gfxx.font.underline then flagu = 117 end
        local flags = flagb + (flagi*256) + (flagu*(256^2))
        gfx.setfont(1,gfxx.font.name,
                      gfxx.font.size,flags)
        if gfxx.font.shadow then
        
          local shadx = nz(gfxx.font.shadow_x,1)
          local shady = nz(gfxx.font.shadow_y,1)
        
          f_Get_SSV(gui.color.black)
          gfx.a = 0.4
          gfx.x, gfx.y = x+shadx,y+shady
          gfx.drawstr(text)
        end
        
        gfx.a = 0.8
        gfx.x, gfx.y = x,y
        f_Get_SSV(textcol)
        
        gfx.drawstr(text)
      
      end
    
    end      


  end
  
  ------------------------------------------------------------    

  function GenCtlDragPreview(gui)
  
    local strip = tracks[track_select].strip
    local i,j
    local minx, miny, maxx, maxy = nil,nil,nil,nil 
    if gfx3_select and #gfx3_select > 0 then
      for ii = 1, #gfx3_select do
        local i = gfx3_select[ii].ctl
        if minx == nil then
          minx = strips[strip][page].graphics[i].x
          miny = strips[strip][page].graphics[i].y
          maxx = strips[strip][page].graphics[i].x + strips[strip][page].graphics[i].stretchw
          maxy = strips[strip][page].graphics[i].y + strips[strip][page].graphics[i].stretchh
        else
          minx = math.min(minx, strips[strip][page].graphics[i].x)
          miny = math.min(miny, strips[strip][page].graphics[i].y)
          maxx = math.max(maxx, strips[strip][page].graphics[i].x + strips[strip][page].graphics[i].stretchw)
          maxy = math.max(maxy, strips[strip][page].graphics[i].y + strips[strip][page].graphics[i].stretchh)
        end
      end
    end
    if #ctl_select > 0 then      
      for ii = 1, #ctl_select do
        local i = ctl_select[ii].ctl
        if minx == nil then
          minx = strips[strip][page].controls[i].x
          miny = strips[strip][page].controls[i].y
          maxx = strips[strip][page].controls[i].x + strips[strip][page].controls[i].w
          maxy = strips[strip][page].controls[i].y + strips[strip][page].controls[i].ctl_info.cellh
        else
          minx = math.min(minx, strips[strip][page].controls[i].x)
          miny = math.min(miny, strips[strip][page].controls[i].y)
          maxx = math.max(maxx, strips[strip][page].controls[i].x + strips[strip][page].controls[i].w)
          maxy = math.max(maxy, strips[strip][page].controls[i].y + strips[strip][page].controls[i].ctl_info.cellh)
        end
      end
    end
    offsetx = -minx
    offsety = -miny
    
    gfx.dest = 1022
    gfx.setimgdim(1022,-1,-1)
    gfx.setimgdim(1022,maxx+offsetx+b_sz*2,maxy+offsety+b_sz*2)

      --draw gfx
      if gfx3_select and #gfx3_select > 0 then
      
        for ii = 1, #gfx3_select do
          local i = gfx3_select[ii].ctl
          local gfxx = strips[strip][page].graphics[i]
          local hidden = Switcher_CtlsHidden(gfxx.switcher, gfxx.grpid)          
          if hidden == false then
            if nz(gfxx.gfxtype, gfxtype.img) == gfxtype.img then
              
              local x = gfxx.x+offsetx 
              local y = gfxx.y+offsety
              local w = gfxx.w
              local h = gfxx.h
              local sw = gfxx.stretchw
              local sh = gfxx.stretchh
              local imageidx = gfxx.imageidx
              
              --gfx.a = 0.3
              --gfx.blit(imageidx,1,0, 0, 0, w, h, x+b_sz, y+b_sz, sw, sh)
            
              if (gfxx.bright and gfxx.bright ~= 0.5) or (gfxx.contr and gfxx.contr ~= 0.5) 
                 or (gfxx.rmult and gfxx.rmult ~= 0.5) or (gfxx.gmult and gfxx.gmult ~= 0.5) or (gfxx.bmult and gfxx.bmult ~= 0.5) 
                 or (gfxx.alpha and gfxx.alpha ~= 1) then
                               
                iidx = 899
                local ba = -F_limit((0.5-gfxx.bright)*2,-1,1)
                local bc = gfxx.contr
                if bc > 0.5 then
                  bc = 1+(bc-0.5)*10
                else
                  bc = bc*2
                end
                
                local mr = gfxx.rmult
                local mg = gfxx.gmult
                local mb = gfxx.bmult
                if mr > 0.5 then
                  mr = 1+(mr-0.5)*10
                else
                  mr = mr*2
                end
                if mg > 0.5 then
                  mg = 1+(mg-0.5)*10
                else
                  mg = mg*2
                end
                if mb > 0.5 then
                  mb = 1+(mb-0.5)*10
                else
                  mb = mb*2
                end
                
                local ma = gfxx.alpha
                
                gfx.setimgdim(iidx, -1, -1)
                gfx.setimgdim(iidx, sw, sh)
                gfx.dest = iidx
                gfx.a = 1
                --gfx.blit(imageidx,1,0, 0, 0, w, h, 0, 0, sw, sh)
                if gfxx.stretchmode == 1 then
                  gfx.blit(imageidx,1,0, 0, 0, w, h, 0, 0, sw, sh)
                else
                  local edge = gfxx.edgesz
                  --corners
                  gfx.blit(imageidx,1,0, 0, 0, edge, edge, 0, 0)
                  gfx.blit(imageidx,1,0, w-edge, 0, edge, edge, sw-edge, 0)
                  gfx.blit(imageidx,1,0, w-edge, h-edge, edge, edge, sw-edge, sh-edge)
                  gfx.blit(imageidx,1,0, 0, h-edge, edge, edge, 0, sh-edge)
                  --sides
                  gfx.blit(imageidx,1,0, edge, 0, w-edge-edge, edge, edge, 0, sw-edge-edge, edge)
                  gfx.blit(imageidx,1,0, w-edge, edge, edge, h-edge-edge, sw-edge, edge, edge, sh-edge-edge)
                  gfx.blit(imageidx,1,0, edge, h-edge, w-edge-edge, edge, edge, sh-edge, sw-edge-edge, edge)
                  gfx.blit(imageidx,1,0, 0, edge, edge, h-edge-edge, 0, edge, edge, sh-edge-edge)
                  --middle
                  gfx.blit(imageidx,1,0, edge, edge, w-edge-edge, h-edge-edge, edge, edge, sw-edge-edge, sh-edge-edge)                  
                end
                
                gfx.muladdrect(0,0,sw,sh,bc*mr,bc*mg,bc*mb,1,ba,ba,ba)
                gfx.dest = 1022
                gfx.a = 0.3*ma
                gfx.blit(iidx,1,0, 0, 0, sw, sh, x+b_sz, y+b_sz)            
              else
                gfx.a = 0.3
                --gfx.blit(imageidx,1,0, 0, 0, w, h, x+b_sz, y+b_sz, sw, sh)
                if gfxx.stretchmode == 1 then
                  gfx.blit(imageidx,1,0, 0, 0, w, h, x+b_sz, y+b_sz, sw, sh)
                else
                  local edge = gfxx.edgesz
                  --corners
                  x=x+b_sz
                  y=y+b_sz
                  gfx.blit(imageidx,1,0, 0, 0, edge, edge, x, y+0)
                  gfx.blit(imageidx,1,0, w-edge, 0, edge, edge, x+sw-edge, y+0)
                  gfx.blit(imageidx,1,0, w-edge, h-edge, edge, edge, x+sw-edge, y+sh-edge)
                  gfx.blit(imageidx,1,0, 0, h-edge, edge, edge, x+0, y+sh-edge)
                  --sides
                  gfx.blit(imageidx,1,0, edge, 0, w-edge-edge, edge, x+edge, y+0, sw-edge-edge, edge)
                  gfx.blit(imageidx,1,0, w-edge, edge, edge, h-edge-edge, x+sw-edge, y+edge, edge, sh-edge-edge)
                  gfx.blit(imageidx,1,0, edge, h-edge, w-edge-edge, edge, x+edge, y+sh-edge, sw-edge-edge, edge)
                  gfx.blit(imageidx,1,0, 0, edge, edge, h-edge-edge, x+0, y+edge, edge, sh-edge-edge)
                  --middle
                  gfx.blit(imageidx,1,0, edge, edge, w-edge-edge, h-edge-edge, x+edge, y+edge, sw-edge-edge, sh-edge-edge)                  
                end
              end
              
            elseif gfxx.gfxtype == gfxtype.txt then
            
              local x = gfxx.x+offsetx 
              local y = gfxx.y+offsety
            
              local text = gfxx.text
              local textcol = gfxx.text_col
              
              local flagb,flagi,flagu = 0,0,0
              if gfxx.font.bold then flagb = 98 end
              if gfxx.font.italics then flagi = 105 end
              if gfxx.font.underline then flagu = 117 end
              local flags = flagb + (flagi*256) + (flagu*(256^2))
              gfx.setfont(1,gfxx.font.name,
                            gfxx.font.size,flags)
              if gfxx.font.shadow then
              
                local shadx = nz(gfxx.font.shadow_x,1)
                local shady = nz(gfxx.font.shadow_y,1)
              
                f_Get_SSV(gui.color.black)
                gfx.a = 0.15
                gfx.x, gfx.y = x+shadx+b_sz,y+shady+b_sz
                gfx.drawstr(text)
              end
              
              gfx.a = 0.3
              gfx.x, gfx.y = x+b_sz,y+b_sz
              f_Get_SSV(textcol)
              
              gfx.drawstr(text)
            
            end
          end      
        end
      end      

    --draw controls    
    if #strips[strip][page].controls > 0 then
    
      for ii = 1, #ctl_select do
        local i = ctl_select[ii].ctl
        local ctl = strips[strip][page].controls[i]
        local hidden = Switcher_CtlsHidden(ctl.switcher, ctl.grpid)          
        if hidden == false then
          local scale = ctl.scale
          local x = ctl.x+offsetx 
          local y = ctl.y+offsety
          local w = ctl.w
          local h = ctl.ctl_info.cellh
          local gh = h
          local val = math.floor(100*nz(ctl.val,0))
          local fxnum = ctl.fxnum
          local param = ctl.param
          local iidx = ctl.ctl_info.imageidx
          local spn = ctl.show_paramname
          local spv = ctl.show_paramval
          local ctlnmov = nz(ctl.ctlname_override,'')
          local tc = ctl.textcol
          local toff = ctl.textoff
          local tsze = nz(ctl.textsize,0)
          local frames = ctl.ctl_info.frames
          local ctltype = ctl.ctltype
          local found = ctl.fxfound
          local font = ctl.font
    
          local v2 = nz(ctl.val,0)
          local val2 = F_limit(round(frames*v2,0),0,frames-1)
          
          gfx.a = 1
          
          if ctltype == 3 then
            --invert button
            val2 = 1-val2
          end
          
          gfx.setfont(1, font, gui.fontsz_knob +tsze-4)
          local _, th_a = gfx.measurestr('|')
          local to = th_a
          
          --[[if ctl.gauge then
            local gx = math.floor(ctl.xsc + offsetx + ctl.wsc/2)
            local gy = math.floor(ctl.ysc + offsety + ctl.hsc/2)
            GUI_DrawGauge2(ctl.gauge,gx,gy,ctl)
          end]]
          
          --load image
          gfx.blit(iidx,scale,0, 0, (val2)*gh, w, h, x + w/2-w*scale/2 +b_sz, y + h/2-h*scale/2 +b_sz)
          
          --xywh = {x = x+b_sz, y = math.floor(y+(h/2)-toff-1)+b_sz, w = w, h = th_a}
          if w > ctl.w/2 then
            local Disp_ParamV
            local Disp_Name
            if ctlnmov == '' then
              Disp_Name = ctl.param_info.paramname
            else
              Disp_Name = ctlnmov
            end
            Disp_ParamV = ''
            
            local mid = x+(w/2)
            local text_len1x, text_len1y = gfx.measurestr(Disp_Name)
            --local text_len2x, text_len2y = gfx.measurestr(Disp_ParamV)
            local xywh1 = {x = math.floor(mid-(text_len1x/2))+b_sz, y = math.floor(y+(h/2)-toff-1)+b_sz, w = text_len1x, h = 1}
            
            if spn then
              GUI_textCtl(gui,xywh1, tostring(Disp_Name),tc,-4+tsze)
            end
          end
        end
      end
        
    end
    
    gfx.dest = 1
  
  end
    
  ------------------------------------------------------------    

  function CheckStripControls()
  
    if strips and tracks[track_select] and strips[tracks[track_select].strip] then
      local tr_found = false
      
      --Check track guid - none for master
      --if strips[tracks[track_select].strip].track.tracknum == -1 then return end
      --DBG(strips[tracks[track_select].strip].track.tracknum)
      if strips[tracks[track_select].strip].track.tracknum ~= -1 then 
        tr_found = CheckTrack(strips[tracks[track_select].strip].track, tracks[track_select].strip)
      end
        
      if (tr_found or strips[tracks[track_select].strip].track.tracknum == -1) and strips and strips[tracks[track_select].strip] then
        local tr = GetTrack(strips[tracks[track_select].strip].track.tracknum)

        local fxoffline = {}
        for fxn = 0, reaper.TrackFX_GetCount(tr)-1 do
          local pn = reaper.TrackFX_GetNumParams(tr,fxn)
          if pn == 2 then
            fxoffline[fxn] = true
          end
        end
  
        for p = 1, 4 do
        
          if #strips[tracks[track_select].strip][p].controls > 0 then
          
            for c = 1, #strips[tracks[track_select].strip][p].controls do
             
              local ctl = strips[tracks[track_select].strip][p].controls[c]
              ctl.offline = nil
              
              local tr2 = tr
              if ctl.tracknum ~= nil then
                tr_found = CheckTrack(tracks[ctl.tracknum],
                                      tracks[track_select].strip, p, c)                      
                if tr_found then
                  tr2 = GetTrack(ctl.tracknum)
                  if ctl.ctlcat == ctlcats.fxparam or ctl.ctlcat == ctlcats.fxoffline 
                     or ctl.ctlcat == ctlcats.fxgui or (ctl.ctlcat == ctlcats.rcm_switch and ctl.fxnum ~= nil) then
                    if ctl.fxguid == reaper.TrackFX_GetFXGUID(tr2, nz(ctl.fxnum,-1)) then
                      --fx found
                      ctl.fxfound = true
                      
                    else
                      --find fx by guid
                      local fx_found = false
                      for f = 0, reaper.TrackFX_GetCount(tr2) do
                        if ctl.fxguid == reaper.TrackFX_GetFXGUID(tr2, f) then
                          fx_found = true
                          ctl.fxnum = f
                          break
                        end
                      end
                      
                      if not fx_found then
                        --find on other track?
                        for t = -1, reaper.CountTracks(0)-1 do
                          local tr3 = GetTrack(t)
                          for f = 0, reaper.TrackFX_GetCount(tr3) do
                            if ctl.fxguid == reaper.TrackFX_GetFXGUID(tr3, f) then
                              fx_found = true
                              local ctl = ctl
                              ctl.fxnum = f
                              if t == tracks[track_select].tracknum then
                                ctl.tracknum = nil
                                ctl.trackguid = nil
                              else
                                ctl.tracknum = t
                                ctl.trackguid = tracks[t].guid
                              end
                              break
                            end
                          end
                        end
                      end
                      
                      PopulateTrackFX()
                      update_gfx = true
                      
                      if fx_found then
                        ctl.fxfound = true
                      else
                        --FX not found
                        ctl.fxfound = false
                      end
                    end
                  
                    local pn = reaper.TrackFX_GetNumParams(tr2,ctl.fxnum)
                    if pn == 2 then
                      ctl.offline = true
                    end
                                          
                  else
                    --other control type
                  
                  end

                else
                  --track not found
                  
                end              
              else
                if ctl.ctlcat == ctlcats.fxparam or ctl.ctlcat == ctlcats.fxoffline 
                   or ctl.ctlcat == ctlcats.fxgui or (ctl.ctlcat == ctlcats.rcm_switch and ctl.fxnum ~= nil) then
                  if ctl.fxguid == reaper.TrackFX_GetFXGUID(tr2, nz(ctl.fxnum,-1)) then
                    --fx found
                    ctl.fxfound = true
                  else
                    --find fx by guid
                    local fx_found = false
                    for f = 0, reaper.TrackFX_GetCount(tr2) do
                      if ctl.fxguid == reaper.TrackFX_GetFXGUID(tr2, f) then
                        fx_found = true
                        ctl.fxnum = f
                        break
                      end
                    end
                    
                    if not fx_found then
                      --find on other track?
                      for t = -1, reaper.CountTracks(0)-1 do
                        local tr3 = GetTrack(t)
                        for f = 0, reaper.TrackFX_GetCount(tr3) do
                          if ctl.fxguid == reaper.TrackFX_GetFXGUID(tr3, f) then
                            fx_found = true
                            --local ctl = strips[tracks[track_select].strip][p].controls[c]
                            ctl.fxnum = f
                            if t == tracks[track_select].tracknum then
                              ctl.tracknum = nil
                              ctl.trackguid = nil
                            else
                              ctl.tracknum = t
                              ctl.trackguid = tracks[t].guid
                            end
                            break
                          end
                        end
                      end                                      
                    end
                    
                    PopulateTrackFX()
                    update_gfx = true
                    
                    if fx_found then
                      ctl.fxfound = true
                    else
                      --FX not found
                      ctl.fxfound = false
                    end
                  end            

                  if fxoffline[ctl.fxnum] then
                    ctl.offline = true
                  end
                else
                  --other control type
                
                end
              end

            end
          end
        end
      
      else
        --Track not found
      end  
    end
    
  end

  function CheckTrack(track, strip, p, c)
  
    --if track == nil then PopulateTracks() end
    
    --master channel
    if track and track.tracknum == -1 then return true end
    if c == nil then
      local found = false
      local trx = GetTrack(track.tracknum)
      if trx then
        if track.guid == reaper.GetTrackGUID(trx) then
          return true
        else
          --Find track and update tracknum
          for i = 0, reaper.CountTracks(0) do
            local tr = GetTrack(i)
            if tr ~= nil then
              if strips[strip].track.guid == reaper.GetTrackGUID(tr) then
                --found
                found = true
                strips[strip].track.tracknum = i
                update_gfx = true
                break 
              end
            end
          end
          PopulateTracks()
        end
      else
        for i = 0, reaper.CountTracks(0) do
          local tr = GetTrack(i)
          if tr ~= nil then
            if strips[strip].track.guid == reaper.GetTrackGUID(tr) then
              --found
              found = true
              strips[strip].track.tracknum = i
              update_gfx = true
              break 
            end
          end
        end    
        PopulateTracks()    
      end
      return found
    else
      --external track ctl
      if strip and strips[strip] and strips[strip][p] and strips[strip][p].controls[c] then --temp
        local found = false
        local trx = GetTrack(nz(strips[strip][p].controls[c].tracknum,-2))
        if trx then
          if strips[strip][p].controls[c].trackguid == reaper.GetTrackGUID(trx) then
            return true
          else
            --Find track and update tracknum
            for i = 0, reaper.CountTracks(0) do
              local tr = GetTrack(i)
              if tr ~= nil then
                if strips[strip][p].controls[c].trackguid == reaper.GetTrackGUID(tr) then
                  --found
                  found = true
                  strips[strip][p].controls[c].tracknum = i
                  update_gfx = true
                  break 
                end
              end
            end
            PopulateTracks()
          end
        else
          for i = 0, reaper.CountTracks(0) do
            local tr = GetTrack(i)
            if tr ~= nil then
              if strips[strip][p].controls[c].trackguid == reaper.GetTrackGUID(tr) then
                --found
                found = true
                strips[strip][p].controls[c].tracknum = i
                update_gfx = true
                break 
              end
            end
          end    
          PopulateTracks()    
        end
        return found
      else
        return true --temp
      end      
    end
        
  end
  
  ------------------------------------------------------------    

  function testchunk(tr)
    _, statechunk = reaper.GetTrackStateChunk(tr,'',false)
    reaper.ClearConsole()
    
    local fxidx = 1
    local r, s, e = GetChunkPresetData(statechunk,fxidx)
    local t = string.sub(statechunk,s,e)
  end
  
  function ReplaceChunkPresetData(trackchunk, fxidx, newdata)

    local ret, s, e = GetChunkPresetData(trackchunk, fxidx)
    local newchunk 
    if s ~= nil and e ~= nil then
      newchunk = string.sub(trackchunk,1,s-1)..newdata..string.sub(trackchunk,e+1)
    end
    return newchunk
    
  end
  
  ------------------------------------------------------------    

  function GetChunkPresetData(chunk, fxidx)
    if chunk == nil then return nil end
    
    local ret,i,x,xe = _,_,0,1
    _,x1 = string.find(chunk, '<FXCHAIN*\n')
    xe = x1
    for i = 0, fxidx do
      if xe ~= nil then
        local cont = true
        while cont == true do
          xs,x = string.find(string.sub(chunk, xe), '<')
          if x == nil then break end
          --look for JS or VST
          if string.upper(string.sub(chunk,xe+xs,xe+xs+2)) == 'VST' or string.upper(string.sub(chunk,xe+xs,xe+xs+2)) == 'JS ' then
            cont = false
          end
          xe = xe + x
        end
      end
    end
    local s,e = nil, nil
    if x ~= nil and xe ~= nil then
      xe=xe-1
      s, e = string.find(string.sub(chunk,xe), '.->')
      s = s+xe
      e = e+xe-3 --not sure why is required - newline+blank space i guess
      ret = string.sub(chunk,s,e)
    else
      ret = nil
    end
    return ret, s, e
  
  end

  --[[function GetLeftTopControlSelected()
  
    local minx,x = 2048,2048
    local miny,y = 2048,2048
    local lctl = -1
    local tctl = -1

    local ctls = strips[tracks[track_select].strip][page].controls

    for j = 1, #ctl_select do
    
      if controls[j].id == stripid or stripid == nil then
        local x = math.min(x,controls[j].x)
        if x < minx then
          minx = x
          lctl = j
        end
      end
    end
    return lctl
    
  end]]

  function CheckSwitcherCtls(c,switchid)
    local ret = false
    for i = 1, #strips[tracks[track_select].strip][page].controls do
      local ctl = strips[tracks[track_select].strip][page].controls[c]
      if ctl.ctlcat == ctlcats.switcher and ctl.switcher == switchid then
        ret = true
        break    
      elseif ctl.ctlcat == ctlcats.switcher and c ~= i then
        local swid = ctl.switcherid
        local swret = CheckSwitcherCtls(i, swid)
        if swret == true then
          ret = swret
          break
        end
      end
    end
    return ret
  end
  
  function CheckSwitcherNotChildOfSelected(c)
  
    local ret = false
    if ctl_select and #ctl_select > 0 then
      local switchid = strips[tracks[track_select].strip][page].controls[c].switcherid
      for i = 1, #ctl_select do
        local ctl = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl]
        if ctl.ctlcat == ctlcats.switcher and i ~= c then
          local swret = CheckSwitcherCtls(i,switchid)
          if swret == true then
            ret = swret
            break
          end
        end
      end
    end
    return ret
  end

  function SwitcherInSwitcher(switchid)
    local ret = false
    for i = 1, #strips[tracks[track_select].strip][page].controls do
      local ctl = strips[tracks[track_select].strip][page].controls[i]
      if ctl.ctlcat == ctlcats.switcher and ctl.switcher == switchid then
        ret = true
      end
    end  
    return ret
  end

  function CheckSwitcherCtls(swid, switchid)
    local ret = false
    for i = 1, #strips[tracks[track_select].strip][page].controls do
      local ctl = strips[tracks[track_select].strip][page].controls[i]
      if ctl.ctlcat == ctlcats.switcher and ctl.switcher == swid then
        ret = true
        break
      elseif ctl.ctlcat == ctlcats.switcher and ctl.switcher == switchid then
        ret = CheckSwitcherCtls(swid, ctl.switcherid)
      end
    end  
    return ret
  end
  
  function SwitcherInSelected(swid)
  
    local ret = false
    if ctl_select and #ctl_select > 0 then
      for i = 1, #ctl_select do
        local ctl = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl]
        if ctl.ctlcat == ctlcats.switcher and swid == ctl.switcherid then
          ret = true
          break
        elseif ctl.ctlcat == ctlcats.switcher then
          --check switcher contains no switcher
          ret = SwitcherInSwitcher(ctl.switcherid)
          --ret = CheckSwitcherCtls(swid, ctl.switcherid)
        end
      end
    end    
    return ret
    
  end
  
  function UnorphanCtls()
  
    local ctls = strips[tracks[track_select].strip][page].controls
    for c = 1, #ctls do
    
      if ctls[c].switcher then
      
        
      
      
      
      end
    end
  
  end
  
  function CtlInSelection(c)
  
    local ret = false
    if ctl_select and #ctl_select > 0 then
      for i = 1, #ctl_select do
        if c == ctl_select[i].ctl then
          ret = true, i
          break
        end
      end
    end
    return ret
    
  end
  
  function GetLTRBControlInGrp(grpid, switchctl)
--  local tt = reaper.time_precise()
    local l,t,r,b = 2048,2048,0,0
    local gl,gt,gr,gb = 2048,2048,0,0
    local set, gset = false, false
    local ctls = strips[tracks[track_select].strip][page].controls
    local swctl = strips[tracks[track_select].strip][page].controls[switchctl]
    for c = 1, #ctls do
    
      if ctls[c].hide ~= true then
        if switchctl then
          if grpid == ctls[c].grpid and swctl.switcherid == ctls[c].switcher then
            set = true
            l = math.min(l, ctls[c].x)
            t = math.min(t, ctls[c].y)
            r = math.max(r, ctls[c].x+ctls[c].w)
            b = math.max(b, ctls[c].y+ctls[c].ctl_info.cellh)
          end      
        else
          if grpid == ctls[c].grpid then
            set = true
            l = math.min(l, ctls[c].x)
            t = math.min(t, ctls[c].y)
            r = math.max(r, ctls[c].x+ctls[c].w)
            b = math.max(b, ctls[c].y+ctls[c].ctl_info.cellh)
          end
        end
      end
    end
    local ctls = strips[tracks[track_select].strip][page].graphics
    for c = 1, #ctls do
    
      if ctls[c].hide ~= true then
        if switchctl then
          if grpid == ctls[c].grpid and swctl.switcherid == ctls[c].switcher then
            gset = true
            gl = math.min(gl, ctls[c].x)
            gt = math.min(gt, ctls[c].y)
            gr = math.max(gr, ctls[c].x+ctls[c].stretchw)
            gb = math.max(gb, ctls[c].y+ctls[c].stretchh)
          end      
        else
          if grpid == ctls[c].grpid then
            gset = true
            gl = math.min(gl, ctls[c].x)
            gt = math.min(gt, ctls[c].y)
            gr = math.max(gr, ctls[c].x+ctls[c].stretchw)
            gb = math.max(gb, ctls[c].y+ctls[c].stretchh)
          end      
        end
      end
    end
    if set == true and gset == true then
--DBG(round(tt-reaper.time_precise(),5))
      return math.min(l,gl), math.min(t,gt), math.max(r,gr), math.max(b,gb), l-gl, b-gb
    elseif set == true then
      return l, t, r, b
    elseif gset == true then
      return gl, gt, gr, gb
    else
      return swctl.x, swctl.y+swctl.ctl_info.cellh, swctl.x+swctl.w, swctl.y+swctl.ctl_info.cellh, 0, 0
    end
  end

  function GetLTRBControlInSel(switchctl)
  
    local l,t,r,b = 2048,2048,0,0
    local gl,gt,gr,gb = 2048,2048,0,0
    local set, gset = false, false
    local ctls = strips[tracks[track_select].strip][page].controls
    local swctl = strips[tracks[track_select].strip][page].controls[switchctl]
    for ctl = 1, #ctl_select do
      c = ctl_select[ctl].ctl
      --if ctls[c].hide ~= true then
        --if switchctl then
          --if grpid == ctls[c].grpid and swctl.switcherid == ctls[c].switcher then
            set = true
            l = math.min(l, ctls[c].x)
            t = math.min(t, ctls[c].y)
            r = math.max(r, ctls[c].x+ctls[c].w)
            b = math.max(b, ctls[c].y+ctls[c].ctl_info.cellh)
          --end      
        --[[else
          if grpid == ctls[c].grpid then
            set = true
            l = math.min(l, ctls[c].x)
            t = math.min(t, ctls[c].y)
            r = math.max(r, ctls[c].x+ctls[c].w)
            b = math.max(b, ctls[c].y+ctls[c].ctl_info.cellh)
          end
        end
      end]]
    end
    if gfx3_select and #gfx3_select > 0 then
      local ctls = strips[tracks[track_select].strip][page].graphics
      for ctl = 1, #gfx3_select do
        c = gfx3_select[ctl].ctl
        
        --if ctls[c].hide ~= true then
          --if switchctl then
            --if grpid == ctls[c].grpid and swctl.switcherid == ctls[c].switcher then
              gset = true
              gl = math.min(gl, ctls[c].x)
              gt = math.min(gt, ctls[c].y)
              gr = math.max(gr, ctls[c].x+ctls[c].stretchw)
              gb = math.max(gb, ctls[c].y+ctls[c].stretchh)
            --end      
          --[[else
            if grpid == ctls[c].grpid then
              gset = true
              gl = math.min(gl, ctls[c].x)
              gt = math.min(gt, ctls[c].y)
              gr = math.max(gr, ctls[c].x+ctls[c].stretchw)
              gb = math.max(gb, ctls[c].y+ctls[c].stretchh)
            end      
          end
        end]]
      end
    end
    if set == true and gset == true then
      return math.min(l,gl), math.min(t,gt), math.max(r,gr), math.max(b,gb), l-gl, b-gb
    elseif set == true then
      return l, t, r, b
    elseif gset == true then
      return gl, gt, gr, gb
    else
      return swctl.x, swctl.y+swctl.ctl_info.cellh, swctl.x+swctl.w, swctl.y+swctl.ctl_info.cellh, 0, 0
    end
  end
  
  function GetGFXOffsetInSel()
  
    if gfx3_select == nil then
      return 0, 0, 0, 0
    else
      local l,t,r,b = 2048,2048,0,0
      local gl,gt,gr,gb = 2048,2048,0,0
      local ctls = strips[tracks[track_select].strip][page].controls
      for i = 1, #ctl_select do
        local c = ctl_select[i].ctl
        l = math.min(l, ctls[c].x)
        t = math.min(t, ctls[c].y)
        r = math.max(r, ctls[c].x+ctls[c].w)
        b = math.max(b, ctls[c].y+ctls[c].ctl_info.cellh)
      end
      local ctls = strips[tracks[track_select].strip][page].graphics
      
      for i = 1, #gfx3_select do
        local c = gfx3_select[i].ctl
        gl = math.min(gl, ctls[c].x)
        gt = math.min(gt, ctls[c].y)
        gr = math.max(gr, ctls[c].x+ctls[c].stretchw)
        gb = math.max(gb, ctls[c].y+ctls[c].stretchh)
      end
      return l-gl, t-gt, r-gr, b-gb
    end    
  end

  function GetLeftControlInStrip(controls, stripid)
  
    local minx,x = 2048,2048
    local lctl = -1

    for j = 1, #controls do
      if controls[j].id == stripid or stripid == nil then
        local x = math.min(x,controls[j].x)
        if x < minx then
          minx = x
          lctl = j
        end
      end
    end
    return lctl
    
  end

  function GetLeftControlInGroup(controls, grpid)
  
    local minx,x = 2048,2048
    local lctl = -1

    for j = 1, #controls do
      if controls[j].grpid == grpid then -- or grpid == nil then
        local x = math.min(x,controls[j].x)
        if x < minx then
          minx = x
          lctl = j
        end
      end
    end
    return lctl
    
  end

  --with respect to gfx
  function GetLeftControlInStrip2(strip)
  
    local minx,gminx,miny,gminy,x,y = 2048,2048,2048,2048,2048,2048
    for j = 1, #strip.controls do
      local x,y = math.min(x,strip.controls[j].x),strip.controls[j].y
      if x < minx then minx = x ly = y end
      if y < miny then miny = y end
    end
    x,y=2048,2048
    if #strip.graphics > 0 then
      for j = 1, #strip.graphics do
        local x,y = math.min(x,strip.graphics[j].x),math.min(y,strip.graphics[j].y)
        if x < gminx then gminx = x end
        if y < miny then miny = y end
      end
    end
    
    local rx, ry = 0,0
    if gminx < 2048 then
      rx = math.max(minx - gminx,0)
    end
    if miny < 2048 then
      ry = ly - miny
    end
    return rx, ry
  end

  --[[function GetLTRBControlInSelection()
  
    local minx,gminx,miny,gminy,x,y = 2048,2048,2048,2048,2048,2048
    local maxx,gmaxx,maxy,gmaxy = 0,0,0,0
    local ctls = strips[tracks[track_select].strip][page].controls
    local lctl, tctl
    for j = 1, #ctl_select do
      local ctl = ctls[ctl_select[j].ctl]
      local x,y = math.min(x,ctl.x),ctl.y
      if x < minx then minx = x lctl = j ly = y end
      if y < miny then miny = y tctl = j end
      local x,y = math.max(x,ctl.x+ctl.w),ctl.y+ctl.h
      if x > maxx then maxx = x rctl = j ly = y end
      if y > maxy then maxy = y bctl = j end
      
    end
    x,y=2048,2048
    if gfx3_select and #gfx3_select > 0 then
      for j = 1, #gfx3_select do
        local ctl = strips[tracks[track_select].strip][page].graphics[gfx3_select[j].ctl]
        local x,y = math.min(x,ctl.x),math.min(y,ctl.y)
        if x < gminx then gminx = x end
        if y < miny then miny = y end
      end
    end
    
    local rx, ry = 0,0
    if gminx < 2048 then
      rx = math.max(minx - gminx,0)
    end
    if miny < 2048 then
      ry = ly - miny
    end
    return rx, ry, lctl, tctl
  end]]
  
  function GetXSpaceInGrid()

    local maxx,x = 0,0
    if strips[tracks[track_select].strip] then
      for j = 1, #strips[tracks[track_select].strip][page].controls do
        local x = math.max(x,strips[tracks[track_select].strip][page].controls[j].x+strips[tracks[track_select].strip][page].controls[j].w)
        if x > maxx then
          maxx = x
        end
      end
      if #strips[tracks[track_select].strip][page].graphics > 0 then
        for j = 1, #strips[tracks[track_select].strip][page].graphics do
          local x = math.max(x,strips[tracks[track_select].strip][page].graphics[j].x+strips[tracks[track_select].strip][page].graphics[j].w)
          if x > maxx then
            maxx = x
          end
        end
      end
    end
    return maxx
  
  end
  
  function SelectStripElements(stripid)
    --find left most
    local lctl = GetLeftControlInStrip(strips[tracks[track_select].strip][page].controls, stripid)
    
    if lctl ~= -1 then
      ctl_select = {}
      ctl_select[1] = {}
      ctl_select[1].ctl = lctl
    
      for j = 1, #strips[tracks[track_select].strip][page].controls do
        if strips[tracks[track_select].strip][page].controls[j].id == stripid and j ~= lctl then
          local cs = #ctl_select+1
          ctl_select[cs] = {}
          ctl_select[cs].ctl = j
          if cs ~= 1 then        
            ctl_select[cs].relx = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].x - strips[tracks[track_select].strip][page].controls[j].x
            ctl_select[cs].rely = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].y - strips[tracks[track_select].strip][page].controls[j].y
          end
        end
      end
      gfx3_select = {}
      for j = 1, #strips[tracks[track_select].strip][page].graphics do
        if strips[tracks[track_select].strip][page].graphics[j].id == stripid then
          local cs = #gfx3_select+1
          gfx3_select[cs] = {}
          gfx3_select[cs].ctl = j
          gfx3_select[cs].relx = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].x - strips[tracks[track_select].strip][page].graphics[j].x
          gfx3_select[cs].rely = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].y - strips[tracks[track_select].strip][page].graphics[j].y
        end
      end
    end
  end

  function SelectSwitchElements(swid, c)
    
    ctl_select = {}
    gfx3_select = {}

    ctl_select[1] = {}
    ctl_select[1].ctl = c

    --SelectSwitchElementsRecurse(swid)
    local ctls = strips[tracks[track_select].strip][page].controls
    for j = 1, #ctls do
      if ctls[j].switcher == swid then
        local cs = #ctl_select+1
        ctl_select[cs] = {}
        ctl_select[cs].ctl = j
        if cs ~= 1 then        
          ctl_select[cs].relx = ctls[ctl_select[1].ctl].x - ctls[j].x
          ctl_select[cs].rely = ctls[ctl_select[1].ctl].y - ctls[j].y
        end
        if ctls[j].ctlcat == ctlcats.switcher then
          SelectSwitchElementsRecurse(ctls[j].switcherid)
        end
      end
    end
    
    local gfxx = strips[tracks[track_select].strip][page].graphics
    for j = 1, #gfxx do
      if gfxx[j].switcher == swid then
        local cs = #gfx3_select+1
        gfx3_select[cs] = {}
        gfx3_select[cs].ctl = j
        gfx3_select[cs].relx = ctls[ctl_select[1].ctl].x - gfxx[j].x
        gfx3_select[cs].rely = ctls[ctl_select[1].ctl].y - gfxx[j].y
      end
    end
  
  end

  function SelectSwitchElementsRecurse(swid)
  
    local ctls = strips[tracks[track_select].strip][page].controls
    for j = 1, #ctls do
      if ctls[j].switcher == swid then
        local cs = #ctl_select+1
        ctl_select[cs] = {}
        ctl_select[cs].ctl = j
        if cs ~= 1 then        
          ctl_select[cs].relx = ctls[ctl_select[1].ctl].x - ctls[j].x
          ctl_select[cs].rely = ctls[ctl_select[1].ctl].y - ctls[j].y
        end
        if ctls[j].ctlcat == ctlcats.switcher then
          SelectSwitchElementsRecurse(ctls[j].switcherid)
        end
      end
    end
    
    local gfxx = strips[tracks[track_select].strip][page].graphics
    for j = 1, #gfxx do
      if gfxx[j].switcher == swid then
        local cs = #gfx3_select+1
        gfx3_select[cs] = {}
        gfx3_select[cs].ctl = j
        gfx3_select[cs].relx = ctls[ctl_select[1].ctl].x - gfxx[j].x
        gfx3_select[cs].rely = ctls[ctl_select[1].ctl].y - gfxx[j].y
      end
    end
    
  end
  
  function SelectGroupElements(grpid)
    --find left most
    local lctl = GetLeftControlInGroup(strips[tracks[track_select].strip][page].controls, grpid)
    
    if lctl ~= -1 then
      ctl_select = {}
      ctl_select[1] = {}
      ctl_select[1].ctl = lctl
    
      for j = 1, #strips[tracks[track_select].strip][page].controls do
        if strips[tracks[track_select].strip][page].controls[j].grpid == grpid and j ~= lctl then
          local cs = #ctl_select+1
          ctl_select[cs] = {}
          ctl_select[cs].ctl = j
          if cs ~= 1 then        
            ctl_select[cs].relx = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].x - strips[tracks[track_select].strip][page].controls[j].x
            ctl_select[cs].rely = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].y - strips[tracks[track_select].strip][page].controls[j].y
          end
        end
      end
      gfx3_select = {}
      for j = 1, #strips[tracks[track_select].strip][page].graphics do
        if strips[tracks[track_select].strip][page].graphics[j].grpid == grpid then
          local cs = #gfx3_select+1
          gfx3_select[cs] = {}
          gfx3_select[cs].ctl = j
          gfx3_select[cs].relx = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].x - strips[tracks[track_select].strip][page].graphics[j].x
          gfx3_select[cs].rely = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].y - strips[tracks[track_select].strip][page].graphics[j].y
        end
      end
    end
  end

  function AutoCentreCtls()
  
    if strips and tracks[track_select] and strips[tracks[track_select].strip] then
      local xywh = CalcCtlRect()
      if xywh then
        if surface_size.limit then
        else
          surface_offset.x = ((obj.sections[10].w + plist_w)/2 - xywh.w/2) - xywh.x 
          surface_offset.y = ((obj.sections[10].h + butt_h)/2 - xywh.h/2) - xywh.y 
        end
        strips[tracks[track_select].strip][page].surface_x = surface_offset.x
        strips[tracks[track_select].strip][page].surface_y = surface_offset.y
        update_gfx = true
      end
    end
  
  end
  
  function OpenMenu(str)
  
    local ret = gfx.showmenu(str)
    return ret
    
  end
  
  function OpenMsgBox(id, str, butt, str2)
  
    MS_Open = id
    msgbox = {text1 = str, text2 = str2, b = butt}
    update_gfx = true
    
  end
  
  function GFXMenu()
    local mstr
    local gp = 'Paste'
    if gfx_clip == nil then
      gp = '#'.. gp
    end
    if gfx2_select then
      local mm = '#Copy formatting|#Paste formatting'
      if strips[tracks[track_select].strip][page].graphics[gfx2_select].gfxtype == gfxtype.txt then
        mm = 'Copy formatting|Paste formatting'
      end
      local mm2 = 'Lock position'
      if nz(strips[tracks[track_select].strip][page].graphics[gfx2_select].poslock,false) == true then
        mm2 = '!'..mm2
      end
      mstr = 'Move up|Move down|Bring to front|Send to back||Insert label||'..mm..'||'..mm2..'||Delete||Copy|'..gp
    else
      mstr = '#Move up|#Move down|#Bring to front|#Send to back||Insert label||#Copy formatting|#Paste formatting||#Lock position||#Delete|#Copy'..gp    
    end
    gfx.x, gfx.y = mouse.mx, mouse.my
    local mx, my = mouse.mx, mouse.my
    res = OpenMenu(mstr)
    if res ~= 0 then
      if res == 1 then
        if gfx2_select < #strips[tracks[track_select].strip][page].graphics then
          local tbl = {}
          table.insert(tbl, strips[tracks[track_select].strip][page].graphics[gfx2_select])
          table.insert(tbl, strips[tracks[track_select].strip][page].graphics[gfx2_select+1])
          strips[tracks[track_select].strip][page].graphics[gfx2_select] = tbl[2]
          strips[tracks[track_select].strip][page].graphics[gfx2_select+1] = tbl[1]
          gfx2_select = gfx2_select +1
        end
              
      elseif res == 2 then
        if gfx2_select > 1 then
          local tbl = {}
          table.insert(tbl, strips[tracks[track_select].strip][page].graphics[gfx2_select])
          table.insert(tbl, strips[tracks[track_select].strip][page].graphics[gfx2_select-1])
          strips[tracks[track_select].strip][page].graphics[gfx2_select] = tbl[2]
          strips[tracks[track_select].strip][page].graphics[gfx2_select-1] = tbl[1]
          gfx2_select = gfx2_select -1
        end      
      
      elseif res == 3 then
        --to front
        if gfx2_select then
          local cnt = #strips[tracks[track_select].strip][page].graphics          
          local tbl = {}
          local tbl2 = {}
          table.insert(tbl2, strips[tracks[track_select].strip][page].graphics[gfx2_select])
          strips[tracks[track_select].strip][page].graphics[gfx2_select] = nil
          
          for i = 1, cnt do
            if strips[tracks[track_select].strip][page].graphics[i] ~= nil then
              table.insert(tbl, strips[tracks[track_select].strip][page].graphics[i])
            end
          end
          table.insert(tbl,tbl2[1])
          strips[tracks[track_select].strip][page].graphics = tbl
          gfx2_select = #strips[tracks[track_select].strip][page].graphics
        end  
          
      elseif res == 4 then
        --to back
        if gfx2_select then
          local cnt = #strips[tracks[track_select].strip][page].graphics          
          local tbl = {}
          table.insert(tbl, strips[tracks[track_select].strip][page].graphics[gfx2_select])
          strips[tracks[track_select].strip][page].graphics[gfx2_select] = nil
          
          for i = 1, cnt do
            if strips[tracks[track_select].strip][page].graphics[i] ~= nil then
              table.insert(tbl, strips[tracks[track_select].strip][page].graphics[i])
            end
          end
          strips[tracks[track_select].strip][page].graphics = tbl
          gfx2_select = 1
        end  

      elseif res == 5 then
      
        InsertLabel(mx,my)

      elseif res == 6 then

        local tbl = {}     
        table.insert(tbl, strips[tracks[track_select].strip][page].graphics[gfx2_select])
        gfx_lblformat_copy = tbl[1]
      
      elseif res == 7 then
      
        if gfx_lblformat_copy then
        
          strips[tracks[track_select].strip][page].graphics[gfx2_select].font.name = gfx_lblformat_copy.font.name
          strips[tracks[track_select].strip][page].graphics[gfx2_select].font.size = gfx_lblformat_copy.font.size
          strips[tracks[track_select].strip][page].graphics[gfx2_select].font.bold = gfx_lblformat_copy.font.bold
          strips[tracks[track_select].strip][page].graphics[gfx2_select].font.italics = gfx_lblformat_copy.font.italics
          strips[tracks[track_select].strip][page].graphics[gfx2_select].font.underline = gfx_lblformat_copy.font.underline
          strips[tracks[track_select].strip][page].graphics[gfx2_select].font.shadow = gfx_lblformat_copy.font.shadow
          strips[tracks[track_select].strip][page].graphics[gfx2_select].font.shadow_x = gfx_lblformat_copy.font.shadow_x
          strips[tracks[track_select].strip][page].graphics[gfx2_select].font.shadow_y = gfx_lblformat_copy.font.shadow_y
          strips[tracks[track_select].strip][page].graphics[gfx2_select].font.shadow_a = gfx_lblformat_copy.font.shadow_a
          strips[tracks[track_select].strip][page].graphics[gfx2_select].text_col = gfx_lblformat_copy.text_col
          
        end

      elseif res == 8 then

        strips[tracks[track_select].strip][page].graphics[gfx2_select].poslock = not strips[tracks[track_select].strip][page].graphics[gfx2_select].poslock
        poslock_select = strips[tracks[track_select].strip][page].graphics[gfx2_select].poslock
        update_gfx = true
        
      elseif res == 9 then
        DeleteSelectedCtls()
        update_gfx = true
      elseif res == 10 then
        gfx_clip = GetGraphicsTable(tracks[track_select].strip, page, gfx2_select)
      elseif res == 11 then
        if gfx_clip then
          local gfxx = strips[tracks[track_select].strip][page].graphics
          local gcnt = #gfxx+1
          gfxx[gcnt] = GetGraphicsTable(_,_,_, gfx_clip)
          gfxx[gcnt].x = (mouse.mx+surface_offset.x-obj.sections[10].x)
          gfxx[gcnt].y = (mouse.my+surface_offset.y-obj.sections[10].y)          
          update_gfx = true
        end  
      end
    end
    update_gfx = true    
  end
  
  function InsertLabel(x,y)
  
    label_add = {x = x, y = y}
    --EditLabel(6)
    if strips and strips[tracks[track_select].strip] then
      OpenEB(6,'Please enter text for label:')
    end
  
  end
  
  function InsertLabel2(txt)
  
    if txt and txt ~= '' then
    
      gfx_text_select = txt
      Strip_AddGFX(gfxtype.txt)
      update_gfx = true
      
    end
    
  end
    
  function EditLabel2(txt)
  
    --for i = 1, #ctl_select do
    if string.len(txt) > 0 then
      gfx_text_select = txt
      strips[tracks[track_select].strip][page].graphics[gfx2_select].text = txt
    end
    --end
    
  end

  function EditFont2(font)

    gfx.setfont(1,font)
    local f2,f3 = gfx.getfont()
    gfx_font_select.name = f3
    strips[tracks[track_select].strip][page].graphics[gfx2_select].font.name = f3

  end

  function CheckFont(font)

    gfx.setfont(1,font)
    local f2,f3 = gfx.getfont()
    if f3 == font then
      return f3
    end
    
  end

  function SortCtlSel_Horiz()
  
    if ctl_select and #ctl_select > 1 then
    
      local ctls = strips[tracks[track_select].strip][page].controls
      nctlsel = {}
      for c = 1, #ctl_select do
    
        if c == 1 then
          table.insert(nctlsel, ctl_select[c])
        else
          local pos = nil
          for nc = 1, #nctlsel do
            if ctls[ctl_select[c].ctl].xsc < ctls[nctlsel[nc].ctl].xsc then
              pos = nc
              break
            end
          end
          if pos then
            --insert at pos
            table.insert(nctlsel, pos, ctl_select[c])            
          else
            --insert at end
            table.insert(nctlsel, ctl_select[c])
          end
        end  
      end
      --[[for i = 1, #nctlsel do
        DBG(i..'  '..ctls[nctlsel[i].ctl].ysc)
      end]]
      
      ctl_select = nctlsel
    
    end
  end

  function Distribute_Horiz()
  
    if ctl_select and #ctl_select > 1 then
    
      SortCtlSel_Horiz()
    
      local ctls = strips[tracks[track_select].strip][page].controls
      local minx = 2048
      local minxc = -1
      local maxx = 0
      local maxxc = -1
      for c = 1, #ctl_select do
        if ctls[ctl_select[c].ctl].x < minx then
          minx = math.floor(ctls[ctl_select[c].ctl].x + (ctls[ctl_select[c].ctl].w / 2))
          minxc = c
        end
        if ctls[ctl_select[c].ctl].x > maxx then
          maxx = math.floor(ctls[ctl_select[c].ctl].x + (ctls[ctl_select[c].ctl].w / 2))
          maxxc = c
        end
      end
      
      local dx = (maxx - minx) / (#ctl_select-1)
      for c = 1, #ctl_select do
      
        ctls[ctl_select[c].ctl].x = math.floor(minx+(dx*(c-1)) - ctls[ctl_select[c].ctl].w/2)
        local scale = ctls[ctl_select[c].ctl].scale
        ctls[ctl_select[c].ctl].xsc = ctls[ctl_select[c].ctl].x + math.floor(ctls[ctl_select[c].ctl].w/2
                                                                   - (ctls[ctl_select[c].ctl].w*scale)/2)
      end
      ReselectSelection()
      SetCtlBitmapRedraw()
      update_gfx = true      
    end
  end
  
  function SortCtlSel_Vert()
  
    if ctl_select and #ctl_select > 1 then
    
      local ctls = strips[tracks[track_select].strip][page].controls
      nctlsel = {}
      for c = 1, #ctl_select do
    
        if c == 1 then
          table.insert(nctlsel, ctl_select[c])
        else
          local pos = nil
          for nc = 1, #nctlsel do
            if ctls[ctl_select[c].ctl].ysc < ctls[nctlsel[nc].ctl].ysc then
              pos = nc
              break
            end
          end
          if pos then
            --insert at pos
            table.insert(nctlsel, pos, ctl_select[c])            
          else
            --insert at end
            table.insert(nctlsel, ctl_select[c])
          end
        end  
      end
      --[[for i = 1, #nctlsel do
        DBG(i..'  '..ctls[nctlsel[i].ctl].ysc)
      end]]
      
      ctl_select = nctlsel
    
    end
  end
  
  function Distribute_Vert()
  
    if ctl_select and #ctl_select > 1 then
    
      SortCtlSel_Vert()
    
      local ctls = strips[tracks[track_select].strip][page].controls
      local miny = 2048
      local minyc = -1
      local maxy = 0
      local maxyc = -1
      for c = 1, #ctl_select do
        if ctls[ctl_select[c].ctl].y < miny then
          miny = math.floor(ctls[ctl_select[c].ctl].y + (ctls[ctl_select[c].ctl].ctl_info.cellh / 2))
          minyc = c
        end
        if ctls[ctl_select[c].ctl].y > maxy then
          maxy = math.floor(ctls[ctl_select[c].ctl].y + (ctls[ctl_select[c].ctl].ctl_info.cellh / 2))
          maxyc = c
        end
      end
      
      local dy = (maxy - miny) / (#ctl_select-1)
      for c = 1, #ctl_select do
      
        ctls[ctl_select[c].ctl].y = math.floor(miny+(dy*(c-1)) - (ctls[ctl_select[c].ctl].ctl_info.cellh/2))
        local scale = ctls[ctl_select[c].ctl].scale
        ctls[ctl_select[c].ctl].ysc = ctls[ctl_select[c].ctl].y + math.floor(ctls[ctl_select[c].ctl].ctl_info.cellh/2
                                                                   - (ctls[ctl_select[c].ctl].ctl_info.cellh*scale)/2)
      end
      ReselectSelection()
      SetCtlBitmapRedraw()
      update_gfx = true      
    end
  end
  
  function Switcher_CtlsHidden(switchid, ctl_grpid)
    local deleted 
    if switchid and switchers[switchid] and switchers[switchid].deleted ~= true then
      if switchers[switchid].current ~= ctl_grpid then
        return true
      else
        if switchers[switchid].parent then
          local ret, deleted = Switcher_CtlsHidden(switchers[switchid].parent.switcherid, switchers[switchid].parent.grpid)
          return ret, deleted
        end
      end
    else
      if switchid and switchers[switchid] and switchers[switchid].deleted == true then
        deleted = true
      end
    end
    return false, deleted
  end

  function Switcher_CtlsDeleted(switchid, ctl_grpid)
    local deleted 
    if switchid and switchers[switchid] and switchers[switchid].deleted ~= true then
      if switchers[switchid].parent == nil and switchers[switchid].current ~= ctl_grpid then
        return true
      else
        if switchers[switchid].parent then
          local ret, deleted = Switcher_CtlsHidden(switchers[switchid].parent.switcherid, switchers[switchid].parent.grpid)
          return ret, deleted
        end
      end
    else
      if switchid and switchers[switchid] and switchers[switchid].deleted == true then
        deleted = true
      end
    end
    return false, deleted
  end
  
  function Switcher_AddStrip(fn, switcher)

    loadstrip = LoadStripFN(fn)
    if loadstrip then                  
      GenStripPreview(gui, loadstrip.strip, loadstrip.switchers, loadstrip.switchconvtab)
      --image_count = image_count_add
      
      local ctls = strips[tracks[track_select].strip][page].controls
      local gfxx = strips[tracks[track_select].strip][page].graphics
      local switchid = ctls[switcher].switcherid
      local ctl_sw = ctls[switcher]
      
      local x,y = ctl_sw.x - surface_offset.x, ctl_sw.y - surface_offset.y
      y = y + ctl_sw.ctl_info.cellh
      local stripid, _, grpid = Strip_AddStrip(loadstrip,x,y,true)
      local sw_cur = #switchers[switchid].grpids+1
      switchers[switchid].grpids[sw_cur] = {}
      switchers[switchid].grpids[sw_cur].id = grpid
      switchers[switchid].grpids[sw_cur].name = string.match(fn,'.+/(.-).strip')
      
      if ctl_sw then
        ctl_sw.param_info.paramname = string.format('%i',sw_cur)..': '..switchers[switchid].grpids[sw_cur].name
      end
      switchers[switchid].current = grpid
      
      for c = 1, #ctls do
        if ctls[c].grpid == grpid then
          ctls[c].switcher = switchid

          if ctls[c].ctlcat == ctlcats.switcher then
            --add parent info
            local sid = ctls[c].switcherid
            switchers[sid].parent = {switcherid = switchid,
                                     grpid = grpid}
          end        
        end      
      end
      for c = 1, #gfxx do
        if gfxx[c].grpid == grpid then
          gfxx[c].switcher = switchid
        end        
      end
      
      update_gfx = true
      update_bg = true
      SetCtlBitmapRedraw()
      reaper.MarkProjectDirty(0)
    end
  
  end
  
  function Switcher_AddPage(switcher)
  
    local grpid = GenID()
    local ctls = strips[tracks[track_select].strip][page].controls
    local switchid = ctls[switcher].switcherid
    local sw_cur = #switchers[switchid].grpids+1
    switchers[switchid].grpids[sw_cur] = {}
    switchers[switchid].grpids[sw_cur].id = grpid
    switchers[switchid].grpids[sw_cur].name = 'Page '..sw_cur
    
    switchers[switchid].current = grpid
    
    local ctl = ctls[switcher]
    if ctl then
      ctl.param_info.paramname = string.format('%i',sw_cur)..': '..switchers[switchid].grpids[sw_cur].name
    end
    
    update_gfx = true
    update_bg = true
    SetCtlBitmapRedraw()

    return grpid
  end
  
  function Switcher_Check()
  
    local swidtab = {}
    local nstab = {}
    local scnt = #switchers
    local nscnt
    local dflag = false
    for s = 1, scnt do
      if switchers[s].deleted ~= true then
        nscnt = #nstab+1
        nstab[nscnt] = switchers[s] 
        swidtab[s] = nscnt
      else
        dflag = true
      end
    end
    if dflag == true then
      switchers = nstab
      
      for s = 1, #switchers do
        if switchers[s].parent then
          local swid = switchers[s].parent.switcherid
          switchers[s].parent.switcherid = swidtab[swid]
        end
      end
      if strips then
        for s = 1, #strips do
          for p = 1, 4 do
            if strips[s] and strips[s][p] then
              if strips[s][p].controls and #strips[s][p].controls > 0 then
                for c = 1, #strips[s][p].controls do
                  local ctl = strips[s][p].controls[c]
                  if ctl.switcher then
                    --DBG(ctl.switcher..'  '..swidtab[ctl.switcher])
                    ctl.switcher = swidtab[ctl.switcher]
                  end
                  if ctl.switcherid then
                    --DBG(ctl.switcherid..'  '..swidtab[ctl.switcherid])
                    ctl.switcherid = swidtab[ctl.switcherid]
                  end
                end
              end
              if strips[s][p].graphics and #strips[s][p].graphics > 0 then
                for c = 1, #strips[s][p].graphics do
                  local ctl = strips[s][p].graphics[c]
                  if ctl.switcher then
                    ctl.switcher = swidtab[ctl.switcher]
                  end
                end            
              end
            end
          end
        end
      end
    end
  end
  
  function Switcher_Delete(switcher, removenils, ccnt, gcnt)
  
    local ctls = strips[tracks[track_select].strip][page].controls
    local gctls = strips[tracks[track_select].strip][page].graphics
    local switchid = ctls[switcher].switcherid
    if switchid then
      if ccnt == nil then
        ccnt = #ctls
      end
      if gcnt == nil then
        gcnt = #gctls
      end
      for c = 1, ccnt do
        local ctl = ctls[c]
        if ctl and ctl.switcher == switchid then
          if ctl.ctlcat == ctlcats.switcher and c ~= switcher then
            Switcher_Delete(c, false, ccnt, gcnt)
          end
          ctls[c] = nil      
        end
      end
      for c = 1, gcnt do
        local ctl = gctls[c]
        if ctl and ctl.switcher == switchid then
          gctls[c] = nil      
        end
      end

      switchers[switchid].grpids = {}
      switchers[switchid].current = -1
      switchers[switchid].parent = nil
      switchers[switchid].deleted = true

      if removenils == true then
        local tbl = {}
        for i = 1, ccnt do
          if ctls[i] ~= nil then
            table.insert(tbl, ctls[i])
          end
        end
        strips[tracks[track_select].strip][page].controls = tbl
        local tbl = {}
        for i = 1, gcnt do
          if gctls[i] ~= nil then
            table.insert(tbl, gctls[i])
          end
        end
        strips[tracks[track_select].strip][page].graphics = tbl
        CheckDataTables()
      end

    end    
  
  end
  
  function Switcher_DeletePage(switchid)
    local ctls = strips[tracks[track_select].strip][page].controls
    --local switchid = ctls[switcher].switcherid
    if switchid then
      local grpid = switchers[switchid].current
      switchers[switchid].current = -1
      local gidcnt = #switchers[switchid].grpids
      if gidcnt > 0 then
        local tbl = {}
        for g = 1, gidcnt do
          if switchers[switchid].grpids[g].id ~= grpid then
            table.insert(tbl, switchers[switchid].grpids[g])
          end
        end
        switchers[switchid].grpids = tbl
      end    
  
      local ctls = strips[tracks[track_select].strip][page].controls
      local gctls = strips[tracks[track_select].strip][page].graphics
      local cnt = #ctls
      local gcnt = #gctls
      for c = 1, cnt do
        if ctls[c] and ctls[c].switcher == switchid and ctls[c].grpid == grpid then
          if ctls[c].ctlcat == ctlcats.switcher then
            Switcher_Delete(c,false,cnt,gcnt)
          end    
          ctls[c] = nil
        end
      end
      for c = 1, gcnt do
        if gctls[c] and gctls[c].switcher == switchid and gctls[c].grpid == grpid then
          gctls[c] = nil
        end
      end

      local tbl = {}
      for i = 1, cnt do
        if ctls[i] ~= nil then
          table.insert(tbl, ctls[i])
        end
      end
      strips[tracks[track_select].strip][page].controls = tbl
      local tbl = {}
      for i = 1, gcnt do
        if gctls[i] ~= nil then
          table.insert(tbl, gctls[i])
        end
      end
      strips[tracks[track_select].strip][page].graphics = tbl

      if switchers[switchid].grpids and #switchers[switchid].grpids > 0 then
        switchers[switchid].current = switchers[switchid].grpids[1].id
        local ctl = strips[tracks[track_select].strip][page].controls[switcher_select]
        ctl.param_info.paramname = string.format('%i',1)..': '..switchers[switchid].grpids[1].name
      else
        switchers[switchid].current = -1
        local ctl = strips[tracks[track_select].strip][page].controls[switcher_select]
        ctl.param_info.paramname = 'No pages'
      end
            
      CheckDataTables()
    end
  end
  
  function RCM_AddProgram()
  
    local retval, retcsv = reaper.GetUserInputs('Add RCM Program',4,'Program Name,Bank MSB,Bank LSB,Program Change,extrawidth=60',',0,0,0')
    if retval == true then
    
      local vals = split(retcsv,',')
      if vals[1] and vals[1] ~= '' and tonumber(vals[2]) and tonumber(vals[3]) and tonumber(vals[4]) then
        local msb = F_limit(tonumber(vals[2]),0,127)
        local lsb = F_limit(tonumber(vals[3]),0,127)
        local prog = F_limit(tonumber(vals[4]),0,127)
        
        local rctl = strips[tracks[track_select].strip][page].controls[rcm_select]
        if rctl.rcmdata == nil then
          rctl.rcmdata = {}
        end
        rctl.rcmdata[#rctl.rcmdata+1] = {name = vals[1],
                                         msb = msb,
                                         lsb = lsb,
                                         prog = prog}
                
      else
        OpenMsgBox(1,'Invalid value.',1)
      end
    end
  
  end

  function RCM_AddProgramNeb()
  
    local retval, retcsv = reaper.GetUserInputs('Add RCM Program',2,'Program Name,Program ID,extrawidth=60',',0')
    if retval == true then
    
      local vals = split(retcsv,',')
      if vals[1] and vals[1] ~= '' and tonumber(vals[2]) then
        local msb = F_limit(tonumber(math.floor(math.floor(vals[2]/100) / 128)),0,127)
        local lsb = F_limit(tonumber(math.floor(vals[2]/100) % 128),0,127)
        local prog = F_limit(tonumber(vals[2] % 100),0,127)
        
        local rctl = strips[tracks[track_select].strip][page].controls[rcm_select]
        if rctl.rcmdata == nil then
          rctl.rcmdata = {}
        end
        local datacnt = #rctl.rcmdata+1
        rctl.rcmdata[datacnt] = {name = vals[1],
                                         msb = msb,
                                         lsb = lsb,
                                         prog = prog}
        if neb_scanboot_tab then
          rctl.rcmdata[datacnt].nebfn = neb_scanboot_tab[tonumber(vals[2])]
        end        
      else
        OpenMsgBox(1,'Invalid value.',1)
      end
    end
  
  end

  function RCM_EditProgram(pn)
  
    local rctl = strips[tracks[track_select].strip][page].controls[rcm_select]
    if rctl and rctl.rcmdata and rctl.rcmdata[pn] then
      local defvals = rctl.rcmdata[pn].name ..','.. rctl.rcmdata[pn].msb ..','..rctl.rcmdata[pn].lsb ..','.. rctl.rcmdata[pn].prog
      local retval, retcsv = reaper.GetUserInputs('Edit RCM Program',4,'Program Name,Bank MSB,Bank LSB,Program Change,extrawidth=60',defvals)
      if retval == true then
      
        local vals = split(retcsv,',')
        if vals[1] and vals[1] ~= '' and tonumber(vals[2]) and tonumber(vals[3]) and tonumber(vals[4]) then
          local msb = F_limit(tonumber(vals[2]),0,127)
          local lsb = F_limit(tonumber(vals[3]),0,127)
          local prog = F_limit(tonumber(vals[4]),0,127)
          
          rctl.rcmdata[pn] = {name = vals[1],
                               msb = msb,
                               lsb = lsb,
                               prog = prog}
                  
        else
          OpenMsgBox(1,'Invalid value.',1)
        end
      end
    end  
  end

  function RCM_EditProgramNeb(pn)
  
    local rctl = strips[tracks[track_select].strip][page].controls[rcm_select]
    if rctl and rctl.rcmdata and rctl.rcmdata[pn] then
      local defvals = rctl.rcmdata[pn].name ..','.. rctl.rcmdata[pn].msb * (128*100) + rctl.rcmdata[pn].lsb*100 + rctl.rcmdata[pn].prog
      local retval, retcsv = reaper.GetUserInputs('Edit RCM Program',2,'Program Name,Program ID,extrawidth=60',defvals)
      if retval == true then
      
        local vals = split(retcsv,',')
        if vals[1] and vals[1] ~= '' and tonumber(vals[2]) then
          local msb = F_limit(tonumber(math.floor(math.floor(vals[2]/100) / 128)),0,127)
          local lsb = F_limit(tonumber(math.floor(vals[2]/100) % 128),0,127)
          local prog = F_limit(tonumber(vals[2] % 100),0,127)
          
          rctl.rcmdata[pn] = {name = vals[1],
                               msb = msb,
                               lsb = lsb,
                               prog = prog}
          if neb_scanboot_tab then
            rctl.rcmdata[pn].nebfn = neb_scanboot_tab[tonumber(vals[2])]
          end        
                  
        else
          OpenMsgBox(1,'Invalid value.',1)
        end
      end
    end  
  end
  
  function RCM_Set(rcm_select, v)

    local strip = tracks[track_select].strip
    local ctl = strips[strip][page].controls[rcm_select]
    if ctl and ctl.rcmdata and ctl.rcmdata[v] then

      if ctl.fxfound == true then
        
        local track
        if ctl.tracknum == nil then
          track = GetTrack(strips[strip].track.tracknum)
        else
          track = GetTrack(ctl.tracknum)
        end
        if track then
          local fxnum = ctl.fxnum
          if fxnum == nil then return end
          local pcnt = reaper.TrackFX_GetNumParams(track, fxnum)
          local p_byp = pcnt-1
          local p_msb = 0
          local p_lsb = 1
          local p_prog = 2
          local p_bken = 13
          
          --bypass
          --reaper.TrackFX_SetParam(track, fxnum, p_byp, 1)
          reaper.TrackFX_SetParam(track, fxnum, p_bken, 1)
          reaper.TrackFX_SetParam(track, fxnum, p_msb, ctl.rcmdata[v].msb/127)
          reaper.TrackFX_SetParam(track, fxnum, p_lsb, ctl.rcmdata[v].lsb/127)
          reaper.TrackFX_SetParam(track, fxnum, p_prog, ctl.rcmdata[v].prog/127)
          os.sleep(0.1)
          reaper.TrackFX_SetParam(track, fxnum, p_bken, 0)
          --reaper.TrackFX_SetParam(track, fxnum, p_byp, 1)
        
          ctl.val = v
          ctl.dirty = true
          update_ctls = true
          
          if ctl.rcmrefresh and ctl.rcmrefresh.guid then
            if rcmrefreshtimer == nil then
              rcmrefreshtimer = {}
            end
            local rcmrtcnt = #rcmrefreshtimer+1
            rcmrefreshtimer[rcmrtcnt] = {time = reaper.time_precise() + (ctl.rcmrefresh.delay),
                                                   guid = ctl.rcmrefresh.guid,
                                                   tracknum = tracks[track_select].tracknum,
                                                   setvals = ctl.rcmrefresh.setvals}
            rcmrefreshtimercount = rcmrefreshtimercount + 1
            if ctl.rcmrefresh.setvals then
              local guid = ctl.rcmrefresh.guid
              for i = 1, #strips[strip][page].controls do
                local sctl = strips[strip][page].controls[i]
                if sctl.fxguid == guid then
                
                  if sctl.ctlcat == ctlcats.fxparam then
                
                    if rcmrefreshtimer[rcmrtcnt].ctlvals == nil then
                      rcmrefreshtimer[rcmrtcnt].ctlvals = {}
                    end
                    rcmrefreshtimer[rcmrtcnt].ctlvals[#rcmrefreshtimer[rcmrtcnt].ctlvals+1] = {val = sctl.val,
                                                                                               strip = strip,
                                                                                               page = page,
                                                                                               ctl = i}
                  end
                end
              end
            
            end
          end
        end
      end
    end
      
  end
  
  function RCMMenu_RB()
    
    local ctl = strips[tracks[track_select].strip][page].controls[rcm_select]

    if ctl then
      if mode == 0 then      
        
        if ctl.rcmdata and #ctl.rcmdata > 0 then
        
          local ddtab = {idx = 1, x = mouse.mx, y = mouse.my, w = 100, h = 100, items = {}, wpad = 40}       
          
          local mstr = ''      
          for i = 1, #ctl.rcmdata do
            ddtab.items[i] = ctl.rcmdata[i].name
            
          end

          OpenDropDown(1, ddtab, true)
  
        end
      
      elseif mode == 1 then
      
        local mstr = 'Add Program'

        if ctl.rcmdata and #ctl.rcmdata > 0 then

          mstr = mstr .. '|>Edit Program'
          for i = 1, #ctl.rcmdata do
          
            if i < #ctl.rcmdata then 
              mstr = mstr..'|'..ctl.rcmdata[i].name
            else
              mstr = mstr..'|<'..ctl.rcmdata[i].name            
            end
          end        
        end
        
        mstr = mstr ..'||Add Program (Nebula)'
        
        if ctl.rcmdata and #ctl.rcmdata > 0 then
          mstr = mstr .. '|>Edit Program (Nebula)'
          for i = 1, #ctl.rcmdata do
          
            if i < #ctl.rcmdata then 
              mstr = mstr..'|'..ctl.rcmdata[i].name
            else
              mstr = mstr..'|<'..ctl.rcmdata[i].name            
            end
          end
          if neb_scanboot_fn then        
            mstr = mstr .. '|Update all program IDs (Nebula)'
          else
            mstr = mstr .. '|#Update all program IDs (Nebula)'          
          end
          mstr = mstr .. '||>Remove Program'
          for i = 1, #ctl.rcmdata do
          
            if i < #ctl.rcmdata then 
              mstr = mstr..'|'..ctl.rcmdata[i].name
            else
              mstr = mstr..'|<'..ctl.rcmdata[i].name            
            end
          end        
        
        end
        
        local edprog_off = 1
        local edprogN_off = 2
        local remprog_off = 3

        if ctl.rcmdata then
          edprog_off = 1+#ctl.rcmdata
          edprogN_off = edprog_off+1 + #ctl.rcmdata
          remprog_off = edprogN_off + #ctl.rcmdata + 1
        end

        local delcnt = 10
        if ctl.rcmrefresh and ctl.rcmrefresh.guid then
          mstr = mstr .. '||>!Refresh Plugin|>Delay'
        else
          mstr = mstr .. '||>Refresh Plugin|>Delay'        
        end
        for i = 1, delcnt do
          if i == delcnt then
            mstr = mstr .. '|<'        
          else
            mstr = mstr .. '|'                  
          end 
          if ctl.rcmrefresh and ctl.rcmrefresh.delay == i then
            mstr = mstr ..'!'..i..' sec'
          else
            mstr = mstr ..i..' sec'
          end
        end
        mstr = mstr..'|>Plugin'
        local track = GetTrack(tracks[track_select].tracknum)
        local fxcnt = reaper.TrackFX_GetCount(track)
        for f = 0, fxcnt-1 do
          local _, fxname = reaper.TrackFX_GetFXName(track,f,'')
          local guid = reaper.TrackFX_GetFXGUID(track,f)
          mstr = mstr .. '|'
          if f == fxcnt-1 then
            mstr = mstr .. '<'
          end
          if ctl.rcmrefresh and ctl.rcmrefresh.guid == guid then
            mstr = mstr .. '!'
          end
          mstr = mstr..fxname
        end
        if ctl.rcmrefresh and ctl.rcmrefresh.setvals == true then
          mstr = mstr .. '|!Retain Values'
        else
          mstr = mstr .. '|Retain Values'        
        end
        mstr = mstr .. '||<Clear'
        
        gfx.x, gfx.y = mouse.mx, mouse.my
        local res = OpenMenu(mstr)
        --DBG(res..'  '..edprog_off..'  '..edprogN_off..'  '..remprog_off)
        if res > 0 then
          if res == 1 then
            RCM_AddProgram()
                      
          elseif res > 1 and res <= edprog_off then
          
            RCM_EditProgram(res-1)

          elseif res == edprog_off+1 then
          
            RCM_AddProgramNeb()

          elseif res > edprog_off+1 and res <= edprogN_off then
          
            RCM_EditProgramNeb(res-(edprog_off+1))

          elseif res == edprogN_off+1 then
          
            --RCM_Neb_UpdateProgIDs(strips[tracks[track_select].strip][page].controls)
            RCM_Neb_UpdateAllProgIDs()
          
          elseif res > edprogN_off+1 and res <= remprog_off then
          
            local rcnt = #ctl.rcmdata
            ctl.rcmdata[res-(edprogN_off)] = nil
            ctl.rcmdata = Table_RemoveNils(ctl.rcmdata, rcnt)
          
          elseif res > remprog_off and res <= remprog_off+delcnt then
            if ctl.rcmrefresh == nil then
              ctl.rcmrefresh = {}
            end
            ctl.rcmrefresh.delay = res-remprog_off
            
          elseif res > remprog_off+delcnt and res <= remprog_off+delcnt+fxcnt then
            local fxnum = res - (remprog_off+delcnt+1)
            if ctl.rcmrefresh == nil then
              ctl.rcmrefresh = {delay = 1}
            end
            ctl.rcmrefresh.guid = reaper.TrackFX_GetFXGUID(track,fxnum)
          elseif res == remprog_off+delcnt+fxcnt+1 then
            if ctl.rcmrefresh == nil then
              ctl.rcmrefresh = {delay = 1}
            end
            if ctl.rcmrefresh.setvals == nil or ctl.rcmrefresh.setvals == false then
              ctl.rcmrefresh.setvals = true
            else
              ctl.rcmrefresh.setvals = nil
            end
          elseif res == remprog_off+delcnt+fxcnt+2 then
            ctl.rcmrefresh = nil
          end
        end
            
      end
    end    
  end
  
  
  function num2note(num)
  
    local i = (num % 12)+1
    local n = math.floor((num)/12)-1
    return noteletters_tab[i]..n
  
  end
  
  function NoteValueOffsetMenu(f)
  
    local vo = ''
    for i = 0, 127 do
      vo = vo .. '|'
      if i == f then
        vo = vo .. '!'
      end
      if i == 127 then
        vo = vo .. '<'
      end
      vo = vo.. string.format('%i',i)..'  -  '..num2note(i)
    end  
    gfx.x, gfx.y = mouse.mx, mouse.my
    local res = OpenMenu(vo)
    if res > 0 then
      lbx_midilrnoff = res-1
    end
  
  end
  
  function SwitcherMenu_RB()
  
    show_dd = false
    
    local sfad = strips[tracks[track_select].strip][page].controls[switcher_select].switchfader           
    local mstr
    local sfcnt = #strip_favs
    if sfcnt > 0 then
      mstr = '>Add Strip'
      for fvs = 1, sfcnt do
        if fvs == sfcnt then
          mstr = mstr .. '|<' .. string.match(strip_favs[fvs],'.+/(.-).strip')
        else
          mstr = mstr .. '|' .. string.match(strip_favs[fvs],'.+/(.-).strip')
        end
      end
      mstr = mstr..'||'
    else
      mstr = ''
    end
    mstr = mstr .. 'Add page|Rename page|Remove page|'
    local exopts = 3
    local fm, lastp = FaderMenu(sfad,true)
    mstr = mstr ..'|'..fm..'|'
    local vo = '>Fader value offset'
    for i = 0, 127 do
      if sfad then
        vo = vo .. '|'
        if i == faders[sfad].voffset then
          vo = vo .. '!'
        end
      else
        vo = vo .. '|#'      
      end
      if i == 127 then
        vo = vo .. '<'
      end
      vo = vo.. string.format('%i',i)..'  -  '..num2note(i)
    end
    local exopts2 = 3 + lastp + 128
    mstr = mstr..vo..'|'

    local ctl = strips[tracks[track_select].strip][page].controls[switcher_select]
    local switchid = ctl.switcherid
    local swc = #switchers[switchid].grpids
    for sid = 1, swc do
      mstr = mstr..'|'..string.format('%i',sid)..': '..tostring(switchers[switchid].grpids[sid].name)
    end
    
    gfx.x, gfx.y = mouse.mx, mouse.my
    local res = OpenMenu(mstr)
    if res > 0 then
    
      if res <= sfcnt then

        local fn = strip_favs[res]
        Switcher_AddStrip(fn, switcher_select)
    
      elseif res == sfcnt + 1 then
      
        Switcher_AddPage(switcher_select)

      elseif res == sfcnt + 2 then

        local ctl = strips[tracks[track_select].strip][page].controls[switcher_select]
        local switchid = ctl.switcherid
        local defname = ''
        for g = 1, #switchers[switchid].grpids do
          if switchers[switchid].grpids[g].id == switchers[switchid].current then
            defname = switchers[switchid].grpids[g].name
            break
          end
        end
        OpenEB(51,'Please enter page name:', defname)

      elseif res == sfcnt + 3 then
        
        Switcher_DeletePage(switchid)
      
      elseif res >= sfcnt + 3 and res < sfcnt + 3 + lastp then
        res = res - (sfcnt + 3)
        local f = {targettype = 6,
                   strip = tracks[track_select].strip,
                   page = page,
                   ctl = switcher_select,
                   c_id = strips[tracks[track_select].strip][page].controls[switcher_select].c_id,
                   voffset = 0}
        AssignFader(res,f)

      elseif res == sfcnt + 3 + lastp then
      
        DeleteFader(sfad)
      
      elseif res > sfcnt + 3 + lastp and res < sfcnt + exopts2 then
        
        res = res - (sfcnt + exopts2 -128)
        if sfad then
        
          faders[sfad].voffset = res-1
        
        end
        
      elseif res >= sfcnt + 1 + exopts2 then
      
        switchers[switchid].current = switchers[switchid].grpids[res - sfcnt - exopts2].id
        local ctl = strips[tracks[track_select].strip][page].controls[switcher_select]
        ctl.param_info.paramname = string.format('%i',res-sfcnt-exopts2)..': '..switchers[switchid].grpids[res - sfcnt-exopts2].name
        update_gfx = true
        update_bg = true

        SetCtlBitmapRedraw()
      end
    
    end
  end

  function SwitcherMenu_LB()
  
    --[[local mstr = ''
    local exopts = 0
    local ctl = strips[tracks[track_select].strip][page].controls[switcher_select]
    local switchid = ctl.switcherid
    local swc = #switchers[switchid].grpids
    for sid = 1, swc do
      if mstr ~= '' then mstr = mstr..'|' end
      mstr = mstr..string.format('%i',sid)..': '..tostring(switchers[switchid].grpids[sid].name)
    end
    gfx.x, gfx.y = mouse.mx, mouse.my
    local res = OpenMenu(mstr)
    if res > 0 then
    
      if res >= 1 then
      
        switchers[switchid].current = switchers[switchid].grpids[res].id
        local ctl = strips[tracks[track_select].strip][page].controls[switcher_select]
        ctl.param_info.paramname = string.format('%i',res)..': '..switchers[switchid].grpids[res].name
        update_gfx = true
        update_bg = true

        SetCtlBitmapRedraw()
      end
    
    end]]

    local ddtab = {idx = 2, x = mouse.mx, y = mouse.my, w = 100, h = 100, items = {}, wpad = 40}
    local exopts = 0
    local ctl = strips[tracks[track_select].strip][page].controls[switcher_select]
    local switchid = ctl.switcherid
    local swc = #switchers[switchid].grpids
    for sid = 1, swc do      
      ddtab.items[sid] = string.format('%i',sid)..': '..tostring(switchers[switchid].grpids[sid].name)
    end
    OpenDropDown(2, ddtab, true)
    
  end
  
  function MenuMidiMsgType()

    local mstr = ''
    for i = 1, #midimsgtype_table do
      
      if mstr ~= '' then
        mstr = mstr .. '|'
      end
      mstr = mstr ..midimsgtype_table[i]
  
    end
    if mstr ~= '' then
      gfx.x, gfx.y = mouse.mx, mouse.my
      local res = OpenMenu(mstr)
      if res ~= 0 then
        return res
      end
    end
    return nil
  
  end
  
  function MenuMidiOuts()
  
    local mstr = ''
    for i = 0, #midiouts do
      
      if mstr ~= '' then
        mstr = mstr .. '|'
      end
      mstr = mstr ..midiouts[i].name
  
    end
    if mstr ~= '' then
      gfx.x, gfx.y = mouse.mx, mouse.my
      local res = OpenMenu(mstr)
      if res ~= 0 then
        return res
      end
    end
    return nil
    
  end
  
  function CheckUngroup()
  
    local ret = true
    if ctl_select and #ctl_select > 0 then
      local grpid
      for c = 1, #ctl_select do
        local ctl = strips[tracks[track_select].strip][page].controls[ctl_select[c].ctl]
        if ctl.grpid ~= nil and grpid then
          if grpid ~= ctl.grpid then
            ret = false
            break
          end
        elseif ctl.grpid ~= nil then
          grpid = ctl.grpid
        end
      end
      if ret == true and gfx3_select and #gfx3_select > 0 then
        for c = 1, #gfx3_select do
          local ctl = strips[tracks[track_select].strip][page].graphics[gfx3_select[c].ctl]
          if ctl.grpid ~= nil and grpid then
            if grpid ~= ctl.grpid then
              ret = false
              break
            end
          elseif ctl.grpid ~= nil then
            grpid = ctl.grpid
          end
        end    
      end
    else
      return false
    end
    return ret
    
  end

  function CheckGroup()

    local ret = true
    if ctl_select and #ctl_select > 0 then
      for c = 1, #ctl_select do
        local ctl = strips[tracks[track_select].strip][page].controls[ctl_select[c].ctl]
        if ctl.switcher ~= nil then
          ret = false
          break
        end
      end
      if ret == true and gfx3_select and #gfx3_select > 0 then
        for c = 1, #gfx3_select do
          local ctl = strips[tracks[track_select].strip][page].graphics[gfx3_select[c].ctl]
          if ctl.switcher ~= nil then
            ret = false
            break
          end
        end    
      end
    else
      return false
    end
    return ret
  
  end
  
  function RBMenu_Snapshot(snapmx, snapmy)
  
    if sstype_select == 1 then
      local fm, lp = FaderMenu(snapshot_fader, true)
      mstr = 'Clone to subset (ctls only)||'..fm
      gfx.x, gfx.y = snapmx, snapmy
      local res = OpenMenu(mstr)
      if res > 0 then
        if res == 1 then
          local newsst = Snapshot_CloneToSubset(tracks[track_select].strip, page, 1, false)
          if newsst then
            sstype_select = newsst
            update_snaps = true
          end
        else
          local f = {targettype = 5}
          res = res -1
          if res ~= lastp then
            AssignFader(res, f)            
          elseif res == lastp then
            DeleteFader(snapshot_fader)
          end
        end
      end        
    elseif sstype_select > 1 then
      local fm, lp = FaderMenu(-1, true)
      mstr = 'Delete subset|Delete all subsets||Clone to subset (ctls only)||'..fm
      gfx.x, gfx.y = snapmx, snapmy
      local res = OpenMenu(mstr)
      if res > 0 then
        if res == 1 then
        
          --DBG('DELETE')
          Snapshot_DeleteSubset(tracks[track_select].strip, page, sstype_select)
          SetCtlBitmapRedraw()
          update_gfx = true
          
        elseif res == 2 then
        
          if snapshots and snapshots[tracks[track_select].strip] and #snapshots[tracks[track_select].strip][page] > 1 then
            OpenMsgBox(3, 'Delete all subsets?', 2)
          end                  

        elseif res == 3 then
          local newsst = Snapshot_CloneToSubset(tracks[track_select].strip, page, sstype_select, false)
          if newsst then
            sstype_select = newsst
            update_snaps = true
          end

        else
          local f = {targettype = 5}
          res = res -3
          if res ~= lastp then
            AssignFader(res, f)            
          elseif res == lastp then
            DeleteFader(snapshot_fader)
          end
        end
      
      end
    end
    
  end
  
  function RBMenu_Edit()
    local mm
    if poslockctl_select then
      mm = '!Lock position'
    else
      mm = 'Lock position'              
    end
    local vv
    if strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].hidden == true then
      vv = 'Visible'
    else
      vv = '!Visible'    
    end
    local ac
    if strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].ctlcat == ctlcats.action then
      ac = '||Assign custom action by name|Assign action by command ID'
    else
      ac = '||#Assign custom action by name|#Assign action by command ID'              
    end
    local cp
    if copy_ctls ~= nil then
      cp = '||Copy|Paste'
    else
      cp = '||Copy|#Paste'
    end
    local cpg
    if gauge_copy ~= nil then
      cpg = '|Copy Gauge|Paste Gauge'
    else
      cpg = '|Copy Gauge|#Paste Gauge'    
    end
    local gg = ''
    if CheckGroup() == true then
      gg = 'Group|'
    else
      gg = '#Group|'
    end
    if CheckUngroup() == true then
      gg = gg..'Ungroup||'
    else
      gg = gg..'#Ungroup||'    
    end
    local sw
    local c = GetControlAtXY(tracks[track_select].strip, page, mouse.mx, mouse.my)
    local ctl
    if c then
      ctl = strips[tracks[track_select].strip][page].controls[c]
      if ctl.ctlcat == ctlcats.switcher and SwitcherInSelected(ctl.switcherid) == false then
        sw = 'Add To Switcher||'
      end
    end 
    if sw == nil then
      sw = '#Add Controls To Switcher||'
    end
    local mstr = 'Duplicate||Align Top|Align Left|Distribute Vertically|Distribute Horizontally||'..gg..sw..mm..'||'..vv..'||Delete'..ac..cp..cpg..'||Control Info'
    gfx.x, gfx.y = mouse.mx, mouse.my
    local res = OpenMenu(mstr)
    if res == 1 then
      local c1 = #strips[tracks[track_select].strip][page].controls+1
      local dx = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].x - (mouse.mx+surface_offset.x-obj.sections[10].x) 
      local dy = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].y - (mouse.my+surface_offset.y-obj.sections[10].y)
      for i = 1, #ctl_select do
        local cc = c1+i-1
        strips[tracks[track_select].strip][page].controls[cc]=GetControlTable(tracks[track_select].strip, page, ctl_select[i].ctl)
        strips[tracks[track_select].strip][page].controls[cc].poslock = false
        --table.insert(strips[tracks[track_select].strip][page].controls[cc], strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl])
        strips[tracks[track_select].strip][page].controls[cc].x = strips[tracks[track_select].strip][page].controls[cc].x - dx
        strips[tracks[track_select].strip][page].controls[cc].y = strips[tracks[track_select].strip][page].controls[cc].y - dy
        strips[tracks[track_select].strip][page].controls[cc].xsc = strips[tracks[track_select].strip][page].controls[cc].xsc - dx
        strips[tracks[track_select].strip][page].controls[cc].ysc = strips[tracks[track_select].strip][page].controls[cc].ysc - dy
        strips[tracks[track_select].strip][page].controls[cc].id = nil
      end
      ctl_select = nil
      for i = c1, #strips[tracks[track_select].strip][page].controls do
        if ctl_select == nil then
          ctl_select = {}
          ctl_select[1] = {ctl = i}
        else
          local cs = #ctl_select+1
          ctl_select[cs] = {}
          ctl_select[cs].ctl = i                      
          ctl_select[cs].relx = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].x - strips[tracks[track_select].strip][page].controls[i].x
          ctl_select[cs].rely = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].y - strips[tracks[track_select].strip][page].controls[i].y
        end
      end
      SetCtlBitmapRedraw()                
      update_gfx = true
    elseif res == 2 then
      if #ctl_select > 1 then
        local y = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].y
        for i = 2, #ctl_select do
          if nz(strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].poslock, false) == false then
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].y = y
            local scale = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].scale
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ysc = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].y
                                                                       + math.floor(strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ctl_info.cellh/2
                                                                       - (strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ctl_info.cellh*scale)/2)
          end
        end
        ReselectSelection()
        SetCtlBitmapRedraw()
        update_gfx = true
      end
    elseif res == 3 then
      if #ctl_select > 1 then
        local x = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].x
        for i = 2, #ctl_select do
          if nz(strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].poslock, false) == false then
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].x = x
            local scale = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].scale
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].xsc = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].x
                                                                       + math.floor(strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].w/2
                                                                       - (strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].w*scale)/2)
          end
        end
        ReselectSelection()
        SetCtlBitmapRedraw()
        update_gfx = true
      end
    elseif res == 4 then
      
      Distribute_Vert()
      
    elseif res == 5 then

      Distribute_Horiz()

    elseif res == 8 then
    
      newgrp = {grpid = switchers[ctl.switcherid].current,
                switchid = c}
      DropCtls()
      SetCtlBitmapRedraw()
    
    elseif res == 6 then

      local ngrp = GenID()
      for i = 1, #ctl_select do
        local ctl = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl]
        if ctl.switcherid ~= nil then
          switchers[ctl.switcherid].parent = nil
        end
        ctl.grpid = ngrp
        ctl.switcher = nil
      end      
      if gfx3_select and #gfx3_select > 0 then
        for i = 1, #gfx3_select do
          strips[tracks[track_select].strip][page].graphics[gfx3_select[i].ctl].grpid = ngrp
          strips[tracks[track_select].strip][page].graphics[gfx3_select[i].ctl].switcher = nil        
        end 
      end     
      update_bg = true
      update_gfx = true

    elseif res == 7 then

      for i = 1, #ctl_select do
        local ctl = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl]
        if ctl.switcherid ~= nil then
          switchers[ctl.switcherid].parent = nil
        end
        ctl.grpid = nil
        ctl.switcher = nil
      end
      if gfx3_select and #gfx3_select > 0 then
        for i = 1, #gfx3_select do
          strips[tracks[track_select].strip][page].graphics[gfx3_select[i].ctl].grpid = nil
          strips[tracks[track_select].strip][page].graphics[gfx3_select[i].ctl].switcher = nil        
        end 
      end     
      update_bg = true
      update_gfx = true
  
    elseif res == 9 then
      for i = 1, #ctl_select do
        strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].poslock = not poslockctl_select
      end
      SetPosLockCtl()
    elseif res == 10 then
      local hidd = not nz(strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].hidden,false)
      for i = 1, #ctl_select do
        strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].hidden = hidd
      end
      update_gfx = true        
      
    elseif res == 11 then
      DeleteSelectedCtls()
      update_gfx = true
    
    elseif res == 12 then
      trackfxparam_select = ctl_select[1].ctl
      show_actionchooser = true
      action_tbl = LoadActionIDs()
      action_tblF = {}
      action_tblF = table.copy(action_tbl)
      
      update_gfx = true
      --OpenEB(12,'Please enter action name:')
    elseif res == 13 then
      trackfxparam_select = ctl_select[1].ctl
      retval, comid = reaper.GetUserInputs('Action Button', 1, 'Please enter action command ID: ,extrawidth=196', '')
      if retval == true and comid then
        local actnm = AssAction_GetNameFromID(comid)
        AssActionByID(comid,actnm)
        update_gfx = true          
      end
      --OpenEB(13,'Please enter action command ID:')
    elseif res == 14 then
      Copy_Selected()
    elseif res == 15 then
      Paste_Selected()
      SetCtlBitmapRedraw()
      update_gfx = true
    elseif res == 16 then
      gauge_copy = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].gauge
    elseif res == 17 then
      for i = 1, #ctl_select do
        strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].gauge = gauge_copy
      end
      update_bg = true
      update_gfx = true
    elseif res == 18 then
      if ctl_select and #ctl_select > 0 then
        for c = 1, #ctl_select do
          CtlInfo(tracks[track_select].strip, page, ctl_select[c].ctl)
        end
      end
    end
  end
  
  function CtlInfo(strip, page, c)
  
    local ctl = strips[strip][page].controls[c]
    DBG('')
    DBG('----------------------------------------------')
    DBG('CTL INFO:')
    DBG('----------------------------------------------')
    DBG('')
    DBG('Ctl ID: '..c)
    DBG('Type: '..ctltype_table[ctl.ctltype])
    DBG('Cat: '..ctl.ctlcat..' - '..string.upper(ctlcats_nm[ctl.ctlcat+1]))
    DBG('Image FN: '..ctl_files[ctl.knob_select].fn)
    DBG('Param Name: '..ctl.param_info.paramname)
    DBG('Display Name: '..tostring(ctl.ctlname_override))
    DBG('')
    DBG('Pos x: '..ctl.x)
    DBG('Pos y: '..ctl.y)
    DBG('Image Width: '..ctl.w)
    DBG('Image Height: '..ctl.ctl_info.cellh)
    DBG('')
    DBG('Scale: '..ctl.scale)
    DBG('Pos x (scaled): '..ctl.xsc)
    DBG('Pos y (scaled): '..ctl.ysc)    
    DBG('Width (scaled): '..ctl.wsc)
    DBG('Height (scaled): '..ctl.hsc)
    DBG('')
    DBG('----------------------------------------------')
    
  end
    
  function MenuStripFolders()
  
    local mstripfolders = {}
    local mstr = ''
    local cnt = 0
    local filcnt = 0
    local i = 0
    local sfol = reaper.EnumerateSubdirectories(strips_path, i)
    while sfol ~= nil do
    
      local mfol = sfol
      i=i+1
      sfol = reaper.EnumerateSubdirectories(strips_path, i)
      if sfol == nil then
        mstr = mstr ..'|<>'.. mfol
      else
        mstr = mstr ..'|>'.. mfol      
      end     
      
      local j = 0
      local sfil = reaper.EnumerateFiles(strips_path..mfol, j)
      if sfil == nil then
        mstr = mstr ..'|<#Empty'
        mstripfolders[#mstripfolders+1] = ''
        cnt = cnt + 1
      else
        while sfil ~= nil do

          if string.sub(sfil, string.len(sfil)-5) == '.strip' then
            cnt = cnt + 1
            filcnt = filcnt + 1
              
            local mfil = sfil
            mstripfolders[#mstripfolders+1] = mfol..'/'..mfil
            
            j=j+1
            sfil = reaper.EnumerateFiles(strips_path..mfol, j)
    
            if sfil == nil then
              mstr = mstr ..'|<'..string.sub(mfil, 1, string.len(mfil)-6)
            else
              mstr = mstr ..'|'..string.sub(mfil, 1, string.len(mfil)-6)
            end
          else
            j=j+1
            sfil = reaper.EnumerateFiles(strips_path..mfol, j)          
          end
              
        end
      end      
    end
    --if filcnt == 0 then cnt = 0 end
    return cnt, mstr, mstripfolders
  
  end
  
  function RBMenu_Capture()
  
    local mstr = 'Capture faderbox settings'
    if settings_savefaderboxassinsnapshots == true then
      mstr = '!'..mstr
    end
    gfx.x, gfx.y = obj.sections[160].x + mouse.mx, obj.sections[160].y + mouse.my
    res = OpenMenu(mstr)
    if res ~= 0 then
      if res == 1 then
        settings_savefaderboxassinsnapshots = not settings_savefaderboxassinsnapshots
        update_gfx = true
      end
    end    
    
  end
  
  function RBMenu(mtype,ccat,i)
    if mtype == 0 then
    
      if ccat == ctlcats.switcher then
        switcher_select = i
        SwitcherMenu_RB()
      else
        local strip = tracks[track_select].strip
        local ctl = strips[strip][page].controls[i]
        local mstr
        local mm = ''
        if show_snapshots then
          mm = '!'
        end
        lspfx = ''
        if settings_locksurface then
          lspfx = '!'
        end
        local mido = '>Midi/OSC Out|#Set|<#Clear'
        if ccat == ctlcats.fxparam or ccat == ctlcats.trackparam or ccat == ctlcats.macro or ccat == ctlcats.midictl then
          local moclr = '|<#Clear'
          if ctl.midiout then
            moclr = '|<Clear'
          end
          mido = '>Midi/OSC Out|Set'..moclr
        end
        local ff = ''
        local fft = ''
        if ctl.macrofader then
          fft = '!'
          ff = '   [Fader '..string.format('%i',ctl.macrofader)..']'
        end  
        if ccat == ctlcats.fxparam then
          mstr = fft..'Faderbox learn (global)'..ff..'|Modulation||Enter value||'..mido..'||Open FX window||Add Envelope|Add All Envelopes For Plugin||'..mm..'Snapshots||>Tools|<Regenerate ID   (emergency only)||Toggle Topbar|Toggle Sidebar||'..lspfx..'Lock Surface'
        elseif ccat == ctlcats.trackparam or ccat == ctlcats.tracksend or ccat == ctlcats.macro or ccat == ctlcats.snapshot then
          mstr = fft..'Faderbox learn (global)'..ff..'|#Modulation||Enter value||'..mido..'||#Open FX window||#Add Envelope|#Add All Envelopes For Plugin||'..mm..'Snapshots||>Tools|<Regenerate ID   (emergency only)||Toggle Topbar|Toggle Sidebar||'..lspfx..'Lock Surface'                  
        else
          mstr = fft..'#Faderbox learn (global)'..ff..'|#Modulation||Enter value||'..mido..'||#Open FX window||#Add Envelope|#Add All Envelopes For Plugin||'..mm..'Snapshots||>Tools|<Regenerate ID   (emergency only)||Toggle Topbar|Toggle Sidebar||'..lspfx..'Lock Surface'                  
        end
        --if ccat ~= ctlcats.macro then
          if #strip_favs > 0 then
            mstr = mstr .. '||#>Insert strip (favorites)'                  
          end
          trackfxparam_select = i
          gfx.x, gfx.y = mouse.mx, mouse.my
          res = OpenMenu(mstr)
          if res ~= 0 then
            if res == 1 then
              --SetParam2(true)
              --reaper.Main_OnCommand(41144,0,0)
              --reaper.OscLocalMessageToHost('/lbx/midilearn')
              lbx_midilrnctl = i
              
              lbx_midilrnval = strips[tracks[track_select].strip][page].controls[lbx_midilrnctl].macrofader
              if lbx_midilrnval then
                lbx_midilrnoff = nz(faders[lbx_midilrnval].voffset,0)
              else
                lbx_midilrnoff = 0
              end
              update_surface = true
              
            elseif res == 2 then
              SetParam2(true)
              reaper.Main_OnCommand(41143,0)
            elseif res == 3 then
              --EditValue(5)
              OpenEB(5,'Please enter value:')
            elseif res == 4 then
              midioutedit_select = i
              midiout_select = ctl.midiout
              if midiout_select == nil then
                midiout_select = {output = nil,
                                  msgtype = 4,
                                  mchan = 1,
                                  msg3 = 1,
                                  msg4 = 0,
                                  vmin = 0,
                                  vmax = 127,
                                  focus = 1,
                                  updategfx = false}
              end
              show_midiout = true
              update_gfx = true
            elseif res == 5 then
              ctl.midiout = nil
              
            elseif res == 6 then
              OpenFXGUI(strips[tracks[track_select].strip][page].controls[i])
              --[[local track
              if strips[tracks[track_select].strip][page].controls[i].tracknum == nil then
                track = GetTrack(tracks[track_select].tracknum)
              else
                track = GetTrack(strips[tracks[track_select].strip][page].controls[i].tracknum)                      
              end
              local fxnum = strips[tracks[track_select].strip][page].controls[i].fxnum
              if not reaper.TrackFX_GetOpen(track, fxnum) then
                reaper.TrackFX_Show(track, fxnum, 3)
              end]]
            elseif res == 7 then
              Envelope_Add(tracks[track_select].strip,page,i)
            elseif res == 8 then
              Envelope_AddAllFX(tracks[track_select].strip,page,i)
            elseif res == 9 then
              show_snapshots = not show_snapshots
              update_gfx = true
            elseif res == 10 then
              i = tonumber(string.format('%i',i))
              strips[tracks[track_select].strip][page].controls[i] = GetControlTable(tracks[track_select].strip, page, i)
              strips[tracks[track_select].strip][page].controls[i].c_id = GenID()
              update_gfx = true
            elseif res == 11 then
              ToggleTopbar()
            elseif res == 12 then
              ToggleSidebar()
              update_surface = true
            elseif res == 13 then
              settings_locksurface = not settings_locksurface
            end
          end
        --end
      end
    elseif mtype == 1 then
    
      mm = ''
      if show_snapshots then
        mm = '!'
      end
      local mstr = ''
      local sfcnt = #strip_favs
      if sfcnt > 0 then
        mstr = mstr .. '>Insert strip (favorites)'
        for fvs = 1, sfcnt do
          if fvs == sfcnt then
            mstr = mstr .. '|<' .. string.match(strip_favs[fvs],'.+/(.-).strip')
          else
            mstr = mstr .. '|' .. string.match(strip_favs[fvs],'.+/(.-).strip')
          end
        end
      else
        mstr = mstr .. '>Insert strip (favorites)|<#Empty'
        sfcnt = 1                 
      end
      local sffcnt, sflist, msf = MenuStripFolders()
      if sflist ~= '' then
        mstr = mstr .. '|>Insert strip (folders)' .. sflist
        sfcnt = sfcnt + sffcnt
      end
            
      local lspfx = ''
      if settings_locksurface then
        lspfx = '!'
      end
      mstr = mstr .. '||#Faderbox learn (global)|#Modulation||#Enter value||#Open FX window||'..mm..'Snapshots||Toggle Topbar|Toggle Sidebar||'..lspfx..'Lock Surface'..
                     '||>Envelopes|Bypass Envelopes|Enable Envelopes|Clear Envelopes||Bypass Strip Envelopes|Enable Strip Envelopes|Clear Strip Envelopes'
      
      gfx.x, gfx.y = mouse.mx, mouse.my
      res = OpenMenu(mstr) 
      if res ~= 0 then
        if res == sfcnt + 5 then
          show_snapshots = not show_snapshots
          update_gfx = true
        elseif res == sfcnt + 6 then
          ToggleTopbar()
        elseif res == sfcnt + 7 then
          ToggleSidebar()
          update_surface = true
        elseif res == sfcnt + 8 then
          settings_locksurface = not settings_locksurface
          
        elseif res <= sfcnt then
          if res <= #strip_favs then
            local fn = strip_favs[res]
            --PopulateStrips()
            loadstrip = LoadStripFN(fn)
            if loadstrip then                  
              GenStripPreview(gui, loadstrip.strip, loadstrip.switchers, loadstrip.switchconvtab)
              --image_count = image_count_add
              
              local dx, dy = GetLeftControlInStrip2(loadstrip.strip)
              insertstrip = {x = mouse.mx, y = mouse.my, dx = dx, dy = dy}
            end
            --loadstrip = nil
          else
            local fn = msf[res-math.max(#strip_favs,1)]
            loadstrip = LoadStripFN(fn)
            if loadstrip then                  
              GenStripPreview(gui, loadstrip.strip, loadstrip.switchers, loadstrip.switchconvtab)
              --image_count = image_count_add
              
              local dx, dy = GetLeftControlInStrip2(loadstrip.strip)
              insertstrip = {x = mouse.mx, y = mouse.my, dx = dx, dy = dy}
            end
          
          end

        elseif res == sfcnt + 9 then
          Envelopes_SetProps(false,nil,false,false)
        elseif res == sfcnt + 10 then
          Envelopes_SetProps(true,nil,true,false)
        elseif res == sfcnt + 11 then
          --delete envs
          Envelopes_SetProps(nil,nil,nil,true)
        elseif res == sfcnt + 12 then
          Envelopes_SetProps(false,nil,false,false,tracks[track_select].strip,page)
        elseif res == sfcnt + 13 then
          Envelopes_SetProps(true,nil,true,false,tracks[track_select].strip,page)
        elseif res == sfcnt + 14 then
          --delete strip envs
          Envelopes_SetProps(nil,nil,nil,true,tracks[track_select].strip,page)
        end
      end
      
    
    elseif mtype == 2 then
        
      mm = ''
      if show_snapshots then
        mm = '!'
      end
      local mstr = ''
      local sfcnt = #strip_favs
      if sfcnt > 0 then
        --mstr = mstr .. '>Insert strip (favorites)'
        for fvs = 1, sfcnt do
          if mstr ~= '' then
            mstr = mstr .. '|'
          end
          --if fvs == sfcnt then
          --  mstr = mstr .. '|<' .. string.match(strip_favs[fvs],'.+/(.-).strip')
         -- else
            mstr = mstr .. string.match(strip_favs[fvs],'.+/(.-).strip')
          --end
        end
      --else
      --  mstr = mstr .. '>Insert strip (favorites)|<#Empty'
      --  sfcnt = 1                 
      end
      local sffcnt, sflist, msf = MenuStripFolders()
      if sflist ~= '' then
        mstr = mstr .. sflist
        sfcnt = sfcnt + sffcnt
      end
      
      gfx.x, gfx.y = mouse.mx, mouse.my
      res = OpenMenu(mstr) 
      if res ~= 0 then
        
        if res <= #strip_favs and #strip_favs > 0 then
          local fn = strip_favs[res]
          --PopulateStrips()
          loadstrip = LoadStripFN(fn)
          if loadstrip then                  
            GenStripPreview(gui, loadstrip.strip, loadstrip.switchers, loadstrip.switchconvtab)
            --image_count = image_count_add
            
            local dx, dy = GetLeftControlInStrip2(loadstrip.strip)
            insertstrip = {x = mouse.mx, y = mouse.my, dx = dx, dy = dy}
          end
          --loadstrip = nil
        else
          local fn = msf[res-#strip_favs]
          loadstrip = LoadStripFN(fn)
          if loadstrip then                  
            GenStripPreview(gui, loadstrip.strip, loadstrip.switchers, loadstrip.switchconvtab)
            --image_count = image_count_add
            
            local dx, dy = GetLeftControlInStrip2(loadstrip.strip)
            insertstrip = {x = mouse.mx, y = mouse.my, dx = dx, dy = dy}
          end
        
        end
      end
    end    

  end
  
  function TopMenu()
  
    local mstr
    local ds
    local ls = ''
    local d = gfx.dock(-1)
    if d%256 == 0 then
      ds = 'Dock Window'
    else
      ds = 'Undock Window'
    end
    if settings_locksurface then
      ls = '!'
    end
    local dt = ''
    
    if (strips and tracks[track_select].strip and strips[tracks[track_select].strip] and #strips[tracks[track_select].strip][page].controls > 0) or strip_default == nil then
      dt = '#'      
    end
    local sub = '||>Strip Set'
    local cs = tonumber(string.match(STRIPSET,'%d'))
    for i = 1, 8 do
      if i < 8 then
        if cs and cs == i then
          sub = sub .. '|!Set '..string.format('%i',i)      
        else
          sub = sub .. '|Set '..string.format('%i',i)
        end
      else
        if cs and cs == i then
          sub = sub .. '|<!Set '..string.format('%i',i)      
        else
          sub = sub .. '|<Set '..string.format('%i',i)
        end      
      end
    end
    sub = sub .. '||Load Set|Merge Set|Save Set||Clear Set||>Script Data|Load Data File|<Load Backup Data File|Statistics'
    if mode == 0 then
      mstr = 'Toggle Topbar|Toggle Sidebar||Lock X|Lock Y|Scroll Up|Scroll Down||Save Project|Open Settings||>Pages|Page 1|Page 2|Page 3|<Page 4||'..ds..'||'..ls..'Lock Surface||'..dt..'Insert Default Strip'
    else
      mstr = 'Toggle Topbar|#Toggle Sidebar||Lock X|Lock Y|Scroll Up|Scroll Down||Save Script Data|Open Settings||>Pages|Page 1|Page 2|Page 3|<Page 4||'..ds..'||'..ls..'Lock Surface||'..dt..'Insert Default Strip'
    end
    mstr = mstr .. sub
    gfx.x, gfx.y = mouse.mx, butt_h
    res = OpenMenu(mstr)
    if res ~= 0 then
      if res == 1 then
        ToggleTopbar()
      elseif res == 2 then
        ToggleSidebar()
      elseif res == 3 then
        LockX()
      elseif res == 4 then
        LockY()
      elseif res == 5 then
        ScrollUp()
      elseif res == 6 then
        ScrollDown()
      elseif res == 7 then
        SaveProj(true, true)
        --lastprojdirty = 0
        --infomsg = "*** DATA SAVED ***"
        OpenMsgBox(1,'Data Saved.',1)
        update_gfx = true      
      elseif res == 8 then
        show_settings = not show_settings
        update_surface = true
      elseif res >= 9 and res <= 12 and navigate then
        SetPage(res-8)
      elseif res == 13 then
        --[[if d%256 == 0 then 
          d=d+1 
        else 
          d=d-1 
        end
        gfx.dock(d)]]
        if d%256 == 0 then
          if dockstate and dockstate%256 ~= 0 then
            gfx.dock(dockstate)
          else
            gfx.dock(d+1)
          end
        else
          dockstate = d
          gfx.dock(256)
        end
        
      elseif res == 14 then
        settings_locksurface = not settings_locksurface
      elseif res == 15 then
        stripfol_select = strip_default.stripfol_select
        strip_select = strip_default.strip_select
        PopulateStrips()
        loadstrip = LoadStrip(strip_select)
        if loadstrip then
          GenStripPreview(gui, loadstrip.strip, loadstrip.switchers, loadstrip.switchconvtab)
          Strip_AddStrip(loadstrip,0,0,true)
          --image_count = image_count_add
          loadstrip = nil
          --SaveSingleStrip(strip)
          reaper.MarkProjectDirty(0)
        end
      elseif res >= 16 and res <= 23 then
        --SaveProj()
        local oscript = SCRIPT
        if res == 16 then
          SCRIPT = 'LBX_STRIPPER'
          STRIPSET = 'STRIP SET 1'
        else
          SCRIPT = 'LBX_STRIPPER_'..res-15        
          STRIPSET = 'STRIP SET '..string.match(tostring(res-15),'(.-)%.')
        end
        if oscript ~= SCRIPT then
          DBGOut('')
          DBGOut('*** LOADING NEW PROJECT ***')    
          
          newloc = true
        end
      elseif res == 24 then
        --load set
        loadset_fn = LoadSet(false)
      elseif res == 25 then
        --merge set
        loadset_fn = LoadSet(true)
      elseif res == 26 then
        --save set
        OpenEB(20,'Please enter name of strip set:')
      elseif res == 27 then
      elseif res == 28 then
        local fn = datafile
        if fn == nil then fn = '' end
        local ret, rfn = reaper.GetUserFileNameForRead(fn, 'Load lbxstripper data file:', nz(string.match(fn, '.+%.(lbxstripper.*)'),''))
        if ret == true then
          LoadDataFile(rfn)
        end
      elseif res == 29 then
        local fn = datafile
        local ret, rfn = reaper.GetUserFileNameForRead(string.match(fn,'(.+).lbxstripper.*'), 'Load lbxstripper data file:', 'lbxbak')
        if ret == true then
          LoadDataFile(rfn)
        end
      elseif res == 30 then
        ShowStats()
      end
      update_gfx = true
    end
    
  end

  function ShowStats()
  
    --GUI_DrawStateWin(obj,gui,'Strip Statistics',true)
    --GUI_DrawStateWin(obj,gui,'')
    DBG('Strip Statistics')
    DBG('')
    local totc = 0
    local totsub = 0
    local totsnap = 0
    for s = 1, #strips do
      local stripc = 0
      local subsetsc = 0
      local snapsc = 0
      for p = 1, 4 do
      
        if strips[s][p] then
          stripc = stripc + #strips[s][p].controls
        end
        if snapshots[s][p] then
          subsetsc = subsetsc + #snapshots[s][p]
          snapsc = snapsc + #snapshots[s][p][1]
        
          if #snapshots[s][p] > 1 then
            for i = 2, #snapshots[s][p] do
            
              snapsc = snapsc + #snapshots[s][p][i].snapshot
            
            end
          end          
        end
        
      end
      if stripc > 0 then
        local tr = ''
        if strips[s].track.tracknum == -1 then
          tr = '(Master)'
        else
          tr = '(Track '..strips[s].track.tracknum+1 ..')'
        end
        local str = 'Strip '..s..' '.. tr ..' ................ #Controls = '..stripc..'  #Snapshot sets = '..subsetsc..'  #Snapshots = '..snapsc
        totc=totc+stripc
        totsub=totsub+subsetsc
        totsnap=totsnap+snapsc
                
        --GUI_DrawStateWin(obj,gui,str)
        DBG(str)
      end    
    end
    --GUI_DrawStateWin(obj,gui,'')
    --GUI_DrawStateWin(obj,gui,'Total Controls = '..totc)
    --GUI_DrawStateWin(obj,gui,'Total Subsets = '..totsub)
    --GUI_DrawStateWin(obj,gui,'Total Snapshots = '..totsnap)
    DBG('')
    DBG('Total Controls = '..totc)
    DBG('Total Snapshot sets = '..totsub)
    DBG('Total Snapshots = '..totsnap)
    --reaper.MB('Close statistics', 'Stats', 0)
  end

  function ToggleTopbar()
  
    hide_topbar = not hide_topbar
    obj = GetObjects()
    update_surface = true
    update_topbar = true
    
  end
  
  function ToggleSidebar()
    
    --if mode == 0 or hide_topbar == true and settings_showminimaltopbar == false then
      show_editbar = not show_editbar
      if show_editbar then
        plist_w = oplist_w
      else
        plist_w = 0
      end
      force_resize = true
    --end    
  
  end
  
  function LockX()
    lockx = not lockx
    if lockx then
      surface_offset.x = 0
    end
    obj = GetObjects()
  end
  
  function LockY()
    locky = not locky
    if locky then
      surface_offset.y = 0
    end
    obj = GetObjects()
  end
  
  function ScrollUp()
    --if settings_locksurface == false then
      if surface_offset.y > 0 then
        if lockh > 0 then
          surface_offset.y = surface_offset.y - lockh
        else
          surface_offset.y = surface_offset.y - math.floor(obj.sections[10].h/settings_gridsize)*settings_gridsize
        end
      end
    --end
  end
  
  function ScrollDown()
    --if settings_locksurface == false then
      if surface_offset.y < surface_size.h-obj.sections[10].h then
        if lockh > 0 then
          surface_offset.y = surface_offset.y + lockh
        else
          surface_offset.y = surface_offset.y + math.floor(obj.sections[10].h/settings_gridsize)*settings_gridsize
        end
      --end
    end
  end
  
  function CheckGlobalTrack()
  
    local track = reaper.GetTrack(0, LBX_GTRACK)
    local _, trn = reaper.GetTrackName(track,'')
    if trn ~= LBX_GTRACK_NAME then
      PopulateTracks()
      update_gfx = true
    end
  
  end

  function CheckGlobalTrackSel()
  
    if LBX_GTRACK then
      CheckGlobalTrack()
      if gpage == true then
        if track_select ~= LBX_GTRACK then
          SetGlobalPage(true)
        end
      else
        if track_select == LBX_GTRACK then
          SetGlobalPage(true)
        end
      end
    else
      if track_select == LBX_GTRACK then
        SetPage(0)
      end        
    end
  
  end
  
  function SetGlobalPage(force)
    if gpage == true and not force then SetPage(nz(gpage_opage,1)) return end
    if LBX_GTRACK == nil then
      PopulateTracks()
    else
      CheckGlobalTrack()
    end
    if LBX_GTRACK then    
    
      if show_fsnapshots then
        show_fsnapshots = false
        show_xysnapshots = false
        update_surface = true
      end
  
      gpage = true
      if track_select ~= LBX_GTRACK then
        gpage_otrackselect = track_select
        gpage_opage = page
      end
            
      track_select = LBX_GTRACK
      page = 1
  
      ctl_select = nil
      gfx2_select = nil
      gfx3_select = nil
      ss_select = nil
      sstype_select = 1
      CloseActChooser()
      show_ctlbrowser = false
  
      if strips and tracks[track_select] and strips[tracks[track_select].strip] then
        strips[tracks[track_select].strip].page = 1
        surface_offset.x = tonumber(strips[tracks[track_select].strip][page].surface_x)
        surface_offset.y = tonumber(strips[tracks[track_select].strip][page].surface_y)
      else
        surface_offset.x = 0
        surface_offset.y = 0       
      end
  
      InsertDefaultStrip()
      
      GUI_DrawCtlBitmap()
      
      if settings_trackchangemidi == true then
        TrackChangeMidi()
      end
  
      update_gfx = true
    else
    
    end

  end
  
  function SetPage(lpage)
  
    --if track_select == LBX_GTRACK then page = 1 return end
    if lpage == 0 then
      if gpage == false and track_select ~= LBX_GTRACK then
        SetGlobalPage()
      end
      return
    end
    
    if show_fsnapshots then
      show_fsnapshots = false
      show_xysnapshots = false
      update_surface = true
    end
    
    gpage = false

    if track_select == LBX_GTRACK and gpage_otrackselect then
      track_select = gpage_otrackselect
      --Set track selected
      if settings_followselectedtrack then
        --Select track
        local tr = GetTrack(track_select)
        if tr then
          if tr ~= nil then
            reaper.SetOnlyTrackSelected(tr)
            reaper.SetTrackSelected(tr, true)
          end
        end      
      end
      --gpage_otrackselect = nil
    end
    page = lpage
    ctl_select = nil
    gfx2_select = nil
    gfx3_select = nil
    ss_select = nil
    sstype_select = 1
    CloseActChooser()
    show_ctlbrowser = false
    
    if strips and tracks[track_select] and strips[tracks[track_select].strip] then
      strips[tracks[track_select].strip].page = page
      surface_offset.x = tonumber(strips[tracks[track_select].strip][page].surface_x)
      surface_offset.y = tonumber(strips[tracks[track_select].strip][page].surface_y)
    else
      surface_offset.x = 0
      surface_offset.y = 0       
    end

    InsertDefaultStrip()
    
    GUI_DrawCtlBitmap()
    
    if settings_trackchangemidi == true then
      TrackChangeMidi()
    end
    
    --if settings_autocentrectls then
    --  AutoCentreCtls()
    --end
    update_gfx = true
    
  end
  
  function TrackChangeMidi()
  
    if tracks[track_select] then
      local strip = tracks[track_select].strip
      if strips[strip] then
        local ctls = strips[strip][page].controls
        for c = 1, #ctls do
          local ctl = ctls[c]
          if ctl.ctlcat ~= ctlcats.midictl and ctl.midiout then
            SendMIDIMsg(ctl.midiout, ctl.val)
          end    
        end
      end
    end
          
  end
  
  function SetCtlSelectVals()
    if ctl_select and #ctl_select > 0 then
      local ctl = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl]
      ctltype_select = ctl.ctltype
      knob_select = ctl.knob_select
      scale_select = ctl.scale
      textcol_select = ctl.textcol
      textcolv_select = ctl.textcolv
      show_paramname = ctl.show_paramname
      show_paramval = ctl.show_paramval
      textoff_select = ctl.textoff
      textoffval_select = ctl.textoffval
      textoff_selectx = ctl.textoffx
      textoffval_selectx = ctl.textoffvalx
      textsize_select = ctl.textsize
      textsizev_select = ctl.textsizev
      defval_select = ctl.defval
      maxdp_select = nz(ctl.maxdp,-1)                  
      dvaloff_select = nz(ctl.dvaloffset,'')                  
      --knob_scalemode_select = nz(ctl.scalemode,1)                  
      scalemode_select = nz(ctl.scalemode,8)
      framemode_select = nz(ctl.framemode,1)
      horiz_select = nz(ctl.horiz,false)
      noss_select = ctl.noss
      knobsens_select = nz(ctl.knobsens,settings_defknobsens)
      --DBG(ctl.cycledata.statecnt)
      if ctl.cycledata and ctl.cycledata.statecnt > 0 then
        mapptof_select = ctl.cycledata.mapptof
        draggable_select = ctl.cycledata.draggable
        spread_select = ctl.cycledata.spread
      end
      local gt = Gauge_CopySelect(ctl.gauge)
      if gt then
        gauge_select = gt
      end
      ctlfont_select = ctl.font
      bypass_bgdraw_c_select = ctl.bypassbg_c
      bypass_bgdraw_n_select = ctl.bypassbg_n
      bypass_bgdraw_v_select = ctl.bypassbg_v
      clickthrough_select = ctl.clickthrough
      
      SetKnobScaleMode()
      cycle_select = Cycle_CopySelectIn(ctl_select[1].ctl)
      local min, max = GetParamMinMax_ctl(ctl_select[1].ctl)
      minov_select = min
      maxov_select = max
    end
  end

  function SetKnobScaleMode()
  
    if scalemode_select == 8 and framemode_select == 1 then
      knob_scalemode_select = 2
    elseif scalemode_select == 12 and framemode_select == 2 then
      knob_scalemode_select = 3
    else
      knob_scalemode_select = 1
    end
  
  end

  function SetGfxSelectVals()
    gfx_font_select.name = strips[tracks[track_select].strip][page].graphics[gfx2_select].font.name
    gfx_font_select.size = strips[tracks[track_select].strip][page].graphics[gfx2_select].font.size
    gfx_font_select.bold = strips[tracks[track_select].strip][page].graphics[gfx2_select].font.bold
    gfx_font_select.italic = strips[tracks[track_select].strip][page].graphics[gfx2_select].font.italic
    gfx_font_select.underline = strips[tracks[track_select].strip][page].graphics[gfx2_select].font.underline
    gfx_font_select.shadow = strips[tracks[track_select].strip][page].graphics[gfx2_select].font.shadow
    gfx_font_select.shadow_x = strips[tracks[track_select].strip][page].graphics[gfx2_select].font.shadow_x
    gfx_font_select.shadow_y = strips[tracks[track_select].strip][page].graphics[gfx2_select].font.shadow_y
    gfx_font_select.shadow_a = strips[tracks[track_select].strip][page].graphics[gfx2_select].font.shadow_a
    gfx_textcol_select = strips[tracks[track_select].strip][page].graphics[gfx2_select].text_col
    gfx_text_select = strips[tracks[track_select].strip][page].graphics[gfx2_select].text
    poslock_select = strips[tracks[track_select].strip][page].graphics[gfx2_select].poslock
  end

  function SetGfxSelectVals2()
    gfxbright_select = nz(strips[tracks[track_select].strip][page].graphics[gfx2_select].bright,0.5)
    gfxcontr_select = nz(strips[tracks[track_select].strip][page].graphics[gfx2_select].contr,0.5)
    gfxr_select = nz(strips[tracks[track_select].strip][page].graphics[gfx2_select].rmult,0.5)
    gfxg_select = nz(strips[tracks[track_select].strip][page].graphics[gfx2_select].gmult,0.5)
    gfxb_select = nz(strips[tracks[track_select].strip][page].graphics[gfx2_select].bmult,0.5)
    gfxa_select = nz(strips[tracks[track_select].strip][page].graphics[gfx2_select].alpha,1)    
    gfxstretchmode_select = nz(strips[tracks[track_select].strip][page].graphics[gfx2_select].stretchmode,1)
    gfxedgesz_select = nz(strips[tracks[track_select].strip][page].graphics[gfx2_select].edgesz,8)
  end
    
  function GetValFromDVal(c, dv, checkov)
    if checkov == nil then checkov = true end
  
    if c then
      local strip = tracks[track_select].strip
      local ctl = strips[strip][page].controls[c]
      local t = strips[strip].track.tracknum
      if ctl.tracknum ~= nil then
        t = ctl.tracknum
      end
      local cc = ctl.ctlcat
      if cc == ctlcats.fxparam or cc == ctlcats.trackparam or cc == ctlcats.tracksend then

        local sldiv = 400

        local f = ctl.fxnum
        local p = ctl.param
        track = GetTrack(t)
        
        local min, max = GetParamMinMax_ctl(c, checkov)
        local v = GetParamValue_Ctl(c)
        
        local dvoff = ctl.dvaloffset
        trackfxparam_select = c
        SetParam3(strip,page,c,ctl,min)
        os.sleep((auto_delay/sldiv)*10)
        --for i = 1, 100 do i=i end
        miv = tonumber(GetParamDisp(cc,t,f,p,dvoff,c))
        --for i = 1, 10 do i=i end
        
        SetParam3(strip,page,c,ctl,max)
        os.sleep((auto_delay/sldiv)*10)
        --for i = 1, 100 do i=i end
        mav = tonumber(GetParamDisp(cc,t,f,p,dvoff,c))
        if (miv == nil or mav == nil) or (miv and mav and mav > miv) then
        
          local pinc = 0
          local found = false
          local mdp = 50
          local nval, dval, dval2, rval = 0, '', '', 0
          for j = 0, mdp do
            for i = 0, 9 do
              local inc = (1/(10^j))*i
              nval = rval + inc
              SetParam3(strip,page,c,ctl,nval)
              os.sleep((auto_delay/sldiv)*10)
              dval2 = GetParamDisp(cc,t,f,p,dvoff,c)
              dval = GetNumericPart(dval2)
              if tonumber(dval) then
                if tonumber(dval) == tonumber(dv) then
                  found = true
                  rval = nval
                  break
                elseif tonumber(dval) < tonumber(dv) then
                  if i ==9 then
                    rval = rval + inc
                  else
                    pinc = inc
                  end
                elseif tonumber(dval) > tonumber(dv) then
                  rval = rval + pinc
                  break
                end
              else
                pinc = inc
                rval = rval + inc
              end        
            end
    
            if found then
              break
            end
          end
          A_SetParam(strip,page,c,ctl)    
          return rval, dval2
        else
          OpenMsgBox(1, 'Currently unavailable for this parameter.', 1)
  --[[
                  local pinc = 0
                  local found = false
                  local mdp = 50
                  local nval, dval, dval2, rval = 0, '', '', 0
                  for j = 0, mdp do
                    pinc = 0
                    for i = 0, 9 do
                      local inc = (1/(10^j))*i
                      nval = rval + inc
                      SetParam3(nval)
                      for x = 1,20 do x=x end
                      dval2 = GetParamDisp(t,f,p,dvoff)
                      dval = GetNumericPart(dval2)
                      if tonumber(dval) then
                        if tonumber(dval) == tonumber(dv) then
                          found = true
                          rval = nval
                          break
                        elseif tonumber(dval) > tonumber(dv) then
                          if i == 9 then
                            rval = rval + inc
                          else
                            pinc = inc
                          end
                        elseif tonumber(dval) < tonumber(dv) then
                          rval = rval + pinc - inc
                          break
                        end
                      else
                        pinc = inc
                        rval = rval + inc
                      end
                    end
            
                    if found then
                      break
                    end
                  end
                  SetParam()    
                  return rval
       ]]
          return 0
        end
      end
    end
  
  end
  
  function SetPosLockCtl()
  
    if ctl_select and #ctl_select > 0 then
      poslockctl_select = true
      for i = 1, #ctl_select do
        if nz(strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].poslock,false) == false then
          poslockctl_select = false
          break
        end    
      end
    else
      poslockctl_select = false
    end
      
  end
  
  --courtesy mpl from http://forum.cockos.com/showthread.php?t=169760
  function Get_ID_By_Name(name)
    kb_table = {}
    filename = reaper.GetResourcePath()..'/'..'reaper-kb.ini'
    file = io.open(filename, "r")
    content = file:read("*all")
    for line in io.lines(filename) do table.insert(kb_table, line) end
    file:close()
  
    for i = 1, #kb_table do
      if string.find(kb_table[i], name) ~= nil then
        temp_t = {}
        for word in string.gmatch(kb_table[i], '.-[%s]') do table.insert(temp_t, word) end
        local actnm = string.match(kb_table[i], '"(.-)"')
        return '_'..string.sub(temp_t[4],0,-2), actnm
      end
    end
  end

  function ActionListFilter(txt)
  
    txt = string.upper(txt)..' '
    tbl = {}

    local temp_t = {}
    for word in string.gmatch(txt, '(.-)[%s]') do table.insert(temp_t, word) end
    for i = 1, #action_tbl do
    
      local cd = string.upper(action_tbl[i].command_desc)
      
      local match = true
      for w = 1, #temp_t do
        local m = string.match(cd,temp_t[w])
        if m == nil then
          match = false
          break
        end
      end
    
      if match then
        table.insert(tbl, action_tbl[i])
      end
    end
  
    return tbl
  end
  
  function LoadActionIDs()
    
    local actcnt = 0
    
    local action_tbl = {}
    local kb_table
    
    --enumerate dump folderr
    local j = 0
    local i = 0
    
    local sd = reaper.EnumerateSubdirectories(resource_path, j)
    while sd ~= nil do

      if sd == 'actiondumps' then
        local df = reaper.EnumerateFiles(actiondump_path,i)
        while df ~= nil do
          
          kb_table = {}
          filename = actiondump_path..'/'..df
          file = io.open(filename, "r")
          content = file:read("*all")
          for line in io.lines(filename) do table.insert(kb_table, line) end
          file:close()
    
          for i = 3, #kb_table do
            local actid, actnm = string.match(kb_table[i],'.-(%d+).-(%w.*)')
            if actid and actnm then
              actcnt = actcnt + 1
              action_tbl[actcnt] = {dcommand_id = actid, command_desc = actnm}
            end
          end
          i=i+1
          df = reaper.EnumerateFiles(actiondump_path,i)
        end
        break
      end
      j=j+1
      sd = reaper.EnumerateSubdirectories(resource_path, j)
    end

    kb_table = {}
    filename = reaper.GetResourcePath()..'/'..'reaper-kb.ini'
    if reaper.file_exists(filename) then
      file = io.open(filename, "r")
      content = file:read("*all")
      for line in io.lines(filename) do table.insert(kb_table, line) end
      file:close()
    
      for i = 1, #kb_table do
        temp_t = {}
        for word in string.gmatch(kb_table[i], '.-[%s]') do table.insert(temp_t, word) end
        if temp_t[1] == 'SCR ' then
          actcnt = actcnt + 1
          local actnm = string.match(kb_table[i], '"(.-)"')
          local actid = '_'..string.sub(temp_t[4],0,-2)
          action_tbl[actcnt] = {command_id = actid, command_desc = actnm}
        end 
      end
      
      kb_table = {}
      filename = reaper.GetResourcePath()..'/'..'S&M_Cyclactions.ini'
      if reaper.file_exists(filename) then
        file = io.open(filename, "r")
        content = file:read("*all")
        for line in io.lines(filename) do table.insert(kb_table, line) end
        file:close()
      
        local cycacttype, cyctype
        for i = 1, #kb_table do
          local l = string.match(kb_table[i], '%[(.*)%]')
          if l then
            cycacttype = l
            if cycacttype == 'Main_Cyclactions' then
              cyctype = '_S&M_CYCLACTION_'
            elseif cycacttype == 'MainAlt_Cyclactions' then
              cyctype = '_S&M_MAIN_ALT_CYCLACTION'
            elseif cycacttype == 'MediaEx_Cyclactions' then
              cyctype = '_S&M_MEDIAEX_CYCLACTION'
            elseif cycacttype == 'ME_Piano_Cyclactions' then
              cyctype = '_S&M_ME_PIANO_CYCLACTION'
            elseif cycacttype == 'ME_List_Cyclactions' then
              cyctype = '_S&M_ME_LIST_CYCLACTION'
            elseif cycacttype == 'ME_Inline_Cyclactions' then
              cyctype = '_S&M_ME_INLINE_CYCLACTION'
            else
              cyctype = nil
            end
          else
            if cyctype then
              local l = string.match(kb_table[i], 'Action(%d)=')
              if l then
                actcnt = actcnt + 1                
                local actid = cyctype..l
                local actnm = string.match(kb_table[i], '"(.-)|')
                action_tbl[actcnt] = {command_id = actid, command_desc = actnm}
              end
            end
          end
          
        end
      end
    end
        
    kb_table = {}
    filename = reaper.GetResourcePath()..'/'..'S&M.ini'
    if reaper.file_exists(filename) then
      file = io.open(filename, "r")
      content = file:read("*all")
      for line in io.lines(filename) do table.insert(kb_table, line) end
      file:close()
      local readacts = false
      for i = 1, #kb_table do
        local l = string.match(kb_table[i], '%[(.*)%]')
        if l and readacts == false then
          if l == 'NbOfActions' then
            readacts = true
          else
            readacts = false
          end
        elseif readacts then
          local l = string.match(kb_table[i], 'S&M_.-=(%d+) ')
          if l then
            local aid = string.match(kb_table[i], '(S&M_.-)=')
            local an = string.match(kb_table[i], '; (.*)')
            local s, e = string.find(an,'.%-%-')
            if s then
              an = string.sub(an,1,s-1)
            end
            for j = 1, l do
  
              actcnt = actcnt + 1          
              local actid = aid..j
              local an = string.gsub(an,'([^a-z])n([^a-z])','%1'..j..'%2')
              an = string.gsub(an,'( [^a-z])(n)$','%1'..j)
              an = string.gsub(an,'( )(n)$','%1'..j)
              local actnm = an
              action_tbl[actcnt] = {command_id = actid, command_desc = actnm}        
            end
          end
        end
      end
    end
    
    return action_tbl
    
  end
      
  function AssActionByName(txt)
  
  end

  function AssAction_GetNameFromID(comid)
  
    if string.sub(comid,1,1) == '_' then
      comid = string.sub(comid,2)
    end
    local ret = 'Action: '..comid
    local acttbl = LoadActionIDs()
    for i = 1, #acttbl do
      --if i%20 == 0 then
      --DBG(tostring(acttbl[i].command_id)..'  '..tostring(acttbl[i].dcommand_id))
      --end
      if acttbl[i].command_id then
        if string.sub(acttbl[i].command_id,1,1) == '_' then
          acttbl[i].command_id = string.sub(acttbl[i].command_id,2)
        end        
        if acttbl[i].command_id == comid then
          ret = acttbl[i].command_desc
          --DBG(ret)
          break
        end
      elseif acttbl[i].dcommand_id then
        if string.sub(acttbl[i].dcommand_id,1,1) == '_' then
          acttbl[i].dcommand_id = string.sub(acttbl[i].dcommand_id,2)
        end 
        if acttbl[i].dcommand_id == comid then
          ret = acttbl[i].command_desc
          --DBG(ret)
          break
        end
      end
    end
    return ret
    
  end
  
  function AssActionByID(txt, p_actnm)
  
    local actnm = 'Action: '..txt
    if p_actnm then
      actnm = p_actnm
    end
    strips[tracks[track_select].strip][page].controls[trackfxparam_select].param_info.paramname = actnm
    if tonumber(txt) == nil then
      strips[tracks[track_select].strip][page].controls[trackfxparam_select].param_info.paramidx = txt
      strips[tracks[track_select].strip][page].controls[trackfxparam_select].param_info.paramnum = nil
    else
      strips[tracks[track_select].strip][page].controls[trackfxparam_select].param_info.paramidx = nil
      strips[tracks[track_select].strip][page].controls[trackfxparam_select].param_info.paramnum = tonumber(txt)
    end
    update_gfx = true
    
  end

  function table.copy(t)
    if t == nil then return nil end
    local u = { }
    for k, v in pairs(t) do u[k] = v end
    return setmetatable(u, getmetatable(t))
  end
  
  function table.deepcopy(o, seen)
    seen = seen or {}
    if o == nil then return nil end
    if seen[o] then return seen[o] end
  
  
    local no = {}
    seen[o] = no
    setmetatable(no, deepcopy(getmetatable(o), seen))
  
    for k, v in next, o, nil do
      k = (type(k) == 'table') and k:deepcopy(seen) or k
      v = (type(v) == 'table') and v:deepcopy(seen) or v
      no[k] = v
    end
    return no
  end
  
  function table_slowsort_val(tbl)
   
     local dtbl = {}
     local rtbl
     local cnt = #tbl
     if cnt > 0 then  
       for st = 1, cnt do
         if st == 1 then
           --insert 
           table.insert(dtbl, tbl[st])
         else
           local inserted = false
           local dcnt = #dtbl
           for dt = 1, dcnt do
             if dtbl[dt].val then
               if tbl[st] and dtbl[dt] and nz(tonumber(tbl[st].val),0) > nz(tonumber(dtbl[dt].val),0) then
                 table.insert(dtbl, dt, tbl[st])
                 inserted = true
                 break
               end
             else
               break
             end
           end 
           if inserted == false then
             table.insert(dtbl, tbl[st])
           end
         end
       end
       rtbl = {}    
       for dt = #dtbl, 1, -1 do
         rtbl[#dtbl-(dt-1)] = dtbl[dt]
       end
     end
     return rtbl
  end
  
  function cycledata_slowsort(tbl)
  
    local dtbl = {}
    if tbl.statecnt > 0 then  
      for st = 1, tbl.statecnt do
        if st == 1 then
          --insert 
          table.insert(dtbl, tbl[st])
        else
          local inserted = false
          local dcnt = #dtbl
          for dt = 1, dcnt do
            if dtbl[dt].val then
              if tbl[st] and dtbl[dt] and nz(tonumber(tbl[st].val),0) > nz(tonumber(dtbl[dt].val),0) then
                table.insert(dtbl, dt, tbl[st])
                inserted = true
                break
              end
            else
              break
            end
          end 
          if inserted == false then
            table.insert(dtbl, tbl[st])
          end
        end
      end    
    end
    
    local otbl = {statecnt = tbl.statecnt,
                  selected = tbl.selected,
                  mapptof = tbl.mapptof,
                  draggable = tbl.draggable,
                  spread = tbl.spread,
                  pos = 1,
                  {}}
    local dcnt = #dtbl
    for i = 1, dcnt do
      otbl[i] = {val = dtbl[dcnt-(i-1)].val, dispval = dtbl[dcnt-(i-1)].dispval, dv = dtbl[dcnt-(i-1)].dv}
    end
                  
    return otbl    
    
  end
      
  function CloseActChooser()
  
    show_actionchooser = false
    action_tbl = {}
    action_tblF = {}
    al_select = 0
    update_actcho = true
    
  end
  
  function GetSnapshotCtlIdx(strip, page, sstype, ctl)

    local idx = nil
    
    if sstype > 1 then
      if snapshots[strip][page][sstype].ctls then
        for c = 1, #snapshots[strip][page][sstype].ctls do 
        
          if snapshots[strip][page][sstype].ctls[c].c_id == strips[strip][page].controls[ctl].c_id then
            idx = c
            break
          end 
        end
      end
    end
    return idx
  end
  
  function GetMacroCtlIdx(strip, page, ctl, selc)

    local idx = nil
    
    if strips[strip][page].controls[ctl].macroctl then
      for c = 1, #strips[strip][page].controls[ctl].macroctl do 
      
        if strips[strip][page].controls[ctl].macroctl[c].c_id == strips[strip][page].controls[selc].c_id then
          idx = c
          break
        end 
      end
    end
    return idx
  end
  
  function SetParam_ToDef(i)
  
    local ctltype = strips[tracks[track_select].strip][page].controls[i].ctltype
    trackfxparam_select = i
    if ctltype == 1 then                  
      strips[tracks[track_select].strip][page].controls[i].val = strips[tracks[track_select].strip][page].controls[i].defval
      SetParam()
      strips[tracks[track_select].strip][page].controls[i].dirty = true
      update_ctls = true
      
    elseif ctltype == 4 then                  
      strips[tracks[track_select].strip][page].controls[i].cycledata.pos = round(strips[tracks[track_select].strip][page].controls[i].cycledata.statecnt *
                                                                           strips[tracks[track_select].strip][page].controls[i].defval)
      if strips[tracks[track_select].strip][page].controls[i].cycledata.pos < 1 then strips[tracks[track_select].strip][page].controls[i].cycledata.pos = 1 
      elseif strips[tracks[track_select].strip][page].controls[i].cycledata.pos > strips[tracks[track_select].strip][page].controls[i].cycledata.statecnt then
        strips[tracks[track_select].strip][page].controls[i].cycledata.pos = strips[tracks[track_select].strip][page].controls[i].cycledata.statecnt
      end
            
      strips[tracks[track_select].strip][page].controls[i].val = 
          strips[tracks[track_select].strip][page].controls[i].cycledata[strips[tracks[track_select].strip][page].controls[i].cycledata.pos].val
      SetParam()
      strips[tracks[track_select].strip][page].controls[i].dirty = true

      update_ctls = true
      
    end  
  end
  
  function SetParam_EnterVal(i)
  
    --if strips[tracks[track_select].strip][page].controls[i].ctlcat == ctlcats.macro then return end
    
    local ctltype = strips[tracks[track_select].strip][page].controls[i].ctltype
    if ctltype == 1 then
      trackfxparam_select = i
      OpenEB(5,'Please enter value:')
    elseif ctltype == 6 then
      trackfxparam_select = i
      strips[tracks[track_select].strip][page].controls[i].defval = GetParamValue_Ctl(i)                                    
    end
    
  end
  
  function Env_Test(strip, page)
  
    if strips and strips[strip] then
      local ctls = strips[strip][page].controls
      reaper.PreventUIRefresh(1)-- Prevent UI refreshing. Uncomment it only if the script works.
      for i = 1, #ctls do
              
        Envelope_SetProps(strip,page,i, false, false, false)
      end
      reaper.PreventUIRefresh(-1)
      for i = 1, #ctls do

        Envelope_SetProps(strip,page,i, nil, true, nil)
        
        reaper.TrackList_AdjustWindows(false)
        reaper.UpdateTimeline()        
        reaper.UpdateArrange()
      
      end
    end  
  end
  
  function Envelope_Clear(env)
  
   --[[ local _, envchunk = reaper.GetEnvelopeStateChunk(env, "", false)
    envchunk = envchunk:gsub("\n", "Â¤Â¤")
    reaper.SetEnvelopeStateChunk(env, envchunk, false)]]
    local env_points_count = reaper.CountEnvelopePoints(env)
    local retval_last, time_last, valueSource_last, shape_last, tension_last, selectedOut_last = reaper.GetEnvelopePoint(env, env_points_count-1)
    reaper.DeleteEnvelopePointRange(env, 0, time_last+1)
    --Envelope_SetProps2(env,true,true,true)
     
  end
  
  function Envelope_Add(strip,page,c)
    local ctl = strips[strip][page].controls[c]
    if ctl.ctlcat == ctlcats.fxparam then
      local track
      if ctl.tracknum == nil then
        track = GetTrack(strips[strip].track.tracknum)
      else
        track = GetTrack(ctl.tracknum)      
      end
      env = reaper.GetFXEnvelope(track, ctl.fxnum, ctl.param_info.paramnum,true)
      reaper.TrackList_AdjustWindows(false)
      reaper.UpdateTimeline()        
      reaper.UpdateArrange()
    end
  end

  function Envelope_AddAllFX(strip,page,c)
    local ctl = strips[strip][page].controls[c]
    if ctl.ctlcat == ctlcats.fxparam then
      local track
      if ctl.tracknum == nil then
        track = GetTrack(strips[strip].track.tracknum)
      else
        track = GetTrack(ctl.tracknum)      
      end
      for cc = 1, #strips[strip][page].controls do
        local cctl = strips[strip][page].controls[cc]
        if cctl.ctlcat == ctlcats.fxparam then
          if cctl.fxguid == ctl.fxguid then
            local env = reaper.GetFXEnvelope(track, cctl.fxnum, cctl.param_info.paramnum, true)
          end
        end
      end
      reaper.TrackList_AdjustWindows(false)
      reaper.UpdateTimeline()        
      reaper.UpdateArrange()
    end
  end
  
  function Envelopes_SetProps(active, visible, armed, clear, strip, page)
  
    if strips and #strips > 0 then
      if strip == nil then
        reaper.PreventUIRefresh(1)
        for s = 1, #strips do
          for p = 1,4 do
            for c = 1, #strips[s][p].controls do
            
              local ctl = strips[s][p].controls[c]
              Envelope_SetProps(s,p,c,active,false,armed, clear)
            
            end
          end  
        end
        reaper.PreventUIRefresh(-1)
        for s = 1, #strips do
          for p = 1,4 do
            for c = 1, #strips[s][p].controls do
            
              local ctl = strips[s][p].controls[c]
              Envelope_SetProps(s,p,c,active,nz(visible,true),armed, clear)
            
            end
          end  
        end
      else
        local s, p = strip, page
        if strip and page and strips[s] then
          reaper.PreventUIRefresh(1)          
          for c = 1, #strips[s][p].controls do
          
            local ctl = strips[s][p].controls[c]
            Envelope_SetProps(s,p,c,active,false,armed, clear)
          
          end
          reaper.PreventUIRefresh(-1)
          for c = 1, #strips[s][p].controls do
          
            local ctl = strips[s][p].controls[c]
            Envelope_SetProps(s,p,c,active,nz(visible,true),armed, clear)
          
          end          
        end      
      end    
      reaper.TrackList_AdjustWindows(false)
      reaper.UpdateTimeline()
      reaper.UpdateArrange()
    end
      
  end
  
  function Envelope_SetProps(strip, page, c, active, visible, armed, clear)

    if strips and strips[strip] and strips[strip][page].controls[c] then

      local ctl = strips[strip][page].controls[c]
      local track
      if ctl.tracknum == nil then
        track = GetTrack(strips[strip].track.tracknum)
      else
        track = GetTrack(ctl.tracknum)      
      end
    
      if track then
      
        local env
        if ctl.ctlcat == ctlcats.fxparam then
          env = reaper.GetFXEnvelope(track, ctl.fxnum, ctl.param_info.paramnum,false)  
         
        elseif ctl.ctlcat == ctlcats.trackparam then
          local env_count = reaper.CountTrackEnvelopes(track)
          for j = 0, env_count-1 do
          
            local e = reaper.GetTrackEnvelope(track, j)            
            retval, envName = reaper.GetEnvelopeName(e, "")
            
            if envName == string.sub(ctl.param_info.paramname,7) then
              env = e
              break
            end
          end
           
        elseif ctl.ctlcat == ctlcats.tracksend then
          --mute all envelopes?]]
        end
      
        if env then
          if clear == true then
            Envelope_Clear(env)
          else
            Envelope_SetProps2(env, active, visible, armed)
          end 
        end
      end
    
    end
  
  end
  
  function Envelope_SetProps2(env, active_out, visible_out, armed_out)
    
    local br_env = reaper.BR_EnvAlloc(env, false)
    local active, visible, armed, inLane, laneHeight, defaultShape, minValue, maxValue, centerValue, type, faderScaling = 
                                          reaper.BR_EnvGetProperties(br_env, true, true, true, true, 0, 0, 0, 0, 0, 0, true)
    if active_out == nil then active_out = active end
    if visible_out == nil then visible_out = visible end
    if armed_out == nil then armed_out = armed end
    
    --reaper.BR_EnvSetProperties(br_env, active_out, false, armed_out, inLane, laneHeight, defaultShape, faderScaling)
    reaper.BR_EnvSetProperties(br_env, active_out, visible_out, armed_out, inLane, laneHeight, defaultShape, faderScaling)
    reaper.BR_EnvFree(br_env, 1)
  
  end
  
  ------------------------------------------------------------
  
  function ChangeTrack(t)
  
    if tracks[t] == nil then
      t = -1
    end
    
    if gpage == true or t ~= LBX_GTRACK then
      gpage = false
    end

    if t == LBX_GTRACK then
      gpage_opage = page
      gpage_otrackselect = track_select
    end

    track_select = t
    trackedit_select = t
        
    gfx3_select = nil
    ctl_select = nil
    
    if T_butt_cnt then
      tlist_offset = CalcTListPos(track_select)
    end
    InsertDefaultStrip()
  
    GUI_DrawCtlBitmap()
    
    if settings_trackchangemidi == true then
      TrackChangeMidi()
    end
    --Env_Test(tracks[track_select].strip, page)
  end
  
  function ChangeTrack2(t)
    local fnd
    if show_eqcontrol then

      fnd = false
      if tracks and tracks[t] and tracks[t].strip and strips[tracks[t].strip] and strips[tracks[t].strip][page].controls then
        for c = 1, #strips[tracks[t].strip][page].controls do

          if strips[tracks[t].strip][page].controls[c].ctlcat == ctlcats.eqcontrol then
          
            eqcontrol_select = c
            if strips[tracks[t].strip][page].controls[c].eqbands and #strips[tracks[t].strip][page].controls[c].eqbands then
              eqcontrolband_select = 1
            else
              eqcontrolband_select = nil
            end
            fnd = true
                      
            break
          end
        
        end
      end
    else
      fnd = true
    end
    
    if fnd then
      if tracks[track_select] and strips[tracks[track_select].strip] then
        strips[tracks[track_select].strip].page = page
      end
      ChangeTrack(t)
      ss_select = nil
      sstype_select = 1
      ssoffset = 0
      
      if settings_followselectedtrack and gpage == false then
        --Select track
        local tr = GetTrack(track_select)
        if tr then
          tracks[track_select].name = reaper.GetTrackState(tr)
          
          if tr ~= nil then
            reaper.SetOnlyTrackSelected(tr)
            reaper.SetTrackSelected(tr, true)
          end
        end      
      end
      
      CheckStripSends()
      PopulateTrackSendsInfo()
      PopulateSpecial()
      
      if strips and tracks[track_select] and strips[tracks[track_select].strip] then
        page = strips[tracks[track_select].strip].page
        surface_offset.x = strips[tracks[track_select].strip][page].surface_x
        surface_offset.y = strips[tracks[track_select].strip][page].surface_y
      else
        page = 1
        surface_offset.x = 0
        surface_offset.y = 0 
      end
      CheckStripControls()            
      update_gfx = true 
    end
        
  end
  ------------------------------------------------------------    

  function Faders_INIT(force)

    if faders == nil or force then
      faders = {}
    end
    if LBX_CTL_TRACK_INF then
      for f = 1, LBX_FB_CNT*LBX_CTL_TRACK_INF.count do
      
        if faders[f] == nil or force then 
          faders[f] = {}
        end
        
      end
  
    end  
    
  end

  function FaderMenu(sel, returnonly)

    if LBX_CTL_TRACK_INF and LBX_CTL_TRACK_INF.count > 0 then
      local mstr = ''
      for fxnum = 0, LBX_CTL_TRACK_INF.count-1 do
        local fs = fxnum*LBX_FB_CNT+1
        local fe = fs+LBX_FB_CNT-1
        if mstr ~= '' then
          mstr = mstr .. '|'
        end
        mstr = mstr .. '>Fader '..string.format('%i',fs)..'-'..string.format('%i',fe)
        
        for pf = 0, LBX_FB_CNT-1 do
          local p = fs + pf
          local assigned = ''
          local ticked = ''
          if faders[p].targettype then
            assigned = '#'
            if p == sel then
              ticked = '!'
            end
          end
  
          if nz(returnonly,false) == false then
            if pf ~= LBX_FB_CNT-1 then
              mstr = mstr .. '|'..ticked..assigned..'Fader '..fs + pf
            else
              mstr = mstr .. '|<'..ticked..assigned..'Fader '..fs + pf        
            end
          else
            if assigned == '' then
              if pf ~= LBX_FB_CNT-1 then
                mstr = mstr .. '|'..ticked..'Fader '..fs + pf
              else
                mstr = mstr .. '|<'..ticked..'Fader '..fs + pf        
              end          
            else
              if pf ~= LBX_FB_CNT-1 then
                mstr = mstr .. '|'..ticked..'[ Fader '..fs + pf..' ]'
              else
                mstr = mstr .. '|<'..ticked..'[ Fader '..fs + pf..' ]'        
              end                      
            end
          end
        end
      end
      local lastp = LBX_CTL_TRACK_INF.count * LBX_FB_CNT+1
      mstr = mstr .. '|Clear Fader'
      return mstr, lastp
    else
      mstr = '#No Faderbox'
      return mstr, 1  
    end
  
  end

  function SetAutomationFader(fad_tab, sel, returnonly)
  
    if LBX_CTL_TRACK_INF and LBX_CTL_TRACK_INF.count > 0 then
      
      local mstr, lastp = FaderMenu(sel, returnonly)
      
      gfx.x = mouse.mx
      gfx.y = mouse.my
      local ret = gfx.showmenu(mstr)
      --DBG(lastp..'  '..ret)
      if nz(returnonly,false) == false then
        if ret > 0 and ret ~= lastp then
          faders[ret] = fad_tab
          if sel then
            faders[sel] = {}
          end
        elseif ret == lastp then
          faders[sel] = {}
          ret = nil
        else
          ret = -1
        end
      elseif ret == lastp then
        ret = -2
      end
            
      return ret
    else
      return -1
    end    
  end
  
  function ReadAutomationFaders()
  
    if LBX_CTL_TRACK then    
    
      if lbx_midilrnctl == nil then
        local ccc = trackfxparam_select
      
        local track = GetTrack(tracks[LBX_CTL_TRACK].tracknum)
        if tracks[LBX_CTL_TRACK].guid ~= reaper.GetTrackGUID(track) then
          PopulateTracks()
        end
        if xxyrecord == false then
          for fxnum = 0, LBX_CTL_TRACK_INF.count-1 do
            for pf = 0, LBX_FB_CNT-1 do
              p = fxnum * LBX_FB_CNT + pf
              faders[p+1].val = round(reaper.TrackFX_GetParam(track, fxnum, pf),5)
              if faders[p+1].val and faders[p+1].val >= 0 and (tostring(faders[p+1].val) ~= tostring(faders[p+1].oval) --[[or faders[p+1].targettype == 5 or faders[p+1].targettype == 6]]) then
                --DBG(faders[p+1].oval)
                
                if faders[p+1].targettype then
                  if faders[p+1].targettype == 0 then
                    if xxy and xxy[faders[p+1].strip] then
                      if faders[p+1].xy == 0 then
                        xxy[faders[p+1].strip][faders[p+1].page][faders[p+1].sstype].x = faders[p+1].val            
                      else
                        xxy[faders[p+1].strip][faders[p+1].page][faders[p+1].sstype].y = faders[p+1].val            
                      end
                      XXY_Set(faders[p+1].strip,faders[p+1].page,faders[p+1].sstype)
                      if show_xxy then
                        update_xxypos = true
                      end
                    else
                      --check fader
                      DeleteFader(p+1)
                    end
                  elseif faders[p+1].targettype == 1 then
                    XXYPath_SetPos(faders[p+1].strip,faders[p+1].page,faders[p+1].sstype,faders[p+1].val, p+1)
                    if show_xxy then
                      update_xxypos = true
                    end                              
                  elseif faders[p+1].targettype == 2 then
                    if strips[faders[p+1].strip] and strips[faders[p+1].strip][faders[p+1].page].controls[faders[p+1].ctl] then
                      strips[faders[p+1].strip][faders[p+1].page].controls[faders[p+1].ctl].oval = strips[faders[p+1].strip][faders[p+1].page].controls[faders[p+1].ctl].val 
                      strips[faders[p+1].strip][faders[p+1].page].controls[faders[p+1].ctl].val = faders[p+1].val
                      --strips[faders[p+1].strip][faders[p+1].page].controls[faders[p+1].ctl].mval = faders[p+1].val
                      strips[faders[p+1].strip][faders[p+1].page].controls[faders[p+1].ctl].dirty = true
                      SetMacro(faders[p+1].strip,faders[p+1].page,faders[p+1].ctl)
                      if macro_edit_mode == true then
                        update_macroedit = true
                      end 
                    else
                      DeleteFader(p+1)
                    end 
                    
                  elseif faders[p+1].targettype == 4 then
                  --DBG('p')
                    local strip = faders[p+1].strip
                    local page = faders[p+1].page
                    local c = faders[p+1].ctl
                    if strips[strip] and strips[strip][page].controls[c] then
                      strips[strip][page].controls[c].oval = strips[strip][page].controls[c].val 
                      strips[strip][page].controls[c].val = faders[p+1].val
                      strips[strip][page].controls[c].dirty = true
                      local ctl = strips[strip][page].controls[c]
                      A_SetParam(strip,page,c,ctl)
                      update_ctls = true
                    else
                      DeleteFader(p+1)
                    end 

                  elseif faders[p+1].targettype == 3 then
                    if mode == 0 and macro_edit_mode ~= true and macro_lrn_mode ~= true and show_xxy ~= true and show_eqcontrol ~= true and show_settings ~= true then
                      local strip = tracks[track_select].strip
                      local c = GetControlAtXY(strip,page,mouse.mx,mouse.my)
                      if c then
                        local ctl = strips[strip][page].controls[c]
                        if c ~= faders[p+1].to_ctl then
                          faders[p+1].to = false
                          faders[p+1].to_ctl = c
                          if faders[p+1].val > ctl.val then
                            faders[p+1].to_pos = 1 
                          elseif faders[p+1].val < ctl.val then
                            faders[p+1].to_pos = 2
                          else
                            faders[p+1].to_pos = 3
                            faders[p+1].to = true
                          end
                        end 
  
                        if ctl.ctlcat == ctlcats.fxparam or ctl.ctlcat == ctlcats.trackparam or ctl.ctlcat == ctlcats.macro then
                          if faders[p+1].mode == 0 then
                            --absolute
                            if faders[p+1].to == false then
                              if faders[p+1].to_pos == 1 then
                                if faders[p+1].val <= ctl.val then
                                  faders[p+1].to = true 
                                end
                              else
                                if faders[p+1].val >= ctl.val then
                                  faders[p+1].to = true 
                                end                            
                              end
                            end
                             
                            if faders[p+1].to == true then
                              ctl.oval = ctl.val
                              ctl.val = faders[p+1].val
                              if ctl.oval ~= ctl.val then
                                A_SetParam(strip,page,c,ctl)
                                ctl.dirty = true
                                update_ctls = true
                              end
                            end
                          else
                            --relative
                            local vi = 0.002
                            local v = F_limit(faders[p+1].val-0.5,-vi,vi)
                            --DBG(faders[p+1].val..'  '..v)
                            ctl.val = F_limit(ctl.val + (v),0,1)
                            --if ctl.oval ~= ctl.val then
                              A_SetParam(strip,page,c,ctl)
                              ctl.dirty = true
                              update_ctls = true
                            --end
                            ctl.oval = ctl.val
                            --[[if ctl.oval == 1 then
                              ctl.oval ]]
                            
                            reaper.TrackFX_SetParam(track, fxnum, pf, 0.5)
                            faders[p+1].oval = faders[p+1].val
                            faders[p+1].val = 0.5
                          end
                        end
                      end
                    end
                  elseif faders[p+1].targettype == 5 then
                    local ss = round(faders[p+1].val*127)+1
                    local fnd = false
                    if sstype_select == 1 then
                      if snapshots[tracks[track_select].strip] and 
                         snapshots[tracks[track_select].strip][page] and
                         snapshots[tracks[track_select].strip][page][sstype_select] and
                         snapshots[tracks[track_select].strip][page][sstype_select][ss] then
                        ss_select = ss
                        fnd = true
                      end
                    else
                      if snapshots[tracks[track_select].strip] and 
                         snapshots[tracks[track_select].strip][page] and
                         snapshots[tracks[track_select].strip][page][sstype_select] and
                         snapshots[tracks[track_select].strip][page][sstype_select].snapshot[ss] then
                        ss_select = ss
                        fnd = true
                      end                    
                    end
                    if fnd then
                      Snapshot_Set(tracks[track_select].strip,page,sstype_select,ss_select)
                      update_gfx = true
                    end                    
                    
                  elseif faders[p+1].targettype == 6 then
                    local sel = round(faders[p+1].val*127)+1 - faders[p+1].voffset
                    Switcher_Set2(faders[p+1].ctl ,sel, faders[p+1].strip, faders[p+1].page)
                    
                  elseif faders[p+1].targettype == 7 then
                    
                    if strips[faders[p+1].strip] and strips[faders[p+1].strip][faders[p+1].page].controls[faders[p+1].ctl] then
                      local ctl = strips[faders[p+1].strip][faders[p+1].page].controls[faders[p+1].ctl]
                      
                      local ss = round(faders[p+1].val*127)+1 -faders[p+1].voffset
                      local fnd = false
                      local sstype = ctl.param 
                      if sstype == 1 then
                        if snapshots[faders[p+1].strip] and 
                           snapshots[faders[p+1].strip][faders[p+1].page] and
                           snapshots[faders[p+1].strip][faders[p+1].page][sstype] and
                           snapshots[faders[p+1].strip][faders[p+1].page][sstype][ss] then
                          if tracks[track_select].strip == faders[p+1].strip and page == faders[p+1].page then 
                            fss_select = ss
                            if sstype_select == sstype then
                              ss_select = ss
                            end
                          end
                          fnd = true
                        end
                      else
                        if snapshots[faders[p+1].strip] and 
                           snapshots[faders[p+1].strip][faders[p+1].page] and
                           snapshots[faders[p+1].strip][faders[p+1].page][sstype] and
                           snapshots[faders[p+1].strip][faders[p+1].page][sstype].snapshot[ss] then
                          if tracks[track_select].strip == faders[p+1].strip and page == faders[p+1].page then 
                            fss_select = ss
                            if sstype_select == sstype then
                              ss_select = ss
                            end
                          end
                          fnd = true
                        end                    
                      end
                      if fnd then
                        Snapshot_Set(faders[p+1].strip,faders[p+1].page,sstype,ss)
                        update_gfx = true
                      end                    
                    end
                  end
                end
              --elseif faders[p+1].val < 0 then
              --  DBG('nil')              
              --  faders[p+1].latch = nil
              end
              faders[p+1].oval = faders[p+1].val    
                          
              if faders[p+1].targettype == 4 then
              --DBG('bb')
                local strip = faders[p+1].strip
                local page = faders[p+1].page
                local c = faders[p+1].ctl
                local ctl = strips[strip][page].controls[c]
                if ctl then
                  local t = strips[strip].track.tracknum
                  if ctl.tracknum ~= nil then
                    t = ctl.tracknum
                  end                
                  local vv = round(GetParamValue_XX(ctl.ctlcat, t, ctl.fxnum, ctl.param, c, strip, page),4)
                  if tostring(vv) ~= tostring(round(faders[p+1].val,4)) then
                    --DBG(vv..'  '..faders[p+1].val)
                    faders[p+1].val = vv
                    SetFader(p+1, vv) 
                  end
                end
              end
            
            end
          end    
          trackfxparam_select = ccc
    
        end

      elseif lbx_midilrnctl then
        
        local track = GetTrack(tracks[LBX_CTL_TRACK].tracknum)
        
        for fxnum = 0, LBX_CTL_TRACK_INF.count-1 do
          for pf = 0, LBX_FB_CNT-1 do
            p = fxnum * LBX_FB_CNT + pf
            faders[p+1].val = reaper.TrackFX_GetParam(track, fxnum, pf)
          -- DBG('v'..tostring(faders[p+1].val))
          -- DBG('o'..tostring(faders[p+1].oval))
            if faders[p+1].val and tostring(round(faders[p+1].val,5)) ~= tostring(round(faders[p+1].oval,5)) then
              lbx_midilrnval = p+1
              faders[p+1].oval = faders[p+1].val
              update_surface = true
              
            end
          end      
        end
        
      end
      
    end  
  end

  function AssignFader(f, ftab)
  
    if faders[f] then
      DeleteFader(f)
    end
    if ftab.targettype == 0 then
      if xxy and xxy[ftab.strip] and xxy[ftab.strip][ftab.page] and xxy[ftab.strip][ftab.page][ftab.sstype] then
        if ftab.xy == 0 then
          DeleteFader(xxy[ftab.strip][ftab.page][ftab.sstype].xfader)
          xxy[ftab.strip][ftab.page][ftab.sstype].xfader = f          
        else
          DeleteFader(xxy[ftab.strip][ftab.page][ftab.sstype].yfader)
          xxy[ftab.strip][ftab.page][ftab.sstype].yfader = f      
        end
        faders[f] = ftab
      end
    elseif ftab.targettype == 1 then    
      if xxy and xxy[ftab.strip] and xxy[ftab.strip][ftab.page] and xxy[ftab.strip][ftab.page][ftab.sstype] then
        DeleteFader(xxy[ftab.strip][ftab.page][ftab.sstype].pathfader)
        xxy[ftab.strip][ftab.page][ftab.sstype].pathfader = f
        faders[f] = ftab    
      end
    elseif ftab.targettype == 2 or ftab.targettype == 4 then    
      if strips and strips[ftab.strip] and strips[ftab.strip][ftab.page].controls[ftab.ctl] then
        DeleteFader(strips[ftab.strip][ftab.page].controls[ftab.ctl].macrofader)
        strips[ftab.strip][ftab.page].controls[ftab.ctl].macrofader = f
        faders[f] = ftab    
      end
    elseif ftab.targettype == 5 then
      DeleteFader(snapshot_fader)    
      snapshot_fader = f      
      faders[f] = ftab    
    elseif ftab.targettype == 6 then    
      if strips and strips[ftab.strip] and strips[ftab.strip][ftab.page].controls[ftab.ctl] then
        DeleteFader(strips[ftab.strip][ftab.page].controls[ftab.ctl].switchfader)
        strips[ftab.strip][ftab.page].controls[ftab.ctl].switchfader = f
        faders[f] = ftab    
      end
    elseif ftab.targettype == 7 then    
      if strips and strips[ftab.strip] and strips[ftab.strip][ftab.page].controls[ftab.ctl] then
        DeleteFader(strips[ftab.strip][ftab.page].controls[ftab.ctl].macrofader)
        strips[ftab.strip][ftab.page].controls[ftab.ctl].macrofader = f
        faders[f] = ftab    
      end
    end
  
  end

  function DeleteFader(f)
    if f and faders[f] then
      if faders[f].targettype == 0 then
        if xxy and xxy[faders[f].strip] and xxy[faders[f].strip][faders[f].page] and xxy[faders[f].strip][faders[f].page][faders[f].sstype] then
          if faders[f].xy == 0 then
            xxy[faders[f].strip][faders[f].page][faders[f].sstype].xfader = nil
          else
            xxy[faders[f].strip][faders[f].page][faders[f].sstype].yfader = nil
          end
        end
      elseif faders[f].targettype == 1 then
        if xxy and xxy[faders[f].strip] and xxy[faders[f].strip][faders[f].page] and xxy[faders[f].strip][faders[f].page][faders[f].sstype] then
          xxy[faders[f].strip][faders[f].page][faders[f].sstype].pathfader = nil
        end
      elseif faders[f].targettype == 2 or faders[f].targettype == 4 then
        if strips and strips[faders[f].strip] and strips[faders[f].strip][faders[f].page].controls[faders[f].ctl] then
          strips[faders[f].strip][faders[f].page].controls[faders[f].ctl].macrofader = nil
        end
      elseif faders[f].targettype == 5 then
        snapshot_fader = nil
      elseif faders[f].targettype == 6 then
        if strips and strips[faders[f].strip] and strips[faders[f].strip][faders[f].page].controls[faders[f].ctl] then
          strips[faders[f].strip][faders[f].page].controls[faders[f].ctl].switchfader = nil
        end
      end
      faders[f] = {}
    end  
  end
  
  ------------------------------------------------------------    

  function setmode(m)
    --1=live,2=fx,3=tr,4=gfx,5=strip
    
    if navigate then

      backalpha2 = 0    
      ctl_select = nil
      gfx2_select = nil
      gfx3_select = nil
      show_paramlearn = false
      CloseActChooser()
      show_ctlbrowser = false
      show_gaugeedit = false
      
      if m == 1 then
        if mode == 1 then
          --SaveEditedData()
        end
        mode = 0
        reaper.MarkProjectDirty(0)        
      else
        g_edstrips = {}
        trackedit_select = track_select
        mode = 1
        PopulateTrackFX()
        
        if m == 2 then
          backalpha2 = 0.5
          submode = 0
          fxmode = 0
        elseif m == 3 then
          backalpha2 = 0.5
          submode = 0
          fxmode = 1
        elseif m == 4 then
          submode = 1
        elseif m == 5 then
          submode = 2
        end
        
      end
      SetCtlBitmapRedraw()
      update_gfx = true
    end
    
  end

  function keypress(char)
    --DBG(char)
    
    --if not mouse.shift then
      if char == 102 then
        setmode(2)
      elseif char == 116 then
        setmode(3)      
      elseif char == 103 then
        setmode(4)      
      elseif char == 115 then
        setmode(5)
      elseif char == 108 then
        setmode(1)
      elseif char == 47 then
        TopMenu()
      elseif char == 91 then
        ToggleSidebar()
      elseif char == 93 then
        hide_topbar = not hide_topbar
        obj = GetObjects()
        update_surface = true
        update_topbar = true
        
      elseif char == 46 then
        local t = track_select + 1
        if gpage == true then
          if gpage_otrackselect then
            t = (gpage_otrackselect) + 1
          end
        end
        if t > #tracks then t = -1 end
        if t == LBX_GTRACK then
          t = t + 1
          if t > #tracks then t = -1 end
        end        
        if t == LBX_GTRACK then
          SetGlobalPage()
        else
          ChangeTrack2(t)
        end
        
      elseif char == 44 then        
        local t = track_select - 1
        if gpage == true then
          if gpage_otrackselect then
            t = (gpage_otrackselect) - 1
          end
        end
        if t < -1 then t = #tracks end
        if t == LBX_GTRACK then
          t = t - 1
          if t < -1 then t = #tracks end
        end
        if t == LBX_GTRACK then
          SetGlobalPage()
        else
          ChangeTrack2(t)
        end
        
      elseif char == 4 then
        local d = gfx.dock(-1)
        if d%256 == 0 then
          if dockstate and dockstate%256 ~= 0 then
            gfx.dock(dockstate)
          else
            gfx.dock(d+1)
          end
        else
          dockstate = d
          gfx.dock(256)
        end
      elseif char == 12 then
        settings_locksurface = not settings_locksurface
      elseif char == 61 then
        if navigate and gpage == true then SetPage(1)
        elseif navigate then SetPage(math.min(page+1,4)) end
        
      elseif char == 45 then  
        if navigate then SetPage(math.max(page-1,0)) end
      elseif char == 19 then
        SaveProj(nil, true)
        lastprojdirty = 0
      --elseif char == 19 then
        --ToggleSidebar()
      elseif char == 83 then
        show_snapshots = not show_snapshots
        update_gfx = true      
      elseif char == 63 then
        show_settings = not show_settings
        update_surface = true
      elseif char == 53 then
        backalpha = math.max(backalpha - 0.05,0)
        update_bg = true
        update_gfx = true
      elseif char == 54 then
        backalpha = math.min(backalpha +0.05,2)
        update_bg = true
        update_gfx = true
      elseif char == 55 then
        backalpha = 1
        update_bg = true
        update_gfx = true
      elseif char == 49 then
        tfxo_listpos = 0
        tfxorder = TrackFXOrder_Read()
        tfxreorder = TrackFXOrder_Read()
        if tfxorder then
          show_trackfxorder = not show_trackfxorder 
          update_gfx = true
        end
        char = 0
      elseif char == 105 then
        RBMenu(2,nil,nil)
      elseif char == 13 then
        show_bitmap = not show_bitmap
        update_gfx = true
      end
    --[[else -- shift
      if char == 19 then
        ToggleSidebar()
      elseif char == 83 then
        show_snapshots = not show_snapshots
        update_gfx = true      
      elseif char == 63 then
        show_settings = not show_settings
        update_surface = true
      end
    end   ]] 
    return char
  end
  
  function TrackFXOrder_Read()
  
    local tfxorder = nil
    if tracks and tracks[track_select] then
      tfxorder = {}
    
      local track = GetTrack(tracks[track_select].tracknum)
      local fxc = reaper.TrackFX_GetCount(track)
      local _, chunk = reaper.GetTrackStateChunk(track,'',false)
      local s,e = 0,0

      for i = 1, fxc do
        local _, name = reaper.TrackFX_GetFXName(track,i-1,'')
        --DBG(i)
        tfxorder[i] = {name = name,
                       guid = reaper.TrackFX_GetFXGUID(track,i-1),
                       fxnum = i-1,
                       found = true}
        
       s, e = string.find(chunk,'BYPASS %d %d %d',s)
       if s and e then
         local bypstr = string.sub(chunk,s,e)
         tfxorder[i].bypass = string.match(bypstr,'(%d) %d %d')
         tfxorder[i].offline = string.match(bypstr,'%d (%d) %d')
         s=e+1
       end           
       --DBG(i..'  '..tfxorder[i].bypass..'  '..tfxorder[i].offline)    
      end
    end
    return tfxorder
  
  end

  function ArrowKey_Shift(char, ctl_select, gfx3_select, gfx2_select)
  
    local shiftsize = settings_gridsize
    if mouse.shift then
      shiftsize = 1
    end
    
    if char == 0x6C656674 then -- left arrow
      if ctl_select and #ctl_select > 0 then
        for i = 1,#ctl_select do
          if strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].poslock == false then
            local scale = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].scale
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].x = 
                          strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].x - shiftsize
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].xsc = 
                                                                strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].x
                                                                 + math.floor(strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].w/2
                                                                 - (strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].w*scale)/2)
          end
        end
      end
      if gfx3_select and #gfx3_select > 0 then
        for i = 1,#gfx3_select do
          strips[tracks[track_select].strip][page].graphics[gfx3_select[i].ctl].x = 
                        strips[tracks[track_select].strip][page].graphics[gfx3_select[i].ctl].x - shiftsize
        end
      end
      if gfx2_select then
        if strips[tracks[track_select].strip][page].graphics[gfx2_select].poslock == false then
        
          if submode == 1 and mouse.ctrl then
            strips[tracks[track_select].strip][page].graphics[gfx2_select].stretchw = 
                          strips[tracks[track_select].strip][page].graphics[gfx2_select].stretchw - shiftsize          
          else
            strips[tracks[track_select].strip][page].graphics[gfx2_select].x = 
                          strips[tracks[track_select].strip][page].graphics[gfx2_select].x - shiftsize
          end        
        end
      end
      update_gfx = true
      SetCtlBitmapRedraw()
    elseif char == 0x72676874 then -- right arrow
      if ctl_select and #ctl_select > 0 then
        for i = 1,#ctl_select do
          if strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].poslock == false then
            local scale = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].scale
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].x = 
                          strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].x + shiftsize
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].xsc = 
                                                                strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].x
                                                                 + math.floor(strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].w/2
                                                                 - (strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].w*scale)/2)
          end
        end
      end
      if gfx3_select and #gfx3_select > 0 then
        for i = 1,#gfx3_select do
          strips[tracks[track_select].strip][page].graphics[gfx3_select[i].ctl].x = 
                        strips[tracks[track_select].strip][page].graphics[gfx3_select[i].ctl].x + shiftsize
        end
      end
      if gfx2_select then
        if strips[tracks[track_select].strip][page].graphics[gfx2_select].poslock == false then

          if submode == 1 and mouse.ctrl then
            strips[tracks[track_select].strip][page].graphics[gfx2_select].stretchw = 
                          strips[tracks[track_select].strip][page].graphics[gfx2_select].stretchw + shiftsize          
          else
            strips[tracks[track_select].strip][page].graphics[gfx2_select].x = 
                          strips[tracks[track_select].strip][page].graphics[gfx2_select].x + shiftsize
          end
        end
      end
      update_gfx = true
      SetCtlBitmapRedraw()
    elseif char == 0x7570 then -- up arrow
      if ctl_select and #ctl_select > 0 then
        for i = 1,#ctl_select do
          if strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].poslock == false then
            local scale = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].scale
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].y = 
                          strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].y - shiftsize
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ysc = 
                                                                strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].y
                                                                 + math.floor(strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ctl_info.cellh/2
                                                                 - (strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ctl_info.cellh*scale)/2)
          end
        end
      end
      if gfx3_select and #gfx3_select > 0 then
        for i = 1,#gfx3_select do
          strips[tracks[track_select].strip][page].graphics[gfx3_select[i].ctl].y = 
                        strips[tracks[track_select].strip][page].graphics[gfx3_select[i].ctl].y - shiftsize
        end
      end
      if gfx2_select then
        if strips[tracks[track_select].strip][page].graphics[gfx2_select].poslock == false then

          if submode == 1 and mouse.ctrl then
            strips[tracks[track_select].strip][page].graphics[gfx2_select].stretchh = 
                          strips[tracks[track_select].strip][page].graphics[gfx2_select].stretchh - shiftsize          
          else
            strips[tracks[track_select].strip][page].graphics[gfx2_select].y = 
                          strips[tracks[track_select].strip][page].graphics[gfx2_select].y - shiftsize
          end
          
        end
      end
      update_gfx = true
      SetCtlBitmapRedraw()
    elseif char == 0x646F776E then -- down arrow
      if ctl_select and #ctl_select > 0 then
        for i = 1,#ctl_select do
          if strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].poslock == false then
            local scale = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].scale
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].y = 
                          strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].y + shiftsize
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ysc = 
                                                                strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].y
                                                                 + math.floor(strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ctl_info.cellh/2
                                                                 - (strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ctl_info.cellh*scale)/2)
          end
        end
      end
      if gfx3_select and #gfx3_select > 0 then
        for i = 1,#gfx3_select do
          strips[tracks[track_select].strip][page].graphics[gfx3_select[i].ctl].y = 
                        strips[tracks[track_select].strip][page].graphics[gfx3_select[i].ctl].y + shiftsize
        end
      end
      if gfx2_select then
        if strips[tracks[track_select].strip][page].graphics[gfx2_select].poslock == false then

          if submode == 1 and mouse.ctrl then
            strips[tracks[track_select].strip][page].graphics[gfx2_select].stretchh = 
                          strips[tracks[track_select].strip][page].graphics[gfx2_select].stretchh + shiftsize          
          else
            strips[tracks[track_select].strip][page].graphics[gfx2_select].y = 
                          strips[tracks[track_select].strip][page].graphics[gfx2_select].y + shiftsize
          end
          
        end
      end
      update_gfx = true                
      SetCtlBitmapRedraw()
    end
  
  end

  function Copy_Selected()
  
    if (ctl_select and #ctl_select > 0) or (gfx3_select and #gfx3_select > 0) then
    
      copy_ctls = {strip = tracks[track_select].strip,
                   page = page,
                   tracknum = tracks[track_select].tracknum,
                   trackguid = tracks[track_select].guid,
                   ctls = {},
                   gfx = {}}
      if ctl_select and #ctl_select > 0 then
        for c = 1, #ctl_select do
          copy_ctls.ctls[c] = ctl_select[c].ctl
        end
      end
      if gfx3_select and #gfx3_select > 0 then
        for c = 1, #gfx3_select do
          copy_ctls.gfx[c] = gfx3_select[c].ctl
        end      
      end
    end
  
  end

  function Paste_Selected()

    if copy_ctls and (copy_ctls.ctls and #copy_ctls.ctls > 0) or (copy_ctls.gfx and #copy_ctls.gfx > 0) then
    
      if tracks[track_select] then
          
        local strip = Strip_INIT()
        local dx, dy
        local grids = {}
        local swids = {}
        local ctls = strips[strip][page].controls
        local gfxx = strips[strip][page].graphics
        
        local cids = {}      
        local cstart, gstart 
      
        if #copy_ctls.ctls > 0 then

          cstart = #ctls + 1
      
          for c = 1, #copy_ctls.ctls do
            local nc = #ctls+1
            local ctbl = GetControlTable(copy_ctls.strip, copy_ctls.page, copy_ctls.ctls[c])
            ctbl.poslock = false
            if ctbl.ctlcat ~= ctlcats.snapshot and ctbl.ctlcat ~= ctlcats.xy and ctbl.ctlcat ~= ctlcats.eqcontrol then
            
              ctls[nc] = ctbl
              cids[strips[copy_ctls.strip][copy_ctls.page].controls[copy_ctls.ctls[c]].c_id] = {cid = ctls[nc].c_id,
                                                                                                ctl = nc}
              if ctls[nc].tracknum == nil and tracks[track_select].trackguid ~= copy_ctls.trackguid then
                ctls[nc].tracknum = copy_ctls.tracknum
                ctls[nc].trackguid = copy_ctls.trackguid
              end
              
              if ctls[nc].grpid then
                if grids[ctls[nc].grpid] then
                  ctls[nc].grpid = grids[ctls[nc].grpid]
                else
                  local grpid = GenID()
                  grids[ctls[nc].grpid] = grpid
                  ctls[nc].grpid = grpid
                end
              end
              
            end
          end
  
          dx = strips[tracks[track_select].strip][page].controls[cstart].x - (mouse.mx+surface_offset.x-obj.sections[10].x) 
          dy = strips[tracks[track_select].strip][page].controls[cstart].y - (mouse.my+surface_offset.y-obj.sections[10].y)
  
          ctl_select = nil
          
          for c = cstart, #ctls do
  
            strips[tracks[track_select].strip][page].controls[c].x = strips[tracks[track_select].strip][page].controls[c].x - dx
            strips[tracks[track_select].strip][page].controls[c].y = strips[tracks[track_select].strip][page].controls[c].y - dy
            strips[tracks[track_select].strip][page].controls[c].xsc = strips[tracks[track_select].strip][page].controls[c].xsc - dx
            strips[tracks[track_select].strip][page].controls[c].ysc = strips[tracks[track_select].strip][page].controls[c].ysc - dy
            strips[tracks[track_select].strip][page].controls[c].id = nil
          
            if ctl_select == nil then
              ctl_select = {} 
              ctl_select[1] = {ctl = c}
            else
              local cs = #ctl_select+1
              ctl_select[cs] = {}
              ctl_select[cs].ctl = c
              ctl_select[cs].relx = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].x - strips[tracks[track_select].strip][page].controls[c].x
              ctl_select[cs].rely = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].y - strips[tracks[track_select].strip][page].controls[c].y
            end
            
            if ctls[c].ctlcat == ctlcats.macro then
            
              local macro = ctls[c].macroctl
              if macro and #macro > 0 then
              
                local mcnt = #macro
                local nils = false
                for m = 1, mcnt do
                  
                  local mcid = macro[m].c_id 
                  if cids[mcid] then
                    macro[m].ctl = cids[mcid].ctl
                    macro[m].c_id = cids[mcid].cid
                  else
                    macro[m] = nil
                    nils = true
                  end
              
                end
                
                if nils then
                  local mtbl = Table_RemoveNils(macro, mcnt)
                  strips[strip][page].controls[c].macroctl = mtbl                
                end
              end
            end
          end
        end
        
        if #copy_ctls.gfx > 0 then        
        
          gstart = #gfxx + 1
        
          for c = 1, #copy_ctls.gfx do
            local nc = #gfxx+1
            local ctbl = GetGraphicsTable(copy_ctls.strip, copy_ctls.page, copy_ctls.gfx[c])
            ctbl.poslock = false
            
            gfxx[nc] = ctbl

            if gfxx[nc].grpid then
              if grids[gfxx[nc].grpid] then
                gfxx[nc].grpid = grids[gfxx[nc].grpid]
              else
                local grpid = GenID()
                grids[gfxx[nc].grpid] = grpid
                gfxx[nc].grpid = grpid
              end
            end
          end

          if dx == nil or dy == nil then
            dx = strips[tracks[track_select].strip][page].graphics[gstart].x - (mouse.mx+surface_offset.x-obj.sections[10].x) 
            dy = strips[tracks[track_select].strip][page].graphics[gstart].y - (mouse.my+surface_offset.y-obj.sections[10].y)
          end
          
          gfx3_select = nil
          
          for c = gstart, #gfxx do

            strips[tracks[track_select].strip][page].graphics[c].x = strips[tracks[track_select].strip][page].graphics[c].x - dx
            strips[tracks[track_select].strip][page].graphics[c].y = strips[tracks[track_select].strip][page].graphics[c].y - dy

            if gfx3_select == nil then
              gfx3_select = {}
            end 
            local cs = #gfx3_select+1
            gfx3_select[cs] = {}
            gfx3_select[cs].ctl = c
            if ctl_select and ctl_select[1] then
              gfx3_select[cs].relx = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].x - strips[tracks[track_select].strip][page].graphics[c].x
              gfx3_select[cs].rely = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].y - strips[tracks[track_select].strip][page].graphics[c].y
            elseif gfx3_select and gfx3_select[1] then
              gfx3_select[cs].relx = strips[tracks[track_select].strip][page].graphics[gfx3_select[1].ctl].x - strips[tracks[track_select].strip][page].graphics[c].x
              gfx3_select[cs].rely = strips[tracks[track_select].strip][page].graphics[gfx3_select[1].ctl].y - strips[tracks[track_select].strip][page].graphics[c].y            
            end            
          end
        end        
        
        --switchers
        local swstart = #switchers+1
        local nsflag = false
        for c = cstart, #ctls do
          if ctls[c].ctlcat == ctlcats.switcher then
            local stab = GetSwitcherTable(ctls[c].switcherid)
            --table.insert(stab, switchers[ctls[c].switcherid]) 
            ns = #switchers+1
            nsflag = true
            switchers[ns] = stab
            swids[ctls[c].switcherid] = ns
            --DBG('1'..tostring(switchers[ctls[c].switcherid]))
            --DBG('2'..tostring(switchers[ns]))
          end      
        end
        if nsflag then
          for s = swstart, #switchers do
            if switchers[s].parent and swids[switchers[s].parent.switcherid] then
              switchers[s].parent.switcherid = swids[switchers[s].parent.switcherid]
              switchers[s].parent.grpid = grids[switchers[s].parent.grpid]
            else
              switchers[s].parent = nil
            end
            if switchers[s].grpids and #switchers[s].grpids > 0 then
              for g = 1, #switchers[s].grpids do
                if grids[switchers[s].grpids[g].id] then
                  switchers[s].grpids[g].id = grids[switchers[s].grpids[g].id]
                else
                  switchers[s].grpids[g].id = GenID()
                end
              end
            end
            if switchers[s].current and grids[switchers[s].current] then
              switchers[s].current = grids[switchers[s].current]
            else
              if switchers[s].grpids and switchers[s].grpids[1] then
                switchers[s].current = switchers[s].grpids[1].id
              else
                switchers[s].current = -1
              end
            end
          end
        end
        
        for c = cstart, #ctls do
          if ctls[c].switcherid then
            if swids[ctls[c].switcherid] then
              ctls[c].switcherid = swids[ctls[c].switcherid]
            else
            
            end
          end
          if ctls[c].switcher then
            if swids[ctls[c].switcher] then
              ctls[c].switcher = swids[ctls[c].switcher]
            else
              ctls[c].switcher = nil
            end
          end
        end 
        if gstart then
          for c = gstart, #gfxx do
            if gfxx[c].switcher then
              if swids[gfxx[c].switcher] then
                gfxx[c].switcher = swids[gfxx[c].switcher]
              else
                gfxx[c].switcher = nil
              end
            end
          end 
        end       
        
      end    
    end  
  end
  
  function GetControlAtXY(strip,page,x,y)
    
    if strips and strips[strip] then              
      local ctls = strips[strip][page].controls
      local ret
      if settings_usectlbitmap then
      
        gfx.dest = ctl_bitmap
        gfx.x = x + surface_offset.x -obj.sections[10].x
        gfx.y = y + surface_offset.y -obj.sections[10].y
        local r,g,b = gfx.getpixel()
        --DBG(r*255 ..'  '..g*255 ..'  '..b*255)
        gfx.dest = 1
        --local cc = r*255 + ((g*255) << 8) + ((b*255) << 16)
        local cc = math.floor(((r*255) + ((g*255) << 8) + ((b*255) << 16))+0.5)
        if cc > 0 and ctls[cc] then
          local ctl = strips[strip][page].controls[cc]
          if Switcher_CtlsHidden(ctl.switcher, ctl.grpid) == false then 
            ret = cc
          end
        end
      else
        for ii = 1, #strips[strip][page].controls do
  
          local ctl = strips[strip][page].controls[ii]
          ctlxywh = {x = ctl.xsc - surface_offset.x +obj.sections[10].x, 
                     y = ctl.ysc - surface_offset.y +obj.sections[10].y, 
                     w = ctl.wsc, 
                     h = ctl.hsc}
          if MOUSE_over(ctlxywh, x, y) then
           
            if Switcher_CtlsHidden(ctl.switcher, ctl.grpid) == false and ctl.clickthrough ~= true then
              ret = ii
              break
            end
          end
  
        end
      end
      return ret
    end
  end
  
  function ZeroProjectFlags()
    reaper.SetProjExtState(0,'LBXFLAGS','LBX_SAVE_PROJECT','')
  end
  
  function ReadProjectFlags()
  
    local _, lbxsaveflag = reaper.GetProjExtState(0,'LBXFLAGS','LBX_SAVE_PROJECT')
    if lbxsaveflag ~= '' then
      if lbxsaveflag == 'N' then
        --reaper.Main_OnCommand(41895,0)
        SaveProj(nil,true)
        reaper.SetProjExtState(0,'LBXFLAGS','LBX_SAVE_PROJECT','')
        DBGOut('*** Save Project (increment filename) via external script ***')      
      else
        SaveProj(nil,true)
        reaper.SetProjExtState(0,'LBXFLAGS','LBX_SAVE_PROJECT','')
        DBGOut('*** Save Project via external script ***')
      end
    end
    
  end
  
  function FindSaveFile(fn)
  
    local f = string.match(fn, '(.*)%.lbxstripper')
    if f then fn = f end
    
    local load_path
    local sf = ''
    --DBG('ssf:'..save_subfolder)
    if save_subfolder and save_subfolder ~= '' then
      sf = save_subfolder
      if sf == '#' then
        local projname = GetProjectName() 
        sf = projname
      end
      sf = sf ..'/'
    end
    
    fn = sf..fn
    --DBG('ffff'..fn)
    
    if settings_savedatainprojectfolder == true then
      load_path=reaper.GetProjectPath('')..'/'
      --DBG(load_path..fn..'.lbxstripper')
      if reaper.file_exists(load_path..fn..'.lbxstripper') ~= true and reaper.file_exists(load_path..fn..'.lbxstripper__') ~= true then
        load_path=projsave_path
      end
    else
      load_path=projsave_path
      --DBG(load_path..fn..'.lbxstripper')
      if reaper.file_exists(load_path..fn..'.lbxstripper') ~= true and reaper.file_exists(load_path..fn..'.lbxstripper__') ~= true then
        load_path=reaper.GetProjectPath('')..'/'
      end      
    end
  
    local ffn=load_path..fn
    --DBG('ffn: '..tostring(ffn))
    local fndffn, fndfn
    if reaper.file_exists(ffn..'.lbxstripper') then
      fndffn = ffn..'.lbxstripper'
      fndfn = fn..'.lbxstripper'
    elseif reaper.file_exists(ffn..'.lbxstripper__') then
      fndffn = ffn..'.lbxstripper__'
      fndfn = fn..'.lbxstripper__'    
    end
    --DBG(fndfn)
    if fndfn then
      return true, fndfn, fndffn, nil
    else
    
      local xfn = GPES('lbxstripper_datafile', true)
      if xfn and reaper.file_exists(load_path..xfn) == true then
        return false, nil, nil, true
      else  
        return false, nil, nil, nil
      end
    end
  
  end
  
  function run()  

    local rt = reaper.time_precise()
    
    ReadProjectFlags()
    
    local PROJNAME = GetProjectName()
    projdirty = reaper.IsProjectDirty()

    if (PROJECTID ~= tonumber(GPES('projectid'))) or newloc then
    
      --DBG('zzz')
      if newloc then
        --SaveData()
        newloc = nil
        DBGOut('*** INIT NEW PROJECT ***')    
        
        INIT()
      else
        INIT()                
      end
      LoadData()
       
    elseif loadset_fn then
    
      --SaveData()
      if lsmerge == true then
        LoadSet2(loadset_fn, true)      
      else
        INIT(true)
        LoadSet2(loadset_fn)
      end
      loadset_fn = nil
   
    elseif lastprojdirty ~= projdirty or PROJNAME ~= lastprojname then
      
      --local fn = GPES('lbxstripper_datafile', true)
      local pfname = string.sub(PROJNAME,0,string.len(PROJNAME)-4)
      local fn = pfname
      
      if projdirty == 0 and PROJNAME == lastprojname then
        --project saved
        SaveProj()
        
      elseif PROJNAME ~= lastprojname then
      
        local pr_pfx = string.match(PROJNAME,'(.*%_)%d+.*')
        local pr_n = string.match(PROJNAME,'%_(%d+).*')
        local ls_pfx = string.match(lastprojname ,'(.*%_)%d+.*')
        local ls_n = string.match(lastprojname ,'%_(%d+).*')
        
        local found, fn, ffn, storeddata = FindSaveFile(fn)
        
        if found == true then
          --load
          --DBG('a')
          INIT()
          LoadData()
          update_gfx = true
          lastprojdirty = projdirty
        
        elseif storeddata == true then
        
          if lastprojname == nil or lastprojname == '' then
            SaveProj()
          else
            --[[DBG('still confused')
            DBG('lpn: '..lastprojname)
            DBG(PROJECTID)
            DBG(PROJNAME)]]
          end          
          
        elseif pr_pfx ~= ls_pfx then
          --DBG('b')
          SaveProj()
        
        elseif (pr_n and ls_n) and pr_n > ls_n then
          --DBG('c')
          SaveProj()

        elseif (pr_n and ls_n) and pr_n < ls_n then
          --DBG('d')
          INIT()
          LoadData()
          update_gfx = true
          lastprojdirty = projdirty
          
        else
        
          --DBG(PROJNAME)
          --DBG('e')
          if nz(PROJNAME,'') ~= '' then
            SaveProj()
          else
            INIT()
            LoadData()
          end
          
        end

        lastprojname = PROJNAME
        update_gfx = true
        --DBG('projmodified')
      end
      lastprojdirty = projdirty
      --end
    end
    
    if gfx.w ~= last_gfx_w or gfx.h ~= last_gfx_h or force_resize then
      local r = false
      if not r or gfx.dock(-1) > 0 then 
        gfx1.main_w = gfx.w
        gfx1.main_h = gfx.h
        win_w = gfx.w
        win_h = gfx.h
  
        last_gfx_w = gfx.w
        last_gfx_h = gfx.h
        
        if obj then
          if show_editbar == true then
            plist_w = oplist_w
          end
          plist_w = math.min(plist_w, gfx1.main_w-obj.sections[19].w-obj.sections[14].w-obj.sections[18].w-obj.sections[1000].w)
          plist_w = math.max(plist_w,0)
          --if plist_w < 4 then show_editbar = false else show_editbar = true end
        end
        
        gui = GetGUI_vars()
        obj = GetObjects()
        
       -- if settings_autocentrectls then
       --   AutoCentreCtls()
       -- end
        show_fsnapshots = false
        show_xysnapshots = false
        resize_display = true
        update_surface = true
        force_resize = false
        
        if surface_size.w < obj.sections[10].w then
          surface_offset.x = -math.floor((obj.sections[10].w - surface_size.w)/2)
        end
      end
    end
    
    if rt >= time_nextupdate_pkmeter then
      for tr = -1, reaper.CountTracks(0)-1 do
        get_peak_info(tr)
      end
    end 
        
    local ct = reaper.CountTracks(0)
    if ct ~= otrkcnt then
      PopulateTracks()
      update_gfx = true
      otrkcnt = ct
      local st = reaper.GetSelectedTrack(0,0)
      if st == nil then
        track_select = -1
      end
      CheckGlobalTrackSel()
      CheckStripSends()
      PopulateTrackSendsInfo()
    else
      if LBX_GTRACK and gpage == true then
        CheckGlobalTrackSel()
      end    
    end    
    
    GUI_draw(obj, gui)
    
    local noscroll = false
    
    mouse.mx, mouse.my = gfx.mouse_x, gfx.mouse_y
    if gfx.mouse_cap == 0 then
      mouse.release = nil
    end
    if not mouse.release then
    mouse.LB = gfx.mouse_cap&1==1
    mouse.RB = gfx.mouse_cap&2==2
    end
    mouse.ctrl = gfx.mouse_cap&4==4
    mouse.shift = gfx.mouse_cap&8==8
    mouse.alt = gfx.mouse_cap&16==16
    
    local char 
    if EB_Open == 0 and MS_Open == 0 then
      char = gfx.getchar() 
      if char ~= 0 then
        --need to check if xxy/trackfxorder open?
        if show_midiout == false and show_trackfxorder == false and show_xxy == false and show_dd == false then
          char = keypress(char)
        end
      end
    
    elseif MS_Open > 0 then
    
      Process_MB()
      
    elseif EB_Open > 0 then
      
      Process_EB()
      
      --mouse.OLB = mouse.LB
      --mouse.ORB = mouse.RB
      noscroll = true
      mouse.LB = nil
      mouse.RB = nil
  
    end

    if show_dd and mouse.context == nil then
      A_Run_DropDown()
    end
    
    if show_trackfxorder then

      --if settings_UCV == 0 then
      --  UpdateControlValues(rt)
      --else      
        UpdateControlValues2(rt)
      --end
    
      A_Run_TFXOrder(char)
    
    elseif show_midiout then
    
      --if settings_UCV == 0 then
      --  UpdateControlValues(rt)
      --else      
        UpdateControlValues2(rt)
      --end

      A_Run_MidiOut(char)
    
    elseif lbx_midilrnctl then
    
      UpdateControlValues2(rt)

      A_Run_MidiLrn(char)
    
    elseif show_xxy == false then

      if settings_followselectedtrack and navigate and gpage == false then
      
        --[[if track_select ~= LBX_GTRACK then
          gpage_opage = page
          gpage_otrackselect = track_select
        end]]

        FollowTrack(ct)
        
      end
      
      local checksends = false
      if settings_disablesendchecks == false and rt >= time_checksend then
        time_checksend = rt + 2
        checksends = true
      end      
      
      --if settings_UCV == 0 then
      --  UpdateControlValues(rt)
      --else      
        UpdateControlValues2(rt)
      --end
      
      if show_settings then
        
        Process_Settings()
        
      else
      
      if show_eqcontrol ~= true and macro_edit_mode ~= true and MOUSE_clickXY(obj.sections[21],plist_w,0 ) and (hide_topbar == false or settings_showminimaltopbar) then
      
        TopMenu()
        mouse.context = contexts.dummy
  
      elseif MOUSE_clickXY(obj.sections[14],plist_w,0) and navigate then
        --page
        if track_select ~= LBX_GTRACK then
          local page = F_limit(math.ceil((mouse.mx-(obj.sections[14].x+plist_w))/(obj.sections[14].w/4)),1,4)
          SetPage(page)            
        end
        
      elseif MOUSE_clickXY(obj.sections[1000],plist_w,0) and navigate then
        --page
        SetGlobalPage()            
      
      elseif MOUSE_click(obj.sections[11]) then
        
        if mouse.mx > obj.sections[11].w-6 then
          mouse.context = contexts.dragsidebar
          offx = 0
        else--if navigate then
        
          if mode == 0 then
            if submode == 0 then
              if fxmode == 0 then
                setmode(2)
              else
                setmode(3)
              end
            elseif submode == 1 then
              setmode(4)
            else
              setmode(5)
            end
          else
            setmode(1)
          end
        
        end
        
      elseif MOUSE_clickXY(obj.sections[18],plist_w,0) and (hide_topbar == false or settings_showminimaltopbar) then
        if mode == 1 then
          mouse.context = contexts.dragsidebar
          offx = mouse.mx-plist_w
        else
          ToggleSidebar()
        end
      
      elseif (obj.sections[17].x > obj.sections[20].x+obj.sections[20].w) and MOUSE_clickXY(obj.sections[17],plist_w,0) then
        SaveProj(true, true)
        OpenMsgBox(1,'Data Saved.',1)
        update_gfx = true
      
      elseif MOUSE_clickXY(obj.sections[20],plist_w,0) then
        local butt = F_limit(math.ceil((mouse.mx-(obj.sections[20].x+plist_w))/(obj.sections[20].w/4)),1,4)
        if butt == 1 then
          LockX()
          
        elseif butt == 2 then
          LockY()
          
        elseif butt == 3 then
          ScrollUp()
          
        elseif butt == 4 then
          ScrollDown()
          
        end
        update_gfx = true
      end
      
      if mouse.context and mouse.context == contexts.dragsidebar then
      
        plist_w = math.max(mouse.mx-offx,0) 
        plist_w = math.min(plist_w, gfx1.main_w-obj.sections[19].w-obj.sections[14].w-obj.sections[18].w)
        oplist_w = math.max(plist_w,100)
        if plist_w <= 4 then
          show_editbar = false
        else
          show_editbar = true
        end
        obj = GetObjects()
        resize_display = true
        update_surface = true
      
      end
      
      if mode == 0 then
        
        noscroll = A_Run_Mode0(noscroll, rt)
        
      elseif mode == 1 then
        
        reaper.MarkProjectDirty(0)
        show_fsnapshots = false
        
        if ct == 0 and track_select ~= -1 then
          --track_select = -1
          ChangeTrack(-1)
          update_gfx = true
        end
      
        local tr = GetTrack(trackedit_select)
        if tr then
          local fxc = reaper.TrackFX_GetCount(tr)
          if fxc ~= ofxcnt then
            PopulateTrackFX()
            update_gfx = true
          end
        end
      
        if mouse.shift then
          settings_gridsize = 1
        else
          settings_gridsize = ogrid      
        end
  
        if strips and tracks[track_select] and strips[tracks[track_select].strip] and #strips[tracks[track_select].strip][page].controls > 0 then
          CheckTrack(strips[tracks[track_select].strip].track, tracks[track_select].strip)
        end
        
        g_edstrips[track_select] = true
        
        if submode == 0 then
                    
          noscroll = A_Run_Submode0(noscroll, rt, char)
                  
        elseif submode == 1 then
  
          noscroll = A_Run_Submode1(noscroll, rt, char)
          
        elseif submode == 2 then
    
          noscroll = A_Run_Submode2(noscroll, rt, char)
          
        end

        if MOUSE_click(obj.sections[13]) then
          if submode ~= 0 or (submode == 0 and mouse.mx < obj.sections[13].x + obj.sections[13].w - 30) then
            if submode == 0 then
              setmode(4)
            elseif submode == 1 then
              setmode(5)
            elseif submode == 2 then
              if fxmode == 0 then
                setmode(2)
              else
                setmode(3)
              end
            end
          elseif submode == 0 and mouse.mx > obj.sections[13].x + obj.sections[13].w - 30 then
            if fxmode == 0 then
              setmode(3)
            else
              setmode(2)
            end
            
          end
  
        elseif MOUSE_click_RB(obj.sections[13]) then
          if submode == 2 then
            setmode(4)
          elseif submode == 0 then
            setmode(5)
          elseif submode == 1 then
            if fxmode == 0 then
              setmode(2)
            else
              setmode(3)
            end
          end
          
        end          
      end
      
      if mouse.context == nil then
        if ((submode == 0 and ctl_select ~= nil) and (MOUSE_click(obj.sections[45]) or (MOUSE_click(obj.sections[100]) and show_cycleoptions) 
            or (MOUSE_click(obj.sections[200]) and show_ctlbrowser)) or (MOUSE_click(obj.sections[800]) and show_gaugeedit)) or 
           ((submode == 1 and gfx2_select ~= nil) and (MOUSE_over(obj.sections[49]) and (show_lbloptions == true or show_gfxoptions == true))) then

        elseif mouse.mx > obj.sections[10].x and show_actionchooser == false then
          if MOUSE_click(obj.sections[10]) then
            if noscroll == false then
              mouse.context = "dragsurface"
              surx = surface_offset.x
              sury = surface_offset.y
              mmx = mouse.mx
              mmy = mouse.my
              update_surface = true
            end

            if show_gaugeedit ~= true then
              ctl_select = nil
              show_cycleoptions = false
              show_ctlbrowser = false
              gfx2_select = nil
              gfx3_select = nil
            else
              show_gaugeedit = false
            end
            
            if mode ~= 0 then
              update_surface = true
            end
          end
  
        end    
      end
      if mouse.context and mouse.context == "dragsurface" then
        if noscroll == false and settings_locksurface == false then
        
          local offx, offy
          if lockx == false then
            offx = MOUSE_surfaceX(obj.sections[10])
          end
          if locky == false then  
            offy = MOUSE_surfaceY(obj.sections[10])
          end
          
          if surface_size.w < obj.sections[10].w then
            surface_offset.x = -math.floor((obj.sections[10].w - surface_size.w)/2)
          elseif offx ~= nil then
            --if locky == false then
            --  surface_offset.x = F_limit(surx + offx,0-math.ceil(obj.sections[10].w*0.25),surface_size.w - math.ceil(obj.sections[10].w*0.75))
            --else
              surface_offset.x = F_limit(surx + offx,0,surface_size.w - obj.sections[10].w)        
            --end
          end
          
          if offy ~= nil then
            --if lockx == false then
            --  surface_offset.y = F_limit(sury + offy,0-math.ceil(obj.sections[10].h*0.25),surface_size.h - math.ceil(obj.sections[10].h*0.75))
            --else
              surface_offset.y = F_limit(sury + offy,0,surface_size.h - obj.sections[10].h)        
            --end
          end
    
          if surface_offset.oldx ~= surface_offset.x or surface_offset.oldy ~= surface_offset.y or (ctls and not ctl_select) then
            surface_offset.oldx = surface_offset.x
            surface_offset.oldy = surface_offset.y
            
            if strips and tracks[track_select] and strips[tracks[track_select].strip] then
              strips[tracks[track_select].strip][page].surface_x = surface_offset.x
              strips[tracks[track_select].strip][page].surface_y = surface_offset.y
            end
            if surface_offset.x < 0 or surface_offset.y < 0 
                or surface_offset.x > surface_size.w-obj.sections[10].w 
                or surface_offset.y > surface_size.h-obj.sections[10].h then 
              update_surfaceedge = true 
            end
            update_surface = true
          end
        end
      end
      
      if settings_mousewheelknob == false and gfx.mouse_wheel ~= 0 and show_ctlbrowser == false and show_cycleoptions == false and show_ctloptions == false then
        if noscroll == false then
          if lockx == false or locky == false then
            local v = gfx.mouse_wheel/120
            if mouse.mx > obj.sections[10].x and MOUSE_over(obj.sections[10]) then
              if ctl_select then
                ctl_select = nil
                update_gfx = true
              end
              if locky then
                surface_offset.x = F_limit(surface_offset.x - v * 50,0,surface_size.w - obj.sections[10].w)
              elseif lockx then
                surface_offset.y = F_limit(surface_offset.y - v * 50,0,surface_size.h - obj.sections[10].h)        
              else
                surface_offset.y = F_limit(surface_offset.y - v * 50,0,surface_size.h - obj.sections[10].h)        
              end
              if strips and tracks[track_select] and strips[tracks[track_select].strip] then
                strips[tracks[track_select].strip][page].surface_x = surface_offset.x
                strips[tracks[track_select].strip][page].surface_y = surface_offset.y
              end
              if surface_offset.x < 0 or surface_offset.y < 0 
                  or surface_offset.x > surface_size.w-obj.sections[10].w 
                  or surface_offset.y > surface_size.h-obj.sections[10].h then 
                update_surfaceedge = true 
              end
              update_surface = true
            end
          end
        else
          if ctl_select then
            ctl_select = nil
            update_gfx = true
          end
        
        end
        gfx.mouse_wheel = 0
      end
          
      end

    else --XXY MODE
    
      A_Run_XXYMode(rt)
      
    end

    if not mouse.LB and not mouse.RB then mouse.context = nil end
    --[[if mouse.context == nil and undotxt then
      reaper.Undo_OnStateChange2(0, undotxt)
      reaper.Undo_EndBlock2(0,undotxt, -1)
      undotxt = nil
    end]]
    if show_cycleoptions == false then cycle_editmode = false end
    
    ReadAutomationFaders()
    
    if rcmrefreshtimercount > 0 then
      RCMRefresh()
    end
    
    if char then 
      if char == 32 then reaper.Main_OnCommandEx(40044, 0,0) end
      if char>=0 and char~=27 then reaper.defer(run) end
    else
      reaper.defer(run)
    end
    gfx.update()
    mouse.last_LB = mouse.LB
    mouse.last_RB = mouse.RB
    mouse.last_x = mouse.mx
    mouse.last_y = mouse.my
    if mouse.LB then
      mouse.lastLBclicktime = rt
    end
    gfx.mouse_wheel = 0
    if ctl_select then ctls = true else ctls = false end
    if closectlbrowser then closectlbrowser = nil show_ctlbrowser = false end
    if closegaugeedit then closegaugeedit  = nil show_gaugeedit = false end
    if redraw_ctlbitmap and reaper.time_precise() >= redraw_ctlbitmap then
      redraw_ctlbitmap = nil
      GUI_DrawCtlBitmap()
    end
    if midimsg == true and reaper.time_precise() >= midimsgto then
      midimsg = false
      update_surface = true
    end
    if touch_timer and touch_timer <= reaper.time_precise() then
      touch_timer = nil
      update_surface = true
    end

  end

  function RCMRefresh()
  --DBG('rcmrefresh')
    if rcmrefreshtimer then
      local cnt = 0
      for r = 1, rcmrefreshtimercount do
        if rcmrefreshtimer[r] then 
          cnt = cnt + 1
          if rcmrefreshtimer[r].tracknum == tracks[track_select].tracknum then
            if reaper.time_precise() >= rcmrefreshtimer[r].time then
              RefreshControlsByGUID(rcmrefreshtimer[r].guid)
              
              if rcmrefreshtimer[r].setvals == true then
                local cvs = rcmrefreshtimer[r].ctlvals
                if cvs and #cvs > 0 then
                  for i = 1, #cvs do
                    local ctl = strips[cvs[i].strip][cvs[i].page].controls[cvs[i].ctl]
                    ctl.val = cvs[i].val
                    A_SetParam(cvs[i].strip,cvs[i].page,cvs[i].ctl,ctl)
                  end
                end
              
              end
              
              rcmrefreshtimer[r] = nil
              rcmrefreshtimercount = math.max(rcmrefreshtimercount -1,0)
            end
          else
            if rcmrefreshtimer[r].setvals == true then
              if reaper.time_precise() >= rcmrefreshtimer[r].time then
                local cvs = rcmrefreshtimer[r].ctlvals
                if cvs and #cvs > 0 then
                  for i = 1, #cvs do
                    local ctl = strips[cvs[i].strip][cvs[i].page].controls[cvs[i].ctl]
                    ctl.val = cvs[i].val
                    A_SetParam(cvs[i].strip,cvs[i].page,cvs[i].ctl,ctl)
                  end
                end
              end
            else
              rcmrefreshtimer[r] = nil
              rcmrefreshtimercount = math.max(rcmrefreshtimercount -1,0)            
            end
          end
        end
      end
      if cnt == 0 then
        rcmrefreshtimer = nil
        rcmrefreshtimercount = 0
      else 
        if rcmrefreshtimercount == 0 then
          rcmrefreshtimer = nil
        end
      end
    else
      rcmrefreshtimercount = 0
    end
    
  end
  
  function GetFXNum(guid)
    local track = GetTrack(tracks[track_select].tracknum)
    if track then
      local fxcnt = reaper.TrackFX_GetCount(track)
      for f = 0, fxcnt do
        if reaper.TrackFX_GetFXGUID(track,f) == guid then
          return f
        end
      end
    end
  end
  
  function RefreshControlsByGUID(guid)
    --DBG(guid..'   '..rcmrefreshtimercount)
    --local fxnum = GetFXNum(guid)
    --if fxnum then
    local strip = tracks[track_select].strip
    for c = 1, #strips[strip][page].controls do
      local ctl = strips[strip][page].controls[c]
      if ctl and ctl.fxguid and ctl.fxguid == guid then
        --DBG(c)
        ctl.dirty = true
      end
    end
  --end
    update_ctls = true
  end

  function A_Run_MidiLrn(char)

    if mouse.context == nil and MOUSE_click(obj.sections[982]) then

      if lbx_midilrnval then
      
        if faders[lbx_midilrnval] and faders[lbx_midilrnval].targettype then
          if reaper.MB('Replace assignment?','Faderbox learn',4) ~= 6 then
            return
          end 
        end
      
        local ctl = strips[tracks[track_select].strip][page].controls[lbx_midilrnctl]
        local tt
        if ctl.ctlcat == ctlcats.snapshot then
          tt = 7
        else
          tt = 4
        end
                
        local f = {targettype = tt,
                   strip = tracks[track_select].strip,
                   page = page,
                   ctl = lbx_midilrnctl,
                   c_id = ctl.c_id,
                   voffset = lbx_midilrnoff}
        for i = 1, #faders do
          if faders[i].targettype == f.targettype and
             faders[i].strip == f.strip and
             faders[i].page == f.page and
             faders[i].ctl == f.ctl and
             faders[i].c_id == f.c_id then
            faders[i] = {}
          end
        end
        AssignFader(lbx_midilrnval, f)
        
      else
        local fad = ctl.macrofader
        if fad then
          DeleteFader(fad)
        end
      end
      lbx_midilrnctl = nil
      lbx_midilrnval = nil
      update_surface = true
    
    elseif MOUSE_click(obj.sections[981]) then

      local ctl = strips[tracks[track_select].strip][page].controls[lbx_midilrnctl]
    
      local f = {targettype = 4,
                 strip = tracks[track_select].strip,
                 page = page,
                 ctl = lbx_midilrnctl,
                 c_id = ctl.c_id,
                 voffset = 0}
      
      local fad = SetAutomationFader(f, ctl.macrofader, true)
      if fad > 0 then
        lbx_midilrnval = fad  
      elseif fad == -2 then
        lbx_midilrnval = nil
      end
      update_surface = true
      
    elseif mouse.context == nil and mouse.LB and not MOUSE_over(obj.sections[980]) then
      lbx_midilrnctl = nil
      lbx_midilrnval = nil
      update_surface = true
      
    elseif MOUSE_click(obj.sections[983]) then
      local ctl = strips[tracks[track_select].strip][page].controls[lbx_midilrnctl]
      if ctl.ctlcat == ctlcats.snapshot then
        NoteValueOffsetMenu(lbx_midilrnoff)
        update_gfx = true
      end
    end

  end
  
  function A_Run_MidiOut(char)
  
    if mouse.context == nil and MOUSE_click(obj.sections[951]) then
      local res = MenuMidiOuts()
      if res and res > 1 then
        midiout_select.output = midiouts[res-1].name
      else
        midiout_select.output = nil
      end
      update_surface = true

    elseif mouse.context == nil and MOUSE_click(obj.sections[954]) then
      local res = MenuMidiMsgType()
      if res then
        midiout_select.msgtype = res
      end
      update_surface = true

    elseif mouse.context == nil and MOUSE_click(obj.sections[955]) then

      local retval, msg = reaper.GetUserInputs('Osc Message',1,'OSC:,extrawidth=220',nz(midiout_select.osc,''))
      if retval == true then
        midiout_select.osc = msg
      end
      update_surface = true

    elseif mouse.context == nil and MOUSE_click(obj.sections[956]) then

      local retval, msg = reaper.GetUserInputs('Value Range',1,'Value Min:',nz(midiout_select.vmin,0))
      if retval == true then
        local msgv = tonumber(msg)
        if msgv then
          midiout_select.vmin = msgv
        end
      end
      update_surface = true

    elseif mouse.context == nil and MOUSE_click(obj.sections[957]) then

      local retval, msg = reaper.GetUserInputs('Value Range',1,'Value Max:',nz(midiout_select.vmax,127))
      if retval == true then
        local msgv = tonumber(msg)
        if msgv then
          midiout_select.vmax = msgv
        end
      end
      update_surface = true
      
    elseif mouse.context == nil and MOUSE_click(obj.sections[958]) then
      midiout_select.focus = midiout_select.focus + 1
      if midiout_select.focus > #focus_table then
        midiout_select.focus = 1
      end
      update_surface = true

    elseif mouse.context == nil and MOUSE_click(obj.sections[959]) then
      midiout_select.updategfx = not midiout_select.updategfx
      update_surface = true

    elseif mouse.context == nil and MOUSE_click(obj.sections[961]) then
      midiout_select.onmu = not midiout_select.onmu
      update_surface = true
      
    elseif mouse.context == nil and MOUSE_click(obj.sections[952]) then
      mouse.context = contexts.midiout_chan
      midiout_select.mchan = F_limit(midiout_select.mchan + 1,1,16)
      dragmidi = {pos = midiout_select.mchan, yoff = mouse.my-obj.sections[952].y}
      
      update_surface = true
    elseif mouse.context == nil and MOUSE_click_RB(obj.sections[952]) then
      midiout_select.mchan = F_limit(midiout_select.mchan - 1,1,16)
      update_surface = true

    elseif mouse.context == nil and MOUSE_click(obj.sections[953]) then
      mouse.context = contexts.midiout_msg
      midiout_select.msg3 = F_limit(midiout_select.msg3 + 1,0,127)
      dragmidi = {pos = midiout_select.msg3, yoff = mouse.my-obj.sections[953].y}
      
      update_surface = true
    elseif mouse.context == nil and MOUSE_click_RB(obj.sections[953]) then
      midiout_select.msg3 = F_limit(midiout_select.msg3 - 1,0,127)
      update_surface = true
      
    elseif mouse.context == nil and mouse.LB and not MOUSE_over(obj.sections[950]) then
      show_midiout = false
      
      local strip = tracks[track_select].strip
      if midioutedit_ctlselect == true then
        if ctl_select and #ctl_select > 0 then
          for c = 1, #ctl_select do
            local ctl = strips[strip][page].controls[ctl_select[c].ctl]
            if ctl and ((midiout_select.output and midioutsidx[midiout_select.output]) or midiout_select.osc) then
            
              ctl.midiout = {output = midiout_select.output,
                             msgtype = midiout_select.msgtype,
                             mchan = midiout_select.mchan,
                             msg3 = midiout_select.msg3,
                             osc = midiout_select.osc,
                             vmin = midiout_select.vmin,
                             vmax = midiout_select.vmax,
                             focus = midiout_select.focus,
                             updategfx = midiout_select.updategfx,
                             onmu = midiout_select.onmu}
            
            else
              ctl.midiout = nil
            end
          end        
        end
        midioutedit_ctlselect = nil
      elseif midioutedit_select then
        local ctl = strips[strip][page].controls[midioutedit_select]
        if ctl and ((midiout_select.output and midioutsidx[midiout_select.output]) or midiout_select.osc) then
        
          ctl.midiout = {output = midiout_select.output,
                         msgtype = midiout_select.msgtype,
                         mchan = midiout_select.mchan,
                         msg3 = midiout_select.msg3,
                         osc = midiout_select.osc,
                         vmin = midiout_select.vmin,
                         vmax = midiout_select.vmax,
                         focus = midiout_select.focus,
                         updategfx = midiout_select.updategfx,
                         onmu = midiout_select.onmu}
        
        else
          ctl.midiout = nil
        end
      end
            
      update_gfx = true
    end
    
    if mouse.context and mouse.context == contexts.midiout_chan then
      local v = MOUSE_slider(obj.sections[952], -dragmidi.yoff)
      if v then
        v=v-0.5
        midiout_select.mchan = F_limit(math.floor(dragmidi.pos - v*32),1,16)
        update_surface = true
      end
    
    elseif mouse.context and mouse.context == contexts.midiout_msg then
      local v = MOUSE_sliderX(obj.sections[953], -dragmidi.yoff)
      if v then
        v=v-0.5
        midiout_select.msg3 = F_limit(math.floor(dragmidi.pos - v*96),0,127)
        update_surface = true
      end
    end
  
  end
  
  function A_Run_TFXOrder(char)
  
    if char ~= 0 then
      if char == 49 then
        show_trackfxorder = false
        update_surface = true
      end
    end
    
    local butt_cnt, bh = GetTFXOButtCnt()
    local xywh = {x = obj.sections[900].x+30,
                  y = obj.sections[900].y+30,
                  w = obj.sections[900].w-50,
                  h = obj.sections[900].h-30}
                  
    if gfx.mouse_wheel ~= 0 and MOUSE_over(xywh) then
      local v = gfx.mouse_wheel/120
    
      if butt_cnt < #tfxorder then
        tfxo_listpos = F_limit(tfxo_listpos -v,0,#tfxorder-butt_cnt)
        update_surface = true
        gfx.mouse_wheel = 0
      end      
    elseif mouse.context == nil and MOUSE_click(xywh) then
      tfxo_sel =  F_limit(math.floor((mouse.my - xywh.y) / bh)+1 +tfxo_listpos, 1, #tfxorder)
      if tfxo_sel <= #tfxorder then
        mouse.context = contexts.tfxo_shift
        tfxo_scrolldel = reaper.time_precise()
        tfxo_pos = tfxo_sel  
      else
        tfxo_sel = nil
      end
      update_surface = true
    elseif mouse.context == nil and mouse.LB and not MOUSE_over(obj.sections[900]) then
      show_trackfxorder = false
      update_surface = true
    end
  
    if mouse.context and mouse.context == contexts.tfxo_shift then
      tfxo_lastpos = tfxo_pos
      local mpos = math.floor((mouse.my - xywh.y) / bh)+1
      tfxo_pos = F_limit(mpos +tfxo_listpos, 1, #tfxorder)
      if reaper.time_precise() > tfxo_scrolldel then
        if mpos < 1 then
          tfxo_listpos = math.max(tfxo_listpos -1,0)
        elseif mpos > butt_cnt then --hard coded size :/
          tfxo_listpos = math.min(tfxo_listpos +1,#tfxorder-butt_cnt)
        end
        tfxo_scrolldel = reaper.time_precise() + 0.1
        update_surface = true
      end        
      if tfxo_pos ~= tfxo_lastpos then      
        tfxreorder = ReOrderTable(tfxorder, 1, tfxo_sel, tfxo_pos)
        update_surface = true
      end
    elseif mouse.context == nil and tfxo_pos then
      MoveFXChunk(tfxo_sel, tfxo_pos)
      tfxo_pos = nil
      tfxo_sel = nil
      tfxorder = tfxreorder
      update_surface = true
    end
    
  end

  function ReOrderTable(tab, s, p1, p2)
  
    local newtab = {}
    local offs = 0
    for i = s, #tab do
      if i ~= p1 then
        table.insert(newtab, tab[i])
      end
    end
    if p2 == #tab then
      table.insert(newtab, tab[p1])
    else
      table.insert(newtab, p2, tab[p1])
    end
    return newtab
    
  end
  
  function A_Run_Mode0(noscroll, rt)
  
    if settings_touchFB == true and mouse.LB then
      touch_trigger = true
      DrawMD(gui, obj)
    end
    if (touch_trigger == true and not mouse.LB) then -- or (mididelay and reaper.time_precise() >= mididelay) then
      if mu_mmsg and (midi1st or mouse.LB) then
        SendMIDIMsg(mu_mmsg.midiout, mu_mmsg.val, true)
        midi1st = nil
      end
      
      if not mouse.LB then
        mu_mmsg = nil
        touch_trigger = false
        update_surface = true
        touch_timer = reaper.time_precise()+0.2
        mididelay = nil
      else
        mididelay = reaper.time_precise()+0.2
      end
    end
    
    if gfx.mouse_wheel ~= 0 then
      local v = gfx.mouse_wheel/120
      if MOUSE_over(obj.sections[500]) then
        tlist_offset = F_limit(tlist_offset - v, 0, #tracks+1)
        update_gfx = true
        gfx.mouse_wheel = 0
      end

      if show_snapshots == true and MOUSE_over(obj.sections[160]) then
        if snapshots and snapshots[tracks[track_select].strip] and
           snapshots[tracks[track_select].strip][page][sstype_select] then
          if sstype_select == 1 then
            ssoffset = F_limit(ssoffset - v, 0, #snapshots[tracks[track_select].strip][page][sstype_select]-1)
          elseif sstype_select > 1 then
            ssoffset = F_limit(ssoffset - v, 0, #snapshots[tracks[track_select].strip][page][sstype_select].snapshot-1)
          end
          update_snaps = true
        end     
        gfx.mouse_wheel = 0
      end

      if show_fsnapshots == true and MOUSE_over(obj.sections[180]) then
        if snapshots and snapshots[tracks[track_select].strip] and
           snapshots[tracks[track_select].strip][page][fsstype_select] then
          if fsstype_select == 1 then
            fssoffset = F_limit(fssoffset - v, 0, #snapshots[tracks[track_select].strip][page][fsstype_select]-1)
          elseif fsstype_select > 1 then
            fssoffset = F_limit(fssoffset - v, 0, #snapshots[tracks[track_select].strip][page][fsstype_select].snapshot-1)
          end
          update_fsnaps = true
        end     
        gfx.mouse_wheel = 0
      end
    end
    
    if insertstrip then
    
      A_Run_InsertStrip()
    
    elseif mouse.context == nil and show_xysnapshots == true and show_eqcontrol ~= true and macro_edit_mode ~= true and (MOUSE_click(obj.sections[180]) or MOUSE_click_RB(obj.sections[180])) then
    
      if mouse.context == nil and MOUSE_click_RB(obj.sections[180]) then
        show_xysnapshots = false
        update_surface = true
      end
    
      local snapmx, snapmy = mouse.mx, mouse.my
      mouse.mx = mouse.mx - obj.sections[180].x
      mouse.my = mouse.my - obj.sections[180].y

      if mouse.context == nil and MOUSE_click(obj.sections[182]) then
        mouse.context = contexts.resizefsnapwindow
        resizesnapwin = {origh = obj.sections[180].h,
                         offy = mouse.my}          

      elseif mouse.context == nil and MOUSE_click(obj.sections[181]) then
        if snapshots and snapshots[tracks[track_select].strip] then
          local i = math.floor((mouse.my-obj.sections[181].y)/butt_h)
      
          if i == 0 then
            local ix = math.floor((mouse.mx-obj.sections[181].x)/(obj.sections[180].w/2))
            if ix == 0 then
              fssoffset = fssoffset-FSS_butt_cnt
              if fssoffset < 0 then fssoffset = 0 end
            else
              if fsstype_select == 1 then
                fssoffset = F_limit(fssoffset+FSS_butt_cnt,0,math.max(0,#snapshots[tracks[track_select].strip][page][fsstype_select]-FSS_butt_cnt))
              elseif fsstype_select > 1 then
                fssoffset = F_limit(fssoffset+FSS_butt_cnt,0,math.max(0,#snapshots[tracks[track_select].strip][page][fsstype_select].snapshot-FSS_butt_cnt))                  
              end
            end
            update_ctls = true
            update_fsnaps = true
          else
            if snapshots and snapshots[tracks[track_select].strip] then
              local maxss
              if fsstype_select == 1 then
                maxss = #snapshots[tracks[track_select].strip][page][fsstype_select]
              else
                maxss = #snapshots[tracks[track_select].strip][page][fsstype_select].snapshot
              end
              
              if fssoffset+i <= maxss then
                fss_select = fssoffset+i

                if xysnap_select == 1 then
                  strips[tracks[track_select].strip][page].controls[xy_select].xydata.snapa = fss_select
                elseif xysnap_select == 2 then
                  strips[tracks[track_select].strip][page].controls[xy_select].xydata.snapb = fss_select
                elseif xysnap_select == 3 then
                  strips[tracks[track_select].strip][page].controls[xy_select].xydata.snapc = fss_select
                elseif xysnap_select == 4 then
                  strips[tracks[track_select].strip][page].controls[xy_select].xydata.snapd = fss_select
                end
                
                g_savedirty = true
                show_xysnapshots = false
                update_surface = true
              end
            end
          end
        end
      end
      
      mouse.mx = snapmx
      mouse.my = snapmy
      noscroll = true
      
    elseif mouse.context == nil and show_fsnapshots == true and show_eqcontrol ~= true and macro_edit_mode ~= true and (MOUSE_click(obj.sections[180]) or MOUSE_click_RB(obj.sections[180])) then

      if mouse.context == nil and MOUSE_click_RB(obj.sections[180]) then
        show_fsnapshots = false
        update_surface = true
      end

      local snapmx, snapmy = mouse.mx, mouse.my
      mouse.mx = mouse.mx - obj.sections[180].x
      mouse.my = mouse.my - obj.sections[180].y

      if mouse.context == nil and MOUSE_click(obj.sections[182]) then
        mouse.context = contexts.resizefsnapwindow
        resizesnapwin = {origh = obj.sections[180].h,
                         offy = mouse.my}          
      
      elseif mouse.context == nil and MOUSE_click(obj.sections[181]) then
        if snapshots and snapshots[tracks[track_select].strip] then
          local i = math.floor((mouse.my-obj.sections[181].y)/butt_h)
      
          if i == 0 then
            local ix = math.floor((mouse.mx-obj.sections[181].x)/(obj.sections[180].w/2))
            if ix == 0 then
              fssoffset = fssoffset-FSS_butt_cnt
              if fssoffset < 0 then fssoffset = 0 end
            else
              if fsstype_select == 1 then
                fssoffset = F_limit(fssoffset+FSS_butt_cnt,0,math.max(0,#snapshots[tracks[track_select].strip][page][fsstype_select]-FSS_butt_cnt))
              elseif fsstype_select > 1 then
                fssoffset = F_limit(fssoffset+FSS_butt_cnt,0,math.max(0,#snapshots[tracks[track_select].strip][page][fsstype_select].snapshot-FSS_butt_cnt))                  
              end
            end
            update_ctls = true
            update_fsnaps = true
          else
            if snapshots and snapshots[tracks[track_select].strip] then
              local maxss
              if fsstype_select == 1 then
                maxss = #snapshots[tracks[track_select].strip][page][fsstype_select]
              else
                maxss = #snapshots[tracks[track_select].strip][page][fsstype_select].snapshot
              end
              
              if fssoffset+i <= maxss then
                fss_select = fssoffset+i
                Snapshot_Set(tracks[track_select].strip, page, fsstype_select, fss_select)
                update_ctls = true --to update snapshot ctls
                update_fsnaps = true          
                if sstype_select == fsstype_select then
                  ss_select = fss_select
                  update_snaps = true       
                end
              end
            end
          end
        end
      end

      mouse.mx = snapmx
      mouse.my = snapmy
      noscroll = true

    elseif mouse.context == nil and (show_snapshots == true and macro_edit_mode ~= true and show_eqcontrol ~= true) and (MOUSE_click(obj.sections[160]) or MOUSE_click_RB(obj.sections[160])) then
    
      A_Run_SnapshotsWin(rt)
      noscroll = true
    
    elseif mouse.context == nil and snaplrn_mode == true then      
      
      A_Run_SnapshotsLearn()
    
    elseif mouse.context and mouse.context == contexts.draglasso then
      if math.abs(lasso.l - mouse.mx) > 10 or math.abs(lasso.t - mouse.my) > 10 then
        lasso.r = mouse.mx
        lasso.b = mouse.my

        Lasso_Select(false)
        update_surface = true
      end
    
    elseif macro_lrn_mode == true then
    
      A_Run_MacroLearn()          
    
    elseif show_eqcontrol == true then
    
      noscroll = A_Run_EQControl(noscroll, rt)

    elseif macro_edit_mode == true and macro_lrn_mode == false then

      noscroll = A_Run_MacroEdit(noscroll, rt)

    elseif mouse.context == nil and (MOUSE_click(obj.sections[10]) or MOUSE_click_RB(obj.sections[10]) or gfx.mouse_wheel ~= 0) then
      
      local togfsnap = false
      --DBG(gfx.mouse_wheel ..'  '.. mouse.mx..'  '..obj.sections[10].x)
      if mouse.mx > obj.sections[10].x then
        if strips and tracks[track_select] and strips[tracks[track_select].strip] then
          local i
          --local ttt = reaper.time_precise()
          local strip = tracks[track_select].strip
          local ctls = strips[tracks[track_select].strip][page].controls
          local c = GetControlAtXY(tracks[track_select].strip, page, mouse.mx, mouse.my)
          if c then
            i = c
            local ctl = ctls[i]
            ctlxywh = {x = ctl.xsc - surface_offset.x +obj.sections[10].x, 
                       y = ctl.ysc - surface_offset.y +obj.sections[10].y, 
                       w = ctl.wsc, 
                       h = ctl.hsc} 
          end
          if i and not ctls[i].hidden then
            if ctls[i].fxfound then
              if MOUSE_click(ctlxywh) and not mouse.ctrl and not mouse.alt then
                local ctltype = ctls[i].ctltype
              
                if mouse.lastLBclicktime and (rt-mouse.lastLBclicktime) < 0.15 and ctltype ~= 5 and ctltype ~= 2 and ctltype ~= 3 then
                  if settings_swapctrlclick == false then
                    SetParam_ToDef(i)             
                  else
                    SetParam_EnterVal(i)
                  end
                      
                  noscroll = true
                  
                end
                
                if ctltype == 1 then
                  
                  if ctls[i].ctlcat ~= ctlcats.macro then
                    --knob/slider
                    if ctls[i].horiz then
                      mouse.context = contexts.sliderctl_h
                      mouse.slideoff = ctlxywh.x+ctlxywh.w/2 - mouse.mx
                    else
                      mouse.context = contexts.sliderctl
                      mouse.slideoff = ctlxywh.y+ctlxywh.h/2 - mouse.my
                    end
                    --knobslider = 'ks'
                    ctlpos = ctlScaleInv(nz(ctls[i].scalemode,8),
                                         ctls[i].val)
                    trackfxparam_select = i
                    oms = mouse.shift
                  else
                    if ctls[i].horiz then
                      mouse.context = contexts.macctl_h
                      mouse.slideoff = ctlxywh.x+ctlxywh.w/2 - mouse.mx
                    else
                      mouse.context = contexts.macctl
                      mouse.slideoff = ctlxywh.y+ctlxywh.h/2 - mouse.my
                    end
                    --knobslider = 'ks'
                    ctlpos = ctlScaleInv(nz(ctls[i].scalemode,8),
                                         ctls[i].val)
                    macctlactive = i 
                    --ctls[i].mval = nil
                    trackfxparam_select = i
                    oms = mouse.shift                      
                  end
                  
                  --undotxt = 'Parameter Change'
                  --reaper.Undo_BeginBlock2()
                  
                elseif ctltype == 2 or ctltype == 3 then
                  --button/button inverse
                  trackfxparam_select = i
                  if ctls[i].val < 0.5 then
                    ctls[i].val = 1
                  else
                    ctls[i].val = 0
                  end
                  A_SetParam(tracks[track_select].strip,page,i,ctls[i])
                  ctls[i].dirty = true
                  if ctls[i].param_info.paramname == 'Bypass' then
                    SetCtlEnabled(ctls[i].fxnum) 
                  end
                  noscroll = true
                  update_ctls = true
                elseif ctltype == 4 then
                  --cycle
                  if ctls[i].cycledata.draggable then
                    if ctls[i].horiz then
                      mouse.context = contexts.dragcycle_h
                      mouse.slideoff = ctlxywh.x+ctlxywh.w/2 - mouse.mx
                    else
                      mouse.context = contexts.dragcycle
                      mouse.slideoff = ctlxywh.y+ctlxywh.h/2 - mouse.my
                    end
                    ctlpos = normalize(0, ctls[i].cycledata.statecnt,
                                       ctls[i].cycledata.pos)
                    trackfxparam_select = i
                    ctls[i].cycledata.posdirty = false
                    oms = mouse.shift
                  else
                    if ctls[i].cycledata.pos == nil then
                      ctls[i].cycledata.pos = 1
                    else
                      ctls[i].cycledata.pos = ctls[i].cycledata.pos +1
                      if ctls[i].cycledata.pos > ctls[i].cycledata.statecnt 
                         or ctls[i].cycledata.pos < 1 then
                        ctls[i].cycledata.pos = 1
                      end
                    end
                    if ctls[i].cycledata.pos <=     
                              ctls[i].cycledata.statecnt then
                      trackfxparam_select = i
                      ctls[i].val = 
                          ctls[i].cycledata[ctls[i].cycledata.pos].val
                      A_SetParam(tracks[track_select].strip,page,i,ctls[i])
                      ctls[i].dirty = true
                      ctls[i].cycledata.posdirty = false
                      update_ctls = true
                    end
                  end
                  noscroll = true
                elseif ctltype == 6 then
                  --mem button
                  trackfxparam_select = i
                  if ctls[i].membtn.state == nil then
                    ctls[i].membtn.state = false
                  end
                  ctls[i].membtn.state = not ctls[i].membtn.state
                  if ctls[i].membtn.state == true then
                    ctls[i].membtn.mem = ctls[i].val
                    ctls[i].val = ctls[i].defval
                    A_SetParam(strip,page,i,ctls[i])
                  else
                    ctls[i].val = ctls[i].membtn.mem
                    A_SetParam(strip,page,i,ctls[i])
                  end
                  update_ctls = true                    
                elseif ctltype == 5 then
                  if ctls[i].ctlcat == ctlcats.xy then
                    if mouse.my - obj.sections[10].y + surface_offset.y - ctls[i].y < ctls[i].ctl_info.cellh - 38 then
                      mouse.context = contexts.dragxy
                      xy_select = i
                    else
                      local xp = math.floor((mouse.mx-12 - obj.sections[10].x + surface_offset.x - ctls[i].x)/((ctls[i].w-24)/4))+1
                      xysnap_select = xp
                      xy_select = i
                      
                      --open fss
                      togfsnap = true
                      if fsstype_select == ctls[i].param then
                        show_xysnapshots = not show_xysnapshots
                        show_fsnapshots = false
                      else
                        show_xysnapshots = true
                        show_fsnapshots = false
                      end
                      fsstype_select = ctls[i].param
                      fsstype_color = ctls[i].textcol
                      if show_xysnapshots then
                        if snapshots and snapshots[tracks[track_select].strip] and snapshots[tracks[track_select].strip][page][fsstype_select] then
                        
                          if xysnap_select == 1 then
                            fss_select = ctls[i].xydata.snapa
                          elseif xysnap_select == 2 then
                            fss_select = ctls[i].xydata.snapb
                          elseif xysnap_select == 3 then
                            fss_select = ctls[i].xydata.snapc
                          elseif xysnap_select == 4 then
                            fss_select = ctls[i].xydata.snapd
                          end
                          obj.sections[180].x = F_limit(ctls[i].x - surface_offset.x + obj.sections[10].x + 
                                                        math.floor((ctls[i].w - obj.sections[180].w)/2),
                                                        obj.sections[10].x,obj.sections[10].x+obj.sections[10].w-obj.sections[180].w)
                          obj.sections[180].y = F_limit(ctls[i].y+ctls[i].ctl_info.cellh
                                                        - surface_offset.y  + obj.sections[10].y - 3,
                                                        obj.sections[10].y,obj.sections[10].y+obj.sections[10].h-obj.sections[180].h)
                        else
                          show_xysnapshots = false
                        end
                      end
                      update_fsnaps = true
                      update_surface = true
                    end
                    
                  elseif ctls[i].ctlcat == ctlcats.snapshot then
                    --SNAPSHOTS
                    local mmx = mouse.mx - ctlxywh.x
                    local mmy = mouse.my - ctlxywh.y
                    if mmy < ctlxywh.h/2 then
                      sstype_select = ctls[i].param
                      if snapshots and snapshots[tracks[track_select].strip] and snapshots[tracks[track_select].strip][page][sstype_select] 
                                                  and snapshots[tracks[track_select].strip][page][sstype_select].selected then
                        ss_select = snapshots[tracks[track_select].strip][page][sstype_select].selected
                        show_snapshots = true
                        update_snaps = true
                      end                      
                    elseif mmx < 20 then
                      local xsstype_select,xss_select
                      xsstype_select = ctls[i].param
                      if snapshots and snapshots[tracks[track_select].strip] and snapshots[tracks[track_select].strip][page][xsstype_select] 
                                                  and snapshots[tracks[track_select].strip][page][xsstype_select].selected then
                        if snapshots[tracks[track_select].strip][page][xsstype_select].selected then
                          if xsstype_select == 1 then
                            xss_select = snapshots[tracks[track_select].strip][page][xsstype_select].selected-1
                            if xss_select < 1 then
                              xss_select = #snapshots[tracks[track_select].strip][page][xsstype_select]
                            end
                          else
                            xss_select = snapshots[tracks[track_select].strip][page][xsstype_select].selected-1
                            if xss_select < 1 then                            
                              xss_select = #snapshots[tracks[track_select].strip][page][xsstype_select].snapshot
                            end
                          end
                        else
                          if xsstype_select == 1 then
                            if #snapshots[tracks[track_select].strip][page][xsstype_select] > 0 then
                              xss_select = 1
                            end
                          else
                            if #snapshots[tracks[track_select].strip][page][xsstype_select].snapshot > 0 then
                              xss_select = 1                            
                            end
                          end
                        end
                        if xss_select then
                          Snapshot_Set(tracks[track_select].strip, page, xsstype_select, xss_select)
                          if xsstype_select == sstype_select then
                            ss_select = xss_select
                          end
                          update_ctls = true
                          update_snaps = true
                          --update_fsnaps = true                       
                        end
                      end                                            
                    elseif mmx > ctlxywh.w-20 then
                      local xsstype_select,xss_select
                      xsstype_select = ctls[i].param
                      if snapshots and snapshots[tracks[track_select].strip] and snapshots[tracks[track_select].strip][page][xsstype_select] 
                                                  and snapshots[tracks[track_select].strip][page][xsstype_select].selected then
                        if snapshots[tracks[track_select].strip][page][xsstype_select].selected then
                          if xsstype_select == 1 then
                            xss_select = snapshots[tracks[track_select].strip][page][xsstype_select].selected+1
                            if xss_select > #snapshots[tracks[track_select].strip][page][xsstype_select] then
                              xss_select = 1
                            end
                          else
                            xss_select = snapshots[tracks[track_select].strip][page][xsstype_select].selected+1
                            if xss_select > #snapshots[tracks[track_select].strip][page][xsstype_select].snapshot then
                              xss_select = 1
                            end
                          end
                        else
                          if xsstype_select == 1 then
                            if #snapshots[tracks[track_select].strip][page][xsstype_select] > 0 then
                              xss_select = 1
                            end
                          else
                            if #snapshots[tracks[track_select].strip][page][xsstype_select].snapshot > 0 then
                              xss_select = 1                            
                            end
                          end
                        end
                        if xss_select then
                          Snapshot_Set(tracks[track_select].strip, page, xsstype_select, xss_select)                          
                          if xsstype_select == sstype_select then
                            ss_select = xss_select
                          end
                          update_ctls = true
                          update_snaps = true
                          --update_fsnaps = true                       
                        end
                      end
                                            
                    else
                      --open fss
                      togfsnap = true
                      if fsstype_select == ctls[i].param then
                        show_fsnapshots = not show_fsnapshots
                        show_xysnapshots = false
                      else
                        show_fsnapshots = true
                        show_xysnapshots = false
                      end
                      fsstype_select = ctls[i].param
                      fsstype_color = ctls[i].textcol
                      if show_fsnapshots then
                        if snapshots and snapshots[tracks[track_select].strip] and snapshots[tracks[track_select].strip][page][fsstype_select] 
                          and snapshots[tracks[track_select].strip][page][fsstype_select].selected then
                        
                          local w = ctls[i].w
                          obj.sections[180].w = math.max(w - (170-138),138)
                          obj.sections[181].w = obj.sections[180].w-6
                          obj.sections[182].w = obj.sections[180].w
                          
                          fss_select = snapshots[tracks[track_select].strip][page][fsstype_select].selected
                          obj.sections[180].x = F_limit(ctls[i].x - surface_offset.x + obj.sections[10].x + 
                                                        math.floor((ctls[i].w - obj.sections[180].w)/2),
                                                        obj.sections[10].x,obj.sections[10].x+obj.sections[10].w-obj.sections[180].w)
                          obj.sections[180].y = F_limit(ctls[i].y+ctls[i].ctl_info.cellh
                                                        - surface_offset.y  + obj.sections[10].y - 3,
                                                        obj.sections[10].y,obj.sections[10].y+obj.sections[10].h-obj.sections[180].h)
                        else
                          show_fsnapshots = false
                        end
                      end
                      update_fsnaps = true
                      update_surface = true
                    end
                                      
                  elseif ctls[i].ctlcat == ctlcats.eqcontrol then
                    eqcontrol_select = i
                    show_eqcontrol = true
                    --navigate = false
                    if ctls[i].eqbands and ctls[i].eqbands[1] then
                      eqcontrolband_select = 1
                    end
                    --EQC_OpenEQs()
                    update_gfx = true
                  elseif ctls[i].ctlcat == ctlcats.switcher then
                    switcher_select = i
                    SwitcherMenu_LB()
                  elseif ctls[i].ctlcat == ctlcats.rcm_switch then
                    rcm_select = i
                    RCMMenu_RB()
                  end
                elseif ctltype == 7 or ctltype == 8 or ctltype == 9 or ctltype == 10 then
                  --hold button
                  holdbtn = 'holdbtn'
                  trackfxparam_select = i
                  mouse.context = contexts.hold
                  ctls[i].val = 1
                  ctls[i].dirty = true
                  update_ctls = true
                  A_SetParam(strip, page, i, ctls[i])
                end
                noscroll = true
                --break
                
              elseif MOUSE_click_RB(ctlxywh) and mouse.ctrl == false then
                local ccat = ctls[i].ctlcat 
                if ccat == ctlcats.macro then
                 -- mstr = 'Select Macro Parameters|Edit Macro Parameters'
                  macro_edit_mode = true
                  macroedit_poffs = 0
                  trackfxparam_select = i
                  macroctl_select = trackfxparam_select
                  --update_surface = true
                  update_gfx = true 
                else
                  RBMenu(0, ccat, i)
                end
                noscroll = true
              
              elseif MOUSE_click(ctlxywh) and mouse.alt then
              
                if ctls[i].ctlcat == ctlcats.fxparam or 
                   ctls[i].ctlcat == ctlcats.fxoffline then
                  OpenFXGUI(ctls[i])
                  --[[local track
                  if ctls[i].tracknum == nil then
                    track = GetTrack(tracks[track_select].tracknum)
                  else
                    track = GetTrack(ctls[i].tracknum)                      
                  end
                  local fxnum = ctls[i].fxnum
                  if not reaper.TrackFX_GetOpen(track, fxnum) then
                    reaper.TrackFX_Show(track, fxnum, 3)
                  end]]
                end
                                
              elseif MOUSE_click(ctlxywh) and mouse.ctrl then --make double_click?
                if settings_swapctrlclick == true then
                  SetParam_ToDef(i)
                else
                  SetParam_EnterVal(i)
                end
                noscroll = true
                           
              elseif settings_mousewheelknob and gfx.mouse_wheel ~= 0 and MOUSE_over(ctlxywh) then
                local ctltype = ctls[i].ctltype
                if ctltype == 1 then
                  trackfxparam_select = i
                  local v
                  if mouse.shift then
                    local mult = ctls[i].knobsens.wheelfine
                    if mult == 0 then mult = settings_defknobsens.wheelfine end
                    v = gfx.mouse_wheel/120 * mult
                  else
                    local mult = ctls[i].knobsens.wheel
                    if mult == 0 then mult = settings_defknobsens.wheel end
                    v = gfx.mouse_wheel/120 * mult
                  end
                  ctls[i].val = F_limit(ctls[i].val+v,0,1)
                  A_SetParam(tracks[track_select].strip,page,i,ctls[i])
                  --SetParam()
                  ctls[i].dirty = true
                  update_ctls = true
                  gfx.mouse_wheel = 0
                elseif ctltype == 4 then
                  local v = gfx.mouse_wheel/120
                  if ctls[i].cycledata.pos == nil then
                    ctls[i].cycledata.pos = 1
                  else
                    ctls[i].cycledata.pos = ctls[i].cycledata.pos + v
                    if ctls[i].cycledata.pos < 1 then
                      if ctls[i].cycledata.draggable then
                        ctls[i].cycledata.pos = 1
                      else
                        ctls[i].cycledata.pos = ctls[i].cycledata.statecnt
                      end
                    elseif ctls[i].cycledata.pos > 
                            ctls[i].cycledata.statecnt then
                      if ctls[i].cycledata.draggable then
                        ctls[i].cycledata.pos = ctls[i].cycledata.statecnt
                      else
                        ctls[i].cycledata.pos = 1
                      end
                    end
                  end
                  if ctls[i].cycledata.pos <=     
                            ctls[i].cycledata.statecnt then
                    trackfxparam_select = i
                    if ctls[i].cycledata[ctls[i].cycledata.pos] then
                      ctls[i].val = 
                          ctls[i].cycledata[ctls[i].cycledata.pos].val
                      --SetParam()
                      A_SetParam(tracks[track_select].strip,page,i,ctls[i])
                      ctls[i].dirty = true
                      update_ctls = true
                    end
                  end
                  noscroll = true
                  gfx.mouse_wheel = 0                  
                end
              end

            end
          end

        end

        if tracks[track_select] then          
          if noscroll == false and MOUSE_click_RB(obj.sections[10]) then
            local i = GetControlAtXY(tracks[track_select].strip,page,mouse.mx,mouse.my)
            if i then
              local ctl = strips[tracks[track_select].strip][page].controls[i]
              RBMenu(0,ctl.ctlcat,i)
            else
              RBMenu(1,nil,nil)
            end
          end
        end    
              
        
      end
    
      if show_fsnapshots and togfsnap == false then
        show_fsnapshots = false
        update_surface = true
      end
    
    end

    if mouse.context and mouse.context == contexts.sliderctl then
      
      local val = MOUSE_slider(ctlxywh,mouse.slideoff)
      if val ~= nil then
        
        local strip = tracks[track_select].strip
        local ctl = strips[strip][page].controls[trackfxparam_select]
        
        if oms ~= mouse.shift then
          oms = mouse.shift
          ctlpos = ctl.val
          mouse.slideoff = ctlxywh.y+ctlxywh.h/2 - mouse.my
        else
          if mouse.shift then
            local mult = ctl.knobsens.fine
            if mult == 0 then mult = settings_defknobsens.fine end
            val = ctlpos + ((0.5-val)*2)*mult
          else
            local mult = ctl.knobsens.norm
            if mult == 0 then mult = settings_defknobsens.norm end
            val = ctlpos + (0.5-val)*mult
          end
          if val < 0 then val = 0 end
          if val > 1 then val = 1 end
          val = ctlScale(ctl.scalemode, val)
          if val ~= octlval then
            ctl.val = val
            A_SetParam(strip,page,trackfxparam_select,ctl)
            ctl.dirty = true
            octlval = val
            update_ctls = true
          end
        end
      end
    elseif mouse.context and mouse.context == contexts.sliderctl_h then
      local val = MOUSE_slider_horiz(ctlxywh,mouse.slideoff)
      if val ~= nil then

        local strip = tracks[track_select].strip
        local ctl = strips[strip][page].controls[trackfxparam_select]

        if oms ~= mouse.shift then
          oms = mouse.shift
          ctlpos = ctl.val
          mouse.slideoff = ctlxywh.y+ctlxywh.h/2 - mouse.my
        else
          if mouse.shift then
            local mult = ctl.knobsens.fine
            if mult == 0 then mult = settings_defknobsens.fine end
            val = ctlpos - ((0.5-val)*2)*mult
          else
            local mult = ctl.knobsens.norm
            if mult == 0 then mult = settings_defknobsens.norm end
            val = ctlpos - (0.5-val)*mult
          end
          if val < 0 then val = 0 end
          if val > 1 then val = 1 end
          val = ctlScale(ctl.scalemode, val)
          if val ~= octlval then
            ctl.val = val
            A_SetParam(strip,page,trackfxparam_select,ctl)
            ctl.dirty = true
            octlval = val
            update_ctls = true
          end
        end
      end
      
    elseif mouse.context and mouse.context == contexts.macctl then
      
      local tfxp_s = trackfxparam_select
      local val = MOUSE_slider(ctlxywh,mouse.slideoff)
      if val ~= nil then

        local strip = tracks[track_select].strip
        local ctl = strips[strip][page].controls[tfxp_s]

        if oms ~= mouse.shift then
          oms = mouse.shift
          ctlpos = ctl.val
          mouse.slideoff = ctlxywh.y+ctlxywh.h/2 - mouse.my
        else
          if mouse.shift then
            local mult = ctl.knobsens.fine
            if mult == 0 then mult = settings_defknobsens.fine end
            val = ctlpos + ((0.5-val)*2)*mult
          else
            local mult = ctl.knobsens.norm
            if mult == 0 then mult = settings_defknobsens.norm end
            val = ctlpos + (0.5-val)*mult
          end
          if val < 0 then val = 0 end
          if val > 1 then val = 1 end
          val = ctlScale(ctl.scalemode, val)
          if val ~= octlval then
            ctl.diff = val - ctl.val
            ctl.oval = ctl.val
            ctl.val = val
            SetMacro(strip, page, tfxp_s)
            ctl.dirty = true
            octlval = val
            update_ctls = true
            
            trackfxparam_select = tfxp_s
          end
        end
      end
      
    elseif mouse.context and mouse.context == contexts.macctl_h then
      
      local tfxp_s = trackfxparam_select
      local val = MOUSE_slider_horiz(ctlxywh,mouse.slideoff)
      if val ~= nil then

        local strip = tracks[track_select].strip
        local ctl = strips[strip][page].controls[tfxp_s]

        if oms ~= mouse.shift then
          oms = mouse.shift
          ctlpos = ctl.val
          mouse.slideoff = ctlxywh.y+ctlxywh.h/2 - mouse.my
        else
          if mouse.shift then
            local mult = ctl.knobsens.fine
            if mult == 0 then mult = settings_defknobsens.fine end
            val = ctlpos - ((0.5-val)*2)*mult
          else
            local mult = ctl.knobsens.norm
            if mult == 0 then mult = settings_defknobsens.norm end
            val = ctlpos - (0.5-val)*mult
          end
          if val < 0 then val = 0 end
          if val > 1 then val = 1 end
          val = ctlScale(ctl.scalemode, val)
          if val ~= octlval then
            ctl.diff = val - ctl.val
            ctl.oval = ctl.val
            ctl.val = val
            SetMacro(strip, page, tfxp_s)
            ctl.dirty = true
            octlval = val
            update_ctls = true
            
            trackfxparam_select = tfxp_s
          end
        end
      end
      
    elseif mouse.context == nil and macctlactive then 
    
      local strip = tracks[track_select].strip
      local mac = strips[strip][page].controls[macctlactive].macroctl
      strips[strip][page].controls[macctlactive].diff = nil
      if mac then
        for m = 1, #mac do
          --strips[strip][page].controls[mac[m].ctl].mval = nil
        end
      end
      macctlactive = nil
    
    elseif mouse.context and mouse.context == contexts.dragcycle then
      local val = MOUSE_slider(ctlxywh,mouse.slideoff)
      if val ~= nil then
        local strip = tracks[track_select].strip
        local ctl = strips[strip][page].controls[trackfxparam_select]
        if oms ~= mouse.shift then
          oms = mouse.shift
          ctlpos = normalize(0, ctl.cycledata.statecnt,
                             ctl.cycledata.pos)
          mouse.slideoff = ctlxywh.y+ctlxywh.h/2 - mouse.my
        else
          if mouse.shift then
            local mult = ctl.knobsens.fine
            if mult == 0 then mult = settings_defknobsens.fine end
            val = ctlpos + ((0.5-val)*2)*mult
          else
            local mult = ctl.knobsens.norm
            if mult == 0 then mult = settings_defknobsens.norm end
            val = ctlpos + (0.5-val)*mult
          end
          if val < 0 then val = 0 end
          if val > 1 then val = 1 end
          if val ~= octlval then
            local pos = F_limit(math.floor(val*ctl.cycledata.statecnt),1,
                                ctl.cycledata.statecnt)
            ctl.cycledata.pos = pos
            ctl.val = ctl.cycledata[pos].val
            A_SetParam(strip,page,trackfxparam_select,ctl)
            ctl.dirty = true
            octlval = val
            update_ctls = true
          end
        end
      end
      
    elseif mouse.context and mouse.context == contexts.dragcycle_h then
      local val = MOUSE_slider_horiz(ctlxywh,mouse.slideoff)
      if val ~= nil then
        local strip = tracks[track_select].strip
        local ctl = strips[strip][page].controls[trackfxparam_select]
        if oms ~= mouse.shift then
          oms = mouse.shift
          ctlpos = normalize(0, ctl.cycledata.statecnt,
                             ctl.cycledata.pos)
          mouse.slideoff = ctlxywh.x+ctlxywh.w/2 - mouse.mx
        else
          if mouse.shift then
            local mult = ctl.knobsens.fine
            if mult == 0 then mult = settings_defknobsens.fine end
            val = ctlpos - ((0.5-val)*2)*mult
          else
            local mult = ctl.knobsens.norm
            if mult == 0 then mult = settings_defknobsens.norm end
            val = ctlpos - (0.5-val)*mult
          end
          if val < 0 then val = 0 end
          if val > 1 then val = 1 end
          if val ~= octlval then
            local pos = F_limit(math.floor(val*ctl.cycledata.statecnt),1,
                                ctl.cycledata.statecnt)
            ctl.cycledata.pos = pos
            ctl.val = ctl.cycledata[pos].val
            A_SetParam(strip,page,trackfxparam_select,ctl)
            ctl.dirty = true
            octlval = val
            update_ctls = true
          end
        end
      end
    elseif mouse.context and mouse.context == contexts.hold then
    elseif mouse.context == nil and holdbtn ~= nil then
      holdbtn = nil
      local strip = tracks[track_select].strip
      if tracks[track_select] and strips[strip] and strips[strip][page].controls[trackfxparam_select] then
        local ctl = strips[strip][page].controls[trackfxparam_select]
        ctl.val = 0
        ctl.dirty = true
        if ctl.ctltype == 7 or 
           ctl.ctltype == 8 then
          A_SetParam(strip, page, trackfxparam_select, ctl)
        end
      end
      update_ctls = true
    elseif mouse.context and mouse.context == contexts.dragxy then
    
      local strip = tracks[track_select].strip
      local ctl = strips[strip][page].controls[xy_select]
      
      local xy_x = F_limit((mouse.mx - obj.sections[10].x-12 - ctl.x + surface_offset.x) / (ctl.w-24),0,1)
      local xy_y = F_limit((mouse.my - obj.sections[10].y-12 - ctl.y + surface_offset.y) / (ctl.ctl_info.cellh - 58),0,1)
      if xy_x ~= ctl.xydata.x or 
         xy_y ~= ctl.xydata.y then
        ctl.xydata.x = xy_x
        ctl.xydata.y = xy_y
        XY_Set(strip,page,ctl.param,xy_select)
        ctl.dirty = true        
        update_ctls = true
      end
    end
    
    if MOUSE_click(obj.sections[500]) and navigate then
      if show_fsnapshots then
        show_fsnapshots = false
        update_surface = true
      end
      
      local i = math.floor((mouse.my - obj.sections[500].y) / butt_h)-1
      if i == -1 then
        if mouse.mx < obj.sections[500].w/2 then
          tlist_offset = tlist_offset - T_butt_cnt
          if tlist_offset < 0 then
            tlist_offset = 0
          end
        else
          if tlist_offset + T_butt_cnt < #tracks then
            tlist_offset = tlist_offset + T_butt_cnt
          end
        end
        update_gfx = true
      elseif tracks[i-1 + tlist_offset] then
        local tr = i-1 + tlist_offset
        if tr == LBX_GTRACK then
          SetGlobalPage()
        else
          ChangeTrack2(i-1 + tlist_offset)
        end
      end
    end
  
    if mouse.context and mouse.context == contexts.movesnapwindow then
      
      obj.sections[160].x = F_limit(mouse.mx - movesnapwin.offx, obj.sections[10].x, gfx1.main_w-obj.sections[160].w)
      obj.sections[160].y = F_limit(mouse.my - movesnapwin.offy, obj.sections[10].y, gfx1.main_h-obj.sections[160].h)
      obj.sections[160].x = math.max(obj.sections[160].x,obj.sections[10].x)      
      obj.sections[160].y = math.max(obj.sections[160].y,obj.sections[10].y)
      
      snapshot_win_pos = {x = obj.sections[160].x, y = obj.sections[160].y}
      update_msnaps = true
    
    elseif mouse.context and mouse.context == contexts.addsnapctl then
      dragparam = {x = mouse.mx-ksel_size.w, y = mouse.my-ksel_size.h, type = 'snapctl'}
      update_gfx = true

    elseif mouse.context and mouse.context == contexts.addxyctl then
      dragparam = {x = mouse.mx-ksel_size.w, y = mouse.my-ksel_size.h, type = 'xyctl'}
      update_gfx = true

    elseif mouse.context and mouse.context == contexts.snapshot_rand then
      dragparam = {x = mouse.mx-ksel_size.w, y = mouse.my-ksel_size.h, type = 'snaprand'}
      update_surface = true
    
    elseif mouse.context and mouse.context == contexts.resizesnapwindow then

      local ly = obj.sections[10].h - obj.sections[160].y + butt_h
      obj.sections[160].h = F_limit(resizesnapwin.origh + (mouse.my - resizesnapwin.offy) - obj.sections[160].y, 180, ly)
      obj.sections[163].h = obj.sections[160].h - 160
      obj.sections[165].y = obj.sections[160].h - obj.sections[165].h
      snaph = obj.sections[160].h
      update_msnaps = true
      resize_snaps = true
      --update_gfx = true

    elseif mouse.context and mouse.context == contexts.resizefsnapwindow then

      local ly = obj.sections[10].h - obj.sections[180].y + butt_h
      obj.sections[180].h = F_limit(resizesnapwin.origh + (mouse.my - resizesnapwin.offy) - obj.sections[180].y, 180, ly)
      obj.sections[181].h = obj.sections[180].h - 12
      obj.sections[182].y = obj.sections[180].h - 6
      fsnaph = obj.sections[180].h
      update_mfsnaps = true
      resize_fsnaps = true
      --update_gfx = true
    
    elseif mouse.context and mouse.context == contexts.snap_move then
      local my = mouse.my-obj.sections[160].y
      local i = math.floor((my-obj.sections[163].y)/butt_h)
      local snapcnt
      if sstype_select == 1 then
        snapcnt = #snapshots[tracks[track_select].strip][page][sstype_select]
      else
        snapcnt = #snapshots[tracks[track_select].strip][page][sstype_select].snapshot      
      end
      if reaper.time_precise() > ssshiftto then
        if i<1 then
          ssoffset = math.max(ssoffset-1,0)
        elseif i>SS_butt_cnt then
          ssoffset = math.min(ssoffset+1,snapcnt-1)      
        end
        ssshiftto = reaper.time_precise() + 0.15
      end
      snap_move.epos = F_limit(ssoffset+i,1,snapcnt+1)
      update_snaps = true
      
    elseif mouse.context == nil and snap_move then

      if snap_move.epos ~= snap_move.spos and snap_move.epos ~= snap_move.spos+1 then
        --move ss
        Snapshot_Move(snap_move.spos, snap_move.epos)
      end

      snap_move = nil
      update_snaps = true
      
    elseif dragparam ~= nil then
    
      if mouse.mx > obj.sections[10].x and not MOUSE_over(obj.sections[160]) then
        Strip_AddParam()
        g_savedirty = true
      end
      
      dragparam = nil
      update_gfx = true
    end
  
    return noscroll
  
  end

  function A_Run_Submode0(noscroll, rt, char)
  
    if show_actionchooser then
      
      if gfx.mouse_wheel ~= 0 then
        local v = (gfx.mouse_wheel/120)*3
        if MOUSE_over(obj.sections[171]) then
            al_offset = F_limit(al_offset - v, 0, #action_tblF-1)
            update_actcho = true
            gfx.mouse_wheel = 0
        end
      end
      
      if mouse.context == nil and MOUSE_click(obj.sections[171]) then
        local i = math.floor((mouse.my-obj.sections[171].y)/butt_h) +1
        if mouse.lastLBclicktime and (rt-mouse.lastLBclicktime) < 0.15 then
          --double-click
          if al_select and action_tblF[al_select] then
            strips[tracks[track_select].strip][page].controls[trackfxparam_select].param_info.paramname = action_tblF[al_select].command_desc
            strips[tracks[track_select].strip][page].controls[trackfxparam_select].param_info.paramidx = action_tblF[al_select].command_id
            strips[tracks[track_select].strip][page].controls[trackfxparam_select].param_info.paramnum = action_tblF[al_select].dcommand_id
            
            CloseActChooser()
            update_gfx = true
          end
          
        elseif action_tblF[i + al_offset] then
          al_select = i + al_offset
        end
        update_actcho = true
        
      elseif mouse.context == nil and MOUSE_click(obj.sections[172]) then
      
        OpenEB(14,'Please enter action command filter:')
      
      elseif mouse.context == nil and MOUSE_click(obj.sections[173]) then
      
        action_tblF = table.copy(action_tbl)
        al_offset = 0
        al_select = 0
        update_actcho = true
      
      elseif mouse.context == nil and MOUSE_click(obj.sections[174]) then
      
        if al_select and action_tblF[al_select] then
          strips[tracks[track_select].strip][page].controls[trackfxparam_select].param_info.paramname = action_tblF[al_select].command_desc
          strips[tracks[track_select].strip][page].controls[trackfxparam_select].param_info.paramidx = action_tblF[al_select].command_id
          strips[tracks[track_select].strip][page].controls[trackfxparam_select].param_info.paramnum = action_tblF[al_select].dcommand_id

          CloseActChooser()
          update_gfx = true
          
        end
                
      elseif mouse.context == nil and MOUSE_click(obj.sections[175]) then

        CloseActChooser()
        
      end

    elseif show_gaugeedit then

      if gfx.mouse_wheel ~= 0 then
        local v = (gfx.mouse_wheel/120)
        if MOUSE_over(obj.sections[809]) then
            gauge_select.x_offs = F_limit(math.floor(gauge_select.x_offs+v),-30,30)
            update_surface = true
            gfx.mouse_wheel = 0
        elseif MOUSE_over(obj.sections[810]) then
            gauge_select.y_offs = F_limit(math.floor(gauge_select.y_offs-v),-30,30)
            update_surface = true
            gfx.mouse_wheel = 0
        elseif MOUSE_over(obj.sections[802]) then
            gauge_select.radius = F_limit(gauge_select.radius+v*0.5,10,150)
            update_surface = true
            gfx.mouse_wheel = 0
        elseif MOUSE_over(obj.sections[803]) then
            gauge_select.arclen = F_limit(gauge_select.arclen+v*0.01,0,1)
            update_surface = true
            gfx.mouse_wheel = 0
        elseif MOUSE_over(obj.sections[804]) then
            gauge_select.rotation = F_limit(gauge_select.rotation+v*0.01,0,1)
            update_surface = true
            gfx.mouse_wheel = 0
        elseif MOUSE_over(obj.sections[805]) then
            --gauge_select.ticks = F_limit(gauge_select.ticks + v,0,50)
            --Gauge_CalcTickVals()
            --update_surface = true
            --gfx.mouse_wheel = 0
        elseif MOUSE_over(obj.sections[807]) then
            gauge_select.tick_size = F_limit(gauge_select.tick_size+v,2,12)
            update_surface = true
            gfx.mouse_wheel = 0
        elseif MOUSE_over(obj.sections[808]) then
            gauge_select.tick_offs = F_limit(gauge_select.tick_offs+v,0,12)
            update_surface = true
            gfx.mouse_wheel = 0
        elseif MOUSE_over(obj.sections[814]) then
            gauge_select.fontsz = F_limit(gauge_select.fontsz+v,-8,0)
            update_surface = true
            gfx.mouse_wheel = 0
        elseif MOUSE_over(obj.sections[825]) then
            gauge_select.val_freq = F_limit(gauge_select.val_freq+v,1,24)
            update_surface = true
            gfx.mouse_wheel = 0
        elseif MOUSE_over(obj.sections[830]) then
          if gauge_select.vals and gauge_ticksel and gauge_select.vals[gauge_ticksel] then
            if gauge_select.vals[gauge_ticksel].nudge == nil then
              gauge_select.vals[gauge_ticksel].nudge = 0
            end
            gauge_select.vals[gauge_ticksel].nudge = F_limit(gauge_select.vals[gauge_ticksel].nudge+v,-10,10)
          end
          update_surface = true
          gfx.mouse_wheel = 0
        end
      end
    
      if mouse.context == nil and MOUSE_click(obj.sections[802]) then mouse.context = contexts.gauge_arcrad
      elseif mouse.context == nil and MOUSE_click(obj.sections[803]) then mouse.context = contexts.gauge_arclen
      elseif mouse.context == nil and MOUSE_click(obj.sections[804]) then mouse.context = contexts.gauge_arcrot
      elseif mouse.context == nil and MOUSE_click(obj.sections[806]) then mouse.context = contexts.gauge_val
        local strip = tracks[track_select].strip
        local ctl = strips[strip][page].controls[ctl_select[1].ctl]
        local gtab = gauge_select

        local ctly = obj.sections[806].y+obj.sections[806].h/2
        mouse.slideoff = ctly - mouse.my
        ctlpos = ctlScaleInv(nz(ctl.scalemode,8),
                                gtab.val)
        oms = mouse.shift
        gaugeglob = {ctly = ctly, sec = obj.sections[806], offset = mouse.slideoff}
        
      elseif mouse.context == nil and MOUSE_click(obj.sections[807]) then mouse.context = contexts.gauge_tksz
      elseif mouse.context == nil and MOUSE_click(obj.sections[808]) then mouse.context = contexts.gauge_tkoffs
      elseif mouse.context == nil and MOUSE_click(obj.sections[809]) then mouse.context = contexts.gauge_xoffs
      elseif mouse.context == nil and MOUSE_click(obj.sections[810]) then mouse.context = contexts.gauge_yoffs
      elseif mouse.context == nil and MOUSE_click(obj.sections[814]) then mouse.context = contexts.gauge_fs
      elseif mouse.context == nil and MOUSE_click(obj.sections[825]) then mouse.context = contexts.gauge_valfreq
      elseif mouse.context == nil and MOUSE_click(obj.sections[830]) then mouse.context = contexts.gauge_nudge
      elseif mouse.context == nil and MOUSE_click(obj.sections[816]) then mouse.context = contexts.auto_delayslider

      elseif mouse.context == nil and MOUSE_click(obj.sections[831]) then
        if fontlist then
          local fnt = ChooseFontMenu(mouse.mx,mouse.my)
          if fnt then
            local f = CheckFont(fnt)
            if f then
              gauge_select.font = f
            end
            update_gfx = true
          end
        else          
          OpenEB(61,'Please enter font name:')
        end
        
      elseif mouse.context == nil and MOUSE_click_RB(obj.sections[830]) then
        if gauge_select.vals and gauge_ticksel and gauge_select.vals[gauge_ticksel] then
          gauge_select.vals[gauge_ticksel].nudge = 0
        end
        update_surface = true
      
      elseif mouse.context == nil and MOUSE_click(obj.sections[811]) then
        gauge_select.show_arc = not gauge_select.show_arc
        update_surface = true
      elseif mouse.context == nil and MOUSE_click(obj.sections[812]) then
        gauge_select.show_tick = not gauge_select.show_tick
        update_surface = true
      elseif mouse.context == nil and MOUSE_click(obj.sections[813]) then
        gauge_select.show_val = not gauge_select.show_val
        update_surface = true
      
      elseif mouse.context == nil and MOUSE_click(obj.sections[805]) then       
        gauge_select.ticks = F_limit(gauge_select.ticks + 1,0,50)
        Gauge_CalcTickVals()
        update_surface = true
      elseif mouse.context == nil and MOUSE_click_RB(obj.sections[805]) then 
        if gauge_select.vals and #gauge_select.vals > 0 then
          gauge_select.vals[#gauge_select.vals] = nil
        end
        gauge_select.ticks = #gauge_select.vals --F_limit(gauge_select.ticks - 1,0,50)
        Gauge_CalcTickVals()
        update_surface = true        
      elseif mouse.context == nil and MOUSE_click(obj.sections[817]) then
                
        gauge_select.val_dp = F_limit(gauge_select.val_dp + 1, -1, 3)
        Gauge_RecalcTickVals()
        for i = 1, #ctl_select do
        end            
        update_surface = true
      
      elseif mouse.context == nil and MOUSE_click_RB(obj.sections[817]) then

        gauge_select.val_dp = F_limit(gauge_select.val_dp - 1, -1, 3)
        Gauge_RecalcTickVals()
        for i = 1, #ctl_select do
        end            
        update_surface = true

      elseif mouse.context == nil and MOUSE_click(obj.sections[827]) then
      
        gauge_select.numonly = not gauge_select.numonly
        Gauge_RecalcTickVals()
        for i = 1, #ctl_select do
        end            
        update_surface = true

      elseif mouse.context == nil and MOUSE_click(obj.sections[832]) then
      
        gauge_select.abbrev = not gauge_select.abbrev
        Gauge_RecalcTickVals()
        for i = 1, #ctl_select do
        end            
        update_surface = true
              
      elseif mouse.context == nil and MOUSE_click_RB(obj.sections[806]) then       
      
        local gtab = gauge_select
        local gcnt = #gtab.vals+1
        gtab.vals[gcnt] = {val = gtab.val, dval = gtab.dval, dover = nil}
        local nonly
        if gtab.numonly then
          nonly = ''
        end
        if gtab.val_dp > -1 then
          gtab.vals[gcnt].dover = roundX(gtab.dval, gtab.val_dp, nonly)
        end
        Gauge_SortVals()
        for i = 1, #gtab.vals do
          if gtab.vals[i].val == gtab.val then
            gauge_ticksel = i
          end
        end
        gauge_select.ticks = #gtab.vals
        update_surface = true
        
      elseif mouse.context == nil and MOUSE_click(obj.sections[818]) then
      
        local strip = tracks[track_select].strip
        local ctl = strips[strip][page].controls[ctl_select[1].ctl]
        if ctl.ctltype == 4 then
        
          Gauge_CopyCycleData()
          Gauge_SortVals()
          update_surface = true
        
        end
      
      elseif mouse.context == nil and MOUSE_click(obj.sections[820]) then
        local gtab = gauge_select
        local retval, c = reaper.GR_SelectColor(_,ConvertColorString(gtab.col_arc))
        if retval ~= 0 then
          gtab.col_arc = ConvertColor(c)
          update_surface = true
        end
      elseif mouse.context == nil and MOUSE_click(obj.sections[821]) then
        local gtab = gauge_select
        local retval, c = reaper.GR_SelectColor(_,ConvertColorString(gtab.col_tick))
        if retval ~= 0 then
          gtab.col_tick = ConvertColor(c)
          update_surface = true
        end
      elseif mouse.context == nil and MOUSE_click(obj.sections[822]) then
        local gtab = gauge_select
        local retval, c = reaper.GR_SelectColor(_,ConvertColorString(gtab.col_val))
        if retval ~= 0 then
          gtab.col_val = ConvertColor(c)
          update_surface = true
        end
        
      elseif mouse.context == nil and MOUSE_click(obj.sections[823]) then
        --REMOVE
        local strip = tracks[track_select].strip
        local ctl = strips[strip][page].controls[ctl_select[1].ctl]
        ctl.gauge = nil
        update_bg = true
        update_gfx = true
        closegaugeedit = true

      elseif mouse.context == nil and MOUSE_click(obj.sections[824]) then
        --RESET
        gauge_select = GaugeSelect_INIT()
        Gauge_CalcTickVals()
        update_surface = true
        
      elseif mouse.context == nil and MOUSE_click(obj.sections[819]) then
        --SAVE
        local strip = tracks[track_select].strip
        local ctl = strips[strip][page].controls[ctl_select[1].ctl]
        ctl.gauge = Gauge_CopySelect(gauge_select)
        update_bg = true
        update_gfx = true
        closegaugeedit = true
        --show_gaugeedit = false
                
      elseif mouse.context == nil and MOUSE_click(obj.sections[801]) then
        local gtab = gauge_select
        gtab.type = gtab.type+1
        if gtab.type > #gaugetype_table then
          gtab.type = 1
        end
        update_surface = true

      elseif mouse.context == nil and MOUSE_click_RB(obj.sections[801]) then
        local gtab = gauge_select
        gtab.type = gtab.type-1
        if gtab.type < 1 then
          gtab.type = #gaugetype_table
        end
        update_surface = true

      elseif mouse.context == nil and MOUSE_click(obj.sections[815]) then
        
        OpenEB(60,'Enter numeric display value to add tick','')
        
      elseif mouse.context == nil and MOUSE_click(obj.sections[826]) then

        local gtab = gauge_select
        if gtab.vals and #gtab.vals > 0 and gauge_ticksel and gauge_ticksel <= #gtab.vals then
          local cnt = #gtab.vals
          gtab.vals[gauge_ticksel] = nil
          gtab.vals = Table_RemoveNils(gtab.vals, cnt)
          if gauge_ticksel > #gtab.vals then
            gauge_ticksel = #gtab.vals
          end
          --Gauge_SortVals()
          gtab.ticks = #gtab.vals
          update_surface = true
        end

      elseif mouse.context == nil and MOUSE_click(obj.sections[828]) then
        if gauge_select.vals and #gauge_select.vals > 0 then
          if gauge_ticksel == nil then
            gauge_ticksel = 1
          else
            gauge_ticksel = gauge_ticksel-1
            if gauge_ticksel < 1 then
              gauge_ticksel = #gauge_select.vals
            end
          end
        else
          gauge_ticksel = 1
        end
        update_surface = true

      elseif mouse.context == nil and MOUSE_click(obj.sections[829]) then
        if gauge_select.vals and #gauge_select.vals > 0 then
          if gauge_ticksel == nil then
            gauge_ticksel = 1
          else
            gauge_ticksel = gauge_ticksel+1
            if gauge_ticksel > #gauge_select.vals then
              gauge_ticksel = 1
            end
          end
        else
          gauge_ticksel = 1
        end
        update_surface = true

      end
    
      if mouse.context and mouse.context == contexts.gauge_val then
      
        local val = MOUSE_slider(gaugeglob.sec,gaugeglob.offset)
        if val ~= nil then
          
          local strip = tracks[track_select].strip
          local ctl = strips[strip][page].controls[ctl_select[1].ctl]
          
          if oms ~= mouse.shift then
            oms = mouse.shift
            local gtab = gauge_select
            ctlpos = gtab.val
            mouse.slideoff = gaugeglob.ctly - mouse.my
          else
            if mouse.shift then
              local mult = ctl.knobsens.fine
              if mult == 0 then mult = settings_defknobsens.fine end
              val = ctlpos + ((0.5-val)*2)*mult
            else
              local mult = ctl.knobsens.norm
              if mult == 0 then mult = settings_defknobsens.norm end
              val = ctlpos + (0.5-val)*mult
            end
            if val < 0 then val = 0 end
            if val > 1 then val = 1 end
            val = ctlScale(ctl.scalemode, val)
            if val ~= octlval then
              gauge_select.val = F_limit(val,0,1)
              gauge_select.dval = nz(GetParamDisp_Val(ctl_select[1].ctl,gauge_select.val,true),'')
              octlval = val
              --update_ctls = true
              update_surface = true
            end
          end
        end
      
        --[[local val = F_limit(MOUSE_slider(obj.sections[806]),0,1)
        if val ~= nil then
          gauge_select.val = F_limit(1-val,0,1)
          gauge_select.dval = GetParamDisp_Val(ctl_select[1].ctl,gauge_select.val)
          for i = 1, #ctl_select do
          end
        end]]
      elseif mouse.context and mouse.context == contexts.auto_delayslider then
      
        local val = F_limit(MOUSE_sliderHBar(obj.sections[816]),0,1)
        if val ~= nil then
          auto_delay = math.floor(val * 10)
          update_surface = true
        end
        
      elseif mouse.context and mouse.context == contexts.gauge_arcrad then
      
        local val = F_limit(MOUSE_sliderHBar(obj.sections[802]),0,1)
        if val ~= nil then
          gauge_select.radius = math.floor(val*110) + 10
          for i = 1, #ctl_select do
          end
        end
        update_surface = true
        
      elseif mouse.context and mouse.context == contexts.gauge_arclen then

        local val = F_limit(MOUSE_sliderHBar(obj.sections[803]),0,1)
        if val ~= nil then
          gauge_select.arclen = val
          for i = 1, #ctl_select do
          end
        end
        update_surface = true

      elseif mouse.context and mouse.context == contexts.gauge_arcrot then

        local val = F_limit(MOUSE_sliderHBar(obj.sections[804]),0,1)
        if val ~= nil then
          gauge_select.rotation = val
          for i = 1, #ctl_select do
          end
        end
        update_surface = true

      elseif mouse.context and mouse.context == contexts.gauge_tksz then

        local val = F_limit(MOUSE_sliderHBar(obj.sections[807]),0,1)
        if val ~= nil then
          gauge_select.tick_size = math.floor(val*10)+2
          for i = 1, #ctl_select do
          end
        end
        update_surface = true

      elseif mouse.context and mouse.context == contexts.gauge_tkoffs then

        local val = F_limit(MOUSE_sliderHBar(obj.sections[808]),0,1)
        if val ~= nil then
          gauge_select.tick_offs = math.floor(val*12)
          for i = 1, #ctl_select do
          end
        end
        update_surface = true

      elseif mouse.context and mouse.context == contexts.gauge_xoffs then

        local val = F_limit(MOUSE_sliderHBar(obj.sections[809]),0,1)
        if val ~= nil then
          gauge_select.x_offs = math.floor(val*60) -30
          for i = 1, #ctl_select do
          end
        end
        update_surface = true

      elseif mouse.context and mouse.context == contexts.gauge_yoffs then

        local val = F_limit(MOUSE_sliderHBar(obj.sections[810]),0,1)
        if val ~= nil then
          gauge_select.y_offs = math.floor(val*60) -30
          for i = 1, #ctl_select do
          end
        end
        update_surface = true

      elseif mouse.context and mouse.context == contexts.gauge_fs then

        local val = F_limit(MOUSE_sliderHBar(obj.sections[814]),0,1)
        if val ~= nil then
          gauge_select.fontsz = math.floor(val*8) -8
          for i = 1, #ctl_select do
          end
        end
        update_surface = true

      elseif mouse.context and mouse.context == contexts.gauge_valfreq then

        local val = F_limit(MOUSE_sliderHBar(obj.sections[825]),0,1)
        if val ~= nil then
          gauge_select.val_freq = math.floor(val*23)+1
          for i = 1, #ctl_select do
          end
        end
        update_surface = true

      elseif mouse.context and mouse.context == contexts.gauge_nudge then

        local val = F_limit(MOUSE_sliderHBar(obj.sections[830]),0,1)
        if val ~= nil and gauge_select.vals and gauge_ticksel and gauge_select.vals[gauge_ticksel] then
          gauge_select.vals[gauge_ticksel].nudge = math.floor(val*20)-10
        end
        update_surface = true
      end
      
    else
      if mouse.context == nil and fxmode == 1 and trctltype_select == 1 and rt > time_sendupdate then
        time_sendupdate = rt + 1
        PopulateTrackSendsInfo()
        update_gfx = true
      end
      
      if gfx.mouse_wheel ~= 0 then
        local v = gfx.mouse_wheel/120
        if MOUSE_over(obj.sections[520]) then
          if fxmode == 0 then
            flist_offset = F_limit(flist_offset - v, 0, #trackfx)
            update_sidebar = true
            gfx.mouse_wheel = 0
          elseif fxmode == 1 then
            trctltypelist_offset = F_limit(trctltypelist_offset - v, 0, #trctltype_table-1)
            update_sidebar = true
            gfx.mouse_wheel = 0            
          end
        end
        if MOUSE_over(obj.sections[522]) then
          if fxmode == 0 then
            plist_offset = F_limit(plist_offset - v, 0, #trackfxparams)
            update_sidebar = true
            gfx.mouse_wheel = 0
          elseif fxmode == 1 then
            if trctltype_select == 0 then
              trctlslist_offset = F_limit(trctlslist_offset - v, 0, #trctls_table-1)
              update_sidebar = true
              gfx.mouse_wheel = 0
            elseif trctltype_select == 1 then
              trctlslist_offset = F_limit(trctlslist_offset - v, 0, #trsends_table*3+2)
              update_sidebar = true
              gfx.mouse_wheel = 0              
            elseif trctltype_select == 2 then
              trctlslist_offset = F_limit(trctlslist_offset - v, 0, #special_table-1)
              update_sidebar = true
              gfx.mouse_wheel = 0              
            elseif trctltype_select == 3 then
              trctlslist_offset = F_limit(trctlslist_offset - v, 0, #otherctl_table-1)
              update_sidebar = true
              gfx.mouse_wheel = 0              
            end
          end          
        end

        if show_ctlbrowser and MOUSE_over(obj.sections[210]) then
        
          local v = gfx.mouse_wheel/120
          if v > 0 then
            cbi_offset = cbi_offset - math.min(ctl_browser_size.slots_x*ctl_browser_size.slots_y,maximg_browse+1)
            if cbi_offset < 0 then cbi_offset = 0 end
            PopulateCtlBrowser_Imgs()
            update_surface = true
            noscroll = true
          
          else
            if cbi_offset + math.min(ctl_browser_size.slots_x*ctl_browser_size.slots_y,maximg_browse+1) < 
                  (math.floor(cbi_cnt/(ctl_browser_size.slots_x*ctl_browser_size.slots_y))+1)*(ctl_browser_size.slots_x*ctl_browser_size.slots_y) then
              cbi_offset = cbi_offset + math.min(ctl_browser_size.slots_x*ctl_browser_size.slots_y,maximg_browse+1)
            end
            PopulateCtlBrowser_Imgs()
            update_surface = true
            noscroll = true
          end
          

        elseif MOUSE_over(obj.sections[45]) then

          local mx, my = mouse.mx, mouse.my
          mouse.mx = mouse.mx - obj.sections[45].x
          mouse.my = mouse.my - obj.sections[45].y

          if ctl_page == 0 then

            local xywh = {x = 0, y = 0, w = obj.sections[45].w, h = 150}
            if MOUSE_over(xywh) then
              knob_select = (knob_select - v) % #ctl_files
              update_ctlopts = true
              gfx.mouse_wheel = 0
            elseif MOUSE_over(obj.sections[50]) then
              scale_select = F_limit(scale_select + (v*0.05),0.5,1)
              for i = 1, #ctl_select do
                if strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ctlcat ~= ctlcats.xy then
                  strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].scale = scale_select
                  strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].xsc = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].x
                                                                                             + math.floor(strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].w/2
                                                                                             - (strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].w*scale_select)/2)
                  strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ysc = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].y
                                                                                             + math.floor(strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ctl_info.cellh/2
                                                                                             - (strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ctl_info.cellh*scale_select)/2)
                  strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].wsc = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].w*scale_select
                  strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].hsc = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ctl_info.cellh*scale_select
                  --strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].dirty = true
                end
              end            
              --update_ctls = true
              --update_ctlopts = true
              --update_surface = true
              update_gfx = true
              gfx.mouse_wheel = 0
            elseif MOUSE_over(obj.sections[56]) then
              if toffY then
                textoff_select = textoff_select + v*2
                for i = 1, #ctl_select do
                  strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].textoff = textoff_select
                end            
              else
                textoff_selectx = textoff_selectx + v*2
                for i = 1, #ctl_select do
                  strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].textoffx = textoff_selectx
                end                            
              end
              update_gfx = true
              gfx.mouse_wheel = 0
            elseif MOUSE_over(obj.sections[65]) then
              if toffY then
                textoffval_select = textoffval_select + v*2
                for i = 1, #ctl_select do
                  strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].textoffval = textoffval_select
                end            
              else
                textoffval_selectx = textoffval_selectx + v*2
                for i = 1, #ctl_select do
                  strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].textoffvalx = textoffval_selectx
                end                            
              end
              update_gfx = true
              gfx.mouse_wheel = 0
            elseif MOUSE_over(obj.sections[58]) then
              textsize_select = F_limit(textsize_select + v,-2,35)
              if textoptlink_select == true then
                textsizev_select = textsize_select
              end
              for i = 1, #ctl_select do
                strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].textsize = textsize_select
                if textoptlink_select == true then
                  strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].textsizev = textsizev_select
                end
                strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].dirty = true
              end            
              update_ctls = true
              update_ctlopts = true            
              --update_gfx = true
              gfx.mouse_wheel = 0
            elseif MOUSE_over(obj.sections[851]) then
              textsizev_select = F_limit(textsizev_select + v,-2,35)
              if textoptlink_select == true then
                textsize_select = textsizev_select
              end
              for i = 1, #ctl_select do
                strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].textsizev = textsizev_select
                if textoptlink_select == true then
                  strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].textsize = textsizev_select
                end
                strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].dirty = true
              end
              update_ctls = true
              update_ctlopts = true            
              --update_gfx = true
              gfx.mouse_wheel = 0
            elseif MOUSE_over(obj.sections[57]) then
              defval_select = F_limit(defval_select + v/200,0,1)
              for i = 1, #ctl_select do
                strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].val = defval_select
                trackfxparam_select = ctl_select[i].ctl
                SetParam()
              end            
              update_gfx = true
              gfx.mouse_wheel = 0
            elseif MOUSE_over(obj.sections[55]) then
              ctltype_select = F_limit(ctltype_select + v,1,#ctltype_table)
              for i = 1, #ctl_select do
                strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ctltype = ctltype_select
                strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].dirty = true
              end
              show_cycleoptions = false
              update_ctls = true
              update_ctlopts = true
              gfx.mouse_wheel = 0
            end
            
          elseif ctl_page == 1 then              

            if MOUSE_over(obj.sections[128]) then
              val = minov_select + v*0.00125
              
              local p = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].param
              local min, max = GetParamMinMax_ctl(ctl_select[1].ctl, false) --trctls_table[p].min, trctls_table[p].max
              
              if val < min then val = min end
              if val > max then val = max end
              if val ~= octlval then
                val = math.min(val,nz(maxov_select-0.05,1))
                SetParam4(val)
                local dval = GetParamDisp_Ctl(ctl_select[1].ctl)
                minov_select = val
                ov_disp = dval
                SetParam()                
                octlval = val
                update_ctls = true
              end
              
              for i = 1, #ctl_select do
                strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].minov = minov_select
              end            
              update_gfx = true
              gfx.mouse_wheel = 0
            
            elseif MOUSE_over(obj.sections[129]) then
              val = maxov_select + v*0.00125
              
              local p = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].param
              local min, max = GetParamMinMax_ctl(ctl_select[1].ctl, false) --trctls_table[p].min, trctls_table[p].max
              
              if val < min then val = min end
              if val > max then val = max end
              if val ~= octlval then
                val = math.max(val,nz(minov_select+0.05,0))
                SetParam4(val)
                local dval = GetParamDisp_Ctl(ctl_select[1].ctl)
                maxov_select = val
                ov_disp = dval
                SetParam()                
                octlval = val
                update_ctls = true
              end
              
              for i = 1, #ctl_select do
                strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].maxov = maxov_select
              end            
              update_gfx = true
              gfx.mouse_wheel = 0
            elseif MOUSE_over(obj.sections[135]) then
              knobsens_select.norm = F_limit(knobsens_select.norm+(v*0.5),0,10)
              for i = 1, #ctl_select do
                strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].knobsens.norm = knobsens_select.norm
              end            
              update_surface = true
              gfx.mouse_wheel = 0
            elseif MOUSE_over(obj.sections[136]) then
              knobsens_select.fine = F_limit(knobsens_select.fine+(v*0.01),0,0.2)
              for i = 1, #ctl_select do
                strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].knobsens.fine = knobsens_select.fine
              end            
              update_surface = true
              gfx.mouse_wheel = 0
            elseif MOUSE_over(obj.sections[137]) then
              knobsens_select.wheel = F_limit(knobsens_select.wheel+(v*0.01),0,0.2)
              for i = 1, #ctl_select do
                strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].knobsens.wheel = knobsens_select.wheel
              end            
              update_surface = true
              gfx.mouse_wheel = 0
            elseif MOUSE_over(obj.sections[138]) then
              knobsens_select.wheelfine = F_limit(knobsens_select.wheelfine+(v*0.001),0,0.02)
              for i = 1, #ctl_select do
                strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].knobsens.wheelfine = knobsens_select.wheelfine
              end            
              update_surface = true
              gfx.mouse_wheel = 0
            end

          end
          
          mouse.mx, mouse.my = mx, my
        end
      end
      
      if show_paramlearn then
        last_touch_fx = GetLastTouchedFX(last_touch_fx)        
      end
      
      if show_paramlearn and (MOUSE_click(obj.sections[115]) or MOUSE_click_RB(obj.sections[115])) then
      
        --LEARN
        
        if MOUSE_click(obj.sections[115]) then
          ctl_select = nil
          update_gfx = true
          
          if ctl_files[knob_select].imageidx ~= nil then
            local w,_ = gfx.getimgdim(ctl_files[knob_select].imageidx)
            local h = ctl_files[knob_select].cellh
            if w == 0 or h == 0 then
              ksel_size = {w = 50, h = 50}
            else
             ksel_size = {w = w/2, h = h/2}
           end
          else 
            ksel_size = {w = 50, h = 50}
          end
          mouse.context = contexts.dragparamlrn
        elseif MOUSE_click_RB(obj.sections[115]) then
          show_paramlearn = false
          ctl_select = nil
          update_gfx = true
        end          
      
      end
      
      if (ctl_select ~= nil or gfx3_select ~= nil) and char ~= 0 then
      
        ArrowKey_Shift(char,ctl_select,gfx3_select)
                                   
      elseif ctl_select ~= nil and show_ctlbrowser and (MOUSE_click(obj.sections[200]) or MOUSE_click_RB(obj.sections[200])) then
      
        if mouse.context == nil and MOUSE_click(obj.sections[211]) then
          cbi_offset = cbi_offset - math.min(ctl_browser_size.slots_x*ctl_browser_size.slots_y,maximg_browse+1)
          if cbi_offset < 0 then cbi_offset = 0 end
          PopulateCtlBrowser_Imgs()
          update_surface = true
      
        elseif mouse.context == nil and MOUSE_click(obj.sections[212]) then
          if cbi_offset + math.min(ctl_browser_size.slots_x*ctl_browser_size.slots_y,maximg_browse+1) < 
                (math.floor(cbi_cnt/(ctl_browser_size.slots_x*ctl_browser_size.slots_y))+1)*(ctl_browser_size.slots_x*ctl_browser_size.slots_y) then
            cbi_offset = cbi_offset + math.min(ctl_browser_size.slots_x*ctl_browser_size.slots_y,maximg_browse+1)
          end
          PopulateCtlBrowser_Imgs()
          update_surface = true
        
        elseif mouse.context == nil and MOUSE_click(obj.sections[210]) then

          if mouse.lastLBclicktime and (rt-mouse.lastLBclicktime) < 0.2 then
            local ix = math.floor((mouse.mx - obj.sections[210].x) / ctl_browser_size.slotsz)
            local iy = math.floor((mouse.my - obj.sections[210].y) / ctl_browser_size.slotsz)
            local i = ix + iy*ctl_browser_size.slots_x
            
            if cbi[i] then
              knob_select = cbi[i].idx
              closectlbrowser = true
              --show_ctlbrowser = false
              update_surface = true
              update_ctlopts = true
            end
          else
            local ix = math.floor((mouse.mx - obj.sections[210].x) / ctl_browser_size.slotsz)
            local iy = math.floor((mouse.my - obj.sections[210].y) / ctl_browser_size.slotsz)
            local i = ix + iy*ctl_browser_size.slots_x

            if cbi[i] then
              cbi_select = cbi[i].idx
              SetCbiSelect()
              update_surface = true
            end
          end
        elseif mouse.context == nil and MOUSE_click_RB(obj.sections[210]) then
          local ix = math.floor((mouse.mx - obj.sections[210].x) / ctl_browser_size.slotsz)
          local iy = math.floor((mouse.my - obj.sections[210].y) / ctl_browser_size.slotsz)
          local i = ix + iy*ctl_browser_size.slots_x

          if cbi[i] then
            cbi_select = cbi[i].idx
            SetCbiSelect()
            if ctl_files[cbi_select] then
              update_surface = true
              GUI_draw(obj,gui)
              gfx.update()

              local mstr = 'Knob|Slider|Button|Meter|Misc'
              gfx.x, gfx.y = mouse.mx, mouse.my
              local res = OpenMenu(mstr)
              if res == 1 then
                ctl_files[cbi_select].ctltype = 0  
              elseif res == 2 then
                ctl_files[cbi_select].ctltype = 1
              elseif res == 3 then
                ctl_files[cbi_select].ctltype = 2
              elseif res == 4 then
                ctl_files[cbi_select].ctltype = 3
              elseif res == 5 then
                ctl_files[cbi_select].ctltype = 4
              end
              if res > 0 then
                
                local save_path=controls_path
                local knbfn = ctl_files[cbi_select].fn
                
                local fn=save_path..string.sub(knbfn,0,string.len(knbfn)-3).. 'knb'

                local knbdata = {fn = ctl_files[cbi_select].fn,
                                 frames = ctl_files[cbi_select].frames,
                                 cellh = ctl_files[cbi_select].cellh,
                                 ctltype = ctl_files[cbi_select].ctltype}
                                 
                local DELETE=true
                local file
                
                if reaper.file_exists(fn) then
                
                end
                
                if DELETE then
                  file=io.open(fn,"w")
                  local pickled_table=pickle(knbdata)
                  file:write(pickled_table)
                  file:close()
                  
                end
                SetCbiSelect()
                update_surface = true
              
              end
            end            
          end            
        
        elseif MOUSE_click(obj.sections[201]) then
          cbi_offset = 0
          cbi_filter = -1
          PopulateCtlBrowser_Imgs()
          update_surface = true
        elseif MOUSE_click(obj.sections[202]) then
          cbi_offset = 0
          cbi_filter = 0
          PopulateCtlBrowser_Imgs()
          update_surface = true
        elseif MOUSE_click(obj.sections[203]) then
          cbi_offset = 0
          cbi_filter = 1
          PopulateCtlBrowser_Imgs()
          update_surface = true
        elseif MOUSE_click(obj.sections[204]) then
          cbi_offset = 0
          cbi_filter = 2
          PopulateCtlBrowser_Imgs()
          update_surface = true
        elseif MOUSE_click(obj.sections[205]) then
          cbi_offset = 0
          cbi_filter = 3
          PopulateCtlBrowser_Imgs()
          update_surface = true
        elseif MOUSE_click(obj.sections[206]) then
          cbi_offset = 0
          cbi_filter = 4
          PopulateCtlBrowser_Imgs()
          update_surface = true
                      
        end
                  
        noscroll = true
        
      elseif ctl_select ~= nil and (MOUSE_click(obj.sections[45]) or MOUSE_click_RB(obj.sections[45])) then
        
        --CONTROL OPTIONS
        
        if mouse.LB and mouse.my > obj.sections[45].y and mouse.my < obj.sections[45].y+butt_h then
          
          show_cycleoptions = false
          ctl_page = ctl_page + 1
          if ctl_page > 2 then
            ctl_page = 0
          end
          update_gfx = true
        end
        
        local mx, my = mouse.mx, mouse.my
        mouse.mx = mouse.mx - obj.sections[45].x
        mouse.my = mouse.my - obj.sections[45].y
        
        if ctl_page == 0 then
          
          if mouse.context == nil and MOUSE_click(obj.sections[90]) then
          
            knob_select = knob_select - 1
            if knob_select < 0 then
              knob_select = #ctl_files
            end
            update_ctlopts = true
          
          elseif mouse.context == nil and MOUSE_click(obj.sections[91]) then
          
            knob_select = knob_select + 1
            if knob_select > #ctl_files then
              knob_select = 0
            end
            update_ctlopts = true

          elseif mouse.LB and mouse.my > butt_h and mouse.my < 150 then
          
            PopulateCtlBrowser_Imgs()
            cbi_select = knob_select
            
            SetCbiSelect()
            
            show_ctlbrowser = true
            update_surface = true              
            
          elseif mouse.context == nil and MOUSE_click(obj.sections[66]) then
          
            maxdp_select = F_limit(maxdp_select + 1, -1, 3)
            for i = 1, #ctl_select do
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].maxdp = maxdp_select
            end            
            update_gfx = true
          
          elseif mouse.context == nil and MOUSE_click_RB(obj.sections[66]) then

            maxdp_select = F_limit(maxdp_select - 1, -1, 3)
            for i = 1, #ctl_select do
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].maxdp = maxdp_select
            end            
            update_gfx = true
          
          elseif mouse.context == nil and MOUSE_click(obj.sections[99]) then
          
            show_gaugeedit = true
            gauge_select.val = 0
            gauge_select.dval = nz(GetParamDisp_Val(ctl_select[1].ctl,gauge_select.val,true),'')
            local strip = tracks[track_select].strip
            if strips[strip][page].controls[ctl_select[1].ctl].gauge == nil then
              Gauge_CalcTickVals()
            end
            update_gfx = true

          elseif mouse.context == nil and MOUSE_click(obj.sections[852]) then
            textoptlink_select = not textoptlink_select
            update_ctlopts = true
            
          elseif mouse.context == nil and MOUSE_click(obj.sections[52]) then
            show_paramname = not show_paramname
            for i = 1, #ctl_select do
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].show_paramname = show_paramname
            end            
            update_gfx = true
          elseif mouse.context == nil and MOUSE_click(obj.sections[53]) then
            show_paramval = not show_paramval
            for i = 1, #ctl_select do
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].show_paramval = show_paramval
            end            
            update_gfx = true
          elseif mouse.context == nil and MOUSE_click(obj.sections[54]) then
            local retval, c = reaper.GR_SelectColor(_,ConvertColorString(textcol_select))
            if retval ~= 0 then
              textcol_select = ConvertColor(c)
              if textoptlink_select == true then
                textcolv_select = textcol_select
              end
              for i = 1, #ctl_select do
                strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].textcol = textcol_select
                if textoptlink_select == true then
                  strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].textcolv = textcol_select
                end
              end
              update_gfx = true
            end
          elseif mouse.context == nil and MOUSE_click(obj.sections[850]) then
            local retval, c = reaper.GR_SelectColor(_,ConvertColorString(textcolv_select))
            if retval ~= 0 then
              textcolv_select = ConvertColor(c)
              if textoptlink_select == true then
                textcol_select = textcolv_select
              end              
              for i = 1, #ctl_select do
                strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].textcolv = textcolv_select
                if textoptlink_select == true then
                  strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].textcol = textcolv_select
                end
              end
              update_gfx = true
            end
          elseif mouse.context == nil and MOUSE_click(obj.sections[55]) then
            ctltype_select = ctltype_select + 1
            if ctltype_select > #ctltype_table then ctltype_select = 1 end
            for i = 1, #ctl_select do
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ctltype = ctltype_select
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].dirty = true
            end
            update_ctls = true
            update_ctlopts = true
            
          elseif MOUSE_click_RB(obj.sections[55]) then
            ctltype_select = ctltype_select - 1
            if ctltype_select < 1 then ctltype_select = #ctltype_table end
            for i = 1, #ctl_select do
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ctltype = ctltype_select
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].dirty = true
            end
            update_ctls = true
            update_ctlopts = true
          end

          if mouse.context == nil and ctltype_select == 4 and MOUSE_click(obj.sections[67]) then
            show_cycleoptions = not show_cycleoptions
            if show_cycleoptions then
              cycle_select.val = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].val
            end
            update_gfx = true
          else
            show_cycleoptions = false          
          end
          
          if mouse.context == nil and MOUSE_click(obj.sections[59]) then
            if ctl_select and #ctl_select > 0 then
              --EditCtlName()
              if strips and strips[tracks[track_select].strip] then
                local ctl = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl]
                local cn = nz(ctl.ctlname_override, ctl.param_info.paramname)
                OpenEB(2,'Please enter a name for the selected controls:',cn)
                --update_gfx = true
              end
            end
          elseif mouse.context == nil and MOUSE_click(obj.sections[960]) then
            if strips and strips[tracks[track_select].strip] then
              if ctl_select and #ctl_select > 0 and strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl]
                 and strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].ctlcat == ctlcats.midictl then
                local ctl = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl]
                
                midioutedit_ctlselect = true
                midioutedit_select = ctl_select[1].ctl
                midiout_select = ctl.midiout
                if midiout_select == nil then
                  midiout_select = {output = nil,
                                    msgtype = 4,
                                    mchan = 1,
                                    msg3 = 1,
                                    msg4 = 0,
                                    osc = nil,
                                    vmin = 0,
                                    vmax = 127,
                                    focus = 1,
                                    updategfx = false}
                end
                show_midiout = true
                update_gfx = true
                mouse.context = contexts.dummy
              
              end            
            end
          
          elseif mouse.context == nil and MOUSE_click(obj.sections[68]) then
            toffY = not toffY
            update_gfx = true
          elseif mouse.context == nil and MOUSE_click_RB(obj.sections[57]) then
            local dv = GetParamValue_Ctl(ctl_select[1].ctl)
            if dv then
              defval_select = dv
              for i = 1, #ctl_select do
                strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].defval = GetParamValue_Ctl(ctl_select[i].ctl)
              end
              update_ctlopts = true
            end
          elseif mouse.context == nil and MOUSE_click(obj.sections[51]) then
            --apply
            if ctl_files[knob_select].imageidx == nil then  
              image_count = F_limit(image_count + 1,0,image_max)
              gfx.loadimg(image_count, controls_path..ctl_files[knob_select].fn)
              ctl_files[knob_select].imageidx = image_count
            end
            local w, _ = gfx.getimgdim(ctl_files[knob_select].imageidx)
            for i = 1, #ctl_select do
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].knob_select = knob_select
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ctl_info.fn = ctl_files[knob_select].fn
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ctl_info.imageidx = ctl_files[knob_select].imageidx
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ctl_info.frames = ctl_files[knob_select].frames
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].w = w
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ctl_info.cellh = ctl_files[knob_select].cellh
              
              local scale = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].scale
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].xsc = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].x
                                                                                         + math.floor(strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].w/2
                                                                                         - (strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].w*scale)/2)
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ysc = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].y
                                                                                         + math.floor(strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ctl_info.cellh/2
                                                                                         - (strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ctl_info.cellh*scale)/2)
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].wsc = w*scale
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].hsc = ctl_files[knob_select].cellh*scale
            end
            SetCtlBitmapRedraw()
            update_gfx = true
          elseif mouse.context == nil and MOUSE_click(obj.sections[48]) then
            if fontlist then
              local fnt = ChooseFontMenu(mx,my)
              if fnt then
                local f = CheckFont(fnt)
                if f then
                  ctlfont_select = f
                  for i = 1, #ctl_select do
                    strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].font = ctlfont_select
                  end            
                end
                update_gfx = true
              end
            else          
              OpenEB(62,'Please enter font name:')
            end
            
          end
          
          if mouse.context == nil and MOUSE_click(obj.sections[50]) then mouse.context = contexts.scaleslider 
          elseif mouse.context == nil and MOUSE_click(obj.sections[56]) then mouse.context = contexts.offsetslider
          elseif mouse.context == nil and MOUSE_click(obj.sections[65]) then mouse.context = contexts.valoffsetslider 
          elseif mouse.context == nil and MOUSE_click(obj.sections[57]) then omx = -1 ctlpos = defval_select mouse.context = contexts.defvalslider
          elseif mouse.context == nil and MOUSE_click(obj.sections[58]) then mouse.context = contexts.textsizeslider 
          elseif mouse.context == nil and MOUSE_click(obj.sections[851]) then mouse.context = contexts.textsizevslider end
  
        elseif ctl_page == 1 then
          
          if MOUSE_click(obj.sections[126]) then
            OpenEB(4,'Please enter normalized min value:')
          
          elseif MOUSE_click(obj.sections[127]) then
            OpenEB(16,'Please enter normalized max value:')
          end
          
          if MOUSE_click(obj.sections[125]) then
            --EditDValOffset()
            OpenEB(3,'Please enter a display offset value:',strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].dvaloffset)
          end

          if MOUSE_click(obj.sections[134]) then
            horiz_select = not horiz_select
            for i = 1, #ctl_select do
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].horiz = horiz_select
            end
            update_gfx = true              
          elseif MOUSE_click(obj.sections[139]) then
            if noss_select then
              noss_select = nil
            else
              noss_select = true
            end 
            for i = 1, #ctl_select do
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].noss = noss_select
            end
            update_gfx = true
          end            

          if MOUSE_click(obj.sections[131]) then
            knob_scalemode_select = knob_scalemode_select + 1
            if knob_scalemode_select > #scalemode_preset_table then knob_scalemode_select = 2 end
            if knob_scalemode_select == 2 then
              scalemode_select = 8
              framemode_select = 1
            elseif knob_scalemode_select == 3 then
              scalemode_select = 12
              framemode_select = 2              
            end
            
            for i = 1, #ctl_select do
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].scalemode = scalemode_select
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].framemode = framemode_select                
            end
            update_gfx = true                        
          end

          if MOUSE_click(obj.sections[132]) then
            scalemode_select = scalemode_select + 1
            if scalemode_select > #scalemode_table then scalemode_select = 1 end
            for i = 1, #ctl_select do
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].scalemode = scalemode_select
            end
            SetKnobScaleMode()
            update_gfx = true                                      
          elseif MOUSE_click_RB(obj.sections[132]) then
            scalemode_select = scalemode_select - 1
            if scalemode_select < 1 then scalemode_select = #scalemode_table end
            for i = 1, #ctl_select do
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].scalemode = scalemode_select
            end
            SetKnobScaleMode()
            update_gfx = true                                      
          end
        
          if MOUSE_click(obj.sections[133]) then
            framemode_select = framemode_select + 1
            if framemode_select > #framemode_table then framemode_select = 1 end
            for i = 1, #ctl_select do
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].framemode = framemode_select
            end
            SetKnobScaleMode()
            update_gfx = true                                      
          elseif MOUSE_click_RB(obj.sections[133]) then
            framemode_select = framemode_select - 1
            if framemode_select < 1 then framemode_select = #framemode_table end
            for i = 1, #ctl_select do
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].framemode = framemode_select
            end
            SetKnobScaleMode()
            update_gfx = true                                      
          end
        
          if mouse.context == nil and MOUSE_click(obj.sections[128]) then
            mouse.context = contexts.minov
            trackfxparam_select = ctl_select[1].ctl
            ctlpos = minov_select
            mouse.slideoff = obj.sections[128].y+obj.sections[128].h/2 - mouse.my
            oms = mouse.shift
            for i = 1, #ctl_select do
              local min, max = GetParamMinMax_ctl(ctl_select[i].ctl)
              ctl_select[i].denorm_defval = DenormalizeValue(min,
                                                             max,
                                                             strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].defval)
            end
            minov_act = 'minov'
            
          elseif mouse.context == nil and MOUSE_click(obj.sections[129]) then 
            mouse.context = contexts.maxov 
            trackfxparam_select = ctl_select[1].ctl
            ctlpos = maxov_select
            mouse.slideoff = obj.sections[129].y+obj.sections[129].h/2 - mouse.my
            oms = mouse.shift
            for i = 1, #ctl_select do
              local min, max = GetParamMinMax_ctl(ctl_select[i].ctl)
              ctl_select[i].denorm_defval = DenormalizeValue(min,
                                                             max,
                                                             strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].defval)
            end
            maxov_act = 'maxov'

          elseif mouse.context == nil and MOUSE_click(obj.sections[135]) then 
            mouse.context = contexts.knobsens_norm
          elseif mouse.context == nil and MOUSE_click(obj.sections[136]) then 
            mouse.context = contexts.knobsens_fine
          elseif mouse.context == nil and MOUSE_click(obj.sections[137]) then 
            mouse.context = contexts.knobsens_wheel
          elseif mouse.context == nil and MOUSE_click(obj.sections[138]) then 
            mouse.context = contexts.knobsens_wheelfine
          end
        
        elseif ctl_page == 2 then
        
          if mouse.context == nil and MOUSE_click(obj.sections[860]) then
            bypass_bgdraw_c_select = not bypass_bgdraw_c_select
            for i = 1, #ctl_select do
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].bypassbg_c = bypass_bgdraw_c_select
            end            
            update_gfx = true
          elseif mouse.context == nil and MOUSE_click(obj.sections[861]) then
            bypass_bgdraw_n_select = not bypass_bgdraw_n_select
            for i = 1, #ctl_select do
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].bypassbg_n = bypass_bgdraw_n_select
            end            
            update_gfx = true
          elseif mouse.context == nil and MOUSE_click(obj.sections[862]) then
            bypass_bgdraw_v_select = not bypass_bgdraw_v_select
            for i = 1, #ctl_select do
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].bypassbg_v = bypass_bgdraw_v_select
            end            
            update_gfx = true
          elseif mouse.context == nil and MOUSE_click(obj.sections[863]) then
            clickthrough_select = not clickthrough_select 
            for i = 1, #ctl_select do
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].clickthrough = clickthrough_select
            end            
            update_gfx = true
          end
          
        end
      
        mouse.mx, mouse.my = mx, my
      
      elseif ctl_select ~= nil and show_cycleoptions and gfx.mouse_wheel ~= 0 and MOUSE_over(obj.sections[103]) then
      
        local v = gfx.mouse_wheel/120
        cyclist_offset = F_limit(cyclist_offset - v, 0, max_cycle-8)
        update_gfx = true
        gfx.mouse_wheel = 0
      
      elseif ctl_select ~= nil and show_cycleoptions and (MOUSE_click(obj.sections[100]) or MOUSE_click_RB(obj.sections[100])) then
      
        -- CYCLE OPTS
        
        if MOUSE_click(obj.sections[102]) and mouse.ctrl == false then
          cyclist_offset = 0
          cycle_select.statecnt = F_limit(cycle_select.statecnt+1,0,max_cycle)
          Cycle_InitData()
          update_gfx = true
        elseif MOUSE_click_RB(obj.sections[102]) then
          cyclist_offset = 0
          cycle_select.statecnt = F_limit(cycle_select.statecnt-1,0,max_cycle)
          Cycle_InitData()
          update_gfx = true
        elseif MOUSE_click(obj.sections[102]) and (mouse.ctrl == true or mouse.shift == true) then
        
          OpenEB(17,'Enter number of cycle states:')
        
        end
        
        if mouse.context == nil and MOUSE_click(obj.sections[101]) then 
          mouse.context = contexts.cycleknob
          cycle_editmode = true 
          trackfxparam_select = ctl_select[1].ctl
          ctlpos = cycle_select.val
          mouse.slideoff = obj.sections[101].y+obj.sections[101].h/2 - mouse.my
          oms = mouse.shift
        end
        
        if MOUSE_click(obj.sections[103]) then
          local i = math.floor((mouse.my - obj.sections[103].y) / butt_h)+1
          cycle_select.selected = F_limit(i+cyclist_offset,1,cycle_select.statecnt)
          --strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].cycledata.pos = cycle_select.selected
          update_gfx = true
        elseif MOUSE_click_RB(obj.sections[103]) then
          if cycle_select and cycle_select.selected then
            local mstr = 'Rename||Delete'
            gfx.x, gfx.y = mouse.mx, mouse.my
            local res = OpenMenu(mstr)
            if res == 1 then
              --txt = EditValue(10)
              OpenEB(10,'Please enter value:')
            elseif res == 2 then
              cycle_select = Cycle_DeleteStep(cycle_select.selected)
              update_gfx = true
            end
          end            
        end          

        if MOUSE_click(obj.sections[104]) then
          Cycle_Auto()
          cyclist_offset = 0
          update_gfx = true            
        end

        if MOUSE_click(obj.sections[110]) then
          mouse.context = contexts.auto_delayslider
        end
      
        if MOUSE_click(obj.sections[105]) then
          local i = math.floor((mouse.mx-obj.sections[105].x)/(obj.sections[105].w/2))
          if #cycle_select < 8 then
            cyclist_offset = 0
          else
            if i >= 1 then
              cyclist_offset = F_limit(cyclist_offset+1,0,math.max(#cycle_select-8,0))
            else
              cyclist_offset = F_limit(cyclist_offset-1,0,math.max(#cycle_select-8,0))            
            end
          end
          update_gfx = true            
        end
        
        if MOUSE_click(obj.sections[106]) then
          trackfxparam_select = ctl_select[1].ctl
          strips[tracks[track_select].strip][page].controls[trackfxparam_select].cycledata = Cycle_CopySelectOut()
          strips[tracks[track_select].strip][page].controls[trackfxparam_select].cycledata.pos = cycle_select.selected
          strips[tracks[track_select].strip][page].controls[trackfxparam_select].dirty = true
          show_cycleoptions = false
          cycle_editmode = false
          update_gfx = true
        end

        if MOUSE_click(obj.sections[107]) then
          cycle_select.mapptof = not cycle_select.mapptof
          mapptof_select = cycle_select.mapptof
          update_gfx = true
        elseif MOUSE_click(obj.sections[108]) then
          cycle_select.draggable = not cycle_select.draggable
          draggable_select = cycle_select.draggable
          update_gfx = true
        elseif MOUSE_click(obj.sections[109]) then
          cycle_select.spread = not cycle_select.spread
          spread_select = cycle_select.spread
          update_gfx = true
        end          
      
      elseif mouse.mx > obj.sections[10].x then
      
        --SURFACE
      
        if mouse.context == nil and MOUSE_click(obj.sections[10]) then
          if strips and tracks[track_select] and strips[tracks[track_select].strip] then
            --for i = 1, #strips[tracks[track_select].strip][page].controls do
            
              --[[local xywh
              local ctl = strips[tracks[track_select].strip][page].controls[i]
              xywh = {x = ctl.x - surface_offset.x +obj.sections[10].x, 
                      y = ctl.y - surface_offset.y +obj.sections[10].y, 
                      w = ctl.w, 
                      h = ctl.ctl_info.cellh}
              if MOUSE_click(xywh) then]]
              
            local c = GetControlAtXY(tracks[track_select].strip, page, mouse.mx, mouse.my)
            if c then
              local i = c
              local ctl = strips[tracks[track_select].strip][page].controls[i]
              
                if Switcher_CtlsHidden(ctl.switcher, ctl.grpid) == false then
                  show_cycleoptions = false
                  
                  local found = false
                  local j, ctlsel
                  if ctl_select ~= nil then
                    for j = 1, #ctl_select do
                      if tonumber(ctl_select[j].ctl) == tonumber(i) then
                        found = true
                        ctlsel = j
                        break
                      end
                    end
                  end

                  if mouse.alt then
                    local stripid = strips[tracks[track_select].strip][page].controls[i].id
                    if stripid ~= nil then
                      ctl_select = nil
                      gfx3_select = nil
                      SelectStripElements(stripid)
                    else
                      if ctl_select == nil then
                        ctl_select = {}
                        ctl_select[1] = {ctl = i}
                      else
                        local cs = #ctl_select+1
                        ctl_select[cs] = {}
                        ctl_select[cs].ctl = i                      
                        ctl_select[cs].relx = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].x - strips[tracks[track_select].strip][page].controls[i].x
                        ctl_select[cs].rely = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].y - strips[tracks[track_select].strip][page].controls[i].y
                      end
                    end

                  elseif mouse.shift or (mouse.lastLBclicktime and (rt-mouse.lastLBclicktime) < 0.2) then
                    local switcherid = strips[tracks[track_select].strip][page].controls[i].switcherid
                    if switcherid then
                      SelectSwitchElements(switcherid,i)
                    else
                      local grpid = strips[tracks[track_select].strip][page].controls[i].grpid
                      if grpid ~= nil then
                        ctl_select = nil
                        gfx3_select = nil
                        SelectGroupElements(grpid)
                      else
                        if ctl_select == nil then
                          ctl_select = {}
                          ctl_select[1] = {ctl = i}
                        end
                      end
                    end
                                                      
                  elseif mouse.ctrl and ctl_select ~= nil and found == true then
                    if ctlsel then
                      local cnt = #ctl_select
                      ctl_select[ctlsel] = nil
                      ctl_select = Table_RemoveNils(ctl_select, cnt)
                      if #ctl_select == 0 then ctl_select = nil end
                    end
                  
                  elseif mouse.ctrl and ctl_select ~= nil and found == false then
                    local cs = #ctl_select+1
                    ctl_select[cs] = {}
                    ctl_select[cs].ctl = i
                    ctl_select[cs].relx = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].x - strips[tracks[track_select].strip][page].controls[i].x
                    ctl_select[cs].rely = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].y - strips[tracks[track_select].strip][page].controls[i].y
                  elseif ctl_select == nil or found == false then
                    ctl_select = {} 
                    gfx3_select = nil
                    ctl_select[1] = {ctl = i}
                  end

                  SetCtlSelectVals()
                  SetPosLockCtl()

                  if ctl_select then                  
                    dragoff = {x = mouse.mx - strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].x - 0.5*strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].w - surface_offset.x,
                               y = mouse.my - strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].y - 0.5*strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].ctl_info.cellh - surface_offset.y}
                    mouse.context = contexts.dummy
                    if ctl_select ~= nil and not mouse.ctrl then --and not mouse.alt then
                      dragctl = 'dragctl'
                      mouse.context = contexts.dragctl
                      GenCtlDragPreview(gui)
                      for i = 1, #ctl_select do
                        strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].hide = true
                      end
                      if gfx3_select and #gfx3_select > 0 then
                        for i = 1, #gfx3_select do
                          strips[tracks[track_select].strip][page].graphics[gfx3_select[i].ctl].hide = true  
                        end                    
                      end
                      --SetCtlBitmapRedraw()
                    end
                    update_bg = true
                  end
                  
                  update_gfx = true
                  --break                  
                end
              --end
            end
          end
        elseif mouse.context == nil and MOUSE_click_RB(obj.sections[10]) then
          mouse.context = contexts.draglasso
          lasso = {l = mouse.mx, t = mouse.my, r = mouse.mx+5, b = mouse.my+5}
        end
      end

      if mouse.context and mouse.context == contexts.auto_delayslider then
        local val = F_limit(MOUSE_sliderHBar(obj.sections[110]),0,1)
        if val ~= nil then
          auto_delay = math.floor(val * 10)
          update_gfx = true
        end
      end
      
      if mouse.context and mouse.context == contexts.knobsens_norm then
        local objsec = obj.sections[135]
        local xywh = {x = obj.sections[45].x + objsec.x,
                      y = obj.sections[45].y + objsec.y,
                      w = objsec.w,
                      h = objsec.h}
        local val = F_limit(MOUSE_sliderHBar(xywh),0,1)
        if val ~= nil then
          local v = math.floor(val * 20)*0.5
          --DBG('v='..v)
          knobsens_select.norm = v
          for i = 1, #ctl_select do
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].knobsens.norm = v
          end
          update_surface = true
          update_ctlopts = true
        end
      elseif mouse.context and mouse.context == contexts.knobsens_fine then
        local objsec = obj.sections[136]
        local xywh = {x = obj.sections[45].x + objsec.x,
                      y = obj.sections[45].y + objsec.y,
                      w = objsec.w,
                      h = objsec.h}
        local val = F_limit(MOUSE_sliderHBar(xywh),0,1)
        if val ~= nil then
          local v = math.floor(val * 20)*0.01
          knobsens_select.fine = v
          for i = 1, #ctl_select do
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].knobsens.fine = v
          end
          update_surface = true
          update_ctlopts = true
        end
      elseif mouse.context and mouse.context == contexts.knobsens_wheel then
        local objsec = obj.sections[137]
        local xywh = {x = obj.sections[45].x + objsec.x,
                      y = obj.sections[45].y + objsec.y,
                      w = objsec.w,
                      h = objsec.h}
        local val = F_limit(MOUSE_sliderHBar(xywh),0,1)
        if val ~= nil then
          local v = math.floor(val * 20)*0.01
          knobsens_select.wheel = v
          for i = 1, #ctl_select do
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].knobsens.wheel = v
          end
          update_surface = true
          update_ctlopts = true
        end
      elseif mouse.context and mouse.context == contexts.knobsens_wheelfine then
        local objsec = obj.sections[138]
        local xywh = {x = obj.sections[45].x + objsec.x,
                      y = obj.sections[45].y + objsec.y,
                      w = objsec.w,
                      h = objsec.h}
        local val = F_limit(MOUSE_sliderHBar(xywh),0,1)
        if val ~= nil then
          local v = math.floor(val * 20)*0.001
          knobsens_select.wheelfine = v
          for i = 1, #ctl_select do
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].knobsens.wheelfine = v
          end
          update_surface = true
          update_ctlopts = true
        end
      
      elseif mouse.context and mouse.context == contexts.minov then
        local objsec = obj.sections[128]
        local xywh = {x = obj.sections[45].x + objsec.x,
                      y = obj.sections[45].y + objsec.y,
                      w = objsec.w,
                      h = objsec.h}
        local val = MOUSE_slider(xywh,mouse.slideoff)
        if val ~= nil then
          if oms ~= mouse.shift then
            oms = mouse.shift
            ctlpos = minov_select
            mouse.slideoff = obj.sections[128].y+obj.sections[128].h/2 - (mouse.my-obj.sections[45].y)
          else
            if mouse.shift then
              val = ctlpos + ((0.5-val)*2)*0.0125
            else
              val = ctlpos + (0.5-val)*1
            end
            local p = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].param
            local min, max = GetParamMinMax_ctl(ctl_select[1].ctl, false) --trctls_table[p].min, trctls_table[p].max
            
            if val < min then val = min end
            if val > max then val = max end
            if val ~= octlval then
              val = math.min(val,nz(maxov_select-0.05,1))
              SetParam4(val)
              local dval = GetParamDisp_Ctl(ctl_select[1].ctl)
              minov_select = val
              ov_disp = dval
              SetParam()                
              octlval = val
              update_ctls = true
              update_ctlopts = true
            end
          end
        elseif minov_act ~= nil then
          minov_act = nil
          
          for i = 1, #ctl_select do
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].minov = minov_select
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].dirty = true
            trackfxparam_select = ctl_select[i].ctl

            local min, max = GetParamMinMax_ctl(ctl_select[i].ctl)
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].defval = normalize(min, max, ctl_select[i].denorm_defval)
            SetParam3(tracks[track_select].strip,page,ctl_select[i].ctl,strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl],
                      strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].defval)
          end
        end
        
      elseif mouse.context and mouse.context == contexts.maxov then
        local objsec = obj.sections[129]
        local xywh = {x = obj.sections[45].x + objsec.x,
                      y = obj.sections[45].y + objsec.y,
                      w = objsec.w,
                      h = objsec.h}
        local val = MOUSE_slider(xywh,mouse.slideoff)
        if val ~= nil then
          if oms ~= mouse.shift then
            oms = mouse.shift
            ctlpos = maxov_select
            mouse.slideoff = obj.sections[129].y+obj.sections[129].h/2 - (mouse.my-obj.sections[45].y)
          else
            if mouse.shift then
              val = ctlpos + ((0.5-val)*2)*0.1
            else
              val = ctlpos + (0.5-val)*2
            end
            local p = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].param
            local min, max = GetParamMinMax_ctl(ctl_select[1].ctl, false) --trctls_table[p].min, trctls_table[p].max
            
            if val < min then val = min end
            if val > max then val = max end
            if val ~= octlval then
              val = math.max(val,nz(minov_select+0.05,0))
              SetParam4(val)
              local dval = GetParamDisp_Ctl(ctl_select[1].ctl)
              maxov_select = val
              ov_disp = dval
              SetParam()
              octlval = val
              update_ctls = true
              update_ctlopts = true
            end
          end
        elseif maxov_act ~= nil then
          maxov_act = nil
          
          for i = 1, #ctl_select do
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].maxov = maxov_select
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].dirty = true
            trackfxparam_select = ctl_select[i].ctl

            local min, max = GetParamMinMax_ctl(ctl_select[i].ctl)
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].defval = normalize(min, max, ctl_select[i].denorm_defval)
            SetParam3(tracks[track_select].strip,page,ctl_select[i].ctl,strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl],
                      strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].defval)
          end
        end
      
      elseif mouse.context and mouse.context == contexts.cycleknob then
        local val = MOUSE_slider(obj.sections[101],mouse.slideoff)
        if val ~= nil then
          if oms ~= mouse.shift then
            oms = mouse.shift
            ctlpos = cycle_select.val
            mouse.slideoff = obj.sections[101].y+obj.sections[101].h/2 - mouse.my
          else
            if mouse.shift then
              val = ctlpos + ((0.5-val)*2)*0.1
            else
              val = ctlpos + (0.5-val)*2
            end
            local min,max = 0,1
            local c = ctl_select[1].ctl
            local strip = tracks[track_select].strip
            local ctl = strips[strip][page].controls[c]
            if ctl.ctlcat == ctlcats.fxparam then
              min, max = GetParamMinMax_ctl(c)
            end
            if val < min then val = min end
            if val > max then val = max end
            if val ~= octlval then
              SetParam3(strip,page,c,ctl,val)
              local t = strips[strip].track.tracknum
              if ctl.tracknum ~= nil then
                t = ctl.tracknum
              end
              local cc = ctl.ctlcat
              local f = ctl.fxnum
              local p = ctl.param
              local dvoff = ctl.dvaloffset
              local v2 = GetParamValue(cc,t,f,p,c)
              cycle_select.val = val
              
              if cycle_select.selected and cycle_select[cycle_select.selected] then
              --if cycle_select.selected then
                local dispval = GetParamDisp(cc, t, f, p, dvoff,c)
                cycle_select[cycle_select.selected].val = v2                  
                cycle_select[cycle_select.selected].dispval = dispval
                cycle_select[cycle_select.selected].dv = dispval
              end
              octlval = val
              --SetParam()
              ctl.dirty = true
              update_ctls = true
            end
          end
        end
      
      end
      
      if mouse.context and mouse.context == contexts.scaleslider then
        local objsec = obj.sections[50]
        local xywh = {x = obj.sections[45].x + objsec.x,
                      y = obj.sections[45].y + objsec.y,
                      w = objsec.w,
                      h = objsec.h}
        local val = F_limit(MOUSE_sliderHBar(xywh),0,1)
        if val ~= nil then
          scale_select = val*0.5 + 0.5
          for i = 1, #ctl_select do
            if strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ctlcat ~= ctlcats.xy then
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].scale = scale_select
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].xsc = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].x
                                                                                         + math.floor(strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].w/2
                                                                                         - (strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].w*scale_select)/2)
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ysc = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].y
                                                                                         + math.floor(strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ctl_info.cellh/2
                                                                                         - (strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ctl_info.cellh*scale_select)/2)
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].wsc = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].w*scale_select
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].hsc = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ctl_info.cellh*scale_select
              --strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].dirty = true
            end
          end            
          --update_ctls = true
          --update_ctlopts = true
          --update_surface = true
          update_gfx = true
        end
      end

      if mouse.context and mouse.context == contexts.offsetslider then
        local objsec = obj.sections[56]
        local xywh = {x = obj.sections[45].x + objsec.x,
                      y = obj.sections[45].y + objsec.y,
                      w = objsec.w,
                      h = objsec.h}
        local val = F_limit(MOUSE_sliderHBar(xywh),0,1)
        if val ~= nil then
          if toffY then
            textoff_select = val*300 - 150
            for i = 1, #ctl_select do
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].textoff = textoff_select
              --strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].dirty = true
            end            
          else
            textoff_selectx = val*300 - 150
            for i = 1, #ctl_select do
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].textoffx = textoff_selectx
              --strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].dirty = true
            end                          
          end
          update_gfx = true
        end
      end

      if mouse.context and mouse.context == contexts.valoffsetslider then
        local objsec = obj.sections[65]
        local xywh = {x = obj.sections[45].x + objsec.x,
                      y = obj.sections[45].y + objsec.y,
                      w = objsec.w,
                      h = objsec.h}
        local val = F_limit(MOUSE_sliderHBar(xywh),0,1)
        if val ~= nil then
          if toffY then
            textoffval_select = val*300 - 150
            for i = 1, #ctl_select do
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].textoffval = textoffval_select
            end            
          else
            textoffval_selectx = val*300 - 150
            for i = 1, #ctl_select do
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].textoffvalx = textoffval_selectx
            end                          
          end
          update_gfx = true
        end
      end

      if mouse.context and mouse.context == contexts.textsizeslider then
        textresize = true
        local objsec = obj.sections[58]
        local xywh = {x = obj.sections[45].x + objsec.x,
                      y = obj.sections[45].y + objsec.y,
                      w = objsec.w,
                      h = objsec.h}
        local val = F_limit(MOUSE_sliderHBar(xywh),0,1)
        if val ~= nil then
          textsize_select = (val*35)-2
          if textoptlink_select == true then
            textsizev_select = textsize_select
          end
          for i = 1, #ctl_select do
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].textsize = textsize_select
            if textoptlink_select == true then
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].textsizev = textsize_select
            end
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].dirty = true
          end            
          update_ctls = true
          update_ctlopts = true
          --update_bg = true
          --update_gfx = true
        end
      elseif mouse.context and mouse.context == contexts.textsizevslider then
        textresize = true
        local objsec = obj.sections[851]
        local xywh = {x = obj.sections[45].x + objsec.x,
                      y = obj.sections[45].y + objsec.y,
                      w = objsec.w,
                      h = objsec.h}
        local val = F_limit(MOUSE_sliderHBar(xywh),0,1)
        if val ~= nil then
          textsizev_select = (val*35)-2
          if textoptlink_select == true then
            textsize_select = textsizev_select
          end
          for i = 1, #ctl_select do
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].textsizev = textsizev_select
            if textoptlink_select == true then
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].textsize = textsizev_select
            end
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].dirty = true
          end            
          update_ctls = true
          update_ctlopts = true
          --update_gfx = true
        end
      elseif mouse.context == nil and textresize then
        textresize = nil
        update_gfx = true
      end

      if mouse.context and mouse.context == contexts.defvalslider then
        local objsec = obj.sections[57]
        local xywh = {x = obj.sections[45].x + objsec.x,
                      y = obj.sections[45].y + objsec.y,
                      w = objsec.w,
                      h = objsec.h}
        local val = F_limit(MOUSE_sliderHBar(xywh),0,1)
        local upd = false
        if mouse.ctrl then
          if mouse.mx ~= omx then
            if mouse.mx > omx then val = 0.002 else val = -0.002 end
            omx = mouse.mx
            val = F_limit(defval_select+val, 0, 1)
            upd = true
          end
        elseif val ~= nil then
          if mouse.shift then val = round(val*4,0)/4 end
          upd = true            
          val = F_limit(val, 0, 1)
        end
        if val ~= octlval and upd then
          defval_select = val
          octlval = val
          for i = 1, #ctl_select do
            if strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].ctltype == 4 then
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].defval = defval_select
            else
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].val = defval_select
              strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].defval = defval_select
            end
            trackfxparam_select = ctl_select[i].ctl
            SetParam_ToDef(trackfxparam_select)
          end
          update_ctls = true
          update_ctlopts = true
        end
      end
          
      if mouse.context and mouse.context == contexts.dragctl then

        local ctls = strips[tracks[track_select].strip][page].controls
        newgrp = nil
        vert = true
        local c = GetControlAtXY(tracks[track_select].strip, page, mouse.mx, mouse.my)
        if c then
          local i = c
          local ctl = strips[tracks[track_select].strip][page].controls[i]
          if ctl.ctlcat == ctlcats.switcher and SwitcherInSelected(ctl.switcherid) == false then 
            local x = mouse.mx -obj.sections[10].x+surface_offset.x
            local y = mouse.my -obj.sections[10].y+surface_offset.y                                
            if x > ctl.x+ctl.w/2 then
              vert = false
            end
            newgrp = {grpid = switchers[ctl.switcherid].current,
                      switchid = i,
                      vert = vert}
          end              
        end

        
        if newgrp then
        
          local rl, rt, rr, rb = GetLTRBControlInGrp(newgrp.grpid, newgrp.switchid)

          if math.floor(mouse.mx) ~= math.floor(mouse.last_x) or math.floor(mouse.my) ~= math.floor(mouse.last_y) then
            local ctl = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl]
            local scale = ctl.scale
            
            local zx, zy = rl, rb               
            if newgrp.vert == false then
              zx, zy = rr, rt
            end
            
            local mrelx, mrely = 0,0
            if #ctl_select > 1 then
              for cs = 2, #ctl_select do
                mrelx = math.max(mrelx, ctl_select[cs].relx)
                mrely = math.max(mrely, ctl_select[cs].rely)
              end
              if gfx3_select then
                for cs = 1, #gfx3_select do
                  mrelx = math.max(mrelx, gfx3_select[cs].relx)
                  mrely = math.max(mrely, gfx3_select[cs].rely)
                end
              end
            end
            zx = zx + mrelx
            zy = zy + mrely
                              
            if nz(ctl.poslock,false) == false then
              ctl.x = zx
              ctl.y = zy
              ctl.xsc = ctl.x + math.floor(ctl.w/2 - (ctl.w*scale)/2)
              ctl.ysc = ctl.y + math.floor(ctl.ctl_info.cellh/2 - (ctl.ctl_info.cellh*scale)/2)
            end

            if #ctl_select > 1 then
              for i = 2, #ctl_select do
                local ctl = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl]
              
                if nz(ctl.poslock,false) == false then
                  scale = ctl.scale
                  ctl.x = zx - ctl_select[i].relx
                  ctl.y = zy - ctl_select[i].rely
                  ctl.xsc = ctl.x + math.floor(ctl.w/2 - (ctl.w*scale)/2)
                  ctl.ysc = ctl.y + math.floor(ctl.ctl_info.cellh/2 - (ctl.ctl_info.cellh*scale)/2)
                end
              end
            end

            if gfx3_select and #gfx3_select > 0 then
              for i = 1, #gfx3_select do
                local ctl = strips[tracks[track_select].strip][page].graphics[gfx3_select[i].ctl]
                ctl.x = zx - gfx3_select[i].relx
                ctl.y = zy - gfx3_select[i].rely
              end            
            end
            update_surface = true
          end              
        else
          if math.floor(mouse.mx/settings_gridsize) ~= math.floor(mouse.last_x/settings_gridsize) or math.floor(mouse.my/settings_gridsize) ~= math.floor(mouse.last_y/settings_gridsize) then
            local i
            local ctl = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl]
            local scale = ctl.scale
            local zx, zy = 0.5*ctl.w, 0.5*ctl.ctl_info.cellh
            
            if nz(ctl.poslock,false) == false then
              ctl.x = math.floor((mouse.mx-zx - surface_offset.x)/settings_gridsize)*settings_gridsize 
                                                                                 - math.floor((dragoff.x)/settings_gridsize)*settings_gridsize
              ctl.y = math.floor((mouse.my-zy - surface_offset.y)/settings_gridsize)*settings_gridsize 
                                                                                 - math.floor((dragoff.y)/settings_gridsize)*settings_gridsize
              ctl.xsc = ctl.x + math.floor(ctl.w/2 - (ctl.w*scale)/2)
              ctl.ysc = ctl.y + math.floor(ctl.ctl_info.cellh/2 - (ctl.ctl_info.cellh*scale)/2)
            end
            if #ctl_select > 1 then
              for i = 2, #ctl_select do
                local ctl = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl]
                
                if nz(ctl.poslock,false) == false then
                  scale = ctl.scale
                  ctl.x = math.floor((mouse.mx-zx - surface_offset.x)/settings_gridsize)*settings_gridsize 
                           - math.floor((dragoff.x)/settings_gridsize)*settings_gridsize 
                           - ctl_select[i].relx
                  ctl.y = math.floor((mouse.my-zy - surface_offset.y)/settings_gridsize)*settings_gridsize 
                           - math.floor((dragoff.y)/settings_gridsize)*settings_gridsize
                           - ctl_select[i].rely
                  ctl.xsc = ctl.x + math.floor(ctl.w/2 - (ctl.w*scale)/2)
                  ctl.ysc = ctl.y + math.floor(ctl.ctl_info.cellh/2 - (ctl.ctl_info.cellh*scale)/2)
                end
              end
            end
            if gfx3_select and #gfx3_select > 0 then
              for i = 1, #gfx3_select do
                local ctl = strips[tracks[track_select].strip][page].graphics[gfx3_select[i].ctl]
                ctl.x = math.floor((mouse.mx-zx - surface_offset.x)/settings_gridsize)*settings_gridsize 
                               - math.floor((dragoff.x)/settings_gridsize)*settings_gridsize 
                               - gfx3_select[i].relx
                ctl.y = math.floor((mouse.my-zy - surface_offset.y)/settings_gridsize)*settings_gridsize 
                               - math.floor((dragoff.y)/settings_gridsize)*settings_gridsize
                               - gfx3_select[i].rely
              end            
            end
            update_surface = true
          end
        end
        
      elseif dragctl ~= nil then
        dragctl = nil
        if MOUSE_over(obj.sections[60]) then
          --delete
          DeleteSelectedCtls()
          update_gfx = true
        else
          DropCtls()
        end
        SetCtlBitmapRedraw()
      end      

      if mouse.context and mouse.context == contexts.draglasso then
        if math.abs(lasso.l - mouse.mx) > 10 or math.abs(lasso.t - mouse.my) > 10 then
          lasso.r = mouse.mx
          lasso.b = mouse.my
          Lasso_Select(mouse.shift)
          if ctl_select ~= nil then
            SetCtlSelectVals()
          end
          SetPosLockCtl()
          update_ctls = true
        end
      elseif lasso ~= nil then
        --Dropped
        --DBG(lasso.l-lasso.r..'  '.. lasso.t-lasso.b)
        if math.abs(lasso.l-lasso.r) < 10 and math.abs(lasso.t-lasso.b) < 10 then
        -- == mouse.mx and lasso.t == mouse.my then
          if ctl_select ~= nil then
            --[[if #ctl_select == 1 and strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].ctlcat == ctlcats.switcher then
              switcher_select = ctl_select[1].ctl
              SwitcherMenu_RB()
            else]]
              RBMenu_Edit()
            --end
          else
            local c = GetControlAtXY(tracks[track_select].strip, page, mouse.mx, mouse.my)
            if c then
              if strips[tracks[track_select].strip][page].controls[c].ctlcat == ctlcats.switcher then
                switcher_select = c
                SwitcherMenu_RB()
              elseif strips[tracks[track_select].strip][page].controls[c].ctlcat == ctlcats.rcm_switch then
                rcm_select = c
                RCMMenu_RB()
              end
            else
            
              local cp
              if copy_ctls ~= nil then
                cp = 'Paste'
              end
              if cp then
                local mstr = cp
                gfx.x, gfx.y = mouse.mx, mouse.my
                local res = OpenMenu(mstr)
                if res == 1 then
                  Paste_Selected()
                  SetCtlBitmapRedraw()  
                  update_gfx = true
                end
              end  
            end              
          end
        
        end
        
        lasso = nil
        update_ctls = true
      end
    
      if MOUSE_click(obj.sections[521]) then
        if mouse.mx > obj.sections[521].w-40 then
          show_paramlearn = not show_paramlearn
          update_gfx = true
        else           
          trackedit_select = trackedit_select + 1 
          if trackedit_select > #tracks then
            trackedit_select = -1
          end
          PopulateTrackFX()
          PopulateTrackSendsInfo()
          PopulateSpecial()
          trctlslist_offset = 0
          update_gfx = true 
        end
      elseif MOUSE_click_RB(obj.sections[521]) then
        trackedit_select = trackedit_select - 1 
        if trackedit_select < -1 then
          trackedit_select = #tracks
        end
        PopulateTrackFX()
        PopulateTrackSendsInfo()
        PopulateSpecial()
        update_gfx = true    
      end
      
      if fxmode == 0 then
        if MOUSE_click(obj.sections[520]) then
          
          if mouse.lastLBclicktime and (rt-mouse.lastLBclicktime) < 0.15 then
            local i = math.floor((mouse.my - obj.sections[520].y) / butt_h)-1
            if i == -1 then
            elseif i >= F_butt_cnt then
            elseif trackfx[i + flist_offset] then
              local track = GetTrack(tracks[track_select].tracknum)
              if not reaper.TrackFX_GetOpen(track, i + flist_offset) then
                reaper.TrackFX_Show(track, i + flist_offset, 3)
              end
            end        
            
          else
            local i = math.floor((mouse.my - obj.sections[520].y) / butt_h)-1
            if i == -1 then
              if mouse.mx < obj.sections[520].w/2 then
                flist_offset = flist_offset - F_butt_cnt
                if flist_offset < 0 then
                  flist_offset = 0
                end
              else
                if flist_offset + F_butt_cnt < #trackfx then
                  flist_offset = flist_offset + F_butt_cnt-1
                end          
              end
              update_gfx = true
            elseif trackfx[i + flist_offset] then
              trackfx_select = i + flist_offset
              PopulateTrackFXParams()
              mouse.context = contexts.reassplugin
              reass_plugin = {fx = trackfx_select, time = rt}
              local w,h = gfx.getimgdim(998)
              if w == 0 or h == 0 then
                ksel_size = {w = 50, h = 50}
              else
               ksel_size = {w = w/2, h = h/2}
              end
              update_gfx = true
            end
          end
        elseif MOUSE_click_RB(obj.sections[520]) then
          --[[local i = math.floor((mouse.my - obj.sections[520].y) / butt_h)-1
          if i == -1 then
          elseif i >= F_butt_cnt then
          elseif trackfx[i + flist_offset] then
            local track = GetTrack(tracks[track_select].tracknum)
            if not reaper.TrackFX_GetOpen(track, i + flist_offset) then
              reaper.TrackFX_Show(track, i + flist_offset, 3)
            end
          end ]]       
        end
    
        if MOUSE_click(obj.sections[522]) then
          local i = math.floor((mouse.my - obj.sections[522].y) / butt_h)-1
          local dp = true
          if i == -1 then
            if mouse.mx < obj.sections[522].w/2 then
              plist_offset = plist_offset - P_butt_cnt
              if plist_offset < 0 then
                plist_offset = 0
              end
            else
              if plist_offset + P_butt_cnt < #trackfxparams then
                plist_offset = plist_offset + P_butt_cnt
              end          
            end
            update_gfx = true
          elseif trackfxparams[i + plist_offset] then
            trackfxparam_select = i + plist_offset
            if mouse.ctrl then
              if tfxp_sel == nil then
                tfxp_sel = {}
                tfxp_sel[i + plist_offset] = true
                tfxp_last = i + plist_offset
              elseif tfxp_sel[i + plist_offset] then
                --remove
                tfxp_sel[i + plist_offset] = nil
              else
                tfxp_sel[i + plist_offset] = true
                tfxp_last = i + plist_offset
              end
              dp = false
            elseif mouse.shift then
              if tfxp_sel == nil then
                tfxp_sel = {}
                tfxp_sel[i + plist_offset] = true
                tfxp_last = i + plist_offset
              else
                if tfxp_last == nil then
                
                else
                  local it = 1
                  if tfxp_last > i + plist_offset then
                    it = -1
                  end
                  tfxp_sel = {}
                  for p = tfxp_last, i + plist_offset, it do
                    tfxp_sel[p] = true  
                  end
                  tfxp_last = i + plist_offset
                end
                dp = false
              end
            
            elseif tfxp_sel and tfxp_sel[i + plist_offset] then
              --do nothing but drag
              tfxp_last = i + plist_offset
              
            else
              tfxp_sel = {}
              tfxp_sel[i + plist_offset] = true            
              tfxp_last = i + plist_offset
            end
            ctl_select = nil
            show_ctlbrowser = false
            
            update_gfx = true

            if ctl_files[knob_select].imageidx ~= nil then
              local w,_ = gfx.getimgdim(ctl_files[knob_select].imageidx)
              local h = ctl_files[knob_select].cellh
              if w == 0 or h == 0 then
                ksel_size = {w = 50, h = 50}
              else
               ksel_size = {w = w/2, h = h/2}
             end
            else 
              ksel_size = {w = 50, h = 50}
            end
            if dp then
              mouse.context = contexts.dragparam
            end
          end
        
        elseif MOUSE_click_RB(obj.sections[522]) then
          local i = math.floor((mouse.my - obj.sections[522].y) / butt_h)-1 
          if i == -1 then
            if mouse.mx < obj.sections[520].w/2 then
              plist_offset = 0
            else
              plist_offset = #trackfxparams - (P_butt_cnt)+2
            end
            update_gfx = true
          end        
        end
      elseif fxmode == 1 then
        if MOUSE_click(obj.sections[520]) then
          local i = math.floor((mouse.my - obj.sections[520].y) / butt_h)-1
          if i == -1 then
            if mouse.mx < obj.sections[520].w/2 then
              trctltypelist_offset = trctltypelist_offset - F_butt_cnt
              if trctltypelist_offset < 0 then
                trctltypelist_offset = 0
              end
            else
              if trctltypelist_offset + F_butt_cnt < #trctltype_table then
                trctltypelist_offset = trctltypelist_offset + F_butt_cnt-1
              end          
            end
            update_gfx = true
          elseif trctltype_table[i + trctltypelist_offset+1] then
            trctltype_select = i + trctltypelist_offset
            trctlslist_offset = 0
            if i + trctltypelist_offset == 2 then
              PopulateSpecial()
            end
            update_gfx = true
          end
        end

        if MOUSE_click(obj.sections[522]) then
          local pcnt = 0
          if trctltype_select == 0 then
            pcnt = #trctls_table
          elseif trctltype_select == 1 then            
            pcnt = (#trsends_table+1)*3
          elseif trctltype_select == 2 then
            pcnt = #special_table              
          elseif trctltype_select == 3 then
            pcnt = #otherctl_table
          end
          local i = math.floor((mouse.my - obj.sections[522].y) / butt_h)-1
          if i == -1 then
            if mouse.mx < obj.sections[522].w/2 then
              trctlslist_offset = trctlslist_offset - P_butt_cnt
              if trctlslist_offset < 0 then
                trctlslist_offset = 0
              end
            else
              if trctlslist_offset + P_butt_cnt < #trctls_table-1 then
                trctlslist_offset = trctlslist_offset + P_butt_cnt
                if trctlslist_offset > pcnt-1 then
                  trctlslist_offset = pcnt-1
                end
              end          
            end
            update_gfx = true
          elseif i >= 0 and i < pcnt then
            if trctltype_select == 0 then
              trctl_select = i + trctlslist_offset+1
              ctl_select = nil
              show_ctlbrowser = false
              
              update_gfx = true
  
              if ctl_files[knob_select].imageidx ~= nil then
                local w,_ = gfx.getimgdim(ctl_files[knob_select].imageidx)
                local h = ctl_files[knob_select].cellh
                if w == 0 or h == 0 then
                  ksel_size = {w = 50, h = 50}
                else
                  ksel_size = {w = w/2, h = h/2}
                end
              else 
                ksel_size = {w = 50, h = 50}
              end
              mouse.context = contexts.dragparam_tr
            elseif trctltype_select == 1 then
              trctl_select = i + trctlslist_offset+1
              ctl_select = nil
              show_ctlbrowser = false
              
              update_gfx = true
  
              if ctl_files[knob_select].imageidx ~= nil then
                local w,_ = gfx.getimgdim(ctl_files[knob_select].imageidx)
                local h = ctl_files[knob_select].cellh
                if w == 0 or h == 0 then
                  ksel_size = {w = 50, h = 50}
                else
                  ksel_size = {w = w/2, h = h/2}
                end
              else 
                ksel_size = {w = 50, h = 50}
              end
              mouse.context = contexts.dragparam_snd              
            elseif trctltype_select == 2 then
              trctl_select = i + trctlslist_offset+1
              ctl_select = nil
              show_ctlbrowser = false
              
              update_gfx = true
  
              if ctl_files[knob_select].imageidx ~= nil then
                local w,_ = gfx.getimgdim(ctl_files[knob_select].imageidx)
                local h = ctl_files[knob_select].cellh
                if w == 0 or h == 0 then
                  ksel_size = {w = 50, h = 50}
                else
                  ksel_size = {w = w/2, h = h/2}
                end
              else 
                ksel_size = {w = 50, h = 50}
              end
              mouse.context = contexts.dragparam_spec

            elseif trctltype_select == 3 then
              trctl_select = i + trctlslist_offset+1
              ctl_select = nil
              show_ctlbrowser = false
              
              update_gfx = true
  
              if ctl_files[knob_select].imageidx ~= nil then
                local w,_ = gfx.getimgdim(ctl_files[knob_select].imageidx)
                local h = ctl_files[knob_select].cellh
                if w == 0 or h == 0 then
                  ksel_size = {w = 50, h = 50}
                else
                  ksel_size = {w = w/2, h = h/2}
                end
              else 
                ksel_size = {w = 50, h = 50}
              end
              mouse.context = contexts.dragparam_other
            end
          end
        end
        
      end
              
      if mouse.context and mouse.context == contexts.reassplugin then
        if rt > reass_plugin.time + 0.75 then
          dragparam = {x = mouse.mx-ksel_size.w, y = mouse.my-ksel_size.h, type = 'reassplugin'}
          reass_param = nil
          if tracks[track_select] and tracks[track_select].strip ~= -1 then
            local i = GetReassCtl()   
            if i and (strips[tracks[track_select].strip][page].controls[i].ctlcat == ctlcats.fxparam or 
                      strips[tracks[track_select].strip][page].controls[i].ctlcat == ctlcats.rcm_switch) then
              reass_param = i
              if trackfx[trackfx_select].name == strips[tracks[track_select].strip][page].controls[i].fxname then
                dragparam.bc = gui.color.green
              else
                dragparam.bc = '255 153 0'
              end
            end
          end                    
          update_surface = true
        end
                      
      elseif mouse.context and mouse.context == contexts.dragparam then
        dragparam = {x = mouse.mx-ksel_size.w, y = mouse.my-ksel_size.h, type = 'track'}
        reass_param = nil
        if tracks[track_select] and tracks[track_select].strip ~= -1 then
          reass_param = GetReassCtl()
        end                    
        update_surface = true
      
      elseif mouse.context and mouse.context == contexts.dragparamlrn then
        dragparam = {x = mouse.mx-ksel_size.w, y = mouse.my-ksel_size.h, type = 'learn'}
        reass_param = nil
        if tracks[track_select] and tracks[track_select].strip ~= -1 then
          reass_param = GetReassCtl()
        end                    
        update_surface = true
      
      elseif mouse.context and mouse.context == contexts.dragparam_tr then
        dragparam = {x = mouse.mx-ksel_size.w, y = mouse.my-ksel_size.h, type = 'trctl'}
        reass_param = nil
        if tracks[track_select] and tracks[track_select].strip ~= -1 then
          reass_param = GetReassCtl()
        end                    
        update_surface = true

      elseif mouse.context and mouse.context == contexts.dragparam_snd then
        dragparam = {x = mouse.mx-ksel_size.w, y = mouse.my-ksel_size.h, type = 'trsnd'}
        reass_param = nil
        if tracks[track_select] and tracks[track_select].strip ~= -1 then
          reass_param = GetReassCtl()
        end                    
        update_surface = true

      elseif mouse.context and mouse.context == contexts.dragparam_spec then
        dragparam = {x = mouse.mx-ksel_size.w, y = mouse.my-ksel_size.h, type = 'pkmeter'}            
        
        reass_param = nil
        if tracks[track_select] and tracks[track_select].strip ~= -1 then
          reass_param = GetReassCtl()
        end                    
        update_surface = true

      elseif mouse.context and mouse.context == contexts.dragparam_other then
      
        if trctl_select == 1 then
          dragparam = {x = mouse.mx-ksel_size.w, y = mouse.my-ksel_size.h, type = 'action'}
        elseif trctl_select == 2 then
          dragparam = {x = mouse.mx-ksel_size.w, y = mouse.my-ksel_size.h, type = 'macro'}
        elseif trctl_select == 3 then
          knob_select = def_boxctl
          dragparam = {x = mouse.mx-ksel_size.w, y = mouse.my-ksel_size.h, type = 'eqcontrol'}
        elseif trctl_select == 4 then
          knob_select = def_switchctl
          dragparam = {x = mouse.mx-ksel_size.w, y = mouse.my-ksel_size.h, type = 'switcher'}
        elseif trctl_select == 5 then
          --knob_select = def_boxctl
          dragparam = {x = mouse.mx-ksel_size.w, y = mouse.my-ksel_size.h, type = 'rcmswitch'}
        elseif trctl_select == 6 then
          --knob_select = def_boxctl
          dragparam = {x = mouse.mx-ksel_size.w, y = mouse.my-ksel_size.h, type = 'midimsgctl'}
        end
        
        reass_param = nil
        if tracks[track_select] and tracks[track_select].strip ~= -1 then
          reass_param = GetReassCtl()
        end                    
        update_surface = true
                
      elseif dragparam ~= nil then
        --Dropped
        if dragparam.type == 'reassplugin' then
          if reass_param ~= nil then
            local rctl = strips[tracks[track_select].strip][page].controls[reass_param]
            if rctl.ctlcat ~= ctlcats.rcm_switch then
              local guid = strips[tracks[track_select].strip][page].controls[reass_param].fxguid
              local nguid = trackfx[trackfx_select].guid
              local nfxnum = trackfx[trackfx_select].fxnum
              local nfxname = trackfx[trackfx_select].name
              for c = 1, #strips[tracks[track_select].strip][page].controls do
                local ctl = strips[tracks[track_select].strip][page].controls[c]
                if ctl.fxguid == guid then
                
                  ctl.fxnum = nfxnum
                  ctl.fxguid = nguid
                  ctl.fxname = nfxname
                  ctl.param_info.paramname = trackfxparams[ctl.param_info.paramnum].paramname
                  
                  if tracks[trackedit_select].tracknum ~= tracks[track_select].tracknum then
                    ctl.tracknum=tracks[trackedit_select].tracknum
                    ctl.trackguid=tracks[trackedit_select].guid
                  else
                    ctl.tracknum=nil
                    ctl.trackguid=nil                  
                  end
                  
                end
              end
            else
              --local guid = strips[tracks[track_select].strip][page].controls[reass_param].fxguid
              local nguid = trackfx[trackfx_select].guid
              local nfxnum = trackfx[trackfx_select].fxnum
              local nfxname = trackfx[trackfx_select].name
              --for c = 1, #strips[tracks[track_select].strip][page].controls do
                --local ctl = strips[tracks[track_select].strip][page].controls[c]
                --if rctl.fxguid == guid then
                
                  rctl.fxnum = nfxnum
                  rctl.fxguid = nguid
                  rctl.fxname = nfxname
                  rctl.fxfound = true
                  rctl.param_info.paramname = 'RCM' --trackfxparams[ctl.param_info.paramnum].paramname
                  
                  if tracks[trackedit_select].tracknum ~= tracks[track_select].tracknum then
                    rctl.tracknum=tracks[trackedit_select].tracknum
                    rctl.trackguid=tracks[trackedit_select].guid
                  else
                    rctl.tracknum=nil
                    rctl.trackguid=nil                  
                  end
                  
                --end
              --end
            
            end
          end
        elseif dragparam.type == 'track' then
          if reass_param == nil then
            if dragparam.x+ksel_size.w > obj.sections[10].x and dragparam.x+ksel_size.w < obj.sections[10].x+obj.sections[10].w and dragparam.y+ksel_size.h > obj.sections[10].y and dragparam.y+ksel_size.h < obj.sections[10].y+obj.sections[10].h then
              local i
              local cnt = 0
              local dpx, dpy = dragparam.x, dragparam.y
              for i = 0, #trackfxparams do
                if tfxp_sel[i] then
                  trackfxparam_select = i
                  Strip_AddParam()
                  cnt = cnt + 1
                  dragparam.x = math.floor(dpx + ((ksel_size.w*2+settings_gridsize) * (cnt % 8)))
                  dragparam.y = math.floor(dpy + (ksel_size.h*2+(2*settings_gridsize)) * math.floor(cnt/8))
                end
              end
              tfxp_sel = nil
              
            end
          else
            if dragparam.x+ksel_size.w > obj.sections[10].x and dragparam.x+ksel_size.w < obj.sections[10].x+obj.sections[10].w and dragparam.y+ksel_size.h > obj.sections[10].y and dragparam.y+ksel_size.h < obj.sections[10].y+obj.sections[10].h then
            
              local i
              local cnt = 0
              for i = 1, #trackfxparams do
                if tfxp_sel[i] then
                  cnt = cnt + 1
                end
              end
              if cnt <= 1 then
                strips[tracks[track_select].strip][page].controls[reass_param].c_id = GenID()
                if tracks[trackedit_select].tracknum ~= tracks[track_select].tracknum then
                  strips[tracks[track_select].strip][page].controls[reass_param].tracknum=tracks[trackedit_select].tracknum
                  strips[tracks[track_select].strip][page].controls[reass_param].trackguid=tracks[trackedit_select].guid
                else
                  strips[tracks[track_select].strip][page].controls[reass_param].tracknum=nil
                  strips[tracks[track_select].strip][page].controls[reass_param].trackguid=nil                  
                end
                strips[tracks[track_select].strip][page].controls[reass_param].ctlcat = ctlcats.fxparam
                strips[tracks[track_select].strip][page].controls[reass_param].fxname=trackfx[trackfx_select].name
                strips[tracks[track_select].strip][page].controls[reass_param].fxguid=trackfx[trackfx_select].guid
                strips[tracks[track_select].strip][page].controls[reass_param].fxnum=trackfx[trackfx_select].fxnum
                strips[tracks[track_select].strip][page].controls[reass_param].fxfound = true
                strips[tracks[track_select].strip][page].controls[reass_param].param = trackfxparam_select
                strips[tracks[track_select].strip][page].controls[reass_param].param_info = trackfxparams[trackfxparam_select]
                strips[tracks[track_select].strip][page].controls[reass_param].val = GetParamValue(ctlcats.fxparam,
                                                                                                   tracks[trackedit_select].tracknum,
                                                                                                   trackfx[trackfx_select].fxnum,
                                                                                                   trackfxparam_select, reass_param)
                strips[tracks[track_select].strip][page].controls[reass_param].defval = GetParamValue(ctlcats.fxparam,
                                                                                                   tracks[trackedit_select].tracknum,
                                                                                                   trackfx[trackfx_select].fxnum,
                                                                                                   trackfxparam_select, reass_param)
              else
                OpenMsgBox(1, 'You cannot reassign multiple controls at once.', 1)
              end
              tfxp_sel = nil
            end
          end
        elseif dragparam.type == 'learn' then
          if reass_param == nil then
            if dragparam.x+ksel_size.w > obj.sections[10].x and dragparam.x+ksel_size.w < obj.sections[10].x+obj.sections[10].w and dragparam.y+ksel_size.h > obj.sections[10].y and dragparam.y+ksel_size.h < obj.sections[10].y+obj.sections[10].h then
              if not MOUSE_over(obj.sections[115]) then
                Strip_AddParam()
              end
            end
          else
            if dragparam.x+ksel_size.w > obj.sections[10].x and dragparam.x+ksel_size.w < obj.sections[10].x+obj.sections[10].w and dragparam.y+ksel_size.h > obj.sections[10].y and dragparam.y+ksel_size.h < obj.sections[10].y+obj.sections[10].h then
              if not MOUSE_over(obj.sections[115]) then
              
                if last_touch_fx.tracknum ~= tracks[track_select].tracknum then
                  strips[tracks[track_select].strip][page].controls[reass_param].tracknum=last_touch_fx.tracknum
                  strips[tracks[track_select].strip][page].controls[reass_param].trackguid=last_touch_fx.trguid
                else
                  strips[tracks[track_select].strip][page].controls[reass_param].tracknum=nil
                  strips[tracks[track_select].strip][page].controls[reass_param].trackguid=nil                  
                end
                strips[tracks[track_select].strip][page].controls[reass_param].c_id = GenID()
                strips[tracks[track_select].strip][page].controls[reass_param].ctlcat = ctlcats.fxparam
                strips[tracks[track_select].strip][page].controls[reass_param].fxname=last_touch_fx.fxname
                strips[tracks[track_select].strip][page].controls[reass_param].fxguid=last_touch_fx.fxguid
                strips[tracks[track_select].strip][page].controls[reass_param].fxnum=last_touch_fx.fxnum
                strips[tracks[track_select].strip][page].controls[reass_param].fxfound = true
                strips[tracks[track_select].strip][page].controls[reass_param].param = last_touch_fx.paramnum
                strips[tracks[track_select].strip][page].controls[reass_param].param_info = {paramname = last_touch_fx.prname,
                                                                                             paramnum = last_touch_fx.paramnum}
                strips[tracks[track_select].strip][page].controls[reass_param].val = GetParamValue(ctlcats.fxparam,
                                                                                                   last_touch_fx.tracknum,
                                                                                                   last_touch_fx.fxnum,
                                                                                                   last_touch_fx.paramnum, reass_param)
                strips[tracks[track_select].strip][page].controls[reass_param].defval = GetParamValue(ctlcats.fxparam,
                                                                                                   last_touch_fx.tracknum,
                                                                                                   last_touch_fx.fxnum,
                                                                                                   last_touch_fx.paramnum, reass_param)
                
              end
            end
          end
                
        elseif dragparam.type == 'trctl' or dragparam.type == 'trsnd' then
          if reass_param == nil then
            if dragparam.x+ksel_size.w > obj.sections[10].x and dragparam.x+ksel_size.w < obj.sections[10].x+obj.sections[10].w and dragparam.y+ksel_size.h > obj.sections[10].y and dragparam.y+ksel_size.h < obj.sections[10].y+obj.sections[10].h then
              trackfxparam_select = i
              Strip_AddParam()              
            end
          else
            local cnt = 1
            if cnt <= 1 then
              if tracks[trackedit_select].tracknum ~= tracks[track_select].tracknum then
                strips[tracks[track_select].strip][page].controls[reass_param].tracknum=tracks[trackedit_select].tracknum
                strips[tracks[track_select].strip][page].controls[reass_param].trackguid=tracks[trackedit_select].guid
              else
                strips[tracks[track_select].strip][page].controls[reass_param].tracknum=nil
                strips[tracks[track_select].strip][page].controls[reass_param].trackguid=nil                  
              end
              strips[tracks[track_select].strip][page].controls[reass_param].c_id = GenID()
              strips[tracks[track_select].strip][page].controls[reass_param].fxguid=nil
              strips[tracks[track_select].strip][page].controls[reass_param].fxnum=nil
              strips[tracks[track_select].strip][page].controls[reass_param].fxfound = true
              strips[tracks[track_select].strip][page].controls[reass_param].param = trctl_select

              if dragparam.type == 'trctl' then
                strips[tracks[track_select].strip][page].controls[reass_param].ctlcat = ctlcats.trackparam
                strips[tracks[track_select].strip][page].controls[reass_param].fxname='Track Parameter'
                strips[tracks[track_select].strip][page].controls[reass_param].param_info = {paramname = 'Track '..trctls_table[trctl_select].name,
                                                                                             paramnum = trctl_select}
                strips[tracks[track_select].strip][page].controls[reass_param].val = GetParamValue(ctlcats.trackparam,
                                                                                                    tracks[trackedit_select].tracknum,
                                                                                                    nil,
                                                                                                    trctl_select, nil)
                strips[tracks[track_select].strip][page].controls[reass_param].defval = strips[tracks[track_select].strip][page].controls[reass_param].val 
                
              elseif dragparam.type == 'trsnd' then
                local sidx = math.floor((trctl_select-1) / 3)
                local pidx = (trctl_select-1) % 3 +1
                strips[tracks[track_select].strip][page].controls[reass_param].ctlcat = ctlcats.tracksend
                strips[tracks[track_select].strip][page].controls[reass_param].fxname='Track Send'
                strips[tracks[track_select].strip][page].controls[reass_param].param_info = {paramname = trsends_table[sidx][pidx].name,
                                                                                             paramnum = trctl_select,
                                                                                             paramidx = trsends_table[sidx].idx,
                                                                                             paramstr = trsends_table[sidx][pidx].parmname,
                                                                                             paramdesttrnum = trsends_table[sidx].desttracknum,
                                                                                             paramdestguid = trsends_table[sidx].desttrackguid,
                                                                                             paramdestchan = trsends_table[sidx].dstchan,
                                                                                             paramsrcchan = trsends_table[sidx].srcchan}
                strips[tracks[track_select].strip][page].controls[reass_param].val = GetParamValue(ctlcats.tracksend,
                                                                                                    tracks[trackedit_select].tracknum,
                                                                                                    nil,
                                                                                                    trctl_select, reass_param)
                strips[tracks[track_select].strip][page].controls[reass_param].defval = strips[tracks[track_select].strip][page].controls[reass_param].val
              end
            else
              OpenMsgBox(1, 'You cannot reassign multiple controls at once.', 1)
            end
          end            
        elseif dragparam.type == 'action' then
          if reass_param == nil then
            if dragparam.x+ksel_size.w > obj.sections[10].x and dragparam.x+ksel_size.w < obj.sections[10].x+obj.sections[10].w and dragparam.y+ksel_size.h > obj.sections[10].y and dragparam.y+ksel_size.h < obj.sections[10].y+obj.sections[10].h then
              trackfxparam_select = i
              Strip_AddParam()              
            end
          else
          
          end
        elseif dragparam.type == 'pkmeter' then
          if reass_param == nil then
            if dragparam.x+ksel_size.w > obj.sections[10].x and dragparam.x+ksel_size.w < obj.sections[10].x+obj.sections[10].w and dragparam.y+ksel_size.h > obj.sections[10].y and dragparam.y+ksel_size.h < obj.sections[10].y+obj.sections[10].h then
              trackfxparam_select = i
              Strip_AddParam()              
            end
          else
          
          end
        elseif dragparam.type == 'macro' then
          if reass_param == nil then
            if dragparam.x+ksel_size.w > obj.sections[10].x and dragparam.x+ksel_size.w < obj.sections[10].x+obj.sections[10].w and dragparam.y+ksel_size.h > obj.sections[10].y and dragparam.y+ksel_size.h < obj.sections[10].y+obj.sections[10].h then
              trackfxparam_select = i
              Strip_AddParam()              
            end
          else
          
          end
        elseif dragparam.type == 'eqcontrol' then
          if reass_param == nil then
            if dragparam.x+ksel_size.w > obj.sections[10].x and dragparam.x+ksel_size.w < obj.sections[10].x+obj.sections[10].w and dragparam.y+ksel_size.h > obj.sections[10].y and dragparam.y+ksel_size.h < obj.sections[10].y+obj.sections[10].h then
              trackfxparam_select = i
              Strip_AddParam()              
            end
          else
          
          end
        elseif dragparam.type == 'switcher' then
          if reass_param == nil then
            if dragparam.x+ksel_size.w > obj.sections[10].x and dragparam.x+ksel_size.w < obj.sections[10].x+obj.sections[10].w and dragparam.y+ksel_size.h > obj.sections[10].y and dragparam.y+ksel_size.h < obj.sections[10].y+obj.sections[10].h then
              trackfxparam_select = i
              Strip_AddParam()              
            end
          else
          
          end
        elseif dragparam.type == 'rcmswitch' then
          if reass_param == nil then
            if dragparam.x+ksel_size.w > obj.sections[10].x and dragparam.x+ksel_size.w < obj.sections[10].x+obj.sections[10].w and dragparam.y+ksel_size.h > obj.sections[10].y and dragparam.y+ksel_size.h < obj.sections[10].y+obj.sections[10].h then
              trackfxparam_select = i
              Strip_AddParam()              
            end
          else
          
          end
        elseif dragparam.type == 'midimsgctl' then
          if reass_param == nil then
            if dragparam.x+ksel_size.w > obj.sections[10].x and dragparam.x+ksel_size.w < obj.sections[10].x+obj.sections[10].w and dragparam.y+ksel_size.h > obj.sections[10].y and dragparam.y+ksel_size.h < obj.sections[10].y+obj.sections[10].h then
              trackfxparam_select = i
              Strip_AddParam()              
            end
          else
          
          end
        end
        
        --if mouse.mx > obj.sections[10].x then
          tfxp_sel = nil
          if tfxp_last then
            tfxp_sel = {}
            tfxp_sel[tfxp_last] = true
          end
        --end
        reass_param = nil
        dragparam = nil
        update_gfx = true
      end
    
      
    
      if ctl_select ~= nil then
        show_ctloptions = true
      else
        show_ctloptions = false
        ctl_page = 0
      end
    
    end -- show_actionchooser
    
    return noscroll
    
  end

  function A_Run_Submode1(noscroll, rt, char)
  
    if gfx.mouse_wheel ~= 0 then
      local v = gfx.mouse_wheel/120
      if MOUSE_over(obj.sections[531]) then
        gflist_offset = F_limit(gflist_offset - v, 0, #graphics_folders)
        update_sidebar = true
        gfx.mouse_wheel = 0
      elseif MOUSE_over(obj.sections[530]) then
        glist_offset = F_limit(glist_offset - v, 0, #graphics_folder_files)
        update_sidebar = true
        gfx.mouse_wheel = 0
      end
      
      if show_lbloptions and gfx2_select and MOUSE_over(obj.sections[49]) then
        if MOUSE_over(obj.sections[141]) then
          gfx_font_select.size = F_limit(gfx_font_select.size+v,8,250)
          strips[tracks[track_select].strip][page].graphics[gfx2_select].font.size = gfx_font_select.size
          update_gfx = true
          gfx.mouse_wheel = 0                
        elseif MOUSE_over(obj.sections[148]) then
          gfx_font_select.shadow_x = gfx_font_select.shadow_x+v
          strips[tracks[track_select].strip][page].graphics[gfx2_select].font.shadow_x = gfx_font_select.shadow_x
          update_gfx = true
          gfx.mouse_wheel = 0                
        elseif MOUSE_over(obj.sections[149]) then
          gfx_font_select.shadow_y = gfx_font_select.shadow_y+v
          strips[tracks[track_select].strip][page].graphics[gfx2_select].font.shadow_y = gfx_font_select.shadow_y
          update_gfx = true
          gfx.mouse_wheel = 0                
        elseif MOUSE_over(obj.sections[150]) then
          gfx_font_select.shadow_a = gfx_font_select.shadow_a+v*0.1
          strips[tracks[track_select].strip][page].graphics[gfx2_select].font.shadow_a = gfx_font_select.shadow_a
          update_gfx = true
          gfx.mouse_wheel = 0                
        end
      elseif show_gfxoptions and gfx2_select and MOUSE_over(obj.sections[49]) then
        if MOUSE_over(obj.sections[910]) then
          gfxbright_select = F_limit(gfxbright_select+(v*0.02),0,1)
          strips[tracks[track_select].strip][page].graphics[gfx2_select].bright = gfxbright_select
          update_gfx = true
          gfx.mouse_wheel = 0                
        elseif MOUSE_over(obj.sections[911]) then
          gfxcontr_select = F_limit(gfxcontr_select+(v*0.02),0,1)
          strips[tracks[track_select].strip][page].graphics[gfx2_select].contr = gfxcontr_select
          update_gfx = true
          gfx.mouse_wheel = 0                
        elseif MOUSE_over(obj.sections[913]) then
          gfxr_select = F_limit(gfxr_select+(v*0.02),0,1)
          strips[tracks[track_select].strip][page].graphics[gfx2_select].rmult = gfxr_select
          update_gfx = true
          gfx.mouse_wheel = 0                
        elseif MOUSE_over(obj.sections[914]) then
          gfxg_select = F_limit(gfxg_select+(v*0.02),0,1)
          strips[tracks[track_select].strip][page].graphics[gfx2_select].gmult = gfxg_select
          update_gfx = true
          gfx.mouse_wheel = 0                
        elseif MOUSE_over(obj.sections[915]) then
          gfxb_select = F_limit(gfxb_select+(v*0.02),0,1)
          strips[tracks[track_select].strip][page].graphics[gfx2_select].bmult = gfxb_select
          update_gfx = true
          gfx.mouse_wheel = 0                
        elseif MOUSE_over(obj.sections[916]) then
          gfxa_select = F_limit(gfxa_select+(v*0.02),0,1)
          strips[tracks[track_select].strip][page].graphics[gfx2_select].alpha = gfxa_select
          update_gfx = true
          gfx.mouse_wheel = 0                
        end      
      end
    end
  
    local clicklblopts = false
    
    if gfx2_select ~= nil and char ~= 0 then
    
      ArrowKey_Shift(char,nil,nil,gfx2_select)
    
    elseif gfx2_select ~= nil and show_lbloptions and (MOUSE_click(obj.sections[49]) or MOUSE_click_RB(obj.sections[49])) then
      
      -- LBL OPTIONS
      clicklblopts = true
    
      if MOUSE_click(obj.sections[140]) then
        --EditLabel(7,gfx_text_select)
        if strips and strips[tracks[track_select].strip] then
          OpenEB(7,'Please enter text for label:',gfx_text_select)
        end
      end          

      if MOUSE_click(obj.sections[147]) then
        if fontlist then
          local fnt = ChooseFontMenu(mouse.mx,mouse.my)
          if fnt then
            EditFont2(fnt)
            update_gfx = true
          end
        else
          if strips and strips[tracks[track_select].strip] then
            OpenEB(8,'Please enter font name:')
          end
        end
      --elseif MOUSE_click_RB(obj.sections[147]) then
      
                
      end          
    
      if MOUSE_click(obj.sections[142]) then
        local retval, c = reaper.GR_SelectColor(_,ConvertColorString(gfx_textcol_select))
        if retval ~= 0 then
          gfx_textcol_select = ConvertColor(c)
          strips[tracks[track_select].strip][page].graphics[gfx2_select].text_col = gfx_textcol_select
          update_gfx = true
        end
      end
      
      if MOUSE_click(obj.sections[143]) then
        gfx_font_select.bold = not gfx_font_select.bold
        strips[tracks[track_select].strip][page].graphics[gfx2_select].font.bold = gfx_font_select.bold
        update_gfx = true
      end

      if MOUSE_click(obj.sections[144]) then
        gfx_font_select.italics = not gfx_font_select.italics
        strips[tracks[track_select].strip][page].graphics[gfx2_select].font.italics = gfx_font_select.italics
        update_gfx = true
      end

      if MOUSE_click(obj.sections[145]) then
        gfx_font_select.underline = not gfx_font_select.underline
        strips[tracks[track_select].strip][page].graphics[gfx2_select].font.underline = gfx_font_select.underline
        update_gfx = true
      end

      if MOUSE_click(obj.sections[146]) then
        gfx_font_select.shadow = not gfx_font_select.shadow
        strips[tracks[track_select].strip][page].graphics[gfx2_select].font.shadow = gfx_font_select.shadow
        update_gfx = true
      end
      
      if mouse.context == nil and MOUSE_click(obj.sections[141]) then mouse.context = contexts.textsizeslider 
      elseif mouse.context == nil and MOUSE_click(obj.sections[148]) then mouse.context = contexts.shadxslider
      elseif mouse.context == nil and MOUSE_click(obj.sections[149]) then mouse.context = contexts.shadyslider
      elseif mouse.context == nil and MOUSE_click(obj.sections[150]) then mouse.context = contexts.shadaslider end
      
    elseif gfx2_select ~= nil and show_gfxoptions and (MOUSE_click(obj.sections[49]) or MOUSE_click_RB(obj.sections[49])) then

      clicklblopts = true
    
      if mouse.context == nil and MOUSE_click(obj.sections[912]) then 
        
        gfxbright_select = 0.5
        gfxcontr_select = 0.5
        gfxr_select = 0.5
        gfxg_select = 0.5
        gfxb_select = 0.5
        gfxa_select = 1
        strips[tracks[track_select].strip][page].graphics[gfx2_select].bright = gfxbright_select
        strips[tracks[track_select].strip][page].graphics[gfx2_select].contr = gfxcontr_select
        strips[tracks[track_select].strip][page].graphics[gfx2_select].rmult = gfxr_select
        strips[tracks[track_select].strip][page].graphics[gfx2_select].gmult = gfxg_select
        strips[tracks[track_select].strip][page].graphics[gfx2_select].bmult = gfxb_select
        strips[tracks[track_select].strip][page].graphics[gfx2_select].amult = gfxa_select
        update_gfx = true
      
      elseif mouse.context == nil and MOUSE_click(obj.sections[917]) then 
            
        gfxstretchmode_select = math.max(((gfxstretchmode_select + 1) % (#gfxstretch_table+1)),1)
        strips[tracks[track_select].strip][page].graphics[gfx2_select].stretchmode = gfxstretchmode_select
        update_gfx = true

      end
      
      if mouse.context == nil and MOUSE_click(obj.sections[910]) then mouse.context = contexts.gfxopt_bright 
      elseif mouse.context == nil and MOUSE_click(obj.sections[911]) then mouse.context = contexts.gfxopt_contr
      elseif mouse.context == nil and MOUSE_click(obj.sections[913]) then mouse.context = contexts.gfxopt_r
      elseif mouse.context == nil and MOUSE_click(obj.sections[914]) then mouse.context = contexts.gfxopt_g
      elseif mouse.context == nil and MOUSE_click(obj.sections[915]) then mouse.context = contexts.gfxopt_b
      elseif mouse.context == nil and MOUSE_click(obj.sections[916]) then mouse.context = contexts.gfxopt_a
      elseif mouse.context == nil and MOUSE_click(obj.sections[918]) then 

        mouse.context = contexts.gfxopt_edge
        gfxedgesz_select = F_limit(gfxedgesz_select + 1,0,127)
        strips[tracks[track_select].strip][page].graphics[gfx2_select].edgesz = gfxedgesz_select
        
        draggfxedge = {pos = gfxedgesz_select, yoff = mouse.my-obj.sections[918].y}
        update_bg = true
        update_gfx = true
      end
    
    end
  
    if mouse.context and mouse.context == contexts.textsizeslider then
      local val = F_limit(MOUSE_sliderHBar(obj.sections[141]),0,1)
      if val ~= nil then
        gfx_font_select.size = F_limit((val*250),8,250)
        --for i = 1, #ctl_select do
        strips[tracks[track_select].strip][page].graphics[gfx2_select].font.size = gfx_font_select.size
        --end            
        update_gfx = true
      end
    elseif mouse.context and mouse.context == contexts.shadxslider then
      local val = F_limit(MOUSE_sliderHBar(obj.sections[148]),0,1)
      if val ~= nil then
        gfx_font_select.shadow_x = math.floor((val*30)-15)
        --for i = 1, #ctl_select do
        strips[tracks[track_select].strip][page].graphics[gfx2_select].font.shadow_x = gfx_font_select.shadow_x
        --end            
        update_gfx = true
      end
    elseif mouse.context and mouse.context == contexts.shadyslider then
      local val = F_limit(MOUSE_sliderHBar(obj.sections[149]),0,1)
      if val ~= nil then
        gfx_font_select.shadow_y = math.floor((val*30)-15)
        --for i = 1, #ctl_select do
        strips[tracks[track_select].strip][page].graphics[gfx2_select].font.shadow_y = gfx_font_select.shadow_y
        --end            
        update_gfx = true
      end
    elseif mouse.context and mouse.context == contexts.shadaslider then
      local val = F_limit(MOUSE_sliderHBar(obj.sections[150]),0,1)
      if val ~= nil then
        gfx_font_select.shadow_a = val
        --for i = 1, #ctl_select do
        strips[tracks[track_select].strip][page].graphics[gfx2_select].font.shadow_a = gfx_font_select.shadow_a
        --end            
        update_gfx = true
      end

    elseif mouse.context and mouse.context == contexts.gfxopt_bright then
      local val = F_limit(MOUSE_sliderHBar(obj.sections[910]),0,1)
      if val ~= nil then
        gfxbright_select = val
        strips[tracks[track_select].strip][page].graphics[gfx2_select].bright = gfxbright_select
        update_gfx = true
      end
    elseif mouse.context and mouse.context == contexts.gfxopt_contr then
      local val = F_limit(MOUSE_sliderHBar(obj.sections[911]),0,1)
      if val ~= nil then
        gfxcontr_select = val
        strips[tracks[track_select].strip][page].graphics[gfx2_select].contr = gfxcontr_select
        update_gfx = true
      end


    elseif mouse.context and mouse.context == contexts.gfxopt_r then
      local val = F_limit(MOUSE_sliderHBar(obj.sections[913]),0,1)
      if val ~= nil then
        gfxr_select = val
        strips[tracks[track_select].strip][page].graphics[gfx2_select].rmult = gfxr_select
        update_gfx = true
      end
    elseif mouse.context and mouse.context == contexts.gfxopt_g then
      local val = F_limit(MOUSE_sliderHBar(obj.sections[914]),0,1)
      if val ~= nil then
        gfxg_select = val
        strips[tracks[track_select].strip][page].graphics[gfx2_select].gmult = gfxg_select
        update_gfx = true
      end
    elseif mouse.context and mouse.context == contexts.gfxopt_b then
      local val = F_limit(MOUSE_sliderHBar(obj.sections[915]),0,1)
      if val ~= nil then
        gfxb_select = val
        strips[tracks[track_select].strip][page].graphics[gfx2_select].bmult = gfxb_select
        update_gfx = true
      end
    elseif mouse.context and mouse.context == contexts.gfxopt_a then
      local val = F_limit(MOUSE_sliderHBar(obj.sections[916]),0,1)
      if val ~= nil then
        gfxa_select = val
        strips[tracks[track_select].strip][page].graphics[gfx2_select].alpha = gfxa_select
        update_gfx = true
      end
      
    elseif mouse.context and mouse.context == contexts.gfxopt_edge then
      local v = MOUSE_sliderX(obj.sections[918], -draggfxedge.yoff)
      if v then
        v=v-0.5
        gfxedgesz_select = F_limit(math.floor(draggfxedge.pos - v*96),0,127)
        strips[tracks[track_select].strip][page].graphics[gfx2_select].edgesz = gfxedgesz_select
        update_bg = true
        update_gfx = true
      end
    end
    
    if MOUSE_click(obj.sections[531]) then
      local i = math.floor((mouse.my - obj.sections[531].y) / butt_h)-1
      if i == -1 then
        if mouse.mx < obj.sections[531].w/2 then
          gflist_offset = gflist_offset - GF_butt_cnt
          if gflist_offset < 0 then
            gflist_offset = 0
          end
        else
          if gflist_offset + GF_butt_cnt < #graphics_folders then
            gflist_offset = gflist_offset + GF_butt_cnt-1
          end          
        end
        update_gfx = true
        
      elseif graphics_folders[i + gflist_offset] then
        gfxfol_select = i + gflist_offset
        --PopulateTrackFXParams()
        PopGfxFolder(gfxfol_select)
        update_gfx = true
      end
      
    elseif MOUSE_click(obj.sections[530]) then
      local i = math.floor((mouse.my - obj.sections[530].y) / butt_h)-1
      
      if i == -1 then
        if mouse.mx < obj.sections[530].w/2 then
          glist_offset = glist_offset - G_butt_cnt
          if glist_offset < 0 then
            glist_offset = 0
          end
        else
          if glist_offset + G_butt_cnt < #graphics_folder_files then
            glist_offset = glist_offset + G_butt_cnt
          end
        end
        update_gfx = true
      elseif graphics_files[graphics_folder_files[i + glist_offset]] then
        gfx_select = i + glist_offset
        
        --load temp image
        local gfol = ''
        local fol = graphics_files[graphics_folder_files[gfx_select]].fol
        if fol and fol ~= 'GENERAL' then
          gfol = fol..'/'
        end
        gfx.loadimg(1023,graphics_path..gfol..graphics_files[graphics_folder_files[gfx_select]].fn)
        draggfx_w, draggfx_h = gfx.getimgdim(1023)
        
        update_gfx = true
        mouse.context = contexts.draggfx
      end
      
    end
    
    if mouse.context and mouse.context == contexts.draggfx then
      draggfx = {x = mouse.mx - draggfx_w/2, y = mouse.my - draggfx_h/2}
      if MOUSE_over(obj.sections[531]) then
        local i = math.floor((mouse.my - obj.sections[531].y) / butt_h)-1
        ogdf = gfx_dropfolder
        if graphics_folders[i + gflist_offset] then
          local dropfolder = i + gflist_offset
          if dropfolder ~= gfx_dropfolder then
            gfx_dropfolder = dropfolder
          end
        else
          gfx_dropfolder = nil
        end
      else
        gfx_dropfolder = nil
      end
      if ogdf ~= gfx_dropfolder then
        update_sidebar = true
      end
      update_surface = true
    elseif draggfx ~= nil then
      --Dropped
      if mouse.mx > obj.sections[10].x and mouse.mx < obj.sections[10].x+obj.sections[10].w and mouse.my > obj.sections[10].y and mouse.my < obj.sections[10].y+obj.sections[10].h then
        Strip_AddGFX(gfxtype.img)
      elseif MOUSE_over(obj.sections[531]) then
      
        local i = math.floor((mouse.my - obj.sections[531].y) / butt_h)-1
        if graphics_folders[i + gflist_offset] then
          local dropfolder = i + gflist_offset
          --DBG(graphics_folders[i + gflist_offset])
          MoveGFXFileToFolder(gfx_select, dropfolder)
        end
        
      end
      
      gfx_dropfolder = nil
      draggfx = nil
      update_gfx = true
    end
  
    if mouse.mx > obj.sections[10].x and clicklblopts == false then
      if strips and tracks[track_select] and strips[tracks[track_select].strip] then
      
        if gfx2_select ~= nil then
        
          local selrect = CalcGFXSelRect()
          selrect.x = selrect.x - surface_offset.x + obj.sections[10].x
          selrect.y = selrect.y - surface_offset.y + obj.sections[10].y
          local xywh = {x = selrect.x+selrect.w-5,
                        y = selrect.y+selrect.h/2-5,
                        w = 10,
                        h = 10}
          if mouse.context == nil and MOUSE_click(xywh) then
            if poslock_select == false then
              mouse.context = contexts.stretch_x
              gfx2_stretch = {mx = mouse.mx, sw = strips[tracks[track_select].strip][page].graphics[gfx2_select].stretchw}
            end
          end

          local xywh = {x = selrect.x+selrect.w/2-5,
                        y = selrect.y+selrect.h-5,
                        w = 10,
                        h = 10}
          if mouse.context == nil and MOUSE_click(xywh) then
            if poslock_select == false then
              mouse.context = contexts.stretch_y
              gfx2_stretch = {my = mouse.my, sh = strips[tracks[track_select].strip][page].graphics[gfx2_select].stretchh}
            end
          end

          local xywh = {x = selrect.x+selrect.w-5,
                        y = selrect.y+selrect.h-5,
                        w = 10,
                        h = 10}
          if mouse.context == nil and MOUSE_click(xywh) then
            if poslock_select == false then
              mouse.context = contexts.stretch_xy
              gfx2_stretch = {mx = mouse.mx, my = mouse.my, sw = strips[tracks[track_select].strip][page].graphics[gfx2_select].stretchw,
                                                            sh = strips[tracks[track_select].strip][page].graphics[gfx2_select].stretchh}
            end
          end
        
          if mouse.context and mouse.context == contexts.stretch_x then
          
            strips[tracks[track_select].strip][page].graphics[gfx2_select].stretchw = math.max(math.floor((gfx2_stretch.sw + (mouse.mx-gfx2_stretch.mx))/settings_gridsize)*settings_gridsize,2)
            update_gfx = true
          
          elseif mouse.context and mouse.context == contexts.stretch_y then
          
            strips[tracks[track_select].strip][page].graphics[gfx2_select].stretchh =  math.max(math.floor((gfx2_stretch.sh + (mouse.my-gfx2_stretch.my))/settings_gridsize)*settings_gridsize,2)
            update_gfx = true
            
          elseif mouse.context and mouse.context == contexts.stretch_xy then
          
            strips[tracks[track_select].strip][page].graphics[gfx2_select].stretchw = math.max(math.floor((gfx2_stretch.sw + (mouse.mx-gfx2_stretch.mx))/settings_gridsize)*settings_gridsize,2)
            strips[tracks[track_select].strip][page].graphics[gfx2_select].stretchh = math.max(math.floor((gfx2_stretch.sh + (mouse.my-gfx2_stretch.my))/settings_gridsize)*settings_gridsize,2)
            update_gfx = true

          end            
        
        end
        
        local clickxywh = false
        if mouse.context == nil then
          for i = #strips[tracks[track_select].strip][page].graphics,1,-1 do
            local xywh
            local gfxx = strips[tracks[track_select].strip][page].graphics[i]
            xywh = {x = gfxx.x - surface_offset.x + obj.sections[10].x, 
                    y = gfxx.y - surface_offset.y + obj.sections[10].y, 
                    w = gfxx.stretchw, 
                    h = gfxx.stretchh}
            
            if xywh.w < 16 then
              xywh.x = xywh.x - 8
              xywh.w = 16
            end
            if xywh.h < 16 then 
              xywh.y = xywh.y - 8
              xywh.h = 16
            end
            
            if MOUSE_click(xywh) and Switcher_CtlsHidden(gfxx.switcher, gfxx.grpid) == false then
              gfx2_select = i              

              poslock_select = nz(strips[tracks[track_select].strip][page].graphics[gfx2_select].poslock,false)
              
              mouse.context = contexts.draggfx2
              draggfx2 = 'draggfx'
              dragoff = {x = mouse.mx - strips[tracks[track_select].strip][page].graphics[gfx2_select].x - surface_offset.x,
                         y = mouse.my - strips[tracks[track_select].strip][page].graphics[gfx2_select].y - surface_offset.y}
              
              if strips[tracks[track_select].strip][page].graphics[gfx2_select].gfxtype == gfxtype.txt then
                show_lbloptions = true
                show_gfxoptions = false
                SetGfxSelectVals()
              else
                show_lbloptions = false
                show_gfxoptions = true
                SetGfxSelectVals2()
              end
              
              GenGFXDragPreview(gui)
              gfxx.hide = true
              
              update_gfx = true
              clickxywh = true
              break
            elseif MOUSE_click_RB(xywh) then
              GFXMenu()
              clickxywh = true
              break
            end
          end
          if clickxywh == false and MOUSE_click_RB(obj.sections[10]) then
            GFXMenu()
          end
        end
        
      end
    end
              
    if mouse.context and mouse.context == contexts.draggfx2 then
      if math.floor(mouse.mx/settings_gridsize) ~= math.floor(mouse.last_x/settings_gridsize) or math.floor(mouse.my/settings_gridsize) ~= math.floor(mouse.last_y/settings_gridsize) then
        local i
        if poslock_select == false then
        
          strips[tracks[track_select].strip][page].graphics[gfx2_select].x = math.floor((mouse.mx - surface_offset.x)/settings_gridsize)*settings_gridsize 
                                                                             - math.floor((dragoff.x)/settings_gridsize)*settings_gridsize
          strips[tracks[track_select].strip][page].graphics[gfx2_select].y = math.floor((mouse.my - surface_offset.y)/settings_gridsize)*settings_gridsize 
                                                                             - math.floor((dragoff.y)/settings_gridsize)*settings_gridsize
        end
        update_surface = true
      end
    elseif draggfx2 ~= nil then
      draggfx2 = nil
      if MOUSE_over(obj.sections[60]) then
        --delete
        ctl_select = nil
        DeleteSelectedCtls()
        update_gfx = true
      else
        strips[tracks[track_select].strip][page].graphics[gfx2_select].hide = nil
        update_gfx = true
      end
    end             
    
    
    return noscroll
    
  end

  function A_Run_Submode2(noscroll, rt, char)
  
    if gfx.mouse_wheel ~= 0 then
      local v = gfx.mouse_wheel/120
      if MOUSE_over(obj.sections[512]) then
        slist_offset = F_limit(slist_offset - v, 0, #strip_files)
        update_sidebar = true
        gfx.mouse_wheel = 0
      end
      if MOUSE_over(obj.sections[510]) then
        sflist_offset = F_limit(sflist_offset - v, 0, #strip_folders)
        update_sidebar = true
        gfx.mouse_wheel = 0
      end
    end
    
    if (ctl_select ~= nil or gfx3_select ~= nil) and char ~= 0 then
    
      ArrowKey_Shift(char,ctl_select,gfx3_select)
    
    elseif MOUSE_click(obj.sections[15]) then
      SaveStrip()
      update_gfx = true
    end
    
    if mouse.mx > obj.sections[10].x then
      if mouse.context == nil and MOUSE_click(obj.sections[10]) then
        if strips and tracks[track_select] and strips[tracks[track_select].strip] then
          local ctls = strips[tracks[track_select].strip][page].controls
          for i = 1, #ctls do
          
            local ctl = ctls[i]
          
            local xywh
            xywh = {x = ctl.x - surface_offset.x + obj.sections[10].x, 
                    y = ctl.y - surface_offset.y + obj.sections[10].y, 
                    w = ctl.w, 
                    h = ctl.ctl_info.cellh}
            if MOUSE_click(xywh) then
              
              local hidden = Switcher_CtlsHidden(ctl.switcher, ctl.grpid)
              local stripid, grpid
              if hidden == false then
                stripid = ctl.id
                grpid = ctl.grpid
                switchid = ctl.switcherid
              end
              if stripid ~= nil or grpid ~= nil or switchid ~= nil then
                
                if switchid then
                  SelectSwitchElements(switchid, i)
                elseif mouse.shift then
                  SelectGroupElements(grpid)
                else
                  SelectStripElements(stripid)
                end

                dragoff = {x = mouse.mx - ctls[ctl_select[1].ctl].x - 0.5*ctls[ctl_select[1].ctl].w - surface_offset.x,
                           y = mouse.my - ctls[ctl_select[1].ctl].y - 0.5*ctls[ctl_select[1].ctl].ctl_info.cellh - surface_offset.y}
                
                if ctl_select ~= nil and not mouse.ctrl then --and not mouse.alt then
                  dragctl = 'dragctl'
                  mouse.context = contexts.dragctl
                  GenCtlDragPreview(gui)
                  for i = 1, #ctl_select do
                    ctls[ctl_select[i].ctl].hide = true
                  end
                  if gfx3_select and #gfx3_select > 0 then
                    local gfxx = strips[tracks[track_select].strip][page].graphics
                    for i = 1, #gfx3_select do
                      gfxx[gfx3_select[i].ctl].hide = true  
                    end                    
                  end
                  SetCtlBitmapRedraw()
                end
                update_gfx = true
                break
              end
              
            end
          end
          if not mouse.context then
            ctl_select = nil
            gfx3_select = nil
          end  
        end
      end  
    end
    
    if mouse.context and mouse.context == contexts.dragctl then
    
      local x = mouse.mx -obj.sections[10].x-surface_offset.x
      local y = mouse.my -obj.sections[10].y-surface_offset.y              
      local ctls = strips[tracks[track_select].strip][page].controls
      newgrp = nil
      vert = true
      local c = GetControlAtXY(tracks[track_select].strip, page, mouse.mx, mouse.my)
      if c then
        local i = c
        local ctl = strips[tracks[track_select].strip][page].controls[i]
        if ctl.ctlcat == ctlcats.switcher and SwitcherInSelected(ctl.switcherid) == false then 
          local x = mouse.mx -obj.sections[10].x+surface_offset.x
          local y = mouse.my -obj.sections[10].y+surface_offset.y                                
          if x > ctl.x+ctl.w/2 then
            vert = false
          end
          newgrp = {grpid = switchers[ctl.switcherid].current,
                    switchid = i,
                    vert = vert}
        end              
      end
      
      if newgrp then
        local rl, rt, rr, rb = GetLTRBControlInGrp(newgrp.grpid, newgrp.switchid)
        --local rl, rt, rr, rb = GetLTRBControlInSel(newgrp.switchid)
        local dl, dt, _, _ = GetGFXOffsetInSel()
        if math.floor(mouse.mx) ~= math.floor(mouse.last_x) or math.floor(mouse.my) ~= math.floor(mouse.last_y) then
          local ctl = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl]
          local scale = ctl.scale
          
          local zx, zy = rl, rb                  
          if newgrp.vert == false then
            zx, zy = rr, rt
          end
          
          local mrelx, mrely = 0,0
          if #ctl_select > 1 then
            for cs = 2, #ctl_select do
              mrelx = math.max(mrelx, ctl_select[cs].relx)
              mrely = math.max(mrely, ctl_select[cs].rely)
            end
            if gfx3_select then
              for cs = 1, #gfx3_select do
                mrelx = math.max(mrelx, gfx3_select[cs].relx)
                mrely = math.max(mrely, gfx3_select[cs].rely)
              end
            end
          end
          zx = zx + mrelx
          zy = zy + mrely
          
          if nz(ctl.poslock,false) == false then
            ctl.x = zx
            ctl.y = zy
            ctl.xsc = ctl.x + math.floor(ctl.w/2 - (ctl.w*scale)/2)
            ctl.ysc = ctl.y + math.floor(ctl.ctl_info.cellh/2 - (ctl.ctl_info.cellh*scale)/2)
          end
      
          if #ctl_select > 1 then
            for i = 2, #ctl_select do
              local ctl = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl]
            
              if nz(ctl.poslock,false) == false then
                scale = ctl.scale
                ctl.x = zx - ctl_select[i].relx
                ctl.y = zy - ctl_select[i].rely
                ctl.xsc = ctl.x + math.floor(ctl.w/2 - (ctl.w*scale)/2)
                ctl.ysc = ctl.y + math.floor(ctl.ctl_info.cellh/2 - (ctl.ctl_info.cellh*scale)/2)
              end
            end
          end
      
          if gfx3_select and #gfx3_select > 0 then
            for i = 1, #gfx3_select do
              local ctl = strips[tracks[track_select].strip][page].graphics[gfx3_select[i].ctl]
              ctl.x = zx - gfx3_select[i].relx
              ctl.y = zy - gfx3_select[i].rely
            end            
          end
          update_surface = true
        end              
      else

        if math.floor(mouse.mx/settings_gridsize) ~= math.floor(mouse.last_x/settings_gridsize) or math.floor(mouse.my/settings_gridsize) ~= math.floor(mouse.last_y/settings_gridsize) then
          local i
          local ctl = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl]
          local scale = ctl.scale
          local zx, zy = 0.5*ctl.w, 0.5*ctl.ctl_info.cellh
          
          if nz(ctl.poslock,false) == false then
            ctl.x = math.floor((mouse.mx-zx - surface_offset.x)/settings_gridsize)*settings_gridsize 
                                                                               - math.floor((dragoff.x)/settings_gridsize)*settings_gridsize
            ctl.y = math.floor((mouse.my-zy - surface_offset.y)/settings_gridsize)*settings_gridsize 
                                                                               - math.floor((dragoff.y)/settings_gridsize)*settings_gridsize
            ctl.xsc = ctl.x + math.floor(ctl.w/2 - (ctl.w*scale)/2)
            ctl.ysc = ctl.y + math.floor(ctl.ctl_info.cellh/2 - (ctl.ctl_info.cellh*scale)/2)
          end
          if #ctl_select > 1 then
            for i = 2, #ctl_select do
              local ctl = strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl]
              
              if nz(ctl.poslock,false) == false then
                scale = ctl.scale
                ctl.x = math.floor((mouse.mx-zx - surface_offset.x)/settings_gridsize)*settings_gridsize 
                         - math.floor((dragoff.x)/settings_gridsize)*settings_gridsize 
                         - ctl_select[i].relx
                ctl.y = math.floor((mouse.my-zy - surface_offset.y)/settings_gridsize)*settings_gridsize 
                         - math.floor((dragoff.y)/settings_gridsize)*settings_gridsize
                         - ctl_select[i].rely
                ctl.xsc = ctl.x + math.floor(ctl.w/2 - (ctl.w*scale)/2)
                ctl.ysc = ctl.y + math.floor(ctl.ctl_info.cellh/2 - (ctl.ctl_info.cellh*scale)/2)
              end
            end
          end
          if gfx3_select and #gfx3_select > 0 then
            for i = 1, #gfx3_select do
              local ctl = strips[tracks[track_select].strip][page].graphics[gfx3_select[i].ctl]
              ctl.x = math.floor((mouse.mx-zx - surface_offset.x)/settings_gridsize)*settings_gridsize 
                             - math.floor((dragoff.x)/settings_gridsize)*settings_gridsize 
                             - gfx3_select[i].relx
              ctl.y = math.floor((mouse.my-zy - surface_offset.y)/settings_gridsize)*settings_gridsize 
                             - math.floor((dragoff.y)/settings_gridsize)*settings_gridsize
                             - gfx3_select[i].rely
            end            
          end
          update_surface = true
        end
      end
      
    elseif mouse.context == nil and dragctl ~= nil then
      dragctl = nil
      if MOUSE_over(obj.sections[60]) then
        --delete
        DeleteSelectedCtls()
        update_gfx = true
      else
        DropCtls()
      end              
      SetCtlBitmapRedraw()
    end      
    
    if MOUSE_click(obj.sections[510]) then
      local i = math.floor(((mouse.my - obj.sections[510].y)) / butt_h)-1
      if i == -1 then
        if mouse.mx < obj.sections[510].w/2 then
          sflist_offset = sflist_offset - SF_butt_cnt
          if sflist_offset < 0 then
            sflist_offset = 0
          end
        else
          if sflist_offset + SF_butt_cnt-1 < #strip_folders then
            sflist_offset = sflist_offset + SF_butt_cnt
          end
        end
        update_gfx = true
      elseif strip_folders[i + sflist_offset] then
        stripfol_select = i + sflist_offset
        PopulateStrips()            
        update_gfx = true
      end
      
    end

    if MOUSE_click(obj.sections[512]) then
      local i = math.floor(((mouse.my - obj.sections[512].y)) / butt_h)
      if i == 0 then
        if mouse.mx < obj.sections[512].w/2 then
          slist_offset = slist_offset - S_butt_cnt
          if slist_offset < 0 then
            slist_offset = 0
          end
        else
          if slist_offset + S_butt_cnt-1 < #strip_files then
            slist_offset = slist_offset + S_butt_cnt-1
          end
        end
        update_gfx = true
      elseif strip_files[i-1 + slist_offset] then
        if mouse.mx <= obj.sections[512].w - butt_h then
          strip_select = i-1 + slist_offset
          --gen preview
          loadstrip = LoadStrip(strip_select)
          if loadstrip then
            GenStripPreview(gui, loadstrip.strip, loadstrip.switchers, loadstrip.switchconvtab)
                      
            mouse.context = contexts.dragstrip
          end
          update_gfx = true
        else
          local fsp = i-1 + slist_offset
          if InFavs(strip_folders[stripfol_select].fn..'/'..strip_files[fsp].fn) then
            RemoveFav(strip_folders[stripfol_select].fn..'/'..strip_files[fsp].fn)
          else
            strip_favs[#strip_favs+1] = strip_folders[stripfol_select].fn..'/'..strip_files[fsp].fn
          end
          update_sidebar = true
        end
      end
      
    elseif MOUSE_click_RB(obj.sections[512]) then
    
      if strip_select then
        local i = math.floor(((mouse.my - obj.sections[512].y)) / butt_h)
        if strip_select == i-1 + slist_offset then
          mstr = 'Set Default (Track)|Set Default (Master)|Set Default (Global)||Clear Default (Track)|Clear Default (Master)|Clear Default (Global)||Save (Overwrite)||Add to favorites||Export Shareable Strip File|Import Shared Strip File'
        else
          mstr = '#Set Default (Track)|#Set Default (Master)|#Set Default (Global)||Clear Default (Track)|Clear Default (Master)|Clear Default (Global)||#Save (Overwrite)||#Add to favorites||#Export Shareable Strip File|Import Shared Strip File'            
        end
        gfx.x, gfx.y = mouse.mx, mouse.my
        res = OpenMenu(mstr)
        if res ~= 0 then
          if res == 1 then
            
            strip_default = {strip_select = strip_select,
                             stripfol_select = stripfol_select}
          elseif res == 2 then
            strip_default_mast = {strip_select = strip_select,
                                  stripfol_select = stripfol_select}
          elseif res == 3 then
            strip_default_glob = {strip_select = strip_select,
                                  stripfol_select = stripfol_select}
          elseif res == 4 then
            strip_default = nil
          elseif res == 5 then
            strip_default_mast = nil
          elseif res == 6 then
            strip_default_glob = nil
          elseif res == 7 then
          
            local ostoff = slist_offset
            SaveStrip3(string.sub(strip_files[strip_select].fn,1,string.len(strip_files[strip_select].fn)-6))
            slist_offset = ostoff
          elseif res == 8 then
            strip_favs[#strip_favs+1] = strip_folders[stripfol_select].fn..'/'..strip_files[strip_select].fn
          elseif res == 9 then
            StripShare_Export(strip_folders[stripfol_select].fn..'/', strip_files[strip_select].fn)
          elseif res == 10 then
            StripShare_Import('')
          end
        end
      end        
    end
    
    if mouse.context and mouse.context == contexts.dragstrip then
      dragstripx = true --to force dropped action even if not 
      if mouse.mx ~= mouse.last_x or mouse.my ~= mouse.last_y then
        dragstrip = {x = mouse.mx, y = mouse.my}
        update_surface = true
      end
    elseif dragstripx ~= nil then
      --Dropped
      --image_count = image_count_add
      if dragstrip then
        if dragstrip.x > obj.sections[10].x and dragstrip.x < obj.sections[10].w and dragstrip.y > obj.sections[10].y and dragstrip.y < obj.sections[10].h then
          Strip_AddStrip(loadstrip, dragstrip.x-obj.sections[10].x, dragstrip.y-obj.sections[10].y)
        end
      end
      loadstrip = nil
      dragstrip = nil
      dragstripx = nil
      ctl_select = nil
      update_gfx = true
      
      SetCtlBitmapRedraw()
      
    end
    
    
    return noscroll
    
  end
  
  function A_Run_XXYMode(rt)
  
    if mouse.context == nil and (MOUSE_click(obj.sections[221])) then
      local i = math.floor((mouse.my - obj.sections[221].y)/butt_h)
      if i == 0 then
      
        xxymode = xxymode + 1
        if xxymode > #xxymode_table-1 then
          xxymode = 0
        end
        xxypath_edit = false
        XXYRecord_Set(false)
        update_snaps = true
        update_xxy = true
      end
    
      local mx, my = mouse.mx, mouse.my
      mouse.mx, mouse.my = mouse.mx - obj.sections[221].x, mouse.my - obj.sections[221].y
      if MOUSE_click(obj.sections[235]) then
      
        XXYRecord_Set(not xxyrecord)
        update_gfx = true
      
      end
      
      mouse.mx, mouse.my = mx, my
      
    elseif mouse.context == nil and MOUSE_click(obj.sections[222]) then
      show_xxy = false
      XXYRecord_Set(false)
      
      --SaveSingleStrip(tracks[track_select].strip)
      reaper.MarkProjectDirty(0)
      update_gfx = true
    end      
    
    if xxymode == 0 then

      if gfx.mouse_wheel ~= 0 then
        xywh = {x = obj.sections[221].x+obj.sections[223].x,
                y = obj.sections[221].y+obj.sections[223].y,
                w = obj.sections[223].w,
                h = obj.sections[223].h}
                
        if MOUSE_over(xywh) then
          local v = gfx.mouse_wheel/120
          xxylist_offset = F_limit(xxylist_offset - v,0,#snapshots[tracks[track_select].strip][page][sstype_select].snapshot-1)
          update_gfx = true
        end
        
        gfx.mouse_wheel = 0
      end
      
      if mouse.context == nil and (MOUSE_click(obj.sections[220]) or MOUSE_click_RB(obj.sections[220])) then
      
        if mouse.LB then
          local strip = tracks[track_select].strip
          if xxy and xxy[strip] and xxy[strip][page] and xxy[strip][page][sstype_select] then
            mouse.context = contexts.xxy_drag
          end
          
        elseif mouse.RB then
          local strip = tracks[track_select].strip
          if xxy and xxy[strip] and xxy[strip][page] and xxy[strip][page][sstype_select] then
          
            for p = 1, #xxy[strip][page][sstype_select].points do
            
              xywh = {x = obj.sections[220].x + xxy[strip][page][sstype_select].points[p].x*obj.sections[220].w - 8,
                      y = obj.sections[220].y + xxy[strip][page][sstype_select].points[p].y*obj.sections[220].h - 8,
                      w = 16,
                      h = 16}
              if MOUSE_click_RB(xywh) and mouse.shift == false and mouse.ctrl == false then
                mouse.context = contexts.xxy_movesnap
                movesnap = {xoff = mouse.mx - xywh.x, yoff = mouse.my - xywh.y, p = p}
                break 
              elseif MOUSE_click_RB(xywh) and mouse.shift == true then
                XXY_PtToggleActive(p)
                update_xxy = true
                break
              
              elseif MOUSE_click_RB(xywh) and mouse.ctrl == true then
              
                DeleteXXY_pt(p)
                update_xxy = true
                break
              end
            
            end
        
          end
        
        end
      
      elseif mouse.context == nil and (MOUSE_click(obj.sections[221]) or MOUSE_click_RB(obj.sections[221])) then
        local mx,my = mouse.mx,mouse.my
        mouse.mx = mouse.mx-obj.sections[221].x
        mouse.my = mouse.my-obj.sections[221].y
        
        local strip = tracks[track_select].strip
        --DBG(mouse.mx..'  '..mouse.my)
        if MOUSE_click(obj.sections[223]) then
          local i = math.floor((mouse.my - obj.sections[223].y)/butt_h)
        
          if i == 0 then
            if mouse.mx < obj.sections[223].x + obj.sections[223].w/2 then
              xxylist_offset = math.max(xxylist_offset - SSXXY_butt_cnt,0)
              update_gfx = true
            else
              xxylist_offset = math.min(xxylist_offset + SSXXY_butt_cnt, math.max(#snapshots[strip][page][sstype_select].snapshot - SSXXY_butt_cnt,0))
              update_gfx = true
            end
          else
            if snapshots[strip][page][sstype_select][i+xxylist_offset] or 
               snapshots[strip][page][sstype_select].snapshot[i+xxylist_offset] then            
                mouse.context = contexts.xxy_dragsnap
                ss_select = i+xxylist_offset
                update_gfx = true
                dragsnap = {x = mouse.mx, y = mouse.my, ss = i+xxylist_offset}
            end
          end
        
        elseif MOUSE_click(obj.sections[225]) then
          mouse.context = contexts.xxy_gravityslider
        
        elseif mouse.context == nil and MOUSE_click(obj.sections[226]) then
        
          if snapshots[tracks[track_select].strip] then
            sstype_select = F_limit(sstype_select + 1, 2, #snapshots[tracks[track_select].strip][page])
            if xxy[tracks[track_select].strip] and xxy[tracks[track_select].strip][page][sstype_select] then
              xxypath_select = xxy[tracks[track_select].strip][page][sstype_select].pathidx
            else
              xxypath_select = nil
            end
          end
          ss_select = nil
          xxylist_offset = 0
          update_gfx = true
        
        elseif mouse.context == nil and MOUSE_click_RB(obj.sections[226]) then
        
          if snapshots[tracks[track_select].strip] then
            sstype_select = F_limit(sstype_select - 1, 2, #snapshots[tracks[track_select].strip][page])
            if xxy[tracks[track_select].strip] and xxy[tracks[track_select].strip][page][sstype_select] then
              xxypath_select = xxy[tracks[track_select].strip][page][sstype_select].pathidx
            else
              xxypath_select = nil
            end
          end
          ss_select = nil
          xxylist_offset = 0
          update_gfx = true

        elseif MOUSE_click(obj.sections[232]) then

          if xxy and xxy[tracks[track_select].strip] and xxy[tracks[track_select].strip][page][sstype_select] then
            local f = {targettype = 0,
                       strip = tracks[track_select].strip,
                       page = page,
                       sstype = sstype_select,
                       xy = 0}
            
            mouse.mx, mouse.my = mx, my
            local fad = SetAutomationFader(f, xxy[tracks[track_select].strip][page][sstype_select].xfader, true)
            if fad == -2 then
              DeleteFader(xxy[tracks[track_select].strip][page][sstype_select].xfader)
              update_gfx = true
            elseif fad ~= -1 then
              --[[if xxy[tracks[track_select].strip][page][sstype_select].xfader and xxy[tracks[track_select].strip][page][sstype_select].xfader ~= fad then
                faders[xxy[tracks[track_select].strip][page][sstype_select].xfader] = {}
              end
              xxy[tracks[track_select].strip][page][sstype_select].xfader = fad]]
              AssignFader(fad, f)
              update_gfx = true
            end
          end
        
        elseif MOUSE_click(obj.sections[233]) then

          if xxy and xxy[tracks[track_select].strip] and xxy[tracks[track_select].strip][page][sstype_select] then
            local f = {targettype = 0,
                       strip = tracks[track_select].strip,
                       page = page,
                       sstype = sstype_select,
                       xy = 1}
            
            mouse.mx, mouse.my = mx, my
            local fad = SetAutomationFader(f, xxy[tracks[track_select].strip][page][sstype_select].yfader, true)
            if fad == -2 then
              DeleteFader(xxy[tracks[track_select].strip][page][sstype_select].yfader)
              update_gfx = true              
            elseif fad ~= -1 then
              --if xxy[tracks[track_select].strip][page][sstype_select].yfader and xxy[tracks[track_select].strip][page][sstype_select].yfader ~= fad then
              --  faders[xxy[tracks[track_select].strip][page][sstype_select].yfader] = {}
              --end
              --xxy[tracks[track_select].strip][page][sstype_select].yfader = fad
              AssignFader(fad, f)
              update_gfx = true
            end
          end
                    
        end
        
        mouse.mx, mouse.my = mx, my
      end

      if mouse.context and mouse.context == contexts.xxy_drag then
        local ox, oy = xxy[tracks[track_select].strip][page][sstype_select].x, xxy[tracks[track_select].strip][page][sstype_select].y
        xxy[tracks[track_select].strip][page][sstype_select].x = F_limit((mouse.mx - obj.sections[220].x) / obj.sections[220].w,0,1)
        xxy[tracks[track_select].strip][page][sstype_select].y = F_limit((mouse.my - obj.sections[220].y) / obj.sections[220].h,0,1)
        
        if xxy[tracks[track_select].strip][page][sstype_select].x ~= ox or xxy[tracks[track_select].strip][page][sstype_select].y ~= oy then
          XXY_Set(tracks[track_select].strip, page, sstype_select)
          update_xxypos = true        
        end
        
      elseif mouse.context and mouse.context == contexts.xxy_movesnap then
        local x = (mouse.mx - obj.sections[220].x)/obj.sections[220].w
        local y = (mouse.my - obj.sections[220].y)/obj.sections[220].h
        
        xxy[tracks[track_select].strip][page][sstype_select].points[movesnap.p].x = F_limit(x,0,1)
        xxy[tracks[track_select].strip][page][sstype_select].points[movesnap.p].y = F_limit(y,0,1)
        
        local strip = tracks[track_select].strip
        if xxy and xxy[strip] and xxy[strip][page] and xxy[strip][page][sstype_select] then
          XXY_Set(tracks[track_select].strip, page, sstype_select)
        end
        update_xxy = true
      
      elseif mouse.context and mouse.context == contexts.xxy_gravityslider then
        local mx,my = mouse.mx,mouse.my
        mouse.mx = mouse.mx-obj.sections[221].x
        mouse.my = mouse.my-obj.sections[221].y
        
        local val = F_limit(MOUSE_sliderHBar(obj.sections[225]),0,1)
        if val ~= nil then
          xxy_gravity = val*3+1
          local strip = tracks[track_select].strip
          if xxy and xxy[strip] and xxy[strip][page] and xxy[strip][page][sstype_select] then
            XXY_Set(tracks[track_select].strip, page, sstype_select)
          end
          update_gfx = true
        end
        mouse.mx, mouse.my = mx, my
        
      elseif mouse.context and mouse.context == contexts.xxy_dragsnap then
        dragsnap.x = mouse.mx
        dragsnap.y = mouse.my
        update_xxy = true
      
      elseif dragsnap ~= nil then
        if MOUSE_over(obj.sections[220]) then
          local strip = tracks[track_select].strip
          local x,y = mouse.mx - obj.sections[220].x, mouse.my - obj.sections[220].y
          x = x/obj.sections[220].w
          y = y/obj.sections[220].h

          XXY_INIT(strip, page, sstype_select)
          pt_cnt = #xxy[strip][page][sstype_select].points + 1
          xxy[strip][page][sstype_select].points[pt_cnt] = {x = x, y = y, ss = dragsnap.ss}

          XXY_Set(tracks[track_select].strip, page, sstype_select)
        end
        update_gfx = true
        dragsnap = nil
      end
    elseif xxymode == 1 then
    
      if mouse.context == nil and MOUSE_click(obj.sections[230]) then
    
        mouse.context = contexts.xxypath_posslider
    
      elseif mouse.context == nil and xxypath_edit and (MOUSE_click(obj.sections[220]) or MOUSE_click_RB(obj.sections[220])) then
      
        if mouse.lastLBclicktime and (rt-mouse.lastLBclicktime) < 0.15 then
        
          --add point
          local x = (mouse.mx - obj.sections[220].x)/obj.sections[220].w
          local y = (mouse.my - obj.sections[220].y)/obj.sections[220].h
          
          XXYPATH_addpoint(x,y)
          update_gfx = true          
          
        elseif MOUSE_click(obj.sections[220]) then
        
          if xxypath[xxypath_select] then
            local fnd = false
            local fnd_p, fnd_sp
            for p = 1, #xxypath[xxypath_select].points do
            
              for sp = 1, #xxypath[xxypath_select].points[p].x do
              
                local xywh = {x = obj.sections[220].x + (xxypath[xxypath_select].points[p].x[sp] * obj.sections[220].w) - 5,
                              y = obj.sections[220].y + (xxypath[xxypath_select].points[p].y[sp] * obj.sections[220].h) - 5,
                              w = 10,
                              h = 10}
                if MOUSE_click(xywh) then
                  fnd = true
                  fnd_p = p
                  fnd_sp = sp
                  break
                end
              end
            
              if fnd then
                break
              end
            end
            if fnd then
            
              if fnd_sp == 2 or fnd_sp == 3 then
              
                mouse.context = contexts.xxypath_dragcontrolpt
                
                local hyp
                if fnd_sp == 2 then
                  if fnd_p > 1 then
                    hyp = math.sqrt((xxypath[xxypath_select].points[fnd_p-1].x[4]-xxypath[xxypath_select].points[fnd_p-1].x[3])^2 + 
                                    (xxypath[xxypath_select].points[fnd_p-1].y[4]-xxypath[xxypath_select].points[fnd_p-1].y[3])^2)
                  end
                else
                  if fnd_p < #xxypath[xxypath_select].points-1 then
                    hyp = math.sqrt((xxypath[xxypath_select].points[fnd_p+1].x[2]-xxypath[xxypath_select].points[fnd_p+1].x[1])^2 + 
                                    (xxypath[xxypath_select].points[fnd_p+1].y[2]-xxypath[xxypath_select].points[fnd_p+1].y[1])^2)
                  end                  
                end
                
                dragcontrolpt = {p = fnd_p, sp = fnd_sp, hyp = hyp}

              else

                mouse.context = contexts.xxypath_dragpt
              
                local dx2,dy2,dx3,dy3
                if fnd_sp == 1 and #xxypath[xxypath_select].points > 1 then
                  dx2 = xxypath[xxypath_select].points[fnd_p].x[2]-xxypath[xxypath_select].points[fnd_p].x[1]
                  dy2 = xxypath[xxypath_select].points[fnd_p].y[2]-xxypath[xxypath_select].points[fnd_p].y[1]                    
                  if fnd_p > 1 then
                    dx3 = xxypath[xxypath_select].points[fnd_p-1].x[4]-xxypath[xxypath_select].points[fnd_p-1].x[3]
                    dy3 = xxypath[xxypath_select].points[fnd_p-1].y[4]-xxypath[xxypath_select].points[fnd_p-1].y[3]
                  end
                elseif #xxypath[xxypath_select].points > 1 then
                  dx3 = xxypath[xxypath_select].points[fnd_p].x[4]-xxypath[xxypath_select].points[fnd_p].x[3]
                  dy3 = xxypath[xxypath_select].points[fnd_p].y[4]-xxypath[xxypath_select].points[fnd_p].y[3]                    
                  if fnd_p < #xxypath[xxypath_select].points-1 then
                    dx2 = xxypath[xxypath_select].points[fnd_p+1].x[2]-xxypath[xxypath_select].points[fnd_p+1].x[1]
                    dy2 = xxypath[xxypath_select].points[fnd_p+1].y[2]-xxypath[xxypath_select].points[fnd_p+1].y[1]
                  end
                end                  
                
                dragpt = {p = fnd_p, sp = fnd_sp, dx2 = dx2, dy2 = dy2, dx3 = dx3, dy3 = dy3}
              
              end
            
            end
          end
        
        end        
      
      elseif mouse.context == nil and (MOUSE_click(obj.sections[221]) or MOUSE_click_RB(obj.sections[221])) then
        local mx,my = mouse.mx,mouse.my
        mouse.mx = mouse.mx-obj.sections[221].x
        mouse.my = mouse.my-obj.sections[221].y

        if MOUSE_click(obj.sections[227]) then
      
          xxypath_edit = not xxypath_edit
          update_xxy = true
          update_snaps = true
          
        elseif MOUSE_click(obj.sections[228]) then

          if xxypath and xxypath[xxypath_select] then
            OpenEB(18,'Please enter a filename for the path:')
          end
          
        elseif MOUSE_click(obj.sections[229]) then
        
          LoadPath()
        
        elseif MOUSE_click(obj.sections[231]) then

          if xxy and xxy[tracks[track_select].strip] and xxy[tracks[track_select].strip][page][sstype_select] then
            local f = {targettype = 1,
                       strip = tracks[track_select].strip,
                       page = page,
                       sstype = sstype_select}
            
            mouse.mx, mouse.my = mx, my
            local fad = SetAutomationFader(f, xxy[tracks[track_select].strip][page][sstype_select].pathfader, true)
            if fad == -2 then
              DeleteFader(xxy[tracks[track_select].strip][page][sstype_select].pathfader)
              update_gfx = true
            elseif fad ~= -1 then
              --if xxy[tracks[track_select].strip][page][sstype_select].pathfader and xxy[tracks[track_select].strip][page][sstype_select].pathfader ~= fad then
              --  faders[xxy[tracks[track_select].strip][page][sstype_select].pathfader] = {}
              --end
              --xxy[tracks[track_select].strip][page][sstype_select].pathfader = fad
              AssignFader(fad,f)
              update_gfx = true
            end
          end
                      
        end
        mouse.mx, mouse.my = mx, my
      
      end
    
      if mouse.context and mouse.context == contexts.xxypath_dragcontrolpt then
        local x = (mouse.mx - obj.sections[220].x) / obj.sections[220].w
        local y = (mouse.my - obj.sections[220].y) / obj.sections[220].h
        XXYPATH_movectlpt(dragcontrolpt,x,y)
        update_gfx = true
      
      elseif mouse.context and mouse.context == contexts.xxypath_dragpt then
        local x = (mouse.mx - obj.sections[220].x) / obj.sections[220].w
        local y = (mouse.my - obj.sections[220].y) / obj.sections[220].h
        XXYPATH_movept(dragpt,x,y)
        update_gfx = true        
      
      elseif mouse.context and mouse.context == contexts.xxypath_posslider then
      
        local pos = F_limit((mouse.mx-obj.sections[230].x)/obj.sections[230].w,0,1)
        if pos ~= oxxysliderpos then
          oxxysliderpos = pos            
          XXYPath_SetPos(tracks[track_select].strip,page,sstype_select,pos)
          update_xxypos = true
        end
      
      elseif mouse.context == nil and dragpt ~= nil or dragcontrolpt ~= nil then
      
        dragpt = nil
        dragcontrolpt = nil
        xxypath[xxypath_select].pathlen = XXYPath_CalcPathLen(xxypath_select)
      
      end
      
    end
  end
  
  function A_Run_SnapshotsLearn()
  
    if show_fsnapshots or show_xysnapshots then
      show_fsnapshots = false
      show_xysnapshots = false
      update_surface = true
    end
    
    if sstype_select > 1 then
      if mouse.context == nil and (MOUSE_click(obj.sections[10])) then -- or MOUSE_click_RB(obj.sections[10])) then
        if mouse.mx > obj.sections[10].x then
          if strips and tracks[track_select] and strips[tracks[track_select].strip] then
            for i = 1, #strips[tracks[track_select].strip][page].controls do
              
              local ctl = strips[tracks[track_select].strip][page].controls[i]
              
              ctlxywh = {x = ctl.xsc - surface_offset.x +obj.sections[10].x, 
                         y = ctl.ysc - surface_offset.y +obj.sections[10].y, 
                         w = ctl.wsc, 
                         h = ctl.hsc}
              if strips[tracks[track_select].strip][page].controls[i].fxfound then
                if MOUSE_click(ctlxywh) then                        
                  
                  if Switcher_CtlsHidden(ctl.switcher, ctl.grpid) == false then
                  
                    if ctl.ctlcat == ctlcats.fxparam or 
                       ctl.ctlcat == ctlcats.trackparam or 
                       ctl.ctlcat == ctlcats.tracksend or 
                       ctl.ctlcat == ctlcats.fxoffline or
                       ctl.ctlcat == ctlcats.midictl then 
                      local strip = tracks[track_select].strip
                      --Add / Remove
                      local ctlidx = GetSnapshotCtlIdx(strip, page, sstype_select, i)
                      if ctlidx then
                        --already added - remove?
                        if snapshots[strip][page][sstype_select].ctls[ctlidx].delete then
                          snapshots[strip][page][sstype_select].ctls[ctlidx].delete = not snapshots[strip][page][sstype_select].ctls[ctlidx].delete
                        else
                          snapshots[strip][page][sstype_select].ctls[ctlidx].delete = true
                        end
                      else
                        --add
                        local ctlidx = #snapshots[strip][page][sstype_select].ctls + 1
                        snapshots[strip][page][sstype_select].ctls[ctlidx] = {c_id = strips[strip][page].controls[i].c_id,
                                                                              ctl = i}
                      end

                    elseif ctl.ctlcat == ctlcats.switcher then
                    
                      switcher_select = i
                      SwitcherMenu_LB()
                     
                    end
                  end
                end
              end
            end
          end
        end      
      elseif mouse.context == nil and (MOUSE_click_RB(obj.sections[10])) then 
        mouse.context = contexts.draglasso
        lasso = {l = mouse.mx, t = mouse.my, r = mouse.mx+5, b = mouse.my+5}
      elseif lasso ~= nil then
        --Dropped
        Lasso_Select(false)
        if ctl_select ~= nil then

          local strip = tracks[track_select].strip
          
          for c = 1, #ctl_select do
            local i = ctl_select[c].ctl
            
            if strips[tracks[track_select].strip][page].controls[i].ctlcat == ctlcats.fxparam or 
               strips[tracks[track_select].strip][page].controls[i].ctlcat == ctlcats.trackparam or 
               strips[tracks[track_select].strip][page].controls[i].ctlcat == ctlcats.tracksend or 
               strips[tracks[track_select].strip][page].controls[i].ctlcat == ctlcats.fxoffline or 
               strips[tracks[track_select].strip][page].controls[i].ctlcat == ctlcats.midictl then 
              --Add / Remove
              local ctlidx = GetSnapshotCtlIdx(strip, page, sstype_select, i)
              if ctlidx then
                --re-add deleted
                if snapshots[strip][page][sstype_select].ctls[ctlidx].delete then
                  snapshots[strip][page][sstype_select].ctls[ctlidx].delete = false
                  strips[tracks[track_select].strip][page].controls[i].dirty = true                  
                end
              else
                --add
                local ctlidx = #snapshots[strip][page][sstype_select].ctls + 1
                snapshots[strip][page][sstype_select].ctls[ctlidx] = {c_id = strips[tracks[track_select].strip][page].controls[i].c_id,
                                                                      ctl = i}
                strips[tracks[track_select].strip][page].controls[i].dirty = true
              end
            end
              
          end
        end
        
        lasso = nil
        ctl_select = nil
        update_ctls = true
        update_surface = true
    
      end
    end
    
  end
  
  function A_Run_SnapshotsWin(rt)
  
    if show_fsnapshots or show_xysnapshots then
      show_fsnapshots = false
      show_xysnapshots = false
      update_surface = true
    end
    
    xywh = {x = obj.sections[160].x,
            y = obj.sections[160].y,
            w = obj.sections[160].w,
            h = butt_h}
    if mouse.context == nil and MOUSE_click(xywh) then
      mouse.context = contexts.movesnapwindow
      movesnapwin = {offx = mouse.mx - obj.sections[160].x,
                     offy = mouse.my - obj.sections[160].y}
    end
    
    local snapmx, snapmy = mouse.mx, mouse.my
    mouse.mx = mouse.mx - obj.sections[160].x
    mouse.my = mouse.my - obj.sections[160].y        
    
    if snaplrn_mode == false then
    
      if mouse.context == nil and MOUSE_click(obj.sections[168]) and mouse.shift == false then
        --update_gfx = true
        knob_select = def_snapshotctl
        if ctl_files[knob_select].imageidx ~= nil then
          local w,_ = gfx.getimgdim(ctl_files[knob_select].imageidx)
          local h = ctl_files[knob_select].cellh
          if w == 0 or h == 0 then
            ksel_size = {w = 50, h = 50}
          else
           ksel_size = {w = w/2, h = h/2}
          end
        else 
          ksel_size = {w = 50, h = 50}
        end
        mouse.context = contexts.addsnapctl          
      
      elseif mouse.context == nil and MOUSE_click_RB(obj.sections[168]) and mouse.shift == false then
      
        RBMenu_Snapshot(snapmx, snapmy)
        
      elseif mouse.context == nil and MOUSE_click(obj.sections[168]) and mouse.shift == true then
      
        if sstype_select > 1 then
          knob_select = def_xyctl
          if ctl_files[knob_select].imageidx ~= nil then
            local w,_ = gfx.getimgdim(ctl_files[knob_select].imageidx)
            local h = ctl_files[knob_select].cellh
            if w == 0 or h == 0 then
              ksel_size = {w = 50, h = 50}
            else
             ksel_size = {w = w/2, h = h/2}
            end
          else 
            ksel_size = {w = 50, h = 50}
          end
          mouse.context = contexts.addxyctl          
        end
                  
      elseif mouse.context == nil and MOUSE_click(obj.sections[165]) then
        mouse.context = contexts.resizesnapwindow
        resizesnapwin = {origh = obj.sections[160].h,
                         offy = mouse.my}          
      
      elseif mouse.context == nil and MOUSE_click(obj.sections[161]) then
      
        if snapshots[tracks[track_select].strip] then
          sstype_select = F_limit(sstype_select + 1, 1, #snapshots[tracks[track_select].strip][page])
        else
          Snapshots_INIT()
          sstype_select = 1
        end
        ss_select = nil
        ssoffset = 0
        update_snaps = true

      elseif mouse.context == nil and MOUSE_click_RB(obj.sections[161]) then
      
        if snapshots[tracks[track_select].strip] then
          sstype_select = F_limit(sstype_select - 1, 1, #snapshots[tracks[track_select].strip][page])
        else
          Snapshots_INIT()
          sstype_select = 1
        end
        ss_select = nil
        ssoffset = 0
        update_snaps = true

      elseif mouse.context == nil and MOUSE_click(obj.sections[162]) then
      
        Snapshots_CREATE(tracks[track_select].strip, page, sstype_select)
        update_snaps = true
        update_ctls = true --to update snapshot ctls

      elseif mouse.context == nil and MOUSE_click_RB(obj.sections[162]) then

        RBMenu_Capture()

      elseif mouse.context == nil and MOUSE_click(obj.sections[169]) then
        if mouse.lastLBclicktime and (rt-mouse.lastLBclicktime) < 0.15 then
          local respectminmax = true
          if mouse.ctrl then respectminmax = false end
          Snapshot_RANDOMIZE(tracks[track_select].strip, page, sstype_select, respectminmax)
          update_ctls = true --to update snapshot ctls
        end  

      elseif mouse.context == nil and MOUSE_click_RB(obj.sections[169]) then

        knob_select = def_boxctl
        if ctl_files[knob_select].imageidx ~= nil then
          local w,_ = gfx.getimgdim(ctl_files[knob_select].imageidx)
          local h = ctl_files[knob_select].cellh
          if w == 0 or h == 0 then
            ksel_size = {w = 50, h = 50}
          else
           ksel_size = {w = w/2, h = h/2}
          end
        else 
          ksel_size = {w = 50, h = 50}
        end
        mouse.context = contexts.snapshot_rand

      elseif mouse.context == nil and MOUSE_click(obj.sections[224]) then
        if sstype_select > 1 then
          show_xxy = true
          if xxy and xxy[tracks[track_select].strip] and xxy[tracks[track_select].strip][page][sstype_select] then
            xxypath_select = xxy[tracks[track_select].strip][page][sstype_select].pathidx
          else
            xxypath_select = nil
          end
          update_gfx = true
        end

      elseif mouse.context == nil and MOUSE_click(obj.sections[166]) then
      
        if snapshots[tracks[track_select].strip] then
          sstype_select = math.max(#snapshots[tracks[track_select].strip][page]+1,2)
        else
          Snapshots_INIT()
          sstype_select = 2
          ssoffset = 0
        end
        Snapshots_CREATE(tracks[track_select].strip, page, sstype_select)
        update_snaps = true
      
      elseif mouse.context == nil and MOUSE_click(obj.sections[167]) then
    
        if sstype_select > 1 then
          snaplrn_mode = true
          navigate = false
          update_gfx = true
        end

      elseif mouse.context == nil and MOUSE_click(obj.sections[164]) then
    
        if sstype_select > 1 then
          OpenEB(15,'Please enter new subset name:')
        end
              
      elseif mouse.context == nil and MOUSE_click(obj.sections[163]) then
        if snapshots and snapshots[tracks[track_select].strip] then
          local i = math.floor((mouse.my-obj.sections[163].y)/butt_h)
      
          if i == 0 then
            local ix = math.floor((mouse.mx-obj.sections[163].x)/(obj.sections[160].w/2))
            if ix == 0 then
              ssoffset = ssoffset-SS_butt_cnt
              if ssoffset < 0 then ssoffset = 0 end
            else
              if sstype_select == 1 then
                ssoffset = F_limit(ssoffset+SS_butt_cnt,0,math.max(0,#snapshots[tracks[track_select].strip][page][sstype_select]-SS_butt_cnt))
              elseif sstype_select > 1 then
                ssoffset = F_limit(ssoffset+SS_butt_cnt,0,math.max(0,#snapshots[tracks[track_select].strip][page][sstype_select].snapshot-SS_butt_cnt))                  
              end
            end
            update_ctls = true
            update_snaps = true
          elseif i > 0 then
            if snapshots and snapshots[tracks[track_select].strip] then
              local maxss
              if sstype_select == 1 then
                maxss = #snapshots[tracks[track_select].strip][page][sstype_select]
                --ss_select = F_limit(ssoffset+i,1,#snapshots[tracks[track_select].strip][page][sstype_select])
              else
                maxss = #snapshots[tracks[track_select].strip][page][sstype_select].snapshot
                --ss_select = F_limit(ssoffset+i,1,#snapshots[tracks[track_select].strip][page][sstype_select].snapshot)                  
              end
              if ssoffset+i <= maxss then
              --if mouse.lastLBclicktime and (rt-mouse.lastLBclicktime) < 0.20 then
                ss_select = ssoffset+i
                Snapshot_Set(tracks[track_select].strip, page, sstype_select, ss_select)
              --end
                update_ctls = true --to update snapshot ctls
                update_snaps = true
                
                if mouse.shift then
                  --Start Moving
                  snap_move = {}
                  snap_move.spos = ssoffset+i
                  snap_move.epos = snap_move.spos
                  mouse.context = contexts.snap_move
                  ssshiftto = reaper.time_precise()
                end          
              end
            end
          end
        end
      --elseif mouse.context == nil and MOUSE_click(obj.sections[163]) and mouse.shift then
        
      elseif MOUSE_click_RB(obj.sections[163]) then
        if ss_select then
          mstr = 'Rename||Delete||Capture (Overwrite)'
          gfx.x, gfx.y = snapmx, snapmy
          res = OpenMenu(mstr)
          if res ~= 0 then
            if res == 1 then
              --EditSSName(11)
              OpenEB(11,'Please enter new snapshot name:')
            elseif res == 2 then
              DeleteSS()
              update_snaps = true
            elseif res == 3 then
              Snapshots_CREATE(tracks[track_select].strip, page, sstype_select, ss_select)
            end
          end
        end        
      end
    elseif mouse.context == nil and MOUSE_click(obj.sections[167]) then
    
      snaplrn_mode = false
      Snap_RemoveDeletedSS(tracks[track_select].strip,page,sstype_select)
      CleanSS(tracks[track_select].strip, page, sstype_select)
      
      navigate = true
      
      update_gfx = true
    
    end
            
    mouse.mx = snapmx
    mouse.my = snapmy
  end
  
  function A_Run_MacroLearn()
    
    -- MACRO LEARN
            
    if MOUSE_click(obj.sections[250]) then
    
      navigate = true
      macro_lrn_mode = false
      Macro_UpdateCtls(tracks[track_select].strip, page, macroctl_select)
      
      update_surface = true
    
    elseif mouse.context == nil and (MOUSE_click(obj.sections[10])) then -- or MOUSE_click_RB(obj.sections[10])) then
      if mouse.mx > obj.sections[10].x then
        if strips and tracks[track_select] and strips[tracks[track_select].strip] then
          local i
          local c = GetControlAtXY(tracks[track_select].strip, page, mouse.mx, mouse.my)
          if c then
            i = c
            local ctl = strips[tracks[track_select].strip][page].controls[i]
            ctlxywh = {x = ctl.xsc - surface_offset.x +obj.sections[10].x, 
                       y = ctl.ysc - surface_offset.y +obj.sections[10].y, 
                       w = ctl.wsc, 
                       h = ctl.hsc} 
          end
                      
          if i then

            if strips[tracks[track_select].strip][page].controls[i].fxfound then
              if MOUSE_click(ctlxywh) then
    
                if strips[tracks[track_select].strip][page].controls[i].ctlcat == ctlcats.fxparam or 
                   strips[tracks[track_select].strip][page].controls[i].ctlcat == ctlcats.trackparam or 
                   strips[tracks[track_select].strip][page].controls[i].ctlcat == ctlcats.tracksend or 
                   strips[tracks[track_select].strip][page].controls[i].ctlcat == ctlcats.fxoffline then 
                  local strip = tracks[track_select].strip
                  
                  --Add / Remove
                  local ctlidx = GetMacroCtlIdx(strip, page, macroctl_select, i)
                  if ctlidx then
                    --already added - remove?
                    if strips[strip][page].controls[macroctl_select].macroctl[ctlidx].delete then
                      strips[strip][page].controls[macroctl_select].macroctl[ctlidx].delete = not strips[strip][page].controls[macroctl_select].macroctl[ctlidx].delete
                    else
                      strips[strip][page].controls[macroctl_select].macroctl[ctlidx].delete = true
                    end
                  
                  else
                    --add
                    if strips[strip][page].controls[macroctl_select].macroctl == nil then
                      strips[strip][page].controls[macroctl_select].macroctl = {}
                    end
                    local ctlidx = #strips[strip][page].controls[macroctl_select].macroctl + 1
                    strips[strip][page].controls[macroctl_select].macroctl[ctlidx] = {c_id = strips[tracks[track_select].strip][page].controls[i].c_id,
                                                                                      ctl = i,
                                                                                      A_val = 0,
                                                                                      B_val = 1,
                                                                                      shape = 1,
                                                                                      bi = false}
                  end
                end
              end
            end
          end
        end
      end      
      
    elseif mouse.context == nil and (MOUSE_click_RB(obj.sections[10])) then 
      mouse.context = contexts.draglasso
      lasso = {l = mouse.mx, t = mouse.my, r = mouse.mx+5, b = mouse.my+5}
      
    --[[elseif mouse.context and mouse.context == contexts.draglasso then
    DBG('A')
      if math.abs(lasso.l - mouse.mx) > 10 or math.abs(lasso.t - mouse.my) > 10 then
        lasso.r = mouse.mx
        lasso.b = mouse.my

        Lasso_Select(false)
        update_surface = true
      end]]
      
    elseif lasso ~= nil then
      --Dropped
      
      Lasso_Select(false)
      if ctl_select ~= nil then
  
        local strip = tracks[track_select].strip
        
        for c = 1, #ctl_select do
          local i = ctl_select[c].ctl
          
          if strips[tracks[track_select].strip][page].controls[i].ctlcat == ctlcats.fxparam or 
             strips[tracks[track_select].strip][page].controls[i].ctlcat == ctlcats.trackparam or 
             strips[tracks[track_select].strip][page].controls[i].ctlcat == ctlcats.tracksend or 
             strips[tracks[track_select].strip][page].controls[i].ctlcat == ctlcats.fxoffline then 
            --Add / Remove
            local ctlidx = GetMacroCtlIdx(strip, page, macroctl_select, i)
            if ctlidx then
              --re-add deleted
              if strips[strip][page].controls[macroctl_select].macroctl[ctlidx].delete then
                strips[strip][page].controls[macroctl_select].macroctl[ctlidx].delete = false
                strips[tracks[track_select].strip][page].controls[i].dirty = true                  
              end
            else
              --add
              if strips[strip][page].controls[macroctl_select].macroctl == nil then
                strips[strip][page].controls[macroctl_select].macroctl = {}
              end
              local ctlidx = #strips[strip][page].controls[macroctl_select].macroctl + 1
              strips[strip][page].controls[macroctl_select].macroctl[ctlidx] = {c_id = strips[tracks[track_select].strip][page].controls[i].c_id,
                                                                                ctl = i,
                                                                                A_val = 0,
                                                                                B_val = 1,
                                                                                shape = 1,
                                                                                bi = false}
              strips[tracks[track_select].strip][page].controls[i].dirty = true
            end
          end
            
        end
      end
      
      lasso = nil
      ctl_select = nil
      update_ctls = true
      update_surface = true
  
    end
  end
  
  function A_Run_MacroEdit(noscroll, rt)

    if strips[tracks[track_select].strip] and strips[tracks[track_select].strip][page].controls[macroctl_select] and
       strips[tracks[track_select].strip][page].controls[macroctl_select].ctlcat == ctlcats.macro then
      
      navigate = false
      noscroll = true
              
      local xywh = {x = obj.sections[300].x+obj.sections[401].x,
                    y = obj.sections[300].y+obj.sections[401].y,
                    w = obj.sections[401].w,
                    h = obj.sections[401].h}
      if mouse.context == nil and MOUSE_click(xywh) then
      
        navigate = true
        macro_edit_mode = false
        macroctl_select = nil
        update_gfx = true
        
      else

        local macroctl = strips[tracks[track_select].strip][page].controls[macroctl_select].macroctl
        if gfx.mouse_wheel ~= 0 and MOUSE_over(obj.sections[300]) then
        
          v = gfx.mouse_wheel/120
          macroedit_poffs = F_limit(macroedit_poffs-v,0,#macroctl-1)
          --DBG(macroedit_poffs)
        
          update_gfx = true
        end

        local mx, my = mouse.mx, mouse.my
        mouse.mx, mouse.my = mouse.mx - obj.sections[300].x, mouse.my - obj.sections[300].y
        
        local xywh_403 = {x = obj.sections[403].x - (macroedit.sliderw*0.5),
                          y = obj.sections[403].y,
                          w = obj.sections[403].w + macroedit.sliderw,
                          h = obj.sections[403].h}
        local xywh_404 = {x = obj.sections[404].x - (macroedit.sliderw*0.5),
                          y = obj.sections[404].y,
                          w = obj.sections[404].w + macroedit.sliderw,
                          h = obj.sections[404].h}

        if mouse.context == nil and MOUSE_click(obj.sections[410]) then
        
          if mouse.lastLBclicktime and (rt-mouse.lastLBclicktime) < 0.15 then
            local i = macroctl_select
            strips[tracks[track_select].strip][page].controls[i].val = strips[tracks[track_select].strip][page].controls[i].defval
            SetMacro(tracks[track_select].strip,page,i)
            update_macroedit = true
          else
            local i = macroctl_select
            macctlactive = i
            mouse.context = contexts.macctl2
            mouse.slideoff = obj.sections[410].y+obj.sections[410].h/2 - mouse.my
            ctlpos = ctlScaleInv(nz(strips[tracks[track_select].strip][page].controls[i].scalemode,8),
                                 strips[tracks[track_select].strip][page].controls[i].val)
            oms = mouse.shift
          end
          
        elseif mouse.context == nil and MOUSE_click(xywh_403) then
          local yy = math.floor((mouse.my - obj.sections[403].y)/macroedit.sech)
          if macroctl[(yy+1)+macroedit_poffs] then

            local val = macroctl[(yy+1)+macroedit_poffs].A_val
            local xywh = {x = obj.sections[403].x + (val*obj.sections[403].w) -(macroedit.sliderw*0.5),
                          y = obj.sections[403].y + (yy*macroedit.sech) + (macroedit.sech*0.5) - (macroedit.sliderh*0.5),
                          w = macroedit.sliderw,
                          h = macroedit.sliderh}
            if MOUSE_over(xywh) then
            
              mouse.context = contexts.macsliderA
              macslide = {xoff = mouse.mx-(xywh.x+(xywh.w*0.5)), macparamidx = (yy+1)+macroedit_poffs}

            end
        
          end
          
        elseif mouse.context == nil and MOUSE_click(xywh_404) then
          local yy = math.floor((mouse.my - obj.sections[404].y)/macroedit.sech)
          if macroctl[(yy+1)+macroedit_poffs] then

            local val = macroctl[(yy+1)+macroedit_poffs].B_val
            local xywh = {x = obj.sections[404].x + (val*obj.sections[404].w) -(macroedit.sliderw*0.5),
                          y = obj.sections[404].y + (yy*macroedit.sech) + (macroedit.sech*0.5) - (macroedit.sliderh*0.5),
                          w = macroedit.sliderw,
                          h = macroedit.sliderh}
            if MOUSE_over(xywh) then
            
              mouse.context = contexts.macsliderB
              macslide = {xoff = mouse.mx-(xywh.x+(xywh.w*0.5)), macparamidx = (yy+1)+macroedit_poffs}

            end
        
          end                  
            
        elseif mouse.context == nil and MOUSE_click(obj.sections[405]) then
          local yy = math.floor((mouse.my - obj.sections[405].y)/macroedit.sech)
          if macroctl[(yy+1)+macroedit_poffs] then

            macroctl[(yy+1)+macroedit_poffs].shape = macroctl[(yy+1)+macroedit_poffs].shape + 1
            if macroctl[(yy+1)+macroedit_poffs].shape > #macroscale_table then
              macroctl[(yy+1)+macroedit_poffs].shape = 1
            end
            update_gfx = true

          end              

        elseif mouse.context == nil and MOUSE_click_RB(obj.sections[405]) then
          local yy = math.floor((mouse.my - obj.sections[405].y)/macroedit.sech)
          if macroctl[(yy+1)+macroedit_poffs] then

            macroctl[(yy+1)+macroedit_poffs].shape = macroctl[(yy+1)+macroedit_poffs].shape - 1
            if macroctl[(yy+1)+macroedit_poffs].shape < 1 then
              macroctl[(yy+1)+macroedit_poffs].shape = #macroscale_table
            end
            update_gfx = true

          end              
        
        elseif mouse.context == nil and MOUSE_click(obj.sections[406]) then
          local yy = math.floor((mouse.my - obj.sections[406].y)/macroedit.sech)
          if macroctl[(yy+1)+macroedit_poffs] then
            local xywh = {x = obj.sections[406].x,
                          y = obj.sections[406].y + yy*macroedit.sech + 0.5*macroedit.sech - 10,
                          w = obj.sections[406].w,
                          h = 20}                
            if MOUSE_over(xywh) then
          
              macroctl[(yy+1)+macroedit_poffs].mute = not nz(macroctl[(yy+1)+macroedit_poffs].mute,false)
              update_macrobutt = true
              
            end
          end    

        elseif mouse.context == nil and MOUSE_click(obj.sections[414]) then
          local yy = math.floor((mouse.my - obj.sections[414].y)/macroedit.sech)
          if macroctl[(yy+1)+macroedit_poffs] then
            local xywh = {x = obj.sections[414].x,
                          y = obj.sections[414].y + yy*macroedit.sech + 0.5*macroedit.sech - 10,
                          w = obj.sections[414].w,
                          h = 20}                
            if MOUSE_over(xywh) then
          
              macroctl[(yy+1)+macroedit_poffs].bi = not nz(macroctl[(yy+1)+macroedit_poffs].bi,false)
              if settings_macroeditmonitor then
                SetMacro(tracks[track_select].strip,page,macroctl_select,true)
              end

              update_macrobutt = true
              
            end
          end    

        elseif mouse.context == nil and MOUSE_click(obj.sections[415]) then
          local yy = math.floor((mouse.my - obj.sections[415].y)/macroedit.sech)
          if macroctl[(yy+1)+macroedit_poffs] then
            local xywh = {x = obj.sections[415].x,
                          y = obj.sections[415].y + yy*macroedit.sech + 0.5*macroedit.sech - 10,
                          w = obj.sections[415].w,
                          h = 20}                
            if MOUSE_over(xywh) then
          
              macroctl[(yy+1)+macroedit_poffs].inv = not nz(macroctl[(yy+1)+macroedit_poffs].inv,false)
              if settings_macroeditmonitor then
                SetMacro(tracks[track_select].strip,page,macroctl_select,true)
              end

              update_macrobutt = true
              
            end
          end    

        elseif mouse.context == nil and MOUSE_click(obj.sections[416]) then
          local yy = math.floor((mouse.my - obj.sections[416].y)/macroedit.sech)
          if macroctl[(yy+1)+macroedit_poffs] then
            local xywh = {x = obj.sections[416].x,
                          y = obj.sections[416].y + yy*macroedit.sech + 0.5*macroedit.sech - 10,
                          w = obj.sections[416].w,
                          h = 20}                
            if MOUSE_over(xywh) then
          
              macroctl[(yy+1)+macroedit_poffs].relative = not nz(macroctl[(yy+1)+macroedit_poffs].relative,false)
              if macroctl[(yy+1)+macroedit_poffs].relative == false and settings_macroeditmonitor then
                SetMacro(tracks[track_select].strip,page,macroctl_select,true)
              end

              update_macrobutt = true
              
            end
          end    

        elseif mouse.context == nil and MOUSE_click(obj.sections[407]) then
          local yy = math.floor((mouse.my - obj.sections[407].y)/macroedit.sech)
          if macroctl[(yy+1)+macroedit_poffs] then
            local xywh = {x = obj.sections[407].x,
                          y = obj.sections[407].y + yy*macroedit.sech + 0.5*macroedit.sech - 10,
                          w = obj.sections[407].w,
                          h = 20}                
            if MOUSE_over(xywh) then
          
              local mcnt = #macroctl
              macroctl[(yy+1)+macroedit_poffs] = nil
              local mtab = Table_RemoveNils(macroctl, mcnt)
              strips[tracks[track_select].strip][page].controls[macroctl_select].macroctl = mtab
              update_gfx = true
              
            end
          end    

        elseif mouse.context == nil and MOUSE_click(obj.sections[408]) then

          local f = {targettype = 2,
                     strip = tracks[track_select].strip,
                     page = page,
                     ctl = macroctl_select,
                     c_id = strips[tracks[track_select].strip][page].controls[macroctl_select].c_id}
            
          mouse.mx, mouse.my = mx, my
          local fad = SetAutomationFader(f, strips[tracks[track_select].strip][page].controls[macroctl_select].macrofader, true)
          if fad == -2 then
            DeleteFader(strips[tracks[track_select].strip][page].controls[macroctl_select].macrofader)
            update_gfx = true
          elseif fad ~= -1 then
            --if strips[tracks[track_select].strip][page].controls[macroctl_select].macrofader and strips[tracks[track_select].strip][page].controls[macroctl_select].macrofader ~= fad then
            --  faders[strips[tracks[track_select].strip][page].controls[macroctl_select].macrofader] = {}
            --end
            --strips[tracks[track_select].strip][page].controls[macroctl_select].macrofader = fad
            AssignFader(fad, f)
            update_gfx = true
          end

        elseif mouse.context == nil and MOUSE_click(obj.sections[409]) then

          macro_lrn_mode = true
          update_gfx = true

        elseif mouse.context == nil and MOUSE_click(obj.sections[411]) then

          Macro_Capture(tracks[track_select].strip,page,macroctl_select,0)
          if settings_macroeditmonitor then
            SetMacro(tracks[track_select].strip,page,macroctl_select,true)
          end
          update_macroedit = true

        elseif mouse.context == nil and MOUSE_click(obj.sections[412]) then

          Macro_Capture(tracks[track_select].strip,page,macroctl_select,1)
          if settings_macroeditmonitor then
            SetMacro(tracks[track_select].strip,page,macroctl_select,true)
          end
          update_macroedit = true

        elseif mouse.context == nil and MOUSE_click(obj.sections[413]) then

          settings_macroeditmonitor = not settings_macroeditmonitor
          update_gfx = true

        end
        
        if mouse.context and mouse.context == contexts.macctl2 then
          
          --local tfxp_s = macroctl_select
          local val = MOUSE_slider(obj.sections[410],mouse.slideoff)
          if val ~= nil then
            local ctl = strips[tracks[track_select].strip][page].controls[macroctl_select]
            if oms ~= mouse.shift then
              oms = mouse.shift
              ctlpos = ctl.val
              mouse.slideoff = ctlxywh.y+ctlxywh.h/2 - mouse.my
            else
              if mouse.shift then
                local mult = ctl.knobsens.fine
                if mult == 0 then mult = settings_defknobsens.fine end
                val = ctlpos + ((0.5-val)*2)*mult
              else
                local mult = ctl.knobsens.norm
                if mult == 0 then mult = settings_defknobsens.norm end
                val = ctlpos + (0.5-val)*mult
              end
              if val < 0 then val = 0 end
              if val > 1 then val = 1 end
              val = ctlScale(ctl.scalemode, val)
              if val ~= octlval then
                ctl.diff = val - ctl.val
                ctl.oval = ctl.val
                ctl.val = val
                SetMacro(tracks[track_select].strip, page, macroctl_select)
                ctl.dirty = true
                octlval = val
                --update_ctls = true
                update_macroedit = true
                --update_ctls = false
              end
            end
          end
        
        elseif mouse.context == nil and macctlactive ~= nil then
        
          local strip = tracks[track_select].strip
          local mac = strips[strip][page].controls[macctlactive].macroctl
          strips[strip][page].controls[macctlactive].diff = nil
          for m = 1, #mac do
            --strips[strip][page].controls[mac[m].ctl].mval = nil
          end
          macctlactive = nil
          
        elseif mouse.context and mouse.context == contexts.macsliderA then
        
          local v = F_limit((mouse.mx - macslide.xoff - obj.sections[403].x)/obj.sections[403].w,0,1)
          macroctl[macslide.macparamidx].A_val = v
          if settings_macroeditmonitor then
            SetMacro(tracks[track_select].strip, page, macroctl_select,true)
          end
          update_macroedit = true
        
        elseif mouse.context and mouse.context == contexts.macsliderB then
        
          local v = F_limit((mouse.mx - macslide.xoff - obj.sections[404].x)/obj.sections[404].w,0,1)
          macroctl[macslide.macparamidx].B_val = v
          if settings_macroeditmonitor then
            SetMacro(tracks[track_select].strip, page, macroctl_select,true)
          end              
          update_macroedit = true
        
        end
        
        noscroll = true
        mouse.mx, mouse.my = mx, my

      end
    else
      navigate = true
      macro_edit_mode = false
      macroctl_select = nil
      update_gfx = true          
    end
    return noscroll
      
  end
  
  function A_Run_DropDown()
  
    if MOUSE_over(ddlist) then
    
      local over = math.floor((mouse.my - ddlist.y)/butt_h)+1
      if over ~= ddlist.over then
      
        ddlist.over = over
        update_dd = true
        update_surface = true
      
      end
      
      if mouse.LB then
        ddlist.select = over
        show_dd = false
        update_surface = true
      end

      if ddlist.select then
        DropDown_ItemSel(ddlist.select)
      end    
      
    else
      ddlist.over = nil
      if mouse.LB then
        show_dd = false          
        update_surface = true
      end
    end
  
  end

  function DropDown_ItemSel(sel)
  
    if sel then
      if ddlist.idx == 1 then
      
        RCM_Set(rcm_select, sel)
      
      elseif ddlist.idx == 2 then
      
        Switcher_Set(switcher_select, sel)
        
      end
    end
    mouse.context = contexts.dd
  
  end
  
  function Switcher_Set(switcher_select, sel)
  
    local strip = tracks[track_select].strip
    local ctl = strips[strip][page].controls[switcher_select]
    local switchid = ctl.switcherid
    
    if switchers[switchid].grpids[sel] then
      switchers[switchid].current = switchers[switchid].grpids[sel].id
      ctl.param_info.paramname = string.format('%i',sel)..': '..switchers[switchid].grpids[sel].name
      update_gfx = true
      update_bg = true
  
      if ctl.switchfader then
        SetFader(ctl.switchfader, (sel-1+faders[ctl.switchfader].voffset)/128)
      end
      SetCtlBitmapRedraw()
    end
      
  end

  function Switcher_Set2(switcher_select, sel, strip, page)
  
    if strips[strip] then
      local ctl = strips[strip][page].controls[switcher_select]
      if ctl then
        local switchid = ctl.switcherid
        
        if switchers[switchid].grpids[sel] and ctl then
          switchers[switchid].current = switchers[switchid].grpids[sel].id
          ctl.param_info.paramname = string.format('%i',sel)..': '..switchers[switchid].grpids[sel].name
          update_gfx = true
          update_bg = true
      
          SetCtlBitmapRedraw()
        end
      end
    end      
  end
  
  function A_Run_EQControl(noscroll, rt)
  
    if strips[tracks[track_select].strip] and strips[tracks[track_select].strip][page].controls[eqcontrol_select] and
       strips[tracks[track_select].strip][page].controls[eqcontrol_select].ctlcat == ctlcats.eqcontrol then
  
      EQC_UpdateVals()
      
      local bands = strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands
      
      local xywh = {x = obj.sections[300].x+obj.sections[351].x,
                    y = obj.sections[300].y+obj.sections[351].y,
                    w = obj.sections[351].w,
                    h = obj.sections[351].h}
      if mouse.context == nil and MOUSE_click(xywh) then
      
        navigate = true
        show_eqcontrol = false
        eq_edit = false
        eqcontrolband_select = nil
        update_gfx = true
        
      end

      local mx, my = mouse.mx, mouse.my
      mouse.mx, mouse.my = mouse.mx - obj.sections[300].x, mouse.my - obj.sections[300].y

      local xywh_pmin, xywh_pmax,xywh_gmin, xywh_gmax, xywh_main
      if bands then
        if eqcontrolband_select and bands[eqcontrolband_select] and 
           bands[eqcontrolband_select].freq_param then
        
          local xmin = nz(bands[eqcontrolband_select].posmin,0)
          local xmax = nz(bands[eqcontrolband_select].posmax,1)
          
          xywh_pmin = {x = obj.sections[302].x + (xmin * obj.sections[302].w) - 4,
                       y = obj.sections[302].y + obj.sections[302].h + 2,
                       w = 8,
                       h = 8}
          xywh_pmax = {x = obj.sections[302].x + (xmax * obj.sections[302].w) - 4,
                       y = obj.sections[302].y + obj.sections[302].h + 2,
                       w = 8,
                       h = 8}

          local ymin = nz(bands[eqcontrolband_select].gmin,0)
          local ymax = nz(bands[eqcontrolband_select].gmax,1)

          xywh_gmin = {x = obj.sections[302].x-12,
                       y = obj.sections[302].y+obj.sections[302].h - (ymin * obj.sections[302].h) - 4,
                       w = 8,
                       h = 8}
          xywh_gmax = {x = obj.sections[302].x-12,
                       y = obj.sections[302].y+obj.sections[302].h - (ymax * obj.sections[302].h) - 4,
                       w = 8,
                       h = 8}
        end
      end
  
      local xywh_main = {x = obj.sections[302].x-10,
                         y = obj.sections[302].y-10,
                         w = obj.sections[302].w+20,
                         h = obj.sections[302].h+20}
  
      if gfx.mouse_wheel ~= 0 then
        if MOUSE_over(xywh_main) then
      
          local track = GetTrack(tracks[track_select].tracknum)
          local fxnum = GetEQC_FXNum(eqcontrolband_select)
          
          if fxnum ~= -1 then
            local param = bands[eqcontrolband_select].q_param
            
            if param then
              local mw = gfx.mouse_wheel/120
              if bands[eqcontrolband_select].q_inv then
                mw = -mw
              end
              local v = F_limit(bands[eqcontrolband_select].q_val + (mw*0.05),0,1)
              
              if v ~= ov then
                reaper.TrackFX_SetParam(track,fxnum,param,v)
                ov = v
                update_eqcontrol = true
              end
            end
          end
                      
        elseif MOUSE_over(obj.sections[303]) then
          local mw = gfx.mouse_wheel/120
          eqcontrolband_select = F_limit(eqcontrolband_select + mw,1,#bands)
          update_gfx = true          

        elseif MOUSE_over(obj.sections[325]) then

          local track = GetTrack(tracks[track_select].tracknum)
          local fxnum = GetEQC_FXNum(eqcontrolband_select)
          local param = bands[eqcontrolband_select].freq_param

          if param then
            local mw = gfx.mouse_wheel/120

            local v
            local mult = 0.015
            if mouse.shift then
              mult = 0.001
            end
            
            v = F_limit(bands[eqcontrolband_select].freq_val + (mw*mult),0,1)
            if v ~= ov then
              reaper.TrackFX_SetParam(track,fxnum,param,v)
              ov = v
              update_eqcontrol = true
            end
          end
          gfx.mouse_wheel = 0

        elseif MOUSE_over(obj.sections[326]) then

          local track = GetTrack(tracks[track_select].tracknum)
          local fxnum = GetEQC_FXNum(eqcontrolband_select)
          local param = bands[eqcontrolband_select].gain_param

          if param then
            local mw = gfx.mouse_wheel/120

            local v
            local mult = 0.015
            if mouse.shift then
              mult = 0.001
            end
            
            v = F_limit(bands[eqcontrolband_select].gain_val + (mw*mult),0,1)
            if v ~= ov then
              reaper.TrackFX_SetParam(track,fxnum,param,v)
              ov = v
              update_eqcontrol = true
            end
          end
          gfx.mouse_wheel = 0

        elseif MOUSE_over(obj.sections[327]) then

          local track = GetTrack(tracks[track_select].tracknum)
          local fxnum = GetEQC_FXNum(eqcontrolband_select)
          local param = bands[eqcontrolband_select].q_param

          if param then
            local mw = gfx.mouse_wheel/120

            local v
            local mult = 0.05
            if mouse.shift then
              mult = 0.005
            end
            
            v = F_limit(bands[eqcontrolband_select].q_val + (mw*mult),0,1)
            if v ~= ov then
              reaper.TrackFX_SetParam(track,fxnum,param,v)
              ov = v
              update_eqcontrol = true
            end
          end
          gfx.mouse_wheel = 0

        elseif MOUSE_over(obj.sections[328]) then

          local track = GetTrack(tracks[track_select].tracknum)
          local fxnum = GetEQC_FXNum(eqcontrolband_select)
          local param = bands[eqcontrolband_select].c1_param

          if param then
            local mw = gfx.mouse_wheel/120

            local v
            local mult = 0.015
            if mouse.shift then
              mult = 0.001
            end
            
            v = F_limit(bands[eqcontrolband_select].c1_val + (mw*mult),0,1)
            if v ~= ov then
              reaper.TrackFX_SetParam(track,fxnum,param,v)
              ov = v
              update_eqcontrol = true
            end
          end
          gfx.mouse_wheel = 0

        elseif MOUSE_over(obj.sections[329]) then

          local track = GetTrack(tracks[track_select].tracknum)
          local fxnum = GetEQC_FXNum(eqcontrolband_select)
          local param = bands[eqcontrolband_select].c2_param

          if param then
            local mw = gfx.mouse_wheel/120

            local v
            local mult = 0.015
            if mouse.shift then
              mult = 0.001
            end
            
            v = F_limit(bands[eqcontrolband_select].c2_val + (mw*mult),0,1)
            if v ~= ov then
              reaper.TrackFX_SetParam(track,fxnum,param,v)
              ov = v
              update_eqcontrol = true
            end
          end
          gfx.mouse_wheel = 0

        elseif MOUSE_over(obj.sections[330]) then

          local track = GetTrack(tracks[track_select].tracknum)
          local fxnum = GetEQC_FXNum(eqcontrolband_select)
          local param = bands[eqcontrolband_select].c3_param

          if param then
            local mw = gfx.mouse_wheel/120

            local v
            local mult = 0.015
            if mouse.shift then
              mult = 0.001
            end
            
            v = F_limit(bands[eqcontrolband_select].c3_val + (mw*mult),0,1)
            if v ~= ov then
              reaper.TrackFX_SetParam(track,fxnum,param,v)
              ov = v
              update_eqcontrol = true
            end
          end
          gfx.mouse_wheel = 0

        elseif MOUSE_over(obj.sections[334]) then

          local track = GetTrack(tracks[track_select].tracknum)
          local fxnum = GetEQC_FXNum(eqcontrolband_select)
          local param = bands[eqcontrolband_select].c4_param

          if param then
            local mw = gfx.mouse_wheel/120

            local v
            local mult = 0.015
            if mouse.shift then
              mult = 0.001
            end
            
            v = F_limit(bands[eqcontrolband_select].c4_val + (mw*mult),0,1)
            if v ~= ov then
              reaper.TrackFX_SetParam(track,fxnum,param,v)
              ov = v
              update_eqcontrol = true
            end
          end
          gfx.mouse_wheel = 0

        elseif MOUSE_over(obj.sections[335]) then

          local track = GetTrack(tracks[track_select].tracknum)
          local fxnum = GetEQC_FXNum(eqcontrolband_select)
          local param = bands[eqcontrolband_select].c5_param
          
          if param then
            local mw = gfx.mouse_wheel/120

            local v
            local mult = 0.015
            if mouse.shift then
              mult = 0.001
            end
            
            v = F_limit(bands[eqcontrolband_select].c5_val + (mw*mult),0,1)
            if v ~= ov then
              reaper.TrackFX_SetParam(track,fxnum,param,v)
              ov = v
              update_eqcontrol = true
            end
          end
          gfx.mouse_wheel = 0
          
        end
        
      end
      
      if eq_edit and xywh_pmin and mouse.context == nil and eqcontrolband_select and MOUSE_click(xywh_pmin) then
        mouse.context = contexts.eqc_pminslider
        draggraph = true
      elseif eq_edit and xywh_pmax and mouse.context == nil and eqcontrolband_select and MOUSE_click(xywh_pmax) then
        mouse.context = contexts.eqc_pmaxslider
        draggraph = true
      
      elseif eq_edit and xywh_gmin and mouse.context == nil and eqcontrolband_select and MOUSE_click(xywh_gmin) then
        mouse.context = contexts.eqc_gminslider
        --draggraph = true
      elseif eq_edit and xywh_gmax and mouse.context == nil and eqcontrolband_select and MOUSE_click(xywh_gmax) then
        mouse.context = contexts.eqc_gmaxslider
        --draggraph = true
      elseif mouse.context == nil and (MOUSE_click(xywh_main) or MOUSE_click_RB(xywh_main)) then
        local bs
        if bands then
          for b = 1, #bands do  
            
            if eq_single == false or b == eqcontrolband_select then
              local fv = bands[b].freq_val
              local gv = bands[b].gain_val
              local xmin = bands[b].posmin
              local xmax = bands[b].posmax
              local ymin = bands[b].gmin
              local ymax = bands[b].gmax

              if eq_scale == false then
                xmin = 0
                xmax = 1
                ymin = 0
                ymax = 1
              end

              if fv and gv then
                local xp = (fv * (xmax-xmin)*obj.sections[302].w)+(xmin*obj.sections[302].w)
                if bands[b].gain_inv then
                  gv = 1-gv
                end
                local yp = obj.sections[302].h-(ymin*obj.sections[302].h) - (gv * (ymax-ymin)*obj.sections[302].h)
                --local yp = obj.sections[302].h - (gv * obj.sections[302].h)
                 
                local xywh = {}
                xywh.x = obj.sections[302].x + xp - 8
                xywh.y = obj.sections[302].y + yp - 8
                xywh.w = 16
                xywh.h = 16
                
                if MOUSE_over(xywh) then
                
                  if mouse.LB and mouse.lastLBclicktime and (rt-mouse.lastLBclicktime) < 0.2 then
                    EQC_SetDefault(b)
                    break                          
                  end
                  
                  if mouse.RB then
                    if bands[b].bypass_param then
                      bands[b].bypass_val = 
                            1-bands[b].bypass_val
                      EQC_SetParam(b,bands[b].bypass_param,
                                   bands[b].bypass_val)
                      update_gfx = true
                    end
                    break
                  elseif mouse.ctrl then
                    EQC_SetDefault(b)
                    break
                  else
                    bs = b
                    eqcdrag = {xoff = mouse.mx - xywh.x-8, yoff = mouse.my - xywh.y-8, xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, mx = mouse.mx, my = mouse.my}
                    update_gfx = true
                    break
                  end
                end
              end
            end
                                      
          end

          if bs then
            eqcontrolband_select = bs
            update_gfx = true
            mouse.context = contexts.eqc_drag
          end
        end
      
      elseif eq_edit == false and mouse.context == nil and MOUSE_click(obj.sections[325]) then
        if bands and
           bands[eqcontrolband_select] then
          if bands[eqcontrolband_select].freq_param then
            if mouse.ctrl or(mouse.lastLBclicktime and (rt-mouse.lastLBclicktime) < 0.2) then
              local b = eqcontrolband_select
              if bands[b].freq_def then
                EQC_SetParam(b, bands[b].freq_param, bands[b].freq_def)
              end
            else
              eqcdraginf = {my = mouse.my, yoff = mouse.my - obj.sections[325].y}
              mouse.context = contexts.eqc_dragfreq
            end
          end
        end
      elseif eq_edit == false and mouse.context == nil and MOUSE_click(obj.sections[326]) then
        if bands and
           bands[eqcontrolband_select] then
          if bands[eqcontrolband_select].gain_param then
            if mouse.ctrl or(mouse.lastLBclicktime and (rt-mouse.lastLBclicktime) < 0.2) then
              local b = eqcontrolband_select
              if bands[b].gain_def then
                EQC_SetParam(b, bands[b].gain_param, bands[b].gain_def)
              end
            else
              eqcdraginf = {my = mouse.my, yoff = mouse.my - obj.sections[326].y}
              mouse.context = contexts.eqc_draggain
            end
          end
        end
      elseif eq_edit == false and mouse.context == nil and MOUSE_click(obj.sections[327]) then
        if bands and
           bands[eqcontrolband_select] then
          if bands[eqcontrolband_select].q_param then
            if mouse.ctrl or(mouse.lastLBclicktime and (rt-mouse.lastLBclicktime) < 0.2) then
              local b = eqcontrolband_select
              if bands[b].q_def then
                EQC_SetParam(b, bands[b].q_param, bands[b].q_def)
              end
            else
              eqcdraginf = {my = mouse.my, yoff = mouse.my - obj.sections[327].y}
              mouse.context = contexts.eqc_dragq
            end
          end
        end
      elseif eq_edit == false and mouse.context == nil and MOUSE_click(obj.sections[328]) then
        if bands and
           bands[eqcontrolband_select] then
          if bands[eqcontrolband_select].c1_param then
            if mouse.ctrl or(mouse.lastLBclicktime and (rt-mouse.lastLBclicktime) < 0.2) then
              local b = eqcontrolband_select
              if bands[b].c1_def then
                EQC_SetParam(b, bands[b].c1_param, bands[b].c1_def)
              end
            else
              eqcdraginf = {my = mouse.my, yoff = mouse.my - obj.sections[328].y}
              mouse.context = contexts.eqc_dragc1
            end
          end
        end
      elseif eq_edit == false and mouse.context == nil and MOUSE_click(obj.sections[329]) then
        if bands and
           bands[eqcontrolband_select] then
          if bands[eqcontrolband_select].c2_param then
            if mouse.ctrl or(mouse.lastLBclicktime and (rt-mouse.lastLBclicktime) < 0.2) then
              local b = eqcontrolband_select
              if bands[b].c2_def then
                EQC_SetParam(b, bands[b].c2_param, bands[b].c2_def)
              end
            else
              eqcdraginf = {my = mouse.my, yoff = mouse.my - obj.sections[329].y}
              mouse.context = contexts.eqc_dragc2
            end
          end
        end
      elseif eq_edit == false and mouse.context == nil and MOUSE_click(obj.sections[330]) then
        if bands and
           bands[eqcontrolband_select] then
          if bands[eqcontrolband_select].c3_param then
            if mouse.ctrl or(mouse.lastLBclicktime and (rt-mouse.lastLBclicktime) < 0.2) then
              local b = eqcontrolband_select
              if bands[b].c3_def then
                EQC_SetParam(b, bands[b].c3_param, bands[b].c3_def)
              end
            else
              eqcdraginf = {my = mouse.my, yoff = mouse.my - obj.sections[330].y}
              mouse.context = contexts.eqc_dragc3
            end
          end
        end
      elseif eq_edit == false and mouse.context == nil and MOUSE_click(obj.sections[334]) then
        if bands and
           bands[eqcontrolband_select] then
          if bands[eqcontrolband_select].c4_param then
            if mouse.ctrl or(mouse.lastLBclicktime and (rt-mouse.lastLBclicktime) < 0.2) then
              local b = eqcontrolband_select
              if bands[b].c4_def then
                EQC_SetParam(b, bands[b].c4_param, bands[b].c4_def)
              end
            else
              eqcdraginf = {my = mouse.my, yoff = mouse.my - obj.sections[334].y}
              mouse.context = contexts.eqc_dragc4
            end
          end
        end
      elseif eq_edit == false and mouse.context == nil and MOUSE_click(obj.sections[335]) then
        if bands and
           bands[eqcontrolband_select] then
          if bands[eqcontrolband_select].c5_param then
            if mouse.ctrl or(mouse.lastLBclicktime and (rt-mouse.lastLBclicktime) < 0.2) then
              local b = eqcontrolband_select
              if bands[b].c5_def then
                EQC_SetParam(b, bands[b].c5_param, bands[b].c5_def)
              end
            else
              eqcdraginf = {my = mouse.my, yoff = mouse.my - obj.sections[335].y}
              mouse.context = contexts.eqc_dragc5
            end
          end
        end
                              
      elseif mouse.context == nil and MOUSE_click(obj.sections[304]) then
      
        EQC_LoadBand()
      
      elseif mouse.context == nil and MOUSE_click(obj.sections[311]) then
        eq_edit = not eq_edit
        if eqcontrolband_select == nil then
          eq_edit = false
        end
        update_gfx = true

      elseif mouse.context == nil and MOUSE_click(obj.sections[320]) then
        eq_single = not eq_single
        if eq_single == true then
          eq_scale = false
        else
          eq_scale = true
        end
        update_gfx = true

      elseif mouse.context == nil and MOUSE_click(obj.sections[321]) then
        eq_scale = not eq_scale
        update_gfx = true

      elseif mouse.context == nil and MOUSE_click(obj.sections[345]) then
        EQC_OpenEQs(eqcontrolband_select, true)
        --update_gfx = true
      
      elseif eq_edit and mouse.context == nil and MOUSE_click(obj.sections[340]) then

        OpenEB(32,'Please enter EQ name:')

      elseif eq_edit and mouse.context == nil and MOUSE_click(obj.sections[312]) then

        EQC_SaveBand()

      elseif eq_edit and mouse.context == nil and MOUSE_click(obj.sections[315]) then

        EQC_DelBand()
        if #bands == 0 then
          eqcontrolband_select = nil
          eq_edit = false
        end

      elseif eq_edit and mouse.context == nil and MOUSE_click(obj.sections[313]) then
      
        EQC_SelectBandType()

      elseif eq_edit and mouse.context == nil and MOUSE_click(obj.sections[314]) then
      
        OpenEB(30,'Please enter band name:')

      elseif eq_edit and mouse.context == nil and MOUSE_click(obj.sections[355]) then

        if bands and bands[eqcontrolband_select] then
          local retval, c = reaper.GR_SelectColor(_,ConvertColorString(bands[eqcontrolband_select].col))
          if retval ~= 0 then
            bands[eqcontrolband_select].col = ConvertColor(c)
            update_gfx = true
          end
        end

      elseif eq_edit and mouse.context == nil and MOUSE_click(obj.sections[356]) then

        if bands and bands[eqcontrolband_select] then
          local fxnum = bands[eqcontrolband_select].fxnum
          local track = GetTrack(tracks[track_select].tracknum)
          
          local p = bands[eqcontrolband_select].freq_param
          if p then
            bands[eqcontrolband_select].freq_def = EQC_GetParam(track, fxnum, p)
          end
          p = bands[eqcontrolband_select].gain_param
          if p then
            bands[eqcontrolband_select].gain_def = EQC_GetParam(track, fxnum, p)
          end
          p = bands[eqcontrolband_select].q_param
          if p then
            bands[eqcontrolband_select].q_def = EQC_GetParam(track, fxnum, p)
          end
          p = bands[eqcontrolband_select].c1_param
          if p then
            bands[eqcontrolband_select].c1_def = EQC_GetParam(track, fxnum, p)
          end
          p = bands[eqcontrolband_select].c2_param
          if p then
            bands[eqcontrolband_select].c2_def = EQC_GetParam(track, fxnum, p)
          end
          p = bands[eqcontrolband_select].c3_param
          if p then
            bands[eqcontrolband_select].c3_def = EQC_GetParam(track, fxnum, p)
          end
          p = bands[eqcontrolband_select].c4_param
          if p then
            bands[eqcontrolband_select].c4_def = EQC_GetParam(track, fxnum, p)
          end
          p = bands[eqcontrolband_select].c5_param
          if p then
            bands[eqcontrolband_select].c5_def = EQC_GetParam(track, fxnum, p)
          end
          
          OpenMsgBox(1,'Default parameter values captured.',1)
        end              

      elseif eq_edit and mouse.context == nil and MOUSE_click_RB(obj.sections[355]) then

        if bands and bands[eqcontrolband_select] then
          local col = round(math.random()*255)..' '..round(math.random()*255)..' '..round(math.random()*255) 
          bands[eqcontrolband_select].col = col
          update_gfx = true
        end
        
      elseif mouse.context == nil and (MOUSE_click(obj.sections[303]) or MOUSE_click_RB(obj.sections[303])) then
      
        if bands then
          local bw = obj.sections[303].w / 20
          local bs = math.floor((mouse.mx - obj.sections[303].x)/bw)+1
          if bs <= #bands then
            if mouse.ctrl or mouse.RB then
              if bands[bs].bypass_param then
                bands[bs].bypass_val = 
                      1-bands[bs].bypass_val
                EQC_SetParam(bs,bands[bs].bypass_param,
                             bands[bs].bypass_val)
                update_gfx = true
              end
            else
              eqcontrolband_select = bs
            end
            update_gfx = true
          end
        end
      elseif eq_edit and mouse.context == nil and MOUSE_click(obj.sections[305]) and eqcontrolband_select then
        local track = GetTrack(tracks[track_select].tracknum)
        local fxcnt = reaper.TrackFX_GetCount(track)
        local mstr = ''
        for fxn = 1, fxcnt do
          local _, fxname = reaper.TrackFX_GetFXName(track, fxn-1, '')
          mstr = mstr..fxn..': '..fxname
          if fxn < fxcnt then
            mstr = mstr..'|'
          end
        end
        gfx.x, gfx.y = mouse.mx, mouse.my
        res = OpenMenu(mstr)
        if res ~= 0 then
          local _, fxname = reaper.TrackFX_GetFXName(track, res-1, '')
          local fxguid = reaper.TrackFX_GetFXGUID(track, res-1)
          bands[eqcontrolband_select] = {}
          bands[eqcontrolband_select].fxnum = res-1
          bands[eqcontrolband_select].fxguid = fxguid
          bands[eqcontrolband_select].fxname = fxname
          bands[eqcontrolband_select].posmin = 0
          bands[eqcontrolband_select].posmax = 1
          bands[eqcontrolband_select].gmin = 0
          bands[eqcontrolband_select].gmax = 1
          bands[eqcontrolband_select].col = '160 160 160'
          
          --[[local s = string.find(fxname,'ReaEQ')
          if s and s > 0 then
            OpenMsgBox(1,'ReaEQ is not recommended for use with EQ Control.', 1, 'Using ReaEQ will produce unexpected control and graph behaviour.')
          end ]]
          update_gfx = true
        end            

      elseif eq_edit and mouse.context == nil and MOUSE_click(obj.sections[322]) and eqcontrolband_select then
        local res = EQC_SelectParam()
        if res ~= 0 then
          if res == -1 then
            bands[eqcontrolband_select].bypass_param = nil
            bands[eqcontrolband_select].bypass_param_name = nil              
          else
            local fxnum = bands[eqcontrolband_select].fxnum
            local track = GetTrack(tracks[track_select].tracknum)
            
            local p = res - 1
            local _, pname = reaper.TrackFX_GetParamName(track, fxnum, p, '')
            bands[eqcontrolband_select].bypass_param = p
            bands[eqcontrolband_select].bypass_param_name = pname
          end                
          update_gfx = true
        end            
        
      elseif eq_edit and mouse.context == nil and MOUSE_click(obj.sections[323]) and eqcontrolband_select then
        local res = EQC_SelectParam()
        if res ~= 0 then
          if res == -1 then
            bands[eqcontrolband_select].c1_param = nil
            bands[eqcontrolband_select].c1_param_name = nil              
            bands[eqcontrolband_select].c1_def = nil          
          else
            local fxnum = bands[eqcontrolband_select].fxnum
            local track = GetTrack(tracks[track_select].tracknum)
            
            local p = res - 1
            local _, pname = reaper.TrackFX_GetParamName(track, fxnum, p, '')
            bands[eqcontrolband_select].c1_param = p
            bands[eqcontrolband_select].c1_param_name = pname
            bands[eqcontrolband_select].c1_def = EQC_GetParam(track, fxnum, p)
          end              
          update_gfx = true
        end            
        
      elseif eq_edit and mouse.context == nil and MOUSE_click(obj.sections[324]) and eqcontrolband_select then
        local res = EQC_SelectParam()
        if res ~= 0 then
          if res == -1 then
            bands[eqcontrolband_select].c2_param = nil
            bands[eqcontrolband_select].c2_param_name = nil              
            bands[eqcontrolband_select].c2_def = nil          
          else
            local fxnum = bands[eqcontrolband_select].fxnum
            local track = GetTrack(tracks[track_select].tracknum)
            
            local p = res - 1
            local _, pname = reaper.TrackFX_GetParamName(track, fxnum, p, '')
            bands[eqcontrolband_select].c2_param = p
            bands[eqcontrolband_select].c2_param_name = pname
            bands[eqcontrolband_select].c2_def = EQC_GetParam(track, fxnum, p)
          end              
          update_gfx = true
        end            
        
      elseif eq_edit and mouse.context == nil and MOUSE_click(obj.sections[331]) and eqcontrolband_select then
        local res = EQC_SelectParam()
        if res ~= 0 then
          if res == -1 then
            bands[eqcontrolband_select].c3_param = nil
            bands[eqcontrolband_select].c3_param_name = nil              
            bands[eqcontrolband_select].c3_def = nil          
          else
            local fxnum = bands[eqcontrolband_select].fxnum
            local track = GetTrack(tracks[track_select].tracknum)
            
            local p = res - 1
            local _, pname = reaper.TrackFX_GetParamName(track, fxnum, p, '')
            bands[eqcontrolband_select].c3_param = p
            bands[eqcontrolband_select].c3_param_name = pname
            bands[eqcontrolband_select].c3_def = EQC_GetParam(track, fxnum, p)
          end              
          update_gfx = true
        end            
        
      elseif eq_edit and mouse.context == nil and MOUSE_click(obj.sections[332]) and eqcontrolband_select then
        local res = EQC_SelectParam()
        if res ~= 0 then
          if res == -1 then
            bands[eqcontrolband_select].c4_param = nil
            bands[eqcontrolband_select].c4_param_name = nil              
            bands[eqcontrolband_select].c4_def = nil          
          else
            local fxnum = bands[eqcontrolband_select].fxnum
            local track = GetTrack(tracks[track_select].tracknum)
            
            local p = res - 1
            local _, pname = reaper.TrackFX_GetParamName(track, fxnum, p, '')
            bands[eqcontrolband_select].c4_param = p
            bands[eqcontrolband_select].c4_param_name = pname
            bands[eqcontrolband_select].c4_def = EQC_GetParam(track, fxnum, p)
          end              
          update_gfx = true
        end            
        
      elseif eq_edit and mouse.context == nil and MOUSE_click(obj.sections[333]) and eqcontrolband_select then
        local res = EQC_SelectParam()
        if res ~= 0 then
          if res == -1 then
            bands[eqcontrolband_select].c5_param = nil
            bands[eqcontrolband_select].c5_param_name = nil              
            bands[eqcontrolband_select].c5_def = nil          
          else
            local fxnum = bands[eqcontrolband_select].fxnum
            local track = GetTrack(tracks[track_select].tracknum)
            
            local p = res - 1
            local _, pname = reaper.TrackFX_GetParamName(track, fxnum, p, '')
            bands[eqcontrolband_select].c5_param = p
            bands[eqcontrolband_select].c5_param_name = pname
            bands[eqcontrolband_select].c5_def = EQC_GetParam(track, fxnum, p)
          end              
          update_gfx = true
        end            
        
      elseif eq_edit and mouse.context == nil and MOUSE_click(obj.sections[306]) and eqcontrolband_select then
        local res = EQC_SelectParam()
        if res ~= 0 then
          if res == -1 then
            bands[eqcontrolband_select].freq_param = nil
            bands[eqcontrolband_select].freq_param_name = nil
            bands[eqcontrolband_select].freq_def = nil          
          else
            local fxnum = bands[eqcontrolband_select].fxnum
            local track = GetTrack(tracks[track_select].tracknum)
            
            local p = res - 1
            local _, pname = reaper.TrackFX_GetParamName(track, fxnum, p, '')
            bands[eqcontrolband_select].freq_param = p
            bands[eqcontrolband_select].freq_param_name = pname
            bands[eqcontrolband_select].freq_def = EQC_GetParam(track, fxnum, p)
            
            bands[eqcontrolband_select].freq_min = nz(calc_eqgraph_getmin(tracks[track_select].tracknum, fxnum, p, true),20)
            bands[eqcontrolband_select].freq_max = nz(calc_eqgraph_getmax(tracks[track_select].tracknum, fxnum, p, true),24000)
          end
          update_gfx = true
        end            

      elseif eq_edit and mouse.context == nil and MOUSE_click(obj.sections[307]) and eqcontrolband_select then
        local res = EQC_SelectParam()
        if res ~= 0 then
          if res == -1 then
            bands[eqcontrolband_select].gain_param = nil
            bands[eqcontrolband_select].gain_param_name = nil
            bands[eqcontrolband_select].gain_def = nil
          else
            local fxnum = bands[eqcontrolband_select].fxnum
            local track = GetTrack(tracks[track_select].tracknum)
            
            local p = res - 1
            local _, pname = reaper.TrackFX_GetParamName(track, fxnum, p, '')
            bands[eqcontrolband_select].gain_param = p
            bands[eqcontrolband_select].gain_param_name = pname
            bands[eqcontrolband_select].gain_def = EQC_GetParam(track, fxnum, p)
            
            bands[eqcontrolband_select].gain_min = nz(calc_eqgraph_getmin(tracks[track_select].tracknum, fxnum, p),-20)
            bands[eqcontrolband_select].gain_max = nz(calc_eqgraph_getmax(tracks[track_select].tracknum, fxnum, p),20)
          end              
          update_gfx = true
        end            

      elseif eq_edit and mouse.context == nil and MOUSE_click(obj.sections[308]) and eqcontrolband_select then
        local res = EQC_SelectParam()
        if res ~= 0 then
          if res == -1 then
            bands[eqcontrolband_select].q_param = nil
            bands[eqcontrolband_select].q_param_name = nil
            bands[eqcontrolband_select].q_def = nil
          else
            local fxnum = bands[eqcontrolband_select].fxnum
            local track = GetTrack(tracks[track_select].tracknum)
            
            local _, pname = reaper.TrackFX_GetParamName(track, fxnum, res-1, '')
            bands[eqcontrolband_select].q_param = res-1
            bands[eqcontrolband_select].q_param_name = pname
            bands[eqcontrolband_select].q_def = EQC_GetParam(track, fxnum, res-1)
          end              
          update_gfx = true
        end            

      elseif eq_edit and mouse.context == nil and MOUSE_click(obj.sections[337]) and eqcontrolband_select then
        mouse.context = contexts.auto_delayslider
        autodelay = true

      elseif eq_edit and mouse.context == nil and MOUSE_click(obj.sections[336]) and eqcontrolband_select then

        bands[eqcontrolband_select].lookmap = nil
        bands[eqcontrolband_select].gmap = nil
        update_gfx = true            

      elseif eq_edit and mouse.context == nil and MOUSE_click(obj.sections[357]) then
        if bands and #bands > 0 then

          for b = 1,#bands do
            EQC_AlignGraph(b)
          end
          update_gfx = true            

        end
          
      elseif eq_edit and mouse.context == nil and MOUSE_click_RB(obj.sections[309]) and eqcontrolband_select then
        if bands[eqcontrolband_select].fxnum then
          if bands[eqcontrolband_select].freq_param then
            
            if bands[eqcontrolband_select].lookmap and 
               mouse.ctrl == false then
              EQC_AlignGraph(eqcontrolband_select,2)                
            end
          end
        end
      elseif eq_edit and mouse.context == nil and MOUSE_click(obj.sections[309]) and eqcontrolband_select then
        if bands[eqcontrolband_select].fxnum then
          if bands[eqcontrolband_select].freq_param then
            
            if bands[eqcontrolband_select].lookmap and 
               mouse.ctrl == false then
              EQC_AlignGraph(eqcontrolband_select,1)                
            else
              local fxnum = GetEQC_FXNum(eqcontrolband_select)
              if fxnum ~= -1 then
                local param = bands[eqcontrolband_select].freq_param                  
                local param2 = bands[eqcontrolband_select].gain_param

                --EQC_OpenEQs(eqcontrolband_select, true)

                --[[strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[eqcontrolband_select].freq_min = 
                                                                    nz(calc_eqgraph_getmin(tracks[track_select].tracknum, fxnum, param),20)
                strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[eqcontrolband_select].freq_max = 
                                                                    nz(calc_eqgraph_getmax(tracks[track_select].tracknum, fxnum, param, true),24000)]]

                local min = nz(bands[eqcontrolband_select].freq_min,20)
                local max = nz(bands[eqcontrolband_select].freq_max,24000)
                local khz = bands[eqcontrolband_select].khz

                --[[strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[eqcontrolband_select].gain_min = 
                                                                    nz(calc_eqgraph_getmin(tracks[track_select].tracknum, fxnum, param2),-20)
                strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[eqcontrolband_select].gain_max = 
                                                                    nz(calc_eqgraph_getmax(tracks[track_select].tracknum, fxnum, param2),20)]]

                local min2 = nz(bands[eqcontrolband_select].gain_min,-20)
                local max2 = nz(bands[eqcontrolband_select].gain_max,20)
                
                local lm, gm = calc_eqgraph(tracks[track_select].tracknum,fxnum,param,min,max,khz,param2,min2,max2)
                bands[eqcontrolband_select].lookmap = lm
                bands[eqcontrolband_select].gmap = gm

                --EQC_OpenEQs(eqcontrolband_select, false)
                
                EQC_AlignGraph(eqcontrolband_select,1)
                
                if bands[eqcontrolband_select].posmax > 1 then
                  bands[eqcontrolband_select].posmax = 1
                end
              end
              update_gfx = true
            end
          end
        end

      elseif eq_edit and mouse.context == nil and MOUSE_click(obj.sections[310]) and eqcontrolband_select then
        --strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqgraph = eqcontrolband_select
        --strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqgraph = EQC_SetMain(eqcontrolband_select)
        OpenMsgBox(2,'Save/overwrite default eq graph?',2)
        update_gfx = true

      elseif eq_edit and mouse.context == nil and MOUSE_click(obj.sections[317]) and eqcontrolband_select then
        bands[eqcontrolband_select].gain_inv = not bands[eqcontrolband_select].gain_inv
        update_gfx = true

      elseif eq_edit and mouse.context == nil and MOUSE_click(obj.sections[318]) and eqcontrolband_select then
        bands[eqcontrolband_select].q_inv = not bands[eqcontrolband_select].q_inv
        update_gfx = true

      elseif eq_edit and mouse.context == nil and MOUSE_click(obj.sections[316]) and eqcontrolband_select then
        bands[eqcontrolband_select].khz = not bands[eqcontrolband_select].khz
        update_gfx = true
        
      end
    
      if mouse.context and mouse.context == contexts.eqc_drag then

        local mmx, fv, yy, gv
        if mouse.shift == true then
          fv = bands[eqcontrolband_select].freq_val
          gv = bands[eqcontrolband_select].gain_val

          local dx = mouse.mx - eqcdrag.mx
          local dy = mouse.my - eqcdrag.my
          
          fv = F_limit(fv + (dx*0.0001),0,1)
          gv = F_limit(gv - (dy*0.0001),0,1)      
          
          eqcdrag.mx = mouse.mx
          eqcdrag.my = mouse.my
          
        else
          mmx = (mouse.mx-eqcdrag.xoff)-(obj.sections[302].x)
          fv = F_limit((mmx-(eqcdrag.xmin*obj.sections[302].w))/((eqcdrag.xmax-eqcdrag.xmin)*obj.sections[302].w),0,1)
          
          yy = obj.sections[302].y+(obj.sections[302].h-(eqcdrag.ymax * obj.sections[302].h))
          gv = (mouse.my-eqcdrag.yoff-yy)/((eqcdrag.ymax-eqcdrag.ymin)*obj.sections[302].h)
          
          gv = F_limit(1-gv,0,1)

          if bands[eqcontrolband_select].gain_inv then
            gv = 1-gv
          end
        end
                    
        local track = GetTrack(tracks[track_select].tracknum)
        local fxnum = GetEQC_FXNum(eqcontrolband_select)
        
        if fxnum ~= -1 then
          local param = bands[eqcontrolband_select].freq_param
          if param and fv ~= ofv then
            reaper.TrackFX_SetParamNormalized(track,fxnum,param,fv)
          
            update_eqcontrol = true
            ofv = fv
          end

          param = bands[eqcontrolband_select].gain_param              
          if param and gv ~= ogv then
            reaper.TrackFX_SetParamNormalized(track,fxnum,param,gv)
          
            update_eqcontrol = true
            ogv = gv
          end
        end            
      elseif mouse.context and mouse.context == contexts.eqc_dragfreq then
      
        local v = bands[eqcontrolband_select].freq_val
        local dy = mouse.my - eqcdraginf.my
        if mouse.shift then
          v = F_limit(v-(dy*0.0002),0,1)              
        else
          v = F_limit(v-(dy*0.0015),0,1)
        end
        local track = GetTrack(tracks[track_select].tracknum)
        local fxnum = GetEQC_FXNum(eqcontrolband_select)
        
        if fxnum ~= -1 then
          local param = bands[eqcontrolband_select].freq_param
          if param and v ~= ov then
            reaper.TrackFX_SetParamNormalized(track,fxnum,param,v)
          
            update_eqcontrol = true
            ov = v
          end
          eqcdraginf.my = mouse.my
        end  
      elseif mouse.context and mouse.context == contexts.eqc_draggain then
    
        local v = bands[eqcontrolband_select].gain_val
        local dy = mouse.my - eqcdraginf.my
        if mouse.shift then
          v = F_limit(v-(dy*0.0002),0,1)              
        else
          v = F_limit(v-(dy*0.0015),0,1)
        end
        local track = GetTrack(tracks[track_select].tracknum)
        local fxnum = GetEQC_FXNum(eqcontrolband_select)
        
        if fxnum ~= -1 then
          local param = bands[eqcontrolband_select].gain_param
          if param and v ~= ov then
            reaper.TrackFX_SetParamNormalized(track,fxnum,param,v)
          
            update_eqcontrol = true
            ov = v
          end
          eqcdraginf.my = mouse.my
        end
          
      elseif mouse.context and mouse.context == contexts.eqc_dragq then
    
        local v = bands[eqcontrolband_select].q_val
        local dy = mouse.my - eqcdraginf.my
        if mouse.shift then
          v = F_limit(v-(dy*0.0002),0,1)              
        else
          v = F_limit(v-(dy*0.0015),0,1)
        end
        local track = GetTrack(tracks[track_select].tracknum)
        local fxnum = GetEQC_FXNum(eqcontrolband_select)
        
        if fxnum ~= -1 then
          local param = bands[eqcontrolband_select].q_param
          if param and v ~= ov then
            reaper.TrackFX_SetParamNormalized(track,fxnum,param,v)
          
            update_eqcontrol = true
            ov = v
          end
          eqcdraginf.my = mouse.my
        end
          
      elseif mouse.context and mouse.context == contexts.eqc_dragc1 then
    
        local v = bands[eqcontrolband_select].c1_val
        local dy = mouse.my - eqcdraginf.my
        if mouse.shift then
          v = F_limit(v-(dy*0.0002),0,1)              
        else
          v = F_limit(v-(dy*0.0015),0,1)
        end
        local track = GetTrack(tracks[track_select].tracknum)
        local fxnum = GetEQC_FXNum(eqcontrolband_select)
        
        if fxnum ~= -1 then
          local param = bands[eqcontrolband_select].c1_param
          if param and v ~= ov then
            reaper.TrackFX_SetParamNormalized(track,fxnum,param,v)
          
            update_eqcontrol = true
            ov = v
          end
          eqcdraginf.my = mouse.my
        end
          
      elseif mouse.context and mouse.context == contexts.eqc_dragc2 then
    
        local v = bands[eqcontrolband_select].c2_val
        local dy = mouse.my - eqcdraginf.my
        if mouse.shift then
          v = F_limit(v-(dy*0.0002),0,1)              
        else
          v = F_limit(v-(dy*0.0015),0,1)
        end
        local track = GetTrack(tracks[track_select].tracknum)
        local fxnum = GetEQC_FXNum(eqcontrolband_select)
        
        if fxnum ~= -1 then
          local param = bands[eqcontrolband_select].c2_param
          if param and v ~= ov then
            reaper.TrackFX_SetParamNormalized(track,fxnum,param,v)
          
            update_eqcontrol = true
            ov = v
          end
          eqcdraginf.my = mouse.my
        end
          
      elseif mouse.context and mouse.context == contexts.eqc_dragc3 then
    
        local v = bands[eqcontrolband_select].c3_val
        local dy = mouse.my - eqcdraginf.my
        if mouse.shift then
          v = F_limit(v-(dy*0.0002),0,1)              
        else
          v = F_limit(v-(dy*0.0015),0,1)
        end
        local track = GetTrack(tracks[track_select].tracknum)
        local fxnum = GetEQC_FXNum(eqcontrolband_select)
        
        if fxnum ~= -1 then
          local param = bands[eqcontrolband_select].c3_param
          if param and v ~= ov then
            reaper.TrackFX_SetParamNormalized(track,fxnum,param,v)
          
            update_eqcontrol = true
            ov = v
          end
          eqcdraginf.my = mouse.my
        end
          
      elseif mouse.context and mouse.context == contexts.eqc_dragc4 then
    
        local v = bands[eqcontrolband_select].c4_val
        local dy = mouse.my - eqcdraginf.my
        if mouse.shift then
          v = F_limit(v-(dy*0.0002),0,1)              
        else
          v = F_limit(v-(dy*0.0015),0,1)
        end
        local track = GetTrack(tracks[track_select].tracknum)
        local fxnum = GetEQC_FXNum(eqcontrolband_select)
        
        if fxnum ~= -1 then
          local param = bands[eqcontrolband_select].c4_param
          if param and v ~= ov then
            reaper.TrackFX_SetParamNormalized(track,fxnum,param,v)
          
            update_eqcontrol = true
            ov = v
          end
          eqcdraginf.my = mouse.my
        end
          
      elseif mouse.context and mouse.context == contexts.eqc_dragc5 then
    
        local v = bands[eqcontrolband_select].c5_val
        local dy = mouse.my - eqcdraginf.my
        if mouse.shift then
          v = F_limit(v-(dy*0.0002),0,1)              
        else
          v = F_limit(v-(dy*0.0015),0,1)
        end
        local track = GetTrack(tracks[track_select].tracknum)
        local fxnum = GetEQC_FXNum(eqcontrolband_select)
        
        if fxnum ~= -1 then
          local param = bands[eqcontrolband_select].c5_param
          if param and v ~= ov then
            reaper.TrackFX_SetParamNormalized(track,fxnum,param,v)
          
            update_eqcontrol = true
            ov = v
          end
          eqcdraginf.my = mouse.my
        end
                                
      elseif mouse.context and mouse.context == contexts.eqc_pminslider then
        local xx = mouse.mx - obj.sections[302].x
        local pos = F_limit((xx / obj.sections[302].w),0,bands[eqcontrolband_select].posmax-0.01)
        
        if mouse.shift then
          local posdif = pos-bands[eqcontrolband_select].posmin
          local posm = bands[eqcontrolband_select].posmax + posdif
          if posm < 1 then
            bands[eqcontrolband_select].posmax = posm                   
            bands[eqcontrolband_select].posmin = pos
          else 
            posdif = posm - 1
            posm = 1
            pos = pos - posdif
            bands[eqcontrolband_select].posmax = posm                   
            bands[eqcontrolband_select].posmin = pos                
          end
        else
          bands[eqcontrolband_select].posmin = pos            
        end
        update_gfx = true
        
      elseif mouse.context and mouse.context == contexts.eqc_pmaxslider then
        local xx = mouse.mx - obj.sections[302].x
        local pos = F_limit((xx / obj.sections[302].w),bands[eqcontrolband_select].posmin+0.01,1)
        
        if mouse.shift then
          local posdif = pos-bands[eqcontrolband_select].posmax
          local posm = bands[eqcontrolband_select].posmin + posdif
          if posm > 0 then
            bands[eqcontrolband_select].posmin = posm                   
            bands[eqcontrolband_select].posmax = pos
          else
            posdif = -posm
            posm = 0
            pos = pos + posdif
            bands[eqcontrolband_select].posmin = posm                   
            bands[eqcontrolband_select].posmax = pos                
          end
        else
          bands[eqcontrolband_select].posmax = pos
        end
        update_gfx = true

      elseif mouse.context and mouse.context == contexts.eqc_gminslider then
        local yy = mouse.my - obj.sections[302].y
        
        local pos = 1-F_limit((yy / obj.sections[302].h),0,1)
        
        --[[if pos > strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[eqcontrolband_select].gmax - 0.01 then
          pos = strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[eqcontrolband_select].gmax - 0.01
        end]]
        if pos > 0.5 then pos = 0.5 end
        
        if mouse.shift then
          bands[eqcontrolband_select].gmin = pos
        else
          bands[eqcontrolband_select].gmin = pos
          bands[eqcontrolband_select].gmax = 1-pos 
        end
        update_gfx = true

      elseif mouse.context and mouse.context == contexts.eqc_gmaxslider then
        local yy = mouse.my - obj.sections[302].y
        
        local pos = 1-F_limit((yy / obj.sections[302].h),0,1)

        --[[if pos < strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[eqcontrolband_select].gmin + 0.01 then
          pos = strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[eqcontrolband_select].gmin + 0.01
        end   ]]         
        if pos < 0.5 then pos = 0.5 end

        if mouse.shift then
          bands[eqcontrolband_select].gmax = pos
        else
          bands[eqcontrolband_select].gmax = pos
          bands[eqcontrolband_select].gmin = 1-pos 
        end
        update_gfx = true
      
      elseif mouse.context and mouse.context == contexts.auto_delayslider then
        local val = F_limit(MOUSE_sliderHBar(obj.sections[337]),0,1)
        if val ~= nil then
          auto_delay = math.floor(val * 10)
          update_gfx = true
        end
      
      elseif autodelay then
        autodelay = nil
        local fxnum = GetEQC_FXNum(eqcontrolband_select)
        local param = bands[eqcontrolband_select].freq_param                              
        local param2 = bands[eqcontrolband_select].gain_param
        bands[eqcontrolband_select].freq_min = nz(calc_eqgraph_getmin(tracks[track_select].tracknum, fxnum, param, true),20)
        bands[eqcontrolband_select].freq_max = nz(calc_eqgraph_getmax(tracks[track_select].tracknum, fxnum, param, true),24000)            
        bands[eqcontrolband_select].gain_min = nz(calc_eqgraph_getmin(tracks[track_select].tracknum, fxnum, param2),-20)
        bands[eqcontrolband_select].gain_max = nz(calc_eqgraph_getmax(tracks[track_select].tracknum, fxnum, param2),20)
        update_gfx = true
        
      elseif eqcdrag then
        eqcdrag = nil
        update_gfx = true
      elseif draggraph then
        draggraph = nil
        update_gfx = true
      end
      noscroll = true
      mouse.mx, mouse.my = mx, my
    else
    
      navigate = true
      show_eqcontrol = false
      eq_edit = false
      eqcontrolband_select = nil
      update_gfx = true
    
    end
    
    return noscroll
    
  end
  
  function A_Run_InsertStrip()
    
    insertstrip.x = mouse.mx
    insertstrip.y = mouse.my
    
    if not mouse.shift then
      nx = surface_offset.x - (math.floor(surface_offset.x/settings_gridsize)*settings_gridsize)
      ny = surface_offset.y - (math.floor(surface_offset.y/settings_gridsize)*settings_gridsize)
      insertstrip.x = math.floor((insertstrip.x-obj.sections[10].x+surface_offset.x+nx)/settings_gridsize)*settings_gridsize -surface_offset.x+obj.sections[10].x-insertstrip.dx 
      insertstrip.y = math.floor((insertstrip.y-obj.sections[10].y+surface_offset.y+ny)/settings_gridsize)*settings_gridsize -surface_offset.y+obj.sections[10].y-insertstrip.dy
    end
    
    if MOUSE_click(obj.sections[10]) then
      --drop
      local dx, dy = insertstrip.x-obj.sections[10].x, insertstrip.y-obj.sections[10].y+math.floor(insertstrip.dy/settings_gridsize)*settings_gridsize
      Strip_AddStrip(loadstrip,dx,dy,true)
      
      update_gfx = true
      reaper.MarkProjectDirty(0)
      insertstrip = nil
    elseif MOUSE_click_RB(obj.sections[10]) then
      --cancel
      insertstrip = nil
    end
    
    update_surface = true
    
  end

  function Process_EB()
  
    if gfx.mouse_cap&1 == 1 then
      if not mouse.down then
        OnMouseDown()      
        if mouse.uptime and os.clock()-mouse.uptime < 0.25 then 
          OnMouseDoubleClick()
        end
      elseif gfx.mouse_x ~= mouse.lx or gfx.mouse_y ~= mouse.ly then
        OnMouseMove() 
      end
    elseif mouse.down then 
      OnMouseUp() 
    end
    if mouse.LB == true and MOUSE_over(obj.sections[6]) or EB_Enter then
      --OK
      EB_Enter = false
      if EB_Open == 1 then
        SaveStrip3(editbox.text)
      elseif EB_Open == 2 then
        EditCtlName2(editbox.text)
        update_gfx = true
      elseif EB_Open == 3 then
        EditDValOffset2(editbox.text)
        update_gfx = true
      elseif EB_Open == 4 then
        EditMinDVal2(editbox.text)
        update_gfx = true
      elseif EB_Open == 16 then
        EditMaxDVal2(editbox.text)
        update_gfx = true
      elseif EB_Open == 5 then
        EditValue2(editbox.text)
        --update_ctls = true
      elseif EB_Open == 6 then
        InsertLabel2(editbox.text)
      elseif EB_Open == 7 then
        EditLabel2(editbox.text)
        update_gfx = true
      elseif EB_Open == 8 then
        EditFont2(editbox.text)
        update_gfx = true
      elseif EB_Open == 10 then
        EditCycleDV(editbox.text)        
      elseif EB_Open == 11 then
        EditSSName2(editbox.text)
        update_snaps = true
      --elseif EB_Open == 12 then
        --[[trackfxparam_select = ctl_select[1].ctl
        retval, comid = reaper.GetUserInputs('Action Button', 1, 'Please enter action command ID: ,extrawidth=196', '')
        if retval == true and comid then
          local actnm = AssAction_GetNameFromID(comid)
          AssActionByID(comid,actnm)
          update_gfx = true          
        end]]
        --OpenEB(13,'Please enter action command ID:')
      --[[elseif EB_Open == 13 then
        trackfxparam_select = ctl_select[1].ctl
        retval, comid = reaper.GetUserInputs('Action Button', 1, 'Please enter action command ID: ,extrawidth=196', '')
        if retval == true and comid then
          local actnm = AssAction_GetNameFromID(comid)
          AssActionByID(comid,actnm)
          update_gfx = true          
        end]]
        --AssActionByID(editbox.text)
        --update_gfx = true          
      elseif EB_Open == 14 then
        action_tblF = ActionListFilter(editbox.text)
        al_offset = 0
        update_gfx = true
      elseif EB_Open == 15 then
        EditSubName(editbox.text)
        update_snaps = true
      elseif EB_Open == 17 then
        local sc = tonumber(editbox.text)
        if sc then
          cycle_select.statecnt = F_limit(sc,0,max_cycle)
          Cycle_InitData()
        end
        update_surface = true
      elseif EB_Open == 18 then
        SavePath(editbox.text)
      elseif EB_Open == 20 then
        SaveSet(editbox.text)
      elseif EB_Open == 30 then
        strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[eqcontrolband_select].bandname = editbox.text
        update_gfx = true
      elseif EB_Open == 31 then
        strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[eqcontrolband_select].bandtype = editbox.text
        local path = eqbands_path
        reaper.RecursiveCreateDirectory(path..string.upper(editbox.text),1)
        
        update_gfx = true
      elseif EB_Open == 32 then        
        EQC_SaveEQ(editbox.text)
      
      elseif EB_Open == 50 then
      
        save_subfolder = editbox.text
        if save_subfolder == '' then
          save_subfolder = nil
        end
        update_gfx = true

      elseif EB_Open == 51 then
      
        local ctl = strips[tracks[track_select].strip][page].controls[switcher_select]
        local switchid = ctl.switcherid
        local newname = editbox.text
        for g = 1, #switchers[switchid].grpids do
          if switchers[switchid].grpids[g].id == switchers[switchid].current then
            switchers[switchid].grpids[g].name = newname
            ctl.param_info.paramname = string.format('%i',g)..': '..switchers[switchid].grpids[g].name
            update_gfx = true
            break
          end
        end
      
      elseif EB_Open == 60 then
        local txt = editbox.text
        local mo = tonumber(txt)
        if mo then
          local nval, dval = GetValFromDVal(ctl_select[1].ctl,txt)
          if nval then
          
            local gtab = gauge_select
            local gcnt = #gtab.vals+1
            gtab.vals[gcnt] = {val = nval, dval = dval, dover = nil}
            local nonly
            if gtab.numonly then
              nonly = ''
            end
            if gtab.val_dp > -1 then
              gtab.vals[gcnt].dover = roundX(dval, gtab.val_dp, nonly)
            end
            Gauge_SortVals()
            for i = 1, #gtab.vals do
              if gtab.vals[i].val == gtab.val then
                gauge_ticksel = i
              end
            end
            gtab.ticks = gtab.ticks+1
            update_surface = true
          
          end
        end  
      elseif EB_Open == 61 then
        local f = CheckFont(editbox.text)
        if f then
          gauge_select.font = f
          update_gfx = true
        end
      elseif EB_Open == 62 then
        local f = CheckFont(editbox.text)
        if f then
          ctlfont_select = f
          for i = 1, #ctl_select do
            strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].font = ctlfont_select
          end            
        end
        update_gfx = true
      end
      editbox = nil
      EB_Open = 0
      mouse.release = true
      
    elseif mouse.LB == true and MOUSE_over(obj.sections[7]) then
      editbox = nil
      EB_Open = 0
      mouse.release = true
    end
        
    local c=gfx.getchar()  
    if editbox and editbox.hasfocus and c > 0 then editbox_onchar(editbox, c) end  
    update_surface = true

  end
  
  function Process_MB()
  
    local c=gfx.getchar()  
    mb_onchar(c)
    
    if MOUSE_click(obj.sections[62]) or MB_Enter then
      --OK
      if MS_Open == 1 then
        msgbox = nil
        MS_Open = 0
      elseif MS_Open == 2 then
        -- savedefaultgraph
        msgbox = nil
        strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqgraph = EQC_SetMain(eqcontrolband_select)
        update_gfx = true
      elseif MS_Open == 3 then
        msgbox = nil
        --MS_Open = 0
        local sscnt = #snapshots[tracks[track_select].strip][page]
        if sscnt > 1 then
          for s = sscnt, 2, -1 do
            Snapshot_DeleteSubset(tracks[track_select].strip, page, s)                  
          end
          SetCtlBitmapRedraw()
          OpenMsgBox(1,sscnt..' subsets deleted.',1)
        end
        update_gfx = true                      
      end
      MB_Enter = false 
      update_surface = true
      mouse.LB = false
      mouse.release = true
    elseif MOUSE_click(obj.sections[64]) then
      --No
      msgbox = nil
      MS_Open = 0
      MB_Enter = false 
      update_surface = true
      mouse.LB = false
      mouse.release = true
    end
    
  end
  
  function FollowTrack(ct)
    if track_select ~= nil or ct > 0 then
      if ct > 0 then
        if track_select == nil then track_select = -1 end
        local st = reaper.GetSelectedTrack(0,0)
        if st == nil then
          st = GetTrack(-1)
        end
        local tr = GetTrack(track_select)
        if st ~= nil and tr ~= nil then
          if reaper.GetTrackGUID(st) ~= reaper.GetTrackGUID(tr) then
            PopulateTracks()
            for i = -1, reaper.CountTracks(0) do
              tr = GetTrack(i)
              if tr ~= nil then
                tracks[i].name = reaper.GetTrackState(tr)
                if reaper.GetTrackGUID(st) == reaper.GetTrackGUID(tr) then
                  if strips[tracks[track_select].strip] then
                    strips[tracks[track_select].strip].page = page
                  end
                  
                  ChangeTrack(i)
                  trctlslist_offset = 0
                  
                  if strips and tracks[track_select] and strips[tracks[track_select].strip] then
                    page = strips[tracks[track_select].strip].page
                    surface_offset.x = strips[tracks[track_select].strip][page].surface_x
                    surface_offset.y = strips[tracks[track_select].strip][page].surface_y
                  else
                    page = 1
                    surface_offset.x = 0
                    surface_offset.y = 0
                  end
                  break
                end
              end
            end
            
            --TRK CHANGED
            CheckStripControls()
            CheckStripSends()          
            PopulateTrackSendsInfo()
            PopulateTrackFX()
            PopulateSpecial()
            ctl_select = nil
            gfx2_select = nil
            gfx3_select = nil
            CloseActChooser()
            show_ctlbrowser = false
            
            ss_select = nil
            sstype_select = 1
            ssoffset = 0
            update_gfx = true
          end
        end 
      end
    end      
  end

  function Process_Settings()
    
    if mouse.LB and not mouse.last_LB and not MOUSE_click(obj.sections[70]) then
      show_settings = false
      SaveSettings()
      update_gfx = true      
    end
    
    if MOUSE_click(obj.sections[71]) then
      settings_followselectedtrack = not settings_followselectedtrack
      update_settings = true
    elseif MOUSE_click(obj.sections[72]) then
      settings_disablesendchecks = not settings_disablesendchecks
      update_settings = true
    elseif MOUSE_click(obj.sections[73]) then
      settings_saveallfxinststrip = not settings_saveallfxinststrip
      update_settings = true
    elseif MOUSE_click(obj.sections[81]) then
      settings_mousewheelknob = not settings_mousewheelknob
      update_settings = true
    elseif MOUSE_click(obj.sections[82]) then
      settings_swapctrlclick = not settings_swapctrlclick
      update_settings = true
    elseif MOUSE_click(obj.sections[83]) then
      settings_insertdefaultoneverytrack = not settings_insertdefaultoneverytrack
      update_settings = true
    elseif MOUSE_click(obj.sections[84]) then
      settings_insertdefaultoneverypage = not settings_insertdefaultoneverypage
      update_settings = true
    elseif MOUSE_click(obj.sections[85]) then
      settings_showbars = not settings_showbars
      obj = GetObjects()
      update_gfx = true
    elseif mouse.context == nil and MOUSE_click(obj.sections[74]) then
      mouse.context = contexts.updatefreq
      oval = settings_updatefreq
    elseif mouse.context == nil and MOUSE_click(obj.sections[75]) then
      lockx = not lockx
      obj = GetObjects()
      update_gfx = true
    elseif mouse.context == nil and MOUSE_click(obj.sections[76]) then
      locky = not locky
      obj = GetObjects()
      update_gfx = true
    elseif mouse.context == nil and MOUSE_click(obj.sections[77]) then
      mouse.context = contexts.lockw
      ctlpos = lockw
    elseif mouse.context == nil and MOUSE_click(obj.sections[78]) then
      mouse.context = contexts.lockh
      ctlpos = lockh
    elseif mouse.context == nil and MOUSE_click(obj.sections[80]) then
      settings_showgrid = not settings_showgrid
      osg = settings_showgrid
      if settings_gridsize < 16 then
        settings_showgrid = false
      end
      update_gfx = true
    elseif mouse.context == nil and MOUSE_click(obj.sections[79]) then
      mouse.context = contexts.gridslider
      ctlpos = settings_gridsize
    elseif mouse.context == nil and MOUSE_click(obj.sections[86]) then
      local retval, c = reaper.GR_SelectColor(_,ConvertColorString(settings_snaplistbgcol))
      if retval ~= 0 then
        settings_snaplistbgcol = ConvertColor(c)
        update_gfx = true
      end
    elseif mouse.context == nil and MOUSE_click(obj.sections[87]) then
      settings_savedatainprojectfolder = not settings_savedatainprojectfolder
      update_gfx = true
    elseif mouse.context == nil and MOUSE_click(obj.sections[96]) then
      settings_hideeditbaronnewproject = not settings_hideeditbaronnewproject
      update_gfx = true
    elseif mouse.context == nil and MOUSE_click(obj.sections[97]) then
      settings_locksurfaceonnewproject = not settings_locksurfaceonnewproject
      update_gfx = true
    elseif mouse.context == nil and MOUSE_click(obj.sections[98]) then
      settings_createbackuponmanualsave = not settings_createbackuponmanualsave
      update_gfx = true
    elseif mouse.context == nil and MOUSE_click(obj.sections[704]) then
      settings_touchFB = not settings_touchFB
      update_gfx = true
    elseif mouse.context == nil and MOUSE_click(obj.sections[705]) then
      settings_trackchangemidi = not settings_trackchangemidi
      update_gfx = true
      
    elseif mouse.context == nil and MOUSE_click(obj.sections[700]) then
      local abs, _ = GetMOFaders()
      local f = {targettype = 3, mode = 0}
      local fadabs = SetAutomationFader(f ,abs, true)
      if fadabs == -2 then
        DeleteFader(abs)
      elseif fadabs ~= -1 then
        AssignFader(fadabs, f)
      end
      update_gfx = true

    elseif mouse.context == nil and MOUSE_click(obj.sections[702]) then
      local retval, c = reaper.GR_SelectColor(_,ConvertColorString(backcol))
      if retval ~= 0 then
        backcol = ConvertColor(c)
        update_bg = true
        update_gfx = true
      end
    elseif mouse.context == nil and MOUSE_click_RB(obj.sections[702]) then
      backcol = '16 16 16'
      update_bg = true
      update_gfx = true
      
    --[[elseif mouse.context == nil and MOUSE_click(obj.sections[701]) then
      local _, rel = GetMOFaders()
      local fadrel = SetAutomationFader({targettype = 3, mode = 1},rel)
      update_gfx = true]]

    elseif mouse.context == nil and MOUSE_click(obj.sections[703]) then
    
      local retval, fn = reaper.GetUserFileNameForRead('~scanboot.xml', 'Locate Nebula Scanboot', '*.XML')
      if retval == true then
      
        nebscanboot_file = fn
        LoadScanBoot(nebscanboot_file)
        update_gfx = true
        
      end
    
    elseif mouse.context == nil and MOUSE_click(obj.sections[88]) then
      settings_usectlbitmap = not settings_usectlbitmap
      if settings_usectlbitmap then
        GUI_DrawCtlBitmap()
      else
        gfx.setimgdim(ctl_bitmap,-1,-1)
      end
      update_gfx = true
    elseif mouse.context == nil and MOUSE_click(obj.sections[89]) then
      settings_showminimaltopbar = not settings_showminimaltopbar
      obj = GetObjects()
      update_surface = true
    elseif mouse.context == nil and MOUSE_click(obj.sections[95]) then
    
      OpenEB(50, 'Please choose a save subfolder name:', nz(save_subfolder,''))
    
    end
    
    if mouse.context and mouse.context == contexts.updatefreq then
      local val = F_limit(MOUSE_sliderHBar(obj.sections[74]),0,1)
      if val ~= nil then
        settings_updatefreq = (1-val)/10
        if oval ~= settings_updatefreq then
          update_settings = true                  
        end 
        oval = settings_updatefreq          
      end
    elseif mouse.context and mouse.context == contexts.lockw then
      local val = F_limit(MOUSE_slider(obj.sections[77]),0,1)
      if val ~= nil then
        val = 1-val
        lockw = F_limit( math.floor((val*1000)/settings_gridsize)*settings_gridsize,64,1000)
        obj = GetObjects()
        update_gfx = true
      end
    elseif mouse.context and mouse.context == contexts.lockh then
      local val = F_limit(MOUSE_slider(obj.sections[78]),0,1)
      if val ~= nil then
        val = 1-val
        lockh = F_limit( math.floor((val*1000)/settings_gridsize)*settings_gridsize,64,1000)
        obj = GetObjects()
        update_gfx = true
      end
    elseif mouse.context and mouse.context == contexts.gridslider then
      local val = F_limit(MOUSE_slider(obj.sections[79]),0,1)
      if val ~= nil then
        val = 1-val
        settings_gridsize = F_limit(ctlpos + math.floor((val-0.5)*200),1,128)
        ogrid = settings_gridsize
        if settings_gridsize < 16 then
          settings_showgrid = false
        else
          settings_showgrid = nz(osg,true)
        end
        update_gfx = true
      end
    end
    
  end

  --[[function UpdateControlValues(rt)

    if rt >= time_nextupdate then
      local suf = settings_updatefreq
      --if mode == 1 then suf = 0.2 end

      time_nextupdate = rt + suf
      if strips and tracks[track_select] and strips[tracks[track_select].strip] and #strips[tracks[track_select].strip][page].controls > 0 then
        --check track
        local strip = tracks[track_select].strip
        
        if CheckTrack(strips[strip].track, strip) then        
          if tracks[track_select] and strips[tracks[track_select].strip] then
            local strip = tracks[track_select].strip

            local tr2 = GetTrack(strips[strip].track.tracknum)
            if tr2 ~= nil then
              if strips and strips[strip] then
                local chktbl = {}
                local pkmts = false

                for i = 1, #strips[strip][page].controls do
                  --check fx
                  local ctl = strips[strip][page].controls[i]
                  
                  tr = tr2
                  local tr_found = true
                  if ctl.tracknum ~= nil then
                    --tr = GetTrack(strips[tracks[track_select].strip][page].controls[i].tracknum)
                    tr_found = CheckTrack(tracks[ctl.tracknum], strip, page, i)
                    if tr_found then
                      tr = GetTrack(ctl.tracknum)
                    end 
                  end
--DBG(tr_found)
                  
                  DBG(ctl.ctlcat)
                  if tr_found then
                  DBG(ctl.ctlcat)
                    if ctl.ctlcat == ctlcats.fxparam then
                      local fxguid = reaper.TrackFX_GetFXGUID(tr, ctl.fxnum)
                      if ctl.fxguid == fxguid then
  --DBG(i)
                        local pn = reaper.TrackFX_GetNumParams(tr,ctl.fxnum)
                        if pn ~= 2 then
                          if ctl.offline ~= nil then
                            ctl.dirty = true
                          end
                          ctl.offline = nil
                        else
                          if ctl.offline == nil then
                            ctl.dirty = true
                          end
                          ctl.offline = true
                        end
                      
                        local v = GetParamValue2(ctl.ctlcat,
                                                 tr,
                                                 ctl.fxnum,
                                                 ctl.param, i)
                        if ctl.ctltype == 4 then
                          if tostring(ctl.val) ~= tostring(v) then
                            ctl.val = v
                            ctl.dirty = true
                            ctl.cycledata.posdirty = true 
                            update_ctls = true
                          end
                        else
                          if ctl.val ~= v then
                            ctl.val = v
                            ctl.dirty = true
                            if ctl.param_info.paramname == 'Bypass' then
                              SetCtlEnabled(ctl.fxnum) 
                            end
                            update_ctls = true
                          end                      
                        end
                      else
                        if ctl.fxfound then
                          CheckStripControls()
                        end
                      end
                    elseif ctl.ctlcat == ctlcats.trackparam then
                      local v = GetParamValue2(ctl.ctlcat,
                                               tr,
                                               nil,
                                               ctl.param, i)
                      if ctl.ctltype == 4 then
                        if tostring(ctl.val) ~= tostring(v) then
                          ctl.val = v
                          ctl.dirty = true
                          ctl.cycledata.posdirty = true 
                          update_ctls = true
                        end
                      else
                        if ctl.val ~= v then
                          ctl.val = v
                          ctl.dirty = true
                          update_ctls = true
                        end
                      end                    
                    elseif ctl.ctlcat == ctlcats.tracksend then
  
                      if settings_disablesendchecks == false and checksends == true then
                        local tt = ctl.tracknum
                        if tt == nil then
                          tt = strips[strip].track.tracknum
                        end
                        local chk
                        
                        chk, chktbl[tt] = CheckSendGUID(tt,nil,ctl.param_info.paramnum,
                                                              ctl.param_info.paramdestguid,
                                                              ctl.param_info.paramdestchan,
                                                              ctl.param_info.paramsrcchan,
                                                              chktbl[tt])
                        if chk == false then
                          chktbl = CheckStripSends(chktbl)
                        end
                      end                    
  
                      local v = GetParamValue2(ctl.ctlcat,
                                               tr,
                                               nil,
                                               ctl.param, i)
  
                      if ctl.ctltype == 4 then
                        if tostring(ctl.val) ~= tostring(v) then
                          ctl.val = v
                          ctl.dirty = true
                          ctl.cycledata.posdirty = true 
                          update_ctls = true                    
                        end
                      else
                        if ctl.val ~= v then
                          ctl.val = v
                          ctl.dirty = true
                          update_ctls = true
                        end
                      end
                    elseif ctl.ctlcat == ctlcats.pkmeter then
                      if rt >= time_nextupdate_pkmeter then
                        pkmts = true
                        local chd = 0
                        local trn = strips[strip].track.tracknum
                        if ctl.tracknum ~= nil then
                          trn = ctl.tracknum
                        end
                        local p = ctl.param
                        local v = GetParamValue2(ctl.ctlcat,
                                                 tr,
                                                 nil,
                                                 p, i)
                        if peak_info[trn] and peak_info[trn][p % 64] then
                          chd = peak_info[trn][p % 64].ch_d
                        else
                          chd = -150
                        end
                        if tostring(ctl.val) ~= tostring(chd) then
                          ctl.val = chd
                          ctl.dirty = true
                          update_ctls = true
                          --update_mtrs = true
                        end
                      end
                    elseif ctl.ctlcat == ctlcats.fxoffline then
                      local fxguid = reaper.TrackFX_GetFXGUID(tr, ctl.fxnum)
                      if ctl.fxguid == fxguid then
  
                        local pn = reaper.TrackFX_GetNumParams(tr,ctl.fxnum)
                        if pn ~= 2 then
                          if ctl.offline ~= nil then
                            ctl.dirty = true
                            update_ctls = true
                          end
                          ctl.offline = nil
                          ctl.val = 0
                        else
                          if ctl.offline == nil then
                            ctl.dirty = true
                            update_ctls = true
                          end
                          ctl.offline = true
                          ctl.val = 1
                        end
                      else
                        if ctl.fxfound then
                          CheckStripControls()
                        end
                      end                  
                    
                    elseif ctl.ctlcat == ctlcats.fxgui or ctl.ctlcat == ctlcats.rcm_switch then
                      local fxguid = reaper.TrackFX_GetFXGUID(tr, ctl.fxnum)
                        DBG('1')
                      if ctl.fxguid and ctl.fxguid ~= fxguid then
                        DBG('1')
                        if ctl.fxfound then
                        DBG('csc')
                          CheckStripControls()
                        end
                      end
                    end
                  end
                end
                chktbl = nil
                if pkmts then
                  time_nextupdate_pkmeter = rt + settings_updatefreq_pkmeter
                end
              end
            end
          end
        end
      end
    end

  end]]

  function UpdateControlValues2(rt)
  
    if rt >= time_nextupdate then
      local suf = settings_updatefreq
      --if mode == 1 then suf = 0.2 end

      time_nextupdate = rt + suf
      if strips and tracks[track_select] and strips[tracks[track_select].strip] and #strips[tracks[track_select].strip][page].controls > 0 then
        --check track
        local strip = tracks[track_select].strip
        
        if CheckTrack(strips[strip].track, strip) then        
          if tracks[track_select] and strips[tracks[track_select].strip] then
            local strip = tracks[track_select].strip

            local tr2 = GetTrack(strips[strip].track.tracknum)
            if tr2 ~= nil then
              if strips and strips[strip] then
                local chktbl = {}
                local pkmts = false

                for i = 1, #strips[strip][page].controls do
                  --check fx
                  local ctl = strips[strip][page].controls[i]
                  
                  tr = tr2
                  local tr_found = true
                  if ctl.tracknum ~= nil then
                    --tr = GetTrack(strips[tracks[track_select].strip][page].controls[i].tracknum)
                    tr_found = CheckTrack(tracks[ctl.tracknum], strip, page, i)
                    if tr_found then
                      tr = GetTrack(ctl.tracknum)
                    end 
                  end
--DBG(tr_found)
                  
                  if tr_found then
                    if ctl.ctlcat == ctlcats.fxparam then
                      local fxguid = reaper.TrackFX_GetFXGUID(tr, ctl.fxnum)
                      if ctl.fxguid == fxguid then
  --DBG(i)
                        local pn = reaper.TrackFX_GetNumParams(tr,ctl.fxnum)
                        if pn ~= 2 then
                          if ctl.offline ~= nil then
                            ctl.dirty = true
                          end
                          ctl.offline = nil
                        else
                          if ctl.offline == nil then
                            ctl.dirty = true
                          end
                          ctl.offline = true
                        end
                      
                        local _, v = reaper.TrackFX_GetFormattedParamValue(tr, ctl.fxnum, ctl.param, "")
                        --DBG(v.. '  '..ctl.dval)
                        local v2 = GetParamValue2(ctl.ctlcat,
                                                 tr,
                                                 ctl.fxnum,
                                                 ctl.param, i)
                          
                        if ctl.ctltype == 4 then
                          if tostring(ctl.dval) ~= tostring(v) then
                          --DBG(tostring(ctl.dval)..'  '..tostring(v))
                            ctl.val = v2
                            ctl.dval = v
                            ctl.dirty = true
                            ctl.cycledata.posdirty = true 
                            update_ctls = true
    
                            if ctl.midiout then
                              SendMIDIMsg(ctl.midiout, ctl.val)
                            end
                          end
                        else
                          if ctl.dval ~= v then
                          --DBG(tostring(ctl.dval)..'  '..tostring(v))
                            ctl.val = v2
                            ctl.dval = v
                            ctl.dirty = true
                            if ctl.param_info.paramname == 'Bypass' then
                              SetCtlEnabled(ctl.fxnum) 
                            end
                            update_ctls = true

                            if ctl.midiout then
                              SendMIDIMsg(ctl.midiout, ctl.val)
                            end
                          end                      
                        end
                      else
                        if ctl.fxfound then
                          CheckStripControls()
                        end
                      end
                    elseif ctl.ctlcat == ctlcats.trackparam then
                      local v = GetParamValue2(ctl.ctlcat,
                                               tr,
                                               nil,
                                               ctl.param, i)
                      if ctl.ctltype == 4 then
                        if tostring(ctl.val) ~= tostring(v) then
                          ctl.val = v
                          ctl.dirty = true
                          ctl.cycledata.posdirty = true 
                          update_ctls = true

                          if ctl.midiout then
                            SendMIDIMsg(ctl.midiout, ctl.val)
                          end                          
                        end
                      else
                        if ctl.val ~= v then
                          ctl.val = v
                          ctl.dirty = true
                          update_ctls = true

                          if ctl.midiout then
                            SendMIDIMsg(ctl.midiout, ctl.val)
                          end
                        end
                      end
                                          
                    elseif ctl.ctlcat == ctlcats.tracksend then
  
                      if settings_disablesendchecks == false and checksends == true then
                        local tt = ctl.tracknum
                        if tt == nil then
                          tt = strips[strip].track.tracknum
                        end
                        local chk
                        
                        chk, chktbl[tt] = CheckSendGUID(tt,nil,ctl.param_info.paramnum,
                                                              ctl.param_info.paramdestguid,
                                                              ctl.param_info.paramdestchan,
                                                              ctl.param_info.paramsrcchan,
                                                              chktbl[tt])
                        if chk == false then
                          chktbl = CheckStripSends(chktbl)
                        end
                      end                    
  
                      local v = GetParamValue2(ctl.ctlcat,
                                               tr,
                                               nil,
                                               ctl.param, i)
  
                      if ctl.ctltype == 4 then
                        if tostring(ctl.val) ~= tostring(v) then
                          ctl.val = v
                          ctl.dirty = true
                          ctl.cycledata.posdirty = true 
                          update_ctls = true                    

                          if ctl.midiout then
                            SendMIDIMsg(ctl.midiout, ctl.val)
                          end
                        end
                      else
                        if ctl.val ~= v then
                          ctl.val = v
                          ctl.dirty = true
                          update_ctls = true

                          if ctl.midiout then
                            SendMIDIMsg(ctl.midiout, ctl.val)
                          end
                        end
                      end
                    elseif ctl.ctlcat == ctlcats.pkmeter then
                      if rt >= time_nextupdate_pkmeter then
                        pkmts = true
                        local chd = 0
                        local trn = strips[strip].track.tracknum
                        if ctl.tracknum ~= nil then
                          trn = ctl.tracknum
                        end
                        local p = ctl.param
                        local v = GetParamValue2(ctl.ctlcat,
                                                 tr,
                                                 nil,
                                                 p, i)
                        if peak_info[trn] and peak_info[trn][p % 64] then
                          chd = peak_info[trn][p % 64].ch_d
                        else
                          chd = -150
                        end
                        if tostring(ctl.val) ~= tostring(chd) then
                          ctl.val = chd
                          ctl.dirty = true
                          update_ctls = true

                          if ctl.midiout then
                            SendMIDIMsg(ctl.midiout, ctl.val)
                          end
                          --update_mtrs = true
                        end
                      end
                    elseif ctl.ctlcat == ctlcats.fxoffline then
                      local fxguid = reaper.TrackFX_GetFXGUID(tr, ctl.fxnum)
                      if ctl.fxguid == fxguid then
  
                        local pn = reaper.TrackFX_GetNumParams(tr,ctl.fxnum)
                        if pn ~= 2 then
                          if ctl.offline ~= nil then
                            ctl.dirty = true
                            update_ctls = true
                            
                            if ctl.midiout then
                              SendMIDIMsg(ctl.midiout, ctl.val)
                            end
                          end
                          ctl.offline = nil
                          ctl.val = 0
                        else
                          if ctl.offline == nil then
                            ctl.dirty = true
                            update_ctls = true
                            
                            if ctl.midiout then
                              SendMIDIMsg(ctl.midiout, ctl.val)
                            end
                          end
                          ctl.offline = true
                          ctl.val = 1
                        end
                      else
                        if ctl.fxfound then
                          CheckStripControls()
                        end
                      end                  
                    elseif ctl.ctlcat == ctlcats.fxgui or (ctl.ctlcat == ctlcats.rcm_switch and ctl.fxnum) then
                      local fxguid = reaper.TrackFX_GetFXGUID(tr, ctl.fxnum)
                      if ctl.fxguid and ctl.fxguid ~= fxguid then
                        if ctl.fxfound then
                          CheckStripControls()
                        end
                      end
                    end
                    
                    if ctl.macrofader then                    
                      --SetFader(ctl.macrofader, ctl.val)                    
                    end
                    
                  end
                end
                chktbl = nil
                if pkmts then
                  time_nextupdate_pkmeter = rt + settings_updatefreq_pkmeter
                end
              end
            end
          end
        end
      end
    end

  end

  function DropCtls()
    --if ctl_select == nil then return end
    local updallowed = true
    --if ctl_select then
      if newgrp then
        for i = 1, #ctl_select do --might need to do nested checks
          if strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].switcherid == strips[tracks[track_select].strip][page].controls[newgrp.switchid].switcherid then 
            updallowed = false
            break
          end
        end
        if updallowed == true then
          if newgrp.grpid == nil or newgrp.grpid == -1 then
            newgrp.grpid = Switcher_AddPage(newgrp.switchid)
          end
        end
      end
      local ctls = strips[tracks[track_select].strip][page].controls
      for i = 1, #ctl_select do
        local ctl = ctls[ctl_select[i].ctl]
        if newgrp then
          if updallowed == true then
            --is parent switcher in selection?
            local par = IsParentSwitchInSel(ctl_select, ctl, i) 
            if par == false then
              ctl.grpid = newgrp.grpid
              ctl.switcher = ctls[newgrp.switchid].switcherid
              if ctl.ctlcat == ctlcats.switcher then
                local swid = ctl.switcherid
                switchers[swid].parent = {}
                switchers[swid].parent.grpid = newgrp.grpid
                switchers[swid].parent.switcherid = ctls[newgrp.switchid].switcherid 
              end
            end
          end
        end
        ctl.hide = nil
      end
      if gfx3_select and #gfx3_select > 0 then
        local gfxx = strips[tracks[track_select].strip][page].graphics
        for i = 1, #gfx3_select do
          local gfxc = strips[tracks[track_select].strip][page].graphics[gfx3_select[i].ctl]
          if newgrp then
            if updallowed == true then 
              --is parent switcher in selection?
              local par = IsParentSwitchInSel(ctl_select, gfxc, i) 
              if par == false then
                gfxc.grpid = newgrp.grpid
                gfxc.switcher = ctls[newgrp.switchid].switcherid
              end
            end
          end 
          gfxc.hide = nil
        end                    
      end
    --end
    newgrp = nil
    update_gfx = true
  end
  
  function IsParentSwitchInSel(ctlselect, ctl, i)
    local par = false
    local ctls = strips[tracks[track_select].strip][page].controls
    if ctl.switcher then
      local ctab = {}
      for j = 1, #ctlselect do
        if j ~= i then
          ctab[#ctab+1] = ctlselect[j]
        end
      end
      for j = 1, #ctlselect do
        if ctls[ctlselect[j].ctl].ctlcat == ctlcats.switcher and ctls[ctlselect[j].ctl].switcherid == ctl.switcher then
          par = true
          break
        elseif ctls[ctlselect[j].ctl].ctlcat == ctlcats.switcher then
          par = IsParentSwitchInSel(ctab, ctls[ctlselect[j].ctl], j)
          if par == true then
            break
          end
        end
      end
    end
    return par
  end
  
  function GetReassCtl()
    local reass_param
    local ctls = strips[tracks[track_select].strip][page].controls
    local reass_param = GetControlAtXY(tracks[track_select].strip, page, mouse.mx, mouse.my)
    
    --[[if settings_usectlbitmap then
                  
      gfx.dest = ctl_bitmap
      gfx.x = mouse.mx + surface_offset.x -obj.sections[10].x
      gfx.y = mouse.my + surface_offset.y -obj.sections[10].y
      local r,g,b = gfx.getpixel()
      gfx.dest = 1
      local cc = r*255 + ((g*255) << 8) + ((b*255) << 16)
      if cc > 0 and ctls[cc] then 
        reass_param = cc
      end
    else
      for i = 1, #ctls do
        local ctl = strips[tracks[track_select].strip][page].controls[i]
        local hidden = Switcher_CtlsHidden(ctl.switcher,ctl.grpid)
      
        if hidden == false then
          local xywh 
          xywh = {x = ctl.x - surface_offset.x +obj.sections[10].x, 
                  y = ctl.y - surface_offset.y +obj.sections[10].y, 
                  w = ctl.w, 
                  h = ctl.ctl_info.cellh}    
          if MOUSE_over(xywh) then
            reass_param = i
            break
          end
        end
      end
    end]]
    return reass_param
  end


  function EQC_LoadGraph(band)

    local fn = eqbands_path..'default.eqgraph'
    if reaper.file_exists(fn) then
    
      local file
      file=io.open(fn,"r")
      local content=file:read("*a")
      file:close()
      
      local defgraph = unpickle(content)
      
      return defgraph
    end
  
  end
  
  function EQC_SetMain(band)
  
    
    local m = {}
    m.lookmap = {}
    m.gmap = {}
    local lm = strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[band].lookmap
    for i = 1, #lm do
      m.lookmap[i] = {pix = lm[i].pix,
                      hz = lm[i].hz}
    end
    local gm = strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[band].gmap
    for i = 1, #gm do
      m.gmap[i] = {pix = gm[i].pix,
                   db = gm[i].db}
    end
    m.gmin = strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[band].gmin
    m.gmax = strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[band].gmax
    m.posmin = strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[band].posmin
    m.posmax = strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[band].posmax
    
    local save_path=eqbands_path
    local fn=save_path.."default.eqgraph"
    
    local DELETE=true
    local file
    
    if reaper.file_exists(fn) then
    
    end
    
    if DELETE then
      file=io.open(fn,"w")
      local pickled_table=pickle(m)
      file:write(pickled_table)
      file:close()
    end
    
    OpenMsgBox(1,'Default EQ graph saved.',1)
    def_graph = m
    return m
      
  end
  
  function EQC_GetParam(track, fx, param)
    if param then
      --local track = GetTrack(tr)
      local v = reaper.TrackFX_GetParamNormalized(track, fx, param)
      return v
    end    
  end
  
  function EQC_SetDefault(b)
  
    local bands = strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands
    if bands and bands[b] then
      if bands[b].freq_def then
        EQC_SetParam(b, bands[b].freq_param, bands[b].freq_def)
      end
      if bands[b].gain_def then
        EQC_SetParam(b, bands[b].gain_param, bands[b].gain_def)
      end
      if bands[b].q_def then
        EQC_SetParam(b, bands[b].q_param, bands[b].q_def)
      end
      if bands[b].c1_def then
        EQC_SetParam(b, bands[b].c1_param, bands[b].c1_def)
      end
      if bands[b].c2_def then
        EQC_SetParam(b, bands[b].c2_param, bands[b].c2_def)
      end
      if bands[b].c3_def then
        EQC_SetParam(b, bands[b].c3_param, bands[b].c3_def)
      end
      if bands[b].c4_def then
        EQC_SetParam(b, bands[b].c4_param, bands[b].c4_def)
      end
      if bands[b].c5_def then
        EQC_SetParam(b, bands[b].c5_param, bands[b].c5_def)
      end
    end
        
  end
  
  function EQC_SetParam(band, param, val)
    if strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[band].fxnum then
      local fxnum = strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[band].fxnum
      local track = GetTrack(tracks[track_select].tracknum)
      reaper.TrackFX_SetParamNormalized(track, fxnum, param, val)
    end
  end
  
  function EQC_SelectParam()
    if strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[eqcontrolband_select].fxnum then
      local fxnum = strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[eqcontrolband_select].fxnum
      local track = GetTrack(tracks[track_select].tracknum)
      local pcnt = reaper.TrackFX_GetNumParams(track, fxnum)
      local mstr = '[ CLEAR ]|'
      for pn = 1, pcnt do
        local _, pname = reaper.TrackFX_GetParamName(track, fxnum, pn-1, '')
        mstr = mstr..pn..': '..pname
        if pn < pcnt then
          mstr = mstr..'|'
        end
      end
      gfx.x, gfx.y = mouse.mx, mouse.my
      res = OpenMenu(mstr)-1
      if res == 0 then res = -1 end
      return res
    else
      return 0
    end
  end
  
  function EQC_AlignGraph(src, aligntype)
  
    if aligntype == nil then aligntype = 1 end
    
    local strip = tracks[track_select].strip
    local eqgraph = strips[strip][page].controls[eqcontrol_select].eqgraph
    if eqgraph then
      local lookmap_src = strips[strip][page].controls[eqcontrol_select].eqbands[src].lookmap
      local lookmap_tgt = eqgraph.lookmap
  
      if lookmap_src and #lookmap_src > 1 then
      
        local src_pts = {}
        for i = 1, #lookmap_src do
        
          if 10^math.floor(math.log(lookmap_src[i].hz,10)) == lookmap_src[i].hz then
            src_pts[#src_pts+1] = i
          end
        
        end
      
        if #src_pts < 2 then
        
          if #src_pts == 1 then
            --if #lookmap_src - src_pts[1] > #lookmap_src / 2 and lookmap_src[#lookmap_src].hz <= lookmap_tgt[#lookmap_tgt].hz then
            if #lookmap_src > src_pts[1] and lookmap_src[#lookmap_src].hz <= lookmap_tgt[#lookmap_tgt].hz and (aligntype == 1 or src_pts[1] == 1) then
              src_pts[2] = #lookmap_src
              --DBG('AA')
            else
              src_pts[2] = 1
              --DBG('BB')
            end
            if src_pts[1] > src_pts[2] then
              local sp = src_pts[1]
              src_pts[1] = src_pts[2]
              src_pts[2] = sp
            end
          else
            src_pts[1] = 1
            src_pts[2] = #lookmap_src 
          end
        end
        local tgt_pts = {}
        for i = 1, #lookmap_tgt do
          if lookmap_tgt[i].hz == lookmap_src[src_pts[1]].hz then
            tgt_pts[1] = i
          elseif lookmap_tgt[i].hz == lookmap_src[src_pts[2]].hz then
            tgt_pts[2] = i          
          end
        end
        if #tgt_pts == 2 then
          local tgt_pix = (lookmap_tgt[tgt_pts[2]].pix/2000) - (lookmap_tgt[tgt_pts[1]].pix/2000)
          local tgt_mult = eqgraph.posmax-eqgraph.posmin
          local tp = (lookmap_tgt[tgt_pts[1]].pix/2000)*tgt_mult
          local src_pix = (lookmap_src[src_pts[2]].pix/2000) - (lookmap_src[src_pts[1]].pix/2000)
          local src_mult = (tgt_pix*tgt_mult)/src_pix
          
          local srcdif = (lookmap_src[src_pts[1]].pix/2000) * src_mult
          local posmin = tp - srcdif + (eqgraph.posmin)
          local posmax = posmin + src_mult
          strips[strip][page].controls[eqcontrol_select].eqbands[src].posmin = posmin
          strips[strip][page].controls[eqcontrol_select].eqbands[src].posmax = posmax
          
          update_gfx = true
        end
      end

      local gmap_src = strips[strip][page].controls[eqcontrol_select].eqbands[src].gmap
      local gmap_tgt = eqgraph.gmap
  
      if gmap_src and #gmap_src > 1 then

        local src_pts = {}
        for i = 1, #gmap_src do
        
          if gmap_src[i].db == 0 then
            src_pts[#src_pts+1] = i
          end
        
        end

        if #src_pts == 1 then

          if #src_pts > src_pts[1]+1 then 

            src_pts[2] = src_pts[1] + 2

          elseif src_pts[1] > 2 then
          
            src_pts[2] = src_pts[1] - 2          

          end
          
          if #src_pts == 2 then
          
            local tgt_pts = {}
            for i = 1, #gmap_tgt do
              if gmap_tgt[i].db == gmap_src[src_pts[1]].db then
                tgt_pts[1] = i
              elseif gmap_tgt[i].db == gmap_src[src_pts[2]].db then
                tgt_pts[2] = i          
              end
            end
          
            if #tgt_pts == 2 then
              local tgt_pix = (gmap_tgt[tgt_pts[2]].pix/2000) - (gmap_tgt[tgt_pts[1]].pix/2000)
              local tgt_mult = eqgraph.gmax-eqgraph.gmin
              local tp = (gmap_tgt[tgt_pts[1]].pix/2000)*tgt_mult
              local src_pix = (gmap_src[src_pts[2]].pix/2000) - (gmap_src[src_pts[1]].pix/2000)
              local src_mult = (tgt_pix*tgt_mult)/src_pix
              
              local srcdif = (gmap_src[src_pts[1]].pix/2000) * src_mult
              local gmin = tp - srcdif + (eqgraph.gmin)
              local gmax = gmin + src_mult
              strips[strip][page].controls[eqcontrol_select].eqbands[src].gmin = gmin
              strips[strip][page].controls[eqcontrol_select].eqbands[src].gmax = gmax
              
              update_gfx = true
            end
          
          end
        end
      end
      
    end

  end
  
  function EQC_LoadBand()
  
    if strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands == nil or 
      (strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands 
        and #strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands < 20) then
      local i = 0
      local mstr = '[ NEW EMPTY BAND ]|>EQs'
      local bands = {}
      local eqs = {}
  
      local eq = reaper.EnumerateFiles(eq_path,i)
      if eq ~= nil then
        while eq ~= nil do
          local str = string.match(eq,'(.*)%.lbxeq')
          i=i+1
          eq = reaper.EnumerateFiles(eq_path,i)
          if eq ~= nil then
            mstr = mstr..'|'..str
            eqs[#eqs+1] = str    
          else
            mstr = mstr..'|<'..str
            eqs[#eqs+1] = str          
          end
        end
      else
        mstr = mstr..'|#<empty'
        eqs[#eqs+1] = ''
      end
          
      i=0
      local bt = reaper.EnumerateSubdirectories(eqbands_path,i)
      while bt ~= nil do
        if mstr ~= '' then
          mstr = mstr .. '|'
        end
        mstr = mstr..'>'..bt
        local btp = eqbands_path..bt
        local b = 0
        local bn = reaper.EnumerateFiles(btp,b)
        if bn ~= nil then
          while bn ~= nil do
            local str = string.match(bn,'(.*)%.eqband')
            b=b+1
            bn = reaper.EnumerateFiles(btp,b)
            if bn ~= nil then
              mstr = mstr..'|'..str
              bands[#bands+1] = bt..'/'..str
            else
              mstr = mstr..'|<'..str
              bands[#bands+1] = bt..'/'..str
            end
          end
        else
          mstr = mstr..'|#<empty'
          bands[#bands+1] = ''
        end
        i=i+1
        bt = reaper.EnumerateSubdirectories(eqbands_path,i)
      end
      gfx.x, gfx.y = mouse.mx+obj.sections[300].x, mouse.my+obj.sections[300].y
      res = OpenMenu(mstr)
      if res ~= 0 then
  
        if res == 1 then
          --add band
          eq_edit = true
          if strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands == nil then
            strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands = {}
          end
          local eqb = #strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands+1
          eqcontrolband_select = eqb
          strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[eqb] = {}
          strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[eqb].posmin = 0
          strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[eqb].posmax = 1
          strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[eqb].gmin = 0
          strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[eqb].gmax = 1
          
          strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[eqb].col = '160 160 160'
          strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[eqb].khz = false
          
          update_gfx = true      
        elseif res-1 <= #eqs then
          res = res - 1
          local fn = eq_path..eqs[res]..'.lbxeq'
          
          EQC_LoadEQ(fn)
          
        else
          res = res - (1+#eqs)
          local fn = eqbands_path..bands[res]..'.eqband'
          if reaper.file_exists(fn) then
          
            local file
            file=io.open(fn,"r")
            local content=file:read("*a")
            file:close()
            
            local loaddata = unpickle(content)
            if loaddata then
              
              local trn = tracks[track_select].tracknum
              local fxc = loaddata.chunk
              local track = GetTrack(trn)
              local _, chunk = reaper.GetTrackStateChunk(track,'',false)
              local nchunk, nfxguid, ofxguid = Chunk_InsertFXChunkAtEndOfFXChain(trn, chunk, fxc)
              if nchunk then
                reaper.SetTrackStateChunk(track,nchunk,false)
                loaddata.eqband.fxguid = nfxguid
                loaddata.eqband.fxnum = reaper.TrackFX_GetCount(tr)-1
                if strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands == nil then
                  strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands = {}
                end
                local newband = #strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands+1
                --loaddata.eqband.col = eqcontrol_colours[newband]
                strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[newband] = loaddata.eqband
                eqcontrolband_select = newband
                --compatibility
                if strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[newband].khz == nil then
                  strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[newband].khz = false
                end
                if strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[newband].gmin == nil then
                  strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[newband].gmin = 0
                  strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[newband].gmax = 1
                end
              end
            end
          
            update_gfx = true
            
          else
            OpenMsgBox(1,'File not found.',1)
          end
        end
      end      
    end
  end
  
  function EQC_SelectBandType()
  
    local i = 0
    local bt = reaper.EnumerateSubdirectories(eqbands_path,i)
    local mstr = '[ NEW FOLDER ]'
    local bandtypes = {'NEW FOLDER'}
    while bt ~= nil do
      bandtypes[#bandtypes+1] = bt
      if mstr ~= '' then
        mstr = mstr .. '|'
      end
      mstr = mstr..bt
      i=i+1
      bt = reaper.EnumerateSubdirectories(eqbands_path,i)
    end
    gfx.x, gfx.y = mouse.mx+obj.sections[300].x, mouse.my+obj.sections[300].y
    res = OpenMenu(mstr)
    if res ~= 0 then
      if res == 1 then
        OpenEB(31,'Please enter new EQ band folder:')
      else
        strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[eqcontrolband_select].bandtype = bandtypes[res]
      end
      update_gfx = true
    end
  
  end
  
  function EQC_CopyBandData(strip, page, c,b)
  
    local bb = strips[strip][page].controls[c].eqbands

    local bd = {posmin = bb[b].posmin,
                posmax = bb[b].posmax,
                gmin = bb[b].gmin,
                gmax = bb[b].gmax,
                fxnum = bb[b].fxnum,
                fxguid = bb[b].fxguid,
                fxname = bb[b].fxname,
                col = bb[b].col,
                freq_param = bb[b].freq_param,
                freq_param_name = bb[b].freq_param_name,
                gain_param = bb[b].gain_param,
                gain_param_name = bb[b].gain_param_name,
                q_param = bb[b].q_param,
                q_param_name = bb[b].q_param_name,
                bypass_param = bb[b].bypass_param,
                bypass_param_name = bb[b].bypass_param_name,
                c1_param = bb[b].c1_param,
                c1_param_name = bb[b].c1_param_name,
                c2_param = bb[b].c2_param,
                c2_param_name = bb[b].c2_param_name,
                c3_param = bb[b].c3_param,
                c3_param_name = bb[b].c3_param_name,
                c4_param = bb[b].c4_param,
                c4_param_name = bb[b].c4_param_name,
                c5_param = bb[b].c5_param,
                c5_param_name = bb[b].c5_param_name,
                freq_min = bb[b].freq_min,
                freq_max = bb[b].freq_max,
                bandtype = bb[b].bandtype,
                bandname = bb[b].bandname,
                lookmap = {},
                gmap = {},
                gain_inv = bb[b].gain_inv,
                q_inv = bb[b].q_inv,
                khz = khz,
                freq_def = bb[b].freq_def,                
                gain_def = bb[b].gain_def,
                q_def = bb[b].q_def,
                c1_def = bb[b].c1_def,
                c2_def = bb[b].c2_def,
                c3_def = bb[b].c3_def,
                c4_def = bb[b].c4_def,
                c5_def = bb[b].c5_def
                }
    if bb[b].lookmap then
      for lc = 1, #bb[b].lookmap do
        bd.lookmap[lc] = {pix = bb[b].lookmap[lc].pix,
                          hz = bb[b].lookmap[lc].hz
                          }
      end
    end
    if bb[b].gmap then    
      for lc = 1, #bb[b].gmap do
        bd.gmap[lc] = {pix = bb[b].gmap[lc].pix,
                        db = bb[b].gmap[lc].db
                        }
      end
    end
        
    return bd
  end
  
  function EQC_DelBand()
  
    local strip = tracks[track_select].strip
    if strips[strip][page].controls[eqcontrol_select].eqbands[eqcontrolband_select] then
      local fxnum = strips[strip][page].controls[eqcontrol_select].eqbands[eqcontrolband_select].fxnum
      local unique = true
      if fxnum then
        for b = 1, #strips[strip][page].controls[eqcontrol_select].eqbands do
          if b ~= eqcontrolband_select and fxnum == strips[strip][page].controls[eqcontrol_select].eqbands[b].fxnum then
            unique = false
          end
        end
      else
        --no fx
        unique = false
      end
            
      local cnt = #strips[strip][page].controls[eqcontrol_select].eqbands
      strips[strip][page].controls[eqcontrol_select].eqbands[eqcontrolband_select] = nil
      strips[strip][page].controls[eqcontrol_select].eqbands = Table_RemoveNils(strips[strip][page].controls[eqcontrol_select].eqbands, cnt)
      
      if eqcontrolband_select > #strips[strip][page].controls[eqcontrol_select].eqbands then
        eqcontrolband_select = #strips[strip][page].controls[eqcontrol_select].eqbands
        if eqcontrolband_select == 0 then
          eqcontrolband_select = nil
        end
      end
      update_gfx = true
        
      if unique and fxnum then
        --can delete
        local tr = GetTrack(tracks[track_select].tracknum)
        local _, chunk = reaper.GetTrackStateChunk(tr,'',false)
        local _, nchunk = RemoveFXChunkFromTrackChunk(chunk, fxnum+1)
        if nchunk then
          reaper.SetTrackStateChunk(tr,nchunk,false)
          
          --Reorganise FXNUM
          for i = 1, #strips[strip][page].controls[eqcontrol_select].eqbands do
            if strips[strip][page].controls[eqcontrol_select].eqbands[i].fxnum and strips[strip][page].controls[eqcontrol_select].eqbands[i].fxnum > fxnum then
              strips[strip][page].controls[eqcontrol_select].eqbands[i].fxnum = strips[strip][page].controls[eqcontrol_select].eqbands[i].fxnum-1
            end
          end
        end
      end

    end
  end
  
  function EQC_SaveBand()
  
    local strip = tracks[track_select].strip
    if eqcontrolband_select then
      local fxnum = strips[strip][page].controls[eqcontrol_select].eqbands[eqcontrolband_select].fxnum
      if fxnum == -1 then OpenMsgBox(1,'Plugin not found.',1) return end
        
      if strips[strip][page].controls[eqcontrol_select].eqbands[eqcontrolband_select].bandtype == nil then
        OpenMsgBox(1,'Select a folder first.',1)        
        return
      end
      if strips[strip][page].controls[eqcontrol_select].eqbands[eqcontrolband_select].bandname == nil then
        OpenMsgBox(1,'Select a band name first.',1)        
        return
      end
    
      local bandtype = strips[strip][page].controls[eqcontrol_select].eqbands[eqcontrolband_select].bandtype      
      local bandname = strips[strip][page].controls[eqcontrol_select].eqbands[eqcontrolband_select].bandname
    
      local savedata = {}
      local track = GetTrack(tracks[track_select].tracknum)
      local _, chunk = reaper.GetTrackStateChunk(track,'',false)
      local fnd, fxc, s, e = GetFXChunkFromTrackChunk(chunk,fxnum+1)
      
      if fnd then
        savedata.eqband = EQC_CopyBandData(strip, page, eqcontrol_select, eqcontrolband_select)
        savedata.chunk = fxc
      
        local fn = bandtype..'/'..bandname
        
        if fn and string.len(fn)>0 then
        
          local save_path=eqbands_path
          local fn=save_path..fn..".eqband"
          
          local DELETE=true
          local file
          
          if reaper.file_exists(fn) then
          
          end
          
          if DELETE then
            file=io.open(fn,"w")
            local pickled_table=pickle(savedata)
            file:write(pickled_table)
            file:close()
          end
          
          OpenMsgBox(1,'EQ band saved.',1)
          
        end
      
      else
        --error
        DBG('Failed to get fx chunk')
      end
    
    end
  
  end

  function EQC_LoadEQ(fn)
  
    if reaper.file_exists(fn) then
    
      local file
      file=io.open(fn,"r")
      local content=file:read("*a")
      file:close()
      
      local loaddata = unpickle(content)
      if loaddata then
        
        local fxcnt = #loaddata.chunks

        GUI_DrawMsgX(obj, gui, 'Loading EQ Data...', ck, fxcnt)
        
        local trn = tracks[track_select].tracknum
        local track = GetTrack(trn)
        local _, chunk = reaper.GetTrackStateChunk(track,'',false)

        local nguids = {}
        for ck = 1, #loaddata.chunks do
        
          local fxc = loaddata.chunks[ck]
          local nchunk, nfxguid, ofxguid = Chunk_InsertFXChunkAtEndOfFXChain(trn, chunk, fxc)
          chunk = nchunk
          nguids[ofxguid] = nfxguid        
        
        end
        reaper.SetTrackStateChunk(track,chunk,false)
        local bandcnt = eqcontrolband_select
        if loaddata.bands and #loaddata.bands > 0 then
          if strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands == nil then
            strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands = {}
          end
          local bands = strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands
          bandcnt = #bands+1
          for b = 1, #loaddata.bands do
            loaddata.bands[b].fxguid = nguids[loaddata.bands[b].fxguid]
            loaddata.bands[b].fxnum = -1

            if #bands < 20 then
              bands[#bands+1] = loaddata.bands[b]
            end
          end
        end
        if loaddata.eqgraph then
          strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqgraph = loaddata.eqgraph
        end

        eqcontrolband_select = bandcnt
        update_gfx = true    
    
      end
    end
  end
  
  function EQC_SaveEQ(fn)
  
    local strip = tracks[track_select].strip
    --if eqcontrolband_select then
  
      --[[if strips[strip][page].controls[eqcontrol_select].eqbands[eqcontrolband_select].bandtype == nil then
        OpenMsgBox(1,'Select a folder first.',1)        
        return
      end
      if strips[strip][page].controls[eqcontrol_select].eqbands[eqcontrolband_select].bandname == nil then
        OpenMsgBox(1,'Select a band name first.',1)        
        return
      end]]
  
      local eqc = strips[strip][page].controls[eqcontrol_select].eqbands
      local savedata = {bands = {}, chunks = {}, eqgraph = {}}
      local track = GetTrack(tracks[track_select].tracknum)
      local fx = {}

      local _, chunk = reaper.GetTrackStateChunk(track,'',false)

      savedata.eqgraph = strips[strip][page].controls[eqcontrol_select].eqgraph
      for b = 1, #eqc do

        --local fxnum = eqc[b].fxnum
        local fxnum = GetEQC_FXNum(b)
        if fxnum == -1 then OpenMsgBox(1,'Save failed.  Plugin not found.',1) return end
        
        fx[fxnum] = true 
        savedata.bands[b] = EQC_CopyBandData(strip, page, eqcontrol_select, b)

      end
      
      local fnd = false
      for f = 0, reaper.TrackFX_GetCount(track)-1 do

        if fx[f] == true then
          fnd = false
          local fxc, s, e
          fnd, fxc, s, e = GetFXChunkFromTrackChunk(chunk,f+1)
          if fnd then
            savedata.chunks[#savedata.chunks+1] = fxc
          end
        end

      end

      if fnd then
        
        if fn and string.len(fn)>0 then
        
          local save_path=eq_path
          local fn=save_path..fn..".lbxeq"
          
          local DELETE=true
          local file
          
          if reaper.file_exists(fn) then
          
          end
          
          if DELETE then
            file=io.open(fn,"w")
            local pickled_table=pickle(savedata)
            file:write(pickled_table)
            file:close()
          end
          
          OpenMsgBox(1,'EQ saved.',1)
          
        end
      end
    --end
  
  end
  
  function EQC_OpenEQs(b, open)
  
    local eqc = strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands
    if eqc then
      local track = GetTrack(tracks[track_select].tracknum)
      for i = 1, #eqc do
        local fxnum = GetEQC_FXNum(i)
        if fxnum and fxnum >= 0 and (b == nil or i == b) then
        
          reaper.TrackFX_SetOpen(track, fxnum, open)
        
        end 
  
      end
    end
    
  end
  
  function EQC_UpdateVals()
  
    if strips[tracks[track_select].strip] and strips[tracks[track_select].strip][page].controls[eqcontrol_select] then
      local eqc = strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands
      if eqc then
        local track = GetTrack(tracks[track_select].tracknum)
        for i = 1, #eqc do
    
          local fxnum = GetEQC_FXNum(i)
          if fxnum ~= -1 then
        
            if eqc[i].freq_param then
              --DBG('f')
              local v = reaper.TrackFX_GetParamNormalized(track, fxnum, eqc[i].freq_param)
              --local v2 = reaper.TrackFX_GetParam(track, fxnum, eqc[i].freq_param)
              --DBG(v..'  '..eqc[i].freq_val..'  '..v2)
              if v ~= eqc[i].freq_val then
                --eqc[i].freq_val = v
                --DBG('A')
                update_eqcontrol = true
                break
              end
            end
            if eqc[i].gain_param then
              local v = reaper.TrackFX_GetParamNormalized(track, fxnum, eqc[i].gain_param)
              if v ~= eqc[i].gain_val then
                --eqc[i].gain_val = v
                update_eqcontrol = true
                break
              end      
            end
            
            if i == eqcontrolband_select then
              if eqc[i].q_param then
                local v = reaper.TrackFX_GetParamNormalized(track, fxnum, eqc[i].q_param)
                if v ~= eqc[i].q_val then
                  --eqc[i].q_val = v
                  update_eqcontrol = true
                  break
                end      
              end
              if eqc[i].c1_param then
                local v = reaper.TrackFX_GetParamNormalized(track, fxnum, eqc[i].c1_param)
                if v ~= eqc[i].c1_val then
                  update_eqcontrol = true
                  break
                end        
              end    
              if eqc[i].c2_param then
                local v = reaper.TrackFX_GetParamNormalized(track, fxnum, eqc[i].c2_param)
                if v ~= eqc[i].c2_val then
                  update_eqcontrol = true
                  break
                end          
              end    
              if eqc[i].c3_param then
                local v = reaper.TrackFX_GetParamNormalized(track, fxnum, eqc[i].c3_param)
                if v ~= eqc[i].c3_val then
                  update_eqcontrol = true
                  break
                end        
              end    
              if eqc[i].c4_param then
                local v = reaper.TrackFX_GetParamNormalized(track, fxnum, eqc[i].c4_param)
                if v ~= eqc[i].c4_val then
                  update_eqcontrol = true
                  break
                end        
              end    
              if eqc[i].c5_param then
                local v = reaper.TrackFX_GetParamNormalized(track, fxnum, eqc[i].c5_param)
                if v ~= eqc[i].c5_val then
                  update_eqcontrol = true
                  break
                end        
              end    
            end    
          end        
        end
      end  
    end
  end
  
  function GetEQC_FXNum(band)
    local fxnum = strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[band].fxnum
    local track = GetTrack(tracks[track_select].tracknum)
    if track and fxnum then
      if reaper.TrackFX_GetFXGUID(track, fxnum) == strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[band].fxguid then
        return fxnum
      else
        local fxcnt = reaper.TrackFX_GetCount(track)
        local guids = {}
        for i = 0, fxcnt-1 do
          local guid = reaper.TrackFX_GetFXGUID(track, i)
          guids[guid] = i
        end
        for i = 1, #strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands do
          local guid = strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[i].fxguid
          if guids[guid] then
            strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[i].fxnum = guids[guid]
          else
            strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[i].fxnum = -1
          end
        end
        
        fxnum = strips[tracks[track_select].strip][page].controls[eqcontrol_select].eqbands[band].fxnum
        return fxnum
      end
    end
  end
  
  function SetCtlBitmapRedraw()
    if settings_usectlbitmap then
      redraw_ctlbitmap = reaper.time_precise() + 0.5
    else
      redraw_ctlbitmap = nil
    end
  end
  
  function XXYRecord_Set(val)
  
    if LBX_CTL_TRACK and tracks[LBX_CTL_TRACK] then
      xxyrecord = val
      if xxyrecord then
        --set automode to touch
        local track = GetTrack(tracks[LBX_CTL_TRACK].tracknum)
        reaper.SetTrackAutomationMode(track, 4)
      else
        --set automode to trim/read
        local track = GetTrack(tracks[LBX_CTL_TRACK].tracknum)
        reaper.SetTrackAutomationMode(track, 0)      
      end
    else
      xxyrecord = false
    end    
  end
  
  function XXYPath_SetPos(strip, page, sst, pos, fader)
  
    if xxy and xxy[strip] and xxy[strip][page][sst] then
      local xxypath_sel = xxy[strip][page][sst].pathidx
      if xxypath_sel and xxypath[xxypath_sel] and xxypath[xxypath_sel].points and xxypath[xxypath_sel].points[1] and xxypath[xxypath_sel].points[1].t then
        if xxyrecord and xxymode == 1 then 
          local track = GetTrack(tracks[LBX_CTL_TRACK].tracknum)
          local pf = xxy[strip][page][sst].pathfader
          if pf and faders[pf] then
            local fxnum = math.floor((pf-1)/LBX_FB_CNT)
            local param = ((pf-1) % LBX_FB_CNT)
            reaper.TrackFX_SetParam(track, fxnum, param, pos)
            faders[pf].val = pos
          end
        end
        
        local xxypath_indexcnt = #xxypath[xxypath_sel].pathidxpt
        local posidx = F_limit(math.floor(pos*xxypath_indexcnt),0,xxypath_indexcnt)
        local pt = math.max(xxypath[xxypath_sel].pathidxpt[posidx],1)
        while xxypath[xxypath_sel].points[pt].posend < pos do
          pt = pt + 1
        end
        
        local secpos = F_limit((pos-xxypath[xxypath_sel].points[pt].posstart)/(xxypath[xxypath_sel].points[pt].posend-xxypath[xxypath_sel].points[pt].posstart),0,1)
        local sp2 = xxypath[xxypath_sel].points[pt].t[math.floor(secpos*#xxypath[xxypath_sel].points[pt].t)]
        local x,y = curve_getxy(xxypath[xxypath_sel].points[pt].x, xxypath[xxypath_sel].points[pt].y, sp2)
        local ox, oy = xxy[strip][page][sst].x, xxy[strip][page][sst].y
        
        xxy[strip][page][sst].x = F_limit(x,0,1)
        xxy[strip][page][sst].y = F_limit(y,0,1)
        if xxy[strip][page][sst].x ~= ox or xxy[strip][page][sst].y ~= oy then
          XXY_Set(strip, page, sst)
        end
      elseif fader and (xxypath_sel == nil or xxypath[xxypath_sel] == nil) then
        DeleteFader(fader)  
      end    
    elseif fader then
      DeleteFader(fader)  
    end
  end

  function XXYPath_SetPos2(strip, page, sst, pos)
  
    local xxypath_sel = xxy[strip][page][sst].pathidx
    if xxypath_sel and xxypath[xxypath_sel] then
      
      local xxypath_indexcnt = #xxypath[xxypath_sel].pathidxpt
      local posidx = F_limit(math.floor(pos*xxypath_indexcnt),0,xxypath_indexcnt)
      local pt = math.max(xxypath[xxypath_sel].pathidxpt[posidx],1)
      while xxypath[xxypath_sel].points[pt].posend < pos do
        pt = pt + 1
      end
      
      local secpos = F_limit((pos-xxypath[xxypath_sel].points[pt].posstart)/(xxypath[xxypath_sel].points[pt].posend-xxypath[xxypath_sel].points[pt].posstart),0,1)
      local x,y = curve_getxy(xxypath[xxypath_sel].points[pt].x, xxypath[xxypath_sel].points[pt].y, secpos)
      local ox, oy = xxy[strip][page][sst].x, xxy[strip][page][sst].y
      
      xxy[strip][page][sst].x = F_limit(x,0,1)
      xxy[strip][page][sst].y = F_limit(y,0,1)
      
      if xxy[strip][page][sst].x ~= ox or xxy[strip][page][sst].y ~= oy then
        XXY_Set(strip, page, sst)
      end
    end    
  end
  
  function LoadPath()
  
    if xxy and xxy[tracks[track_select].strip] and xxy[tracks[track_select].strip][page][sstype_select] then

      local retval, fn = reaper.GetUserFileNameForRead(paths_path..'*', 'Load Meta Path', '.path')
      if retval then
      
        if reaper.file_exists(fn) then
        
          local file
          file=io.open(fn,"r")
          local content=file:read("*a")
          file:close()
          
          local loaddata = unpickle(content)
          if loaddata then
            
            if xxypath_select == nil then
              xxypath_select = #xxypath+1
              xxy[tracks[track_select].strip][page][sstype_select].pathidx = xxypath_select
            end
            xxypath[xxypath_select] = {}
            xxypath[xxypath_select] = loaddata
          end
  
          update_gfx = true
          
        else
          OpenMsgBox(1,'File not found.',1)
        end
      
      end
        
    end

  end
    
  function SavePath(fn)

    if fn and string.len(fn)>0 then
    
      local save_path=paths_path
      local fn=save_path..fn..".path"
      
      local DELETE=true
      local file
      
      if reaper.file_exists(fn) then
      
      end
      
      if DELETE then
        file=io.open(fn,"w")
        local pickled_table=pickle(xxypath[xxypath_select])
        file:write(pickled_table)
        file:close()
      end
      
      OpenMsgBox(1,'Path saved.',1)
      
    end
        
  end
  
  function XXYPATH_movept(pt, x, y)

    if #xxypath[xxypath_select].points > 1 then
      if pt.sp == 1 then
      
        if pt.p == 1 then
        
          xxypath[xxypath_select].points[pt.p].x[pt.sp] = F_limit(x,0,1)
          xxypath[xxypath_select].points[pt.p].y[pt.sp] = F_limit(y,0,1)
          xxypath[xxypath_select].points[pt.p].x[2] = F_limit(x+pt.dx2,0,1)
          xxypath[xxypath_select].points[pt.p].y[2] = F_limit(y+pt.dy2,0,1)
  
          xxypath[xxypath_select].points[pt.p].len = XXYPath_CalcPathSectionLength(pt.p)
        
        else
        
          xxypath[xxypath_select].points[pt.p].x[pt.sp] = F_limit(x,0,1)
          xxypath[xxypath_select].points[pt.p].y[pt.sp] = F_limit(y,0,1)
          xxypath[xxypath_select].points[pt.p-1].x[4] = F_limit(x,0,1)
          xxypath[xxypath_select].points[pt.p-1].y[4] = F_limit(y,0,1)
          xxypath[xxypath_select].points[pt.p].x[2] = F_limit(x+pt.dx2,0,1)
          xxypath[xxypath_select].points[pt.p].y[2] = F_limit(y+pt.dy2,0,1)
          xxypath[xxypath_select].points[pt.p-1].x[3] = F_limit(x-pt.dx3,0,1)
          xxypath[xxypath_select].points[pt.p-1].y[3] = F_limit(y-pt.dy3,0,1)
  
          xxypath[xxypath_select].points[pt.p].len = XXYPath_CalcPathSectionLength(pt.p)
          xxypath[xxypath_select].points[pt.p-1].len = XXYPath_CalcPathSectionLength(pt.p-1)
        
        end
      
      else
  
        if pt.p >= #xxypath[xxypath_select].points-1  then
        
          xxypath[xxypath_select].points[pt.p].x[pt.sp] = F_limit(x,0,1)
          xxypath[xxypath_select].points[pt.p].y[pt.sp] = F_limit(y,0,1)
          xxypath[xxypath_select].points[pt.p].x[3] = F_limit(x-pt.dx3,0,1)
          xxypath[xxypath_select].points[pt.p].y[3] = F_limit(y-pt.dy3,0,1)
          if pt.p == #xxypath[xxypath_select].points-1 then
            xxypath[xxypath_select].points[pt.p+1].x[1] = F_limit(x,0,1)
            xxypath[xxypath_select].points[pt.p+1].y[1] = F_limit(y,0,1)      
          end
  
        else
        
          xxypath[xxypath_select].points[pt.p].x[pt.sp] = F_limit(x,0,1)
          xxypath[xxypath_select].points[pt.p].y[pt.sp] = F_limit(y,0,1)
          xxypath[xxypath_select].points[pt.p+1].x[1] = F_limit(x,0,1)
          xxypath[xxypath_select].points[pt.p+1].y[1] = F_limit(y,0,1)
          xxypath[xxypath_select].points[pt.p+1].x[2] = F_limit(x+pt.dx2,0,1)
          xxypath[xxypath_select].points[pt.p+1].y[2] = F_limit(y+pt.dy2,0,1)
          xxypath[xxypath_select].points[pt.p].x[3] = F_limit(x-pt.dx3,0,1)
          xxypath[xxypath_select].points[pt.p].y[3] = F_limit(y-pt.dy3,0,1)
        
        end
  
        xxypath[xxypath_select].points[pt.p].len = XXYPath_CalcPathSectionLength(pt.p)
        xxypath[xxypath_select].points[pt.p+1].len = XXYPath_CalcPathSectionLength(pt.p+1)
      
      end    
    else
      xxypath[xxypath_select].points[pt.p].x[1] = F_limit(x,0,1)
      xxypath[xxypath_select].points[pt.p].y[1] = F_limit(y,0,1)
    
    end    
  end
  
  function XXYPATH_movectlpt(ctlpt, x, y)
  
    if ctlpt.sp == 2 then
    
      if ctlpt.p == 1 then
      
        xxypath[xxypath_select].points[ctlpt.p].x[ctlpt.sp] = F_limit(x,0,1)
        xxypath[xxypath_select].points[ctlpt.p].y[ctlpt.sp] = F_limit(y,0,1)

        xxypath[xxypath_select].points[ctlpt.p].len = XXYPath_CalcPathSectionLength(ctlpt.p)
        
      else

        xxypath[xxypath_select].points[ctlpt.p].x[ctlpt.sp] = F_limit(x,0,1)
        xxypath[xxypath_select].points[ctlpt.p].y[ctlpt.sp] = F_limit(y,0,1)

        local sp2_opp = xxypath[xxypath_select].points[ctlpt.p].x[2]-xxypath[xxypath_select].points[ctlpt.p].x[1]
        local sp2_adj = xxypath[xxypath_select].points[ctlpt.p].y[2]-xxypath[xxypath_select].points[ctlpt.p].y[1]
        local sp3_theta = math.atan(sp2_opp/sp2_adj)

        local sp3_x, sp3_y                                    
        if sp2_adj >= 0 then
          sp3_x = xxypath[xxypath_select].points[ctlpt.p-1].x[4]-math.sin(sp3_theta)*ctlpt.hyp
          sp3_y = xxypath[xxypath_select].points[ctlpt.p-1].y[4]-math.cos(sp3_theta)*ctlpt.hyp
        else
          sp3_x = xxypath[xxypath_select].points[ctlpt.p-1].x[4]+math.sin(sp3_theta)*ctlpt.hyp
          sp3_y = xxypath[xxypath_select].points[ctlpt.p-1].y[4]+math.cos(sp3_theta)*ctlpt.hyp
        end
        xxypath[xxypath_select].points[ctlpt.p-1].x[3] = F_limit(sp3_x,0,1)
        xxypath[xxypath_select].points[ctlpt.p-1].y[3] = F_limit(sp3_y,0,1)

        xxypath[xxypath_select].points[ctlpt.p].len = XXYPath_CalcPathSectionLength(ctlpt.p)
        xxypath[xxypath_select].points[ctlpt.p-1].len = XXYPath_CalcPathSectionLength(ctlpt.p-1)
        
      end
    
    else
    
      if ctlpt.p >= #xxypath[xxypath_select].points-1 then

        xxypath[xxypath_select].points[ctlpt.p].x[ctlpt.sp] = F_limit(x,0,1)
        xxypath[xxypath_select].points[ctlpt.p].y[ctlpt.sp] = F_limit(y,0,1)
    
        xxypath[xxypath_select].points[ctlpt.p].len = XXYPath_CalcPathSectionLength(ctlpt.p)
      else

        xxypath[xxypath_select].points[ctlpt.p].x[ctlpt.sp] = F_limit(x,0,1)
        xxypath[xxypath_select].points[ctlpt.p].y[ctlpt.sp] = F_limit(y,0,1)

        local sp3_opp = xxypath[xxypath_select].points[ctlpt.p].x[4]-xxypath[xxypath_select].points[ctlpt.p].x[3]
        local sp3_adj = xxypath[xxypath_select].points[ctlpt.p].y[4]-xxypath[xxypath_select].points[ctlpt.p].y[3]
        local sp2_theta = math.atan(sp3_opp/sp3_adj)

        local sp2_x, sp2_y
        if sp3_adj < 0 then
          sp2_x = xxypath[xxypath_select].points[ctlpt.p+1].x[1]-math.sin(sp2_theta)*ctlpt.hyp
          sp2_y = xxypath[xxypath_select].points[ctlpt.p+1].y[1]-math.cos(sp2_theta)*ctlpt.hyp
        else
          sp2_x = xxypath[xxypath_select].points[ctlpt.p+1].x[1]+math.sin(sp2_theta)*ctlpt.hyp
          sp2_y = xxypath[xxypath_select].points[ctlpt.p+1].y[1]+math.cos(sp2_theta)*ctlpt.hyp
        end
        xxypath[xxypath_select].points[ctlpt.p+1].x[2] = F_limit(sp2_x,0,1)
        xxypath[xxypath_select].points[ctlpt.p+1].y[2] = F_limit(sp2_y,0,1)

        xxypath[xxypath_select].points[ctlpt.p].len = XXYPath_CalcPathSectionLength(ctlpt.p)
        xxypath[xxypath_select].points[ctlpt.p+1].len = XXYPath_CalcPathSectionLength(ctlpt.p+1)
      
      end

    end
  
  end
  
  function XXYPATH_addpoint(x,y)
  
    --[[if #xxypath == 0 then
      xxypath = {points = {x = {}, y = {}}}
    end]]
    if xxypath_select == nil then
      local strip = tracks[track_select].strip
      if xxy and xxy[strip] and xxy[strip][page][sstype_select] then
        xxypath_select = #xxypath + 1
        xxy[strip][page][sstype_select].pathidx = xxypath_select
      else
        return
      end
    end
    
    if xxypath[xxypath_select] == nil then
      xxypath[xxypath_select] = {}
      xxypath[xxypath_select].points = {}
    end
    
    local p = #xxypath[xxypath_select].points
    if p == 0 then
      xxypath[xxypath_select].points[p+1] = {x={x},y={y}}
    else
      xxypath[xxypath_select].points[p+1] = {x={x},y={y}}
      
      xxypath[xxypath_select].points[p].x[4] = x
      xxypath[xxypath_select].points[p].y[4] = y
      
      if p == 1 then
        xxypath[xxypath_select].points[p].x[2] = (xxypath[xxypath_select].points[p].x[4] - xxypath[xxypath_select].points[p].x[1]) * 0.25 + xxypath[xxypath_select].points[p].x[1]
        xxypath[xxypath_select].points[p].y[2] = (xxypath[xxypath_select].points[p].y[4] - xxypath[xxypath_select].points[p].y[1]) * 0.25 + xxypath[xxypath_select].points[p].y[1]
      else
        xxypath[xxypath_select].points[p].x[2] = xxypath[xxypath_select].points[p].x[1] + (xxypath[xxypath_select].points[p-1].x[4] - xxypath[xxypath_select].points[p-1].x[3])
        xxypath[xxypath_select].points[p].y[2] = xxypath[xxypath_select].points[p].y[1] + (xxypath[xxypath_select].points[p-1].y[4] - xxypath[xxypath_select].points[p-1].y[3])     
      end
      xxypath[xxypath_select].points[p].x[3] = (xxypath[xxypath_select].points[p].x[4] - xxypath[xxypath_select].points[p].x[1]) * 0.75 + xxypath[xxypath_select].points[p].x[1]
      xxypath[xxypath_select].points[p].y[3] = (xxypath[xxypath_select].points[p].y[4] - xxypath[xxypath_select].points[p].y[1]) * 0.75 + xxypath[xxypath_select].points[p].y[1]
      
    end
  
    if p > 0 then
      xxypath[xxypath_select].points[p].len = XXYPath_CalcPathSectionLength(p)
      xxypath[xxypath_select].pathlen = XXYPath_CalcPathLen(xxypath_select)      
    end
    
  end
  
  function XXYPath_CalcPathLen(xxysel)
  
    local len = 0
    if #xxypath[xxysel].points > 1 then
      for pt = 1, #xxypath[xxysel].points do
        if xxypath[xxysel].points[pt].len then
          len = len + xxypath[xxysel].points[pt].len
        end
      end
      local ppos = 0
      for pt = 1, #xxypath[xxysel].points do
        if xxypath[xxysel].points[pt].len then
          if pt == 0 then
            xxypath[xxysel].points[pt].posstart = 0
          else
            xxypath[xxysel].points[pt].posstart = ppos / len
          end
          xxypath[xxysel].points[pt].posend = (ppos + xxypath[xxysel].points[pt].len)/ len
          ppos = ppos + xxypath[xxysel].points[pt].len
        end
      end
      
      xxypath[xxysel].pathidxpt = {}
      local pt = 1
      for pi = 0,xxypath_indexcnt do
        local pival = 1/xxypath_indexcnt * pi
        while xxypath[xxysel].points[pt] and xxypath[xxysel].points[pt].posstart and (xxypath[xxysel].points[pt].posstart <= pival) do
          pt = pt + 1
        end
        xxypath[xxysel].pathidxpt[pi] = pt-1
      end
            
    end
    return len
  
  end
  
  function XXYPath_CalcPathSectionLength(pt)
    if #xxypath[xxypath_select].points > 1 and pt < #xxypath[xxypath_select].points then
      return path_length(xxypath[xxypath_select].points[pt].x,xxypath[xxypath_select].points[pt].y,xxypath[xxypath_select].points[pt])
    end
  end
  
  function path_length(x_table, y_table, pt)
    order = #x_table
    ----------------------------
    ----------------------------
    function bezier_eq(n, tab_xy, dt)
      local B = 0
      for i = 0, n-1 do
        B = B + 
          ( fact[n] / ( fact[i] * fact[n-i] ) ) 
          *  (1-dt)^(n-i)  
          * dt ^ i
          * tab_xy[i+1]
      end 
      return B
    end  
    ----------------------------
    local ox,oy = nil, nil
    local pathl = 0
    pt.lens = {}
    local resolution = 1/1000
    for t = 0, 1, resolution do
      x_point = bezier_eq(order, x_table, t)+ t^order*x_table[order]
      y_point = bezier_eq(order, y_table, t)+ t^order*y_table[order] 
      x = (x_point)
      y = (y_point)
      if ox and oy then
        local secl = math.sqrt((x_point-ox)^2+(y_point-oy)^2)
        pathl = pathl + secl
      end
      pt.lens[tonumber(string.format('%i',tostring((1/resolution)*t)))] = pathl
      ox,oy = x,y
    end
    local def = math.floor(math.max(pathl * 500,xxypath_tres))
    local p = 0
    pt.t = {}
    for d = 0, def do
      while p < #pt.lens and pt.lens[p] / pathl < d/def do
        p = p + 1
      end
      pt.t[d] = math.max(resolution * (p-1),0)
    end
    pt.lens = nil
    return pathl
  end

  function Faders_Check(strip, page)
    if LBX_CTL_TRACK then    
    
      local ccc = trackfxparam_select
    
      local track = GetTrack(tracks[LBX_CTL_TRACK].tracknum)
      if tracks[LBX_CTL_TRACK].guid ~= reaper.GetTrackGUID(track) then
        PopulateTracks()
      end
      for fxnum = 0, LBX_CTL_TRACK_INF.count-1 do
        for pf = 0, LBX_FB_CNT-1 do
          p = fxnum * LBX_FB_CNT + pf
          if faders[p+1].targettype then
            if faders[p+1].targettype == 2 then
              --macro check
              if faders[p+1].c_id then
                local ctls = strips[faders[p+1].strip][faders[p+1].page].controls
                if ctls[faders[p+1].ctl] == nil or (ctls[faders[p+1].ctl] and faders[p+1].c_id ~= ctls[faders[p+1].ctl].c_id) then
                  local fnd = false
                  for c = 1, #ctls do
                    if ctls[c].c_id == faders[p+1].c_id then
                      fnd = true
                      faders[p+1].ctl = c
                      break
                    end
                  end
                  if fnd == false then
                    --not found - delete assignment - macro control deleted
                    faders[p+1] = {}
                  end
                end
              end
            end
          end    
        end
      end
    end
  end
  
  function Macro_Capture(strip, page, ctl, ab)
  
    local macro = strips[strip][page].controls[ctl].macroctl
    for m = 1, #macro do

      local ctl = macro[m].ctl
      local v = strips[strip][page].controls[ctl].val
      
      if ab == 0 then
        macro[m].A_val = v
      else
        if macro[m].bi == false then
          macro[m].B_val = v
        end
      end
    
    end
    
  end

  function Macros_Check(strip, page)
  
    local ctls = strips[strip][page].controls
    if ctls and #ctls > 0 then
      
      local cids = {}
      for c = 1,#ctls do
        cids[ctls[c].c_id] = c
      end    
      
      for c = 1,#ctls do
    
        if ctls[c].ctlcat == ctlcats.macro then  
    
          local macro = ctls[c].macroctl
          
          if macro and #macro > 0 then
          
            local mcnt = #macro
            for m = 1, mcnt do
          
              if macro[m].c_id ~= ctls[macro[m].ctl] then
          
                if cids[macro[m].c_id] then
                  macro[m].ctl = cids[macro[m].c_id]
                else
                  --deleted
                  macro[m] = nil
                end
              end
            end
            strips[strip][page].controls[c].macroctl = Table_RemoveNils(macro, mcnt)
          end
        end
      end
    end
  
  end
  
  function Macro_UpdateCtls(strip, page, ctl)

    local macro = strips[strip][page].controls[ctl].macroctl
    if macro then
      local nmacro = {}
      local mcnt = #macro
      for m = 1, mcnt do
      
        if macro[m].delete then
          macro[m] = nil
        end
      
      end
      nmacro = Table_RemoveNils(macro, mcnt)
      strips[strip][page].controls[ctl].macroctl = nmacro
    
      update_gfx = true
    end 
  end
  
  function SetMacro(strip, page, ctl, mon)

    ofxparam = trackfxparam_select
    local ctls = strips[strip][page].controls
    local macro = ctls[ctl].macroctl
    ctls[ctl].dirty = true
    if macro then
      local byp = {}
      for m = 1, #macro do
      
        if macro[m].mute == false or macro[m].mute == nil then
          if macro[m].relative ~= true then
            if macro[m].bi == true then
  
              local c = ctls[macro[m].ctl]
              local mv = ctls[ctl].val
              local ma = macro[m].A_val
              local mb = macro[m].B_val
              trackfxparam_select = macro[m].ctl
              
              local v
              if macro[m].inv then
                v = F_limit(ma - macScale(macro[m].shape,(mv-0.5)*2) * mb,F_limit(ma-mb,0,1),F_limit(ma+mb,0,1))            
              else
                v = F_limit(ma + macScale(macro[m].shape,(mv-0.5)*2) * mb,F_limit(ma-mb,0,1),F_limit(ma+mb,0,1))
              end
              if v ~= macro[m].oval then
                c.val = v
                A_SetParam(strip, page, trackfxparam_select, c)
                macro[m].oval = v
                if c.param_info.paramname == 'Bypass' then
                  byp[#byp+1] = c.fxnum
                end
              end
            
            else
              local c = ctls[macro[m].ctl]
              local mv = ctls[ctl].val
              local ma = macro[m].A_val
              local mb = macro[m].B_val
              
              trackfxparam_select = macro[m].ctl
              local v
              if macro[m].inv then            
                v = (ma - mb) * macScale(macro[m].shape,mv) + mb              
              else
                v = (mb - ma) * macScale(macro[m].shape,mv) + ma
              end
              if v ~= macro[m].oval then
                c.val = v
                A_SetParam(strip, page, trackfxparam_select, c)
                macro[m].oval = v
                if c.param_info.paramname == 'Bypass' then
                  byp[#byp+1] = c.fxnum
                end
              end
            end

          elseif mon ~= true then

            local c = ctls[macro[m].ctl]
            local mc = ctls[ctl]
            local mva = mc.val
            local mov = mc.oval
            if not mov then mov = mva end
            local mv = -(macScale(macro[m].shape,mov)-macScale(macro[m].shape,mva))
            local ma = macro[m].A_val
            local mb = macro[m].B_val
            if mv then
              mv =  mv * mb 
              trackfxparam_select = macro[m].ctl
              if macro[m].inv then            
                mv = -mv             
              end
              if c.mval then
                v = c.mval + mv
              else
                v = c.val + mv
              end

              if v ~= macro[m].oval then

                c.val = F_limit(v,0,1)
                A_SetParam(strip, page, trackfxparam_select, c)
                c.mval = v
                macro[m].oval = v
                if c.param_info.paramname == 'Bypass' then
                  byp[#byp+1] = c.fxnum
                end
              end            
            end          
          end
        end
      end
      if #byp > 0 then
        SetCtlsEnabled(byp)
      end
    end
    trackfxparam_select = ofxparam
      
  end
  
  function XXY_Set(strip, page, sst)
  
    if sst > 1 then
    
      local fsqrt = math.sqrt
      local fmin = math.min
      local fmax = math.max
      local ffloor = math.floor
      
      xxy_mindist = 1
      xxy_maxdist = 0
      local xxytbl = xxy[strip][page][sst]
      local d = {}
      local gtrack = GetTrack(strips[strip].track.tracknum)
      local px, py = xxytbl.x, xxytbl.y
      if xxyrecord and xxymode == 0 then 
        local track = GetTrack(tracks[LBX_CTL_TRACK].tracknum)
        local xf = xxytbl.xfader
        local yf = xxytbl.yfader
        if xf and faders[xf] then
          local fxnum = ffloor((xf-1)/LBX_FB_CNT)
          local param = ((xf-1) % LBX_FB_CNT)
          reaper.TrackFX_SetParam(track, fxnum, param, px)
          faders[xf].val = px
        end
        if yf and faders[yf] then
          local fxnum = ffloor((yf-1)/LBX_FB_CNT)
          local param = (yf-1) % LBX_FB_CNT
          reaper.TrackFX_SetParam(track, fxnum, param, py)
          faders[yf].val = py
        end        
      end
      for p = 1, #xxytbl.points do
        d[p] = fsqrt((px - xxytbl.points[p].x)^2 + (py - xxytbl.points[p].y)^2)
        xxytbl.points[p].d2 = d[p]
        d[p] = d[p]^xxy_gravity
        xxytbl.points[p].distance = d[p]
        xxy_mindist = fmin(xxy_mindist,d[p])
        xxy_maxdist = fmax(xxy_maxdist,d[p])
      end
      for ctl = 1, #snapshots[strip][page][sst].ctls do
        local num, den = 0, 0
        for p = 1, #d do
          if xxytbl.points[p].inactive ~= true then
            local ss = xxytbl.points[p].ss
            if snapshots[strip][page][sst].snapshot[ss].data[ctl] then
              local v = snapshots[strip][page][sst].snapshot[ss].data[ctl].dval
              if v then
                num = num + v/d[p]
                den = den + 1/d[p]
              end
            end
          end
        end
        local nv = num/den
        
        if xxytbl.points[1] then
          local ss = xxytbl.points[1].ss
          if snapshots[strip][page][sst].snapshot[ss].data[ctl] then
            local c = snapshots[strip][page][sst].snapshot[ss].data[ctl].ctl
            if c and nv and nv < 1/0 and nv > -1/0 then
              trackfxparam_select = c
              if strips[strip][page].controls[c].tracknum then
                track = GetTrack(strips[strip][page].controls[c].tracknum)
              else
                track = gtrack
              end
              if tostring(nv) ~= tostring(strips[strip][page].controls[c].xxydval) then
                SetParam3_Denorm2_Safe(track, nv, strip, page)
                strips[strip][page].controls[c].xxydval = nv
              end        
            end
          end
        end
      end
    end

  end
  
  function XXY_INIT(strip, page, sst)
    if xxy == nil then
      xxy = {}
    end
    if xxy[strip] == nil then
      xxy[strip] = {}
    end
    if xxy[strip][page] == nil then
      xxy[strip][page] = {}
    end
    if xxy[strip][page][sst] == nil then
      xxy[strip][page][sst] = {x = 0.5, y = 0.5, points = {}}
    end
  end
  
  function ReselectSelection()
  
    local tbl = {}
    tbl[1] = {ctl = ctl_select[1].ctl}
    for i = 2, #ctl_select do
    
      tbl[i] = {}
      tbl[i].ctl = ctl_select[i].ctl
      tbl[i].relx = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].x - strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].x    
      tbl[i].rely = strips[tracks[track_select].strip][page].controls[ctl_select[1].ctl].y - strips[tracks[track_select].strip][page].controls[ctl_select[i].ctl].y
    
    end
    
    ctl_select = tbl
      
  end
  
  function GetLastTouchedFX(lastfx)
    
    local rt, tr, fx, pr = reaper.GetLastTouchedFX()
    if rt == true then
      if lastfx == nil or (lastfx ~= nil and (tr-1 ~= lastfx.tracknum or fx ~= lastfx.fxnum or pr ~= lastfx.paramnum)) then
        local track = GetTrack(tr-1)
        if track ~= nil then
          local tn = reaper.GetTrackState(track)
          local trg = reaper.GetTrackGUID(track)
          local _, fxn = reaper.TrackFX_GetFXName(track, fx, '')
          local fxg = reaper.TrackFX_GetFXGUID(track, fx)
          local _, prn = reaper.TrackFX_GetParamName(track, fx, pr, '')
          lastfx = {tracknum = tr-1,
                    trguid = trg,
                    fxnum = fx,
                    paramnum = pr,
                    trname = tn,
                    fxname = fxn,
                    fxguid = fxg,
                    prname = prn}
          update_gfx = true
        end
      end
      return lastfx
    else
      return lastfx
    end
  
  end
  
  function Cycle_InitData()
  
    if cycle_select.statecnt > 0 then

      trackfxparam_select = ctl_select[1].ctl
      local strip = tracks[track_select].strip
      local ctl = strips[strip][page].controls[trackfxparam_select]
      local tracknum = strips[strip].track.tracknum
      if ctl.tracknum ~= nil then
        tracknum = ctl.tracknum
      end
      local cc = ctl.ctlcat
      local fxnum = ctl.fxnum
      local param = ctl.param
      local dvoff = ctl.dvaloffset
      for i = 1, cycle_select.statecnt do      
        if cycle_select[i] == nil or (cycle_select[i] and cycle_select[i].dispval == nil) then
          if cc ~= ctlcats.action then
            SetParam3(strip,page,trackfxparam_select,ctl,cycle_select.val)
          end
          local dv = GetParamDisp(cc, tracknum, fxnum, param, dvoff,trackfxparam_select)
          cycle_select[i] = {val = cycle_select.val, dispval = dv, dv = dv}
        end
      end
      cycle_select.selected = cycle_select.statecnt
      
      if cc ~= ctlcats.action then
        A_SetParam(strip,page,trackfxparam_select,ctl)
      end
      
    end
  
  end
  
  function Cycle_CopySelectIn(ctl)
  
    local cd = {}
    if strips[tracks[track_select].strip][page].controls[ctl].cycledata then
      cd = strips[tracks[track_select].strip][page].controls[ctl].cycledata
      local co
      if cd.statecnt > 0 then
        co = {statecnt = cd.statecnt,
                    selected = cd.selected,
                    mapptof = cd.mapptof,
                    draggable = cd.draggable,
                    spread = cd.spread,
                    val = 0,
                    {}}
      else
        co = {statecnt = cd.statecnt,
                    selected = cd.selected,
                    mapptof = mapptof_select,
                    draggable = draggable_select,
                    spread = spread_select,
                    val = 0,
                    {}}      
      end
      for i = 1, max_cycle do
        if cd[i] then
          co[i] = {val = cd[i].val, dispval = cd[i].dispval, dv = cd[i].dv}
        end
      end
      return co
    else
      return {statecnt = 0,mapptof = mapptof_select,draggable = draggable_select,spread = spread_select,val = 0,nil}
    end    
  end
  
  function Cycle_CopySelectOut()
  
    local cd = {}
    if cycle_select then
      cd = cycle_select
      local co = {statecnt = cd.statecnt,
                  selected = cd.selected,
                  mapptof = cd.mapptof,
                  draggable = cd.draggable,
                  spread = cd.spread,
                  {}}
      for i = 1, max_cycle do
        if cd[i] then
          co[i] = {val = tonumber(cd[i].val), dispval = cd[i].dispval, dv = cd[i].dv}
        end
      end
      co = cycledata_slowsort(cd)
      return co
    else
      return {statecnt = 0,mapptof = false,draggable = false,spread = false,pos = 1,{}}
    end    
  end
  
  function Cycle_Norm(v, c)
  
    if c then
    
      local cc = strips[tracks[track_select].strip][page].controls[c].ctlcat
      if cc == ctlcats.fxparam then
        local min, max = GetParamMinMax_ctl(c)
        return normalize(min, max, v)
      elseif cc ~= ctlcats.action then 
        local min, max = GetParamMinMax_ctl(c)
        return F_limit(v,min,max)
      end
    
    end
  
  end
  
  function Cycle_DeleteStep(step)
    
    local cd = {}
    if cycle_select then
      cd = cycle_select
      local co = {statecnt = cd.statecnt,
                  selected = nil,
                  mapptof = cd.mapptof,
                  draggable = cd.draggable,
                  spread = cd.spread,
                  val = 0,
                  {}}
      cd[step] = nil
      local ins = 0
      for i = 1, max_cycle do
        if cd[i] then
          ins = ins + 1
          co[ins] = {val = tonumber(cd[i].val), dispval = cd[i].dispval, dv = cd[i].dv}
        end
      end
      co.statecnt = ins
      return co
    else
      return {statecnt = 0,mapptof = false,draggable = false,spread = false,pos = 1,{}}
    end    
  end
  
  function Cycle_Auto()
  
    local sldiv = 400
    --local ad = auto_delay*1000000
    --DBG(auto_delay)
    if cycle_select.statecnt == 0 then
    
      trackfxparam_select = ctl_select[1].ctl
      local strip = tracks[track_select].strip
      local ctl = strips[tracks[track_select].strip][page].controls[trackfxparam_select]
      local v, v2 = 0.0,0.0
  
      local tracknum = strips[strip].track.tracknum
      if ctl.tracknum ~= nil then
        tracknum = ctl.tracknum
      end
      local cc = ctl.ctlcat
      local fxnum = ctl.fxnum
      local param = ctl.param
      local dvoff = ctl.dvaloffset
      
      SetParam3(strip,page,trackfxparam_select,ctl,v)
      local x = 0
      os.sleep((auto_delay/sldiv)*10)
      local dval = GetParamDisp(cc, tracknum, fxnum, param, dvoff,trackfxparam_select)
      local stcnt = 1
      local ndval
      
      cycle_temp = {}
      cycle_temp[1] = {val = v, dispval = dval, dv = dval}
      
      for v = 0.01, 1, 0.01 do
        
        GUI_DrawMsgX(obj, gui, 'Scanning values...', v, 1)
        SetParam3(strip,page,trackfxparam_select,ctl,v)
        local x = 0
        os.sleep((auto_delay/sldiv)*10)
        ndval = GetParamDisp(cc, tracknum, fxnum, param, dvoff,trackfxparam_select)
        if ndval ~= dval then
          dval = ndval
          local v2 = GetParamValue(cc, tracknum, fxnum, param, trackfxparam_select)
          cycle_temp[#cycle_temp+1] = {val = v2, dispval = dval, dv = dval}
          stcnt = stcnt + 1
        end
      
      end
    
      if stcnt > max_cycle then
        OpenMsgBox(1, 'Too many values.', 1)
      else
        for i = 1, max_cycle do
          cycle_select[i] = cycle_temp[i]
        end
        cycle_select.statecnt = stcnt
      end
      A_SetParam(strip,page,trackfxparam_select,ctl)
  
    else
    
      trackfxparam_select = ctl_select[1].ctl
      local strip = tracks[track_select].strip
      local ctl = strips[tracks[track_select].strip][page].controls[trackfxparam_select]

      local min, max = GetParamMinMax_ctl(trackfxparam_select, true)
      local step = (max-min)/(cycle_select.statecnt-1)
      local min2, max2 = GetParamMinMax_ctl(trackfxparam_select, false)
      local md = (max2-min2)/(max-min)
      local v, v2 = min2,0.0
  
      local tracknum = strips[strip].track.tracknum
      if ctl.tracknum ~= nil then
        tracknum = ctl.tracknum
      end
      local cc = ctl.ctlcat
      local fxnum = ctl.fxnum
      local param = ctl.param
      local dvoff = ctl.dvaloffset
      
      SetParam3(strip,page,trackfxparam_select,ctl,v)
      local x = 0
      os.sleep((auto_delay/sldiv)*10)
      local dval = GetParamDisp(cc, tracknum, fxnum, param, dvoff,trackfxparam_select)
      local stcnt = 1
      local ndval

      cycle_temp = {}
      cycle_temp[1] = {val = v, dispval = dval, dv = dval}

      for i = 1, cycle_select.statecnt-1 do
      
        GUI_DrawMsgX(obj, gui, 'Scanning values...', i, cycle_select.statecnt-1)
        v = min2+(i*step*md)
        SetParam3(strip,page,trackfxparam_select,ctl,v)
        local x = 0
        os.sleep((auto_delay/sldiv)*10)
        ndval = GetParamDisp(cc, tracknum, fxnum, param, dvoff, trackfxparam_select)
        if ndval ~= dval then
          dval = ndval
          local v2 = GetParamValue(cc, tracknum, fxnum, param, trackfxparam_select)
          cycle_temp[#cycle_temp+1] = {val = v2, dispval = dval, dv = dval}
          stcnt = stcnt + 1
        end
      
      end
      
      for i = 1, stcnt do
        cycle_select[i] = cycle_temp[i]
      end
      if cycle_select.statecnt > stcnt then
        for i = stcnt + 1, cycle_select.statecnt do
          cycle_select[i] = {val = 0, dispval = '', dv = ''}
        end
      end
      --cycle_select.statecnt = stcnt
      A_SetParam(strip,page,trackfxparam_select,ctl)
    
    end
  
  end
  
  function SetCtlEnabled(fxnum)
  
    local i
    local enabled = reaper.TrackFX_GetEnabled(GetTrack(tracks[track_select].tracknum),fxnum)
    local strip = tracks[track_select].strip
    for i = 1, #strips[strip][page].controls do
      local ctl = strips[strip][page].controls[i]
      if ctl.fxnum == fxnum then
        ctl.dirty = true
      end
    end
    
  end

  function SetCtlsEnabled(fxnum)
  
    local i
    --local enabled = reaper.TrackFX_GetEnabled(GetTrack(tracks[track_select].tracknum),fxnum)
    local strip = tracks[track_select].strip
    for i = 1, #strips[strip][page].controls do
      local ctl = strips[strip][page].controls[i]
      for f = 1, #fxnum do
        if ctl.fxnum == fxnum[f] then
          ctl.dirty = true
          break
        end
      end
    end
    
  end
  
  function GetGraphicsTable(strip, page, c, obj)

    if obj == nil then
      obj = strips[strip][page].graphics[c]
    end
    
    local tbl = {gfxtype = obj.gfxtype,
                 fn = obj.fn,
                 imageidx = obj.imageidx,
                 x = obj.x,
                 y = obj.y,
                 w = obj.w,
                 h = obj.h,
                 scale = obj.scale,
                 stretchw = obj.stretchw,
                 stretchh = obj.stretchh,
                 switcher = obj.switcher,
                 grpid = obj.grpid,
                 font = {idx = obj.font.idx,
                         name = obj.font.name,
                         size = obj.font.size,
                         bold = obj.font.bold,
                         italics = obj.font.italics,
                         underline = obj.font.underline,
                         shadow = obj.font.shadow,
                         shadow_x = obj.font.shadow_x,
                         shadow_y = obj.font.shadow_y,
                         shadow_a = obj.font.shadow_a
                         },
                 text = obj.text,
                 text_col = obj.text_col,
                 poslock = false,
                 bright = obj.bright,
                 contr = obj.contr,
                 rmult = obj.rmult,
                 gmult = obj.gmult,
                 bmult = obj.bmult,
                 alpha = obj.alpha,
                 stretchmode = obj.stretchmode,
                 edgesz = obj.edgesz,
                 }
    return tbl

  end
  
  function GetSwitcherTable(switchid)
  
    local tbl = {grpids = {},
                 current = switchers[switchid].current,
                 parent = {}}
    if switchers[switchid].parent then
      tbl.parent.switcherid = switchers[switchid].parent.switcherid
      tbl.parent.grpid = switchers[switchid].parent.grpid      
    end
    if switchers[switchid].grpids and #switchers[switchid].grpids > 0 then
      for g = 1, #switchers[switchid].grpids do
        tbl.grpids[g] = {}
        tbl.grpids[g].id = switchers[switchid].grpids[g].id
        tbl.grpids[g].name = switchers[switchid].grpids[g].name      
      end  
    end
    return tbl
    
  end
  
  function GetControlTable(strip, page, c)
    
    local ctl = strips[strip][page].controls[c]
    local tbl = {ctlcat=ctl.ctlcat,
                 fxname=ctl.fxname,
                 fxguid=ctl.fxguid, 
                 fxnum=ctl.fxnum, 
                 fxfound = ctl.fxfound,
                 param = ctl.param,
                 param_info = {paramname = ctl.param_info.paramname,
                               paramnum = ctl.param_info.paramnum,
                               paramidx = ctl.param_info.paramidx,
                               paramstr = ctl.param_info.paramstr,
                               paramdesttrnum = ctl.param_info.paramdesttrnum,
                               paramdestguid = ctl.param_info.paramdestguid,
                               paramdestchan = ctl.param_info.paramdestchan,
                               paramsrcchan = ctl.param_info.paramsrcchan},
                 ctltype = ctl.ctltype,
                 knob_select = ctl.knob_select,
                 ctl_info = {fn = ctl.ctl_info.fn,
                             frames = ctl.ctl_info.frames,
                             imageidx = ctl.ctl_info.imageidx, 
                             cellh = ctl.ctl_info.cellh},
                 x = ctl.x,
                 y = ctl.y,
                 w = ctl.w,
                 scale = ctl.scale,
                 xsc = ctl.xsc,
                 ysc = ctl.ysc,
                 wsc = ctl.wsc,
                 hsc = ctl.hsc,
                 show_paramname = ctl.show_paramname,
                 show_paramval = ctl.show_paramval,
                 ctlname_override = ctl.ctlname_override,
                 textcol = ctl.textcol,
                 textoff = ctl.textoff,
                 textoffval = ctl.textoffval,
                 textoffx = ctl.textoffx,
                 textoffvalx = ctl.textoffvalx,
                 textsize = ctl.textsize,
                 textsizev = ctl.textsizev,
                 textcolv = ctl.textcolv,
                 font = ctl.font,
                 val = ctl.val,
                 defval = ctl.defval,
                 maxdp = ctl.maxdp,
                 cycledata = ctl.cycledata,
                 switcherid = ctl.switcherid,
                 switcher = ctl.switcher,
                 id = ctl.id,
                 grpid = ctl.grpid,
                 tracknum = ctl.tracknum,
                 trackguid = ctl.trackguid,
                 dvaloffset = ctl.dvaloffset,
                 minov = ctl.minov,
                 maxov = ctl.maxov,
                 membtn = {state = ctl.membtn.state,
                           mem = ctl.membtn.mem},
                 xydata = {snapa = ctl.xydata.snapa,
                           snapb = ctl.xydata.snapb,
                           snapc = ctl.xydata.snapc,
                           snapd = ctl.xydata.snapd,
                           x = ctl.xydata.x,
                           y = ctl.xydata.y},
                 scalemode = ctl.scalemode,
                 framemode = ctl.framemode,
                 horiz = ctl.horiz,
                 poslock = ctl.poslock,
                 c_id = GenID(),
                 knobsens = {norm = ctl.knobsens.norm,
                             fine = ctl.knobsens.fine,
                             wheel = ctl.knobsens.wheel,
                             wheelfine = ctl.knobsens.wheelfine},
                 hidden = ctl.hidden,
                 gauge = Gauge_CopySelect(ctl.gauge),
                 noss = ctl.noss,
                 bright = ctl.bright,
                 bypassbg_c = ctl.bypassbg_c,
                 bypassbg_n = ctl.bypassbg_n,
                 bypassbg_v = ctl.bypassbg_v,
                 clickthrough = ctl.clickthrough,
                 }
    if ctl.ctlcat == ctlcats.macro and ctl.macroctl then
      local macro = ctl.macroctl
      local mctl = {}
      for m = 1, #macro do
      
        mctl[m] = {c_id = macro[m].c_id,
                   ctl = macro[m].ctl,
                   A_val = macro[m].A_val,
                   B_val = macro[m].B_val,
                   shape = macro[m].shape,
                   bi = macro[m].bi,
                   inv = macro[m].inv,
                   mute = macro[m].mute
                   }
      
      end
      tbl.macroctl = mctl
    end
    if ctl.ctlcat == ctlcats.rcm_switch and ctl.rcmdata and #ctl.rcmdata > 0 then
      tbl.rcmdata = table.copy(ctl.rcmdata)
      tbl.rcmrefresh = table.copy(ctl.rcmrefresh)
    end
    if ctl.ctlcat == ctlcats.midictl and ctl.midiout then
      tbl.midiout = table.copy(ctl.midiout)
    end
    
    return tbl
  end
  
  BGCOL=0xFFFFFF
  
  function setcolor(i)
    gfx.set(((i>>16)&0xFF)/0xFF, ((i>>8)&0xFF)/0xFF, (i&0xFF)/0xFF)
  end
  
  ---- editbox ----
  
  function editbox_draw(gui, e)
  
    f_Get_SSV('0 0 0')
    gfx.a = 1
    gfx.rect(obj.sections[8].x,obj.sections[8].y,obj.sections[8].w,obj.sections[8].h,true)
    f_Get_SSV(gui.color.white)
    gfx.rect(obj.sections[8].x,obj.sections[8].y,obj.sections[8].w,obj.sections[8].h,0)
  
    GUI_DrawButton(gui, 'OK', obj.sections[6], gui.color.blue, gui.color.black, true)
    GUI_DrawButton(gui, 'Cancel', obj.sections[7], gui.color.blue, gui.color.black, true)
  
    GUI_textsm_LJ(gui, obj.sections[5], e.title, gui.color.white, 0)
  
    e.x = obj.sections[9].x
    e.y = obj.sections[9].y
    e.w = obj.sections[9].w
    e.h = obj.sections[9].h
    
    setcolor(e.bgcol)
    gfx.rect(e.x,e.y,e.w,e.h,true)
    
    setcolor(e.hasfocus and e.fgfcol or e.fgcol)
    gfx.rect(e.x,e.y,e.w,e.h,false)
    gfx.setfont(e.font) 
    setcolor(e.txtcol)
    local w,h=gfx.measurestr(e.text)
    local ox,oy=e.x+e.l,e.y+(e.h-h)/2
    gfx.x,gfx.y=ox,oy
    gfx.drawstr(e.text)
    if e.sel ~= 0 then
      local sc,ec=e.caret,e.caret+e.sel
      if sc > ec then sc,ec=ec,sc end
      local sx=gfx.measurestr(string.sub(e.text, 0, sc))
      local ex=gfx.measurestr(string.sub(e.text, 0, ec))
      setcolor(e.txtcol)
      gfx.rect(ox+sx, oy, ex-sx, h, true)
      setcolor(e.bgcol)
      gfx.x,gfx.y=ox+sx,oy
      gfx.drawstr(string.sub(e.text, sc+1, ec))
    end
    if e.hasfocus == true then
      if e.cursstate < 8 then   
        w=gfx.measurestr(string.sub(e.text, 0, e.caret))    
        setcolor(e.curscol)
        gfx.line(e.x+e.l+w, e.y+2, e.x+e.l+w, e.y+e.h-4)
      end
      e.cursstate=(e.cursstate+1)%16
    end
  end
  
  function editbox_getcaret(e)
    local len=string.len(e.text)
    for i=1,len do
      w=gfx.measurestr(string.sub(e.text,1,i))
      if gfx.mouse_x < e.x+e.l+w then return i-1 end
    end
    return len
  end
  
  function editbox_onmousedown(e)
    --e.hasfocus=
    --  gfx.mouse_x >= editbox.x and gfx.mouse_x < editbox.x+editbox.w and
    --  gfx.mouse_y >= editbox.y and gfx.mouse_y < editbox.y+editbox.h    
    if e.hasfocus then
      e.caret=editbox_getcaret(e) 
      e.cursstate=0
    end
    e.sel=0 
  end
  
  function editbox_onmousedoubleclick(e)
    local len=string.len(e.text)
    e.caret=len ; e.sel=-len
  end
  
  function editbox_onmousemove(e)
    e.sel=editbox_getcaret(e)-e.caret
  end
  
  function editbox_onchar(e, c)
    --DBG(c)
    if c == 0x6C656674 then -- left arrow
      if mouse.shift then
        if e.caret > 0 then e.caret=e.caret-1 e.sel=e.sel+1 end        
      else
        if e.caret > 0 then e.caret=e.caret-1 end
        e.sel = 0
      end
    elseif c == 0x72676874 then -- right arrow
      if mouse.shift then
        if e.caret < string.len(e.text) then e.caret=e.caret+1 e.sel=e.sel-1 end        
      else
        if e.caret < string.len(e.text) then e.caret=e.caret+1 end
        e.sel = 0
      end
    elseif c == 6647396 then -- end
      if mouse.shift then
        e.sel = -(string.len(e.text)-e.caret)
      else
        e.sel = 0
      end
      e.caret = string.len(e.text)
    elseif c == 1752132965 then --home
      if mouse.shift then
        e.sel = e.caret
      else
        e.sel = 0
      end
      e.caret = 0    
    elseif c == 8 then -- backspace
      if e.sel ~= 0 then
        local sc,ec=e.caret,e.caret+e.sel
        if sc > ec then sc,ec=ec,sc end
        e.text=string.sub(e.text,1,sc)..string.sub(e.text,ec+1)
        e.caret=sc
        e.sel=0
      else
        if e.caret > 0 then 
          e.text=string.sub(e.text,1,e.caret-1)..string.sub(e.text,e.caret+1)
          e.caret=e.caret-1
        end    
      end

    elseif c == 13 then
      EB_Enter = true
    elseif c >= 32 and c <= 125 and string.len(e.text) < e.maxlen then
      if e.sel ~= 0 then
        local sc,ec=e.caret,e.caret+e.sel
        if sc > ec then sc,ec=ec,sc end
        e.text=string.sub(e.text,1,sc)..string.sub(e.text,ec+1)
        e.caret=sc
        e.sel=0
      end
      e.text=string.format("%s%c%s", 
      string.sub(e.text,1,e.caret), c, string.sub(e.text,e.caret+1))
      e.caret=e.caret+1
    end
  end
  
  function mb_onchar(c)
  
    if c == 13 then
      MB_Enter = true
    end
    
  end
  
  ---- generic mouse handling ----
  
  mouse={}
  
  function OnMouseDown()
    editbox_onmousedown(editbox)    
    mouse.down=true ; mouse.capcnt=0
    mouse.ox,mouse.oy=gfx.mouse_x,gfx.mouse_y
  end
  
  function OnMouseDoubleClick()
    if editbox.hasfocus then editbox_onmousedoubleclick(editbox) end
  end
  
  function OnMouseMove()
    if editbox.hasfocus then editbox_onmousemove(editbox) end  
    mouse.lx,mouse.ly=gfx.mouse_x,gfx.mouse_y
    mouse.capcnt=mouse.capcnt+1
  end
  
  function OnMouseUp()
    mouse.down=false
    mouse.uptime=os.clock()
  end
    
  --gfx.setfont(1,"verdana",editbox.fontsz)
  
  --reaper.defer(runloop)  
  
  function CheckTrackExists(s)
    if strips[s].track.tracknum == -1 then return true end
    
    local found = false
    local trx = GetTrack(strips[s].track.tracknum)
    if trx then
      if strips[s].track.guid ~= reaper.GetTrackGUID(trx) then
        --Find track and update tracknum
        for i = -1, reaper.CountTracks(0) do
          local tr = GetTrack(i)
          if tr ~= nil then
            if strips[s].track.guid == reaper.GetTrackGUID(tr) then
              --found
              found = true
              strips[s].track.tracknum = i
              break 
            end
          end
        end
      else
        found = true
      end
    else
      for i = 0, reaper.CountTracks(0) do
        local tr = GetTrack(i)
        if tr ~= nil then
          if strips[s].track.guid == reaper.GetTrackGUID(tr) then
            --found
            found = true
            strips[s].track.tracknum = i
            break 
          end
        end
      end
      --PopulateTracks()    
    end
    return found
  end

  
  function GPES(key, nilallowed)
    if nilallowed == nil then nilallowed = false end
    
    local _, val = reaper.GetProjExtState(0,SCRIPT,key)
    if nilallowed then
      if val == '' then
        val = nil
      end
    end
    return val
  end

  function GES(key, nilallowed)
    if nilallowed == nil then nilallowed = false end
    
    local val = reaper.GetExtState(SCRIPT,key)
    if nilallowed then
      if val == '' then
        val = nil
      end
    end
    return val
  end
  
  function readln(ln,nilallowed)
    local v = string.match(ln,'[.-](.*)')
    lsd_ln = lsd_ln + 1
    if nilallowed and v == '' then
      return nil
    else
      return v
    end
  end
  
  function decipher(ln)
    return string.match(ln,'%[(.-)%](.*)')
  end
    
  function LoadStripData(s, ss, data)
  
    t = reaper.time_precise()
    local pfx = ''
    
    if data == nil then
      local load_path
      local fn = GPES('strips_datafile_'..string.format("%03d",s))
  
      if settings_savedatainprojectfolder == true then
        load_path=reaper.GetProjectPath('')..'/'
        if reaper.file_exists(load_path..fn) ~= true then
          load_path=projsave_path
        end
      else
        load_path=projsave_path
        if reaper.file_exists(load_path..fn) ~= true then
          load_path=reaper.GetProjectPath('')..'/'
        end      
      end
    
      local ffn=load_path..fn
      if reaper.file_exists(ffn) ~= true then
        DBG('Missing file: '..ffn)
        return 0
      end    
  
      local file
  
      local ccnt
      
      data = {}
      for line in io.lines(ffn) do
        local idx, val = string.match(line,'%[(.-)%](.*)') --decipher(line)
        if idx then
          data[idx] = val
        end
      end
    else 
      pfx = 'strip_s'..ss..'_'
    end
        
    strips[ss] = {}
              
    strips[ss].page = tonumber(zn(data[pfx..'page'],1))
    strips[ss].track = {
                       name = data[pfx..'track_name'],
                       guid = data[pfx..'track_guid'],
                       tracknum = tonumber(data[pfx..'track_num']),
                       strip = tonumber(data[pfx..'track_strip'])
                      }

    for p = 1, 4 do
    
      local key = pfx..'p'..p..'_'
    
      strips[ss][p] = LoadStripDataX(key, data)
      
    end
    
  end  
  
  function LoadStripDataX(pfx, data)
  
    if pfx == nil then pfx = '' end
    local key = pfx
    
    local strip = {
                    surface_x = tonumber(data[key..'surface_x']),
                    surface_y = tonumber(data[key..'surface_y']),
                    controls = {},
                    graphics = {}
                   }          
  
    local ccnt = tonumber(data[key..'controls_count'])
    local gcnt = tonumber(data[key..'graphics_count'])
    
    local rcms = false
    
    if ccnt and ccnt > 0 then
      for c = 1, ccnt do

        local key = pfx..'c_'..c..'_'
        strip.controls[c] = {
                                    c_id = tonumber(zn(data[key..'cid'],GenID())),
                                    ctlcat = tonumber(zn(data[key..'ctlcat'],0)),
                                    fxname = data[key..'fxname'],
                                    fxguid = data[key..'fxguid'],
                                    fxnum = tonumber(zn(data[key..'fxnum'])),
                                    fxfound = tobool(data[key..'fxfound']),
                                    param = tonumber(data[key..'param']),
                                    param_info = {
                                                  paramname = data[key..'param_info_name'],
                                                  paramnum = tonumber(zn(data[key..'param_info_paramnum'])),
                                                  paramidx = zn(data[key..'param_info_idx']),
                                                  paramstr = zn(data[key..'param_info_str']),
                                                  paramdestguid = zn(data[key..'param_info_guid']),
                                                  paramdestchan = tonumber(zn(data[key..'param_info_chan'])),
                                                  paramsrcchan = tonumber(zn(data[key..'param_info_srcchan']))
                                                 },
                                    ctltype = tonumber(data[key..'ctltype']),
                                    knob_select = tonumber(data[key..'knob_select']),
                                    ctl_info = {
                                                fn = data[key..'ctl_info_fn'],
                                                frames = tonumber(data[key..'ctl_info_frames']),
                                                imageidx = tonumber(data[key..'ctl_info_imageidx']),
                                                cellh = tonumber(data[key..'ctl_info_cellh'])
                                               },
                                    x = tonumber(data[key..'x']),
                                    y = tonumber(data[key..'y']),
                                    w = tonumber(data[key..'w']),
                                    scale = tonumber(data[key..'scale']),
                                    show_paramname = tobool(data[key..'show_paramname']),
                                    show_paramval = tobool(data[key..'show_paramval']),
                                    ctlname_override = zn(data[key..'ctlname_override'],''),
                                    textcol = data[key..'textcol'],
                                    textcolv = zn(data[key..'textcolv'],data[key..'textcol']),
                                    textoff = tonumber(data[key..'textoff']),
                                    textoffval = tonumber(zn(data[key..'textoffval'],0)),
                                    textoffx = tonumber(zn(data[key..'textoffx'],0)),
                                    textoffvalx = tonumber(zn(data[key..'textoffvalx'],0)),
                                    textsize = tonumber(zn(data[key..'textsize'],0)),
                                    textsizev = tonumber(zn(data[key..'textsizev'],zn(data[key..'textsize'],0))),
                                    font = zn(data[key..'font'],fontname_def),
                                    val = tonumber(data[key..'val']),
                                    mval = tonumber(data[key..'mval']),
                                    defval = tonumber(data[key..'defval']),
                                    maxdp = tonumber(zn(data[key..'maxdp'],-1)),
                                    cycledata = {statecnt = 0,{}},
                                    xydata = {x = tonumber(zn(data[key..'xydata_x'],0.5)), 
                                              y = tonumber(zn(data[key..'xydata_y'],0.5)), 
                                              snapa = tonumber(zn(data[key..'xydata_snapa'],1)),
                                              snapb = tonumber(zn(data[key..'xydata_snapb'],1)),
                                              snapc = tonumber(zn(data[key..'xydata_snapc'],1)),
                                              snapd = tonumber(zn(data[key..'xydata_snapd'],1))},
                                    id = deconvnum(data[key..'id'],true),
                                    grpid = deconvnum(data[key..'grpid'], true),
                                    scalemode = tonumber(zn(data[key..'scalemodex'],8)),
                                    framemode = tonumber(zn(data[key..'framemodex'],1)),
                                    poslock = tobool(zn(data[key..'poslock'],false)),
                                    horiz = tobool(zn(data[key..'horiz'],false)),
                                    macrofader = tonumber(zn(data[key..'macrofader'])),
                                    switchfader = tonumber(zn(data[key..'switchfader'])),
                                    hidden = tobool(zn(data[key..'hidden'],false)),
                                    switcherid = tonumber(zn(data[key..'switcherid'])),
                                    switcher = tonumber(zn(data[key..'switcher'])),
                                    noss = tobool(zn(data[key..'noss'])),
                                    bypassbg_c = tobool(zn(data[key..'bypassbg_c'])),
                                    bypassbg_n = tobool(zn(data[key..'bypassbg_n'])),
                                    bypassbg_v = tobool(zn(data[key..'bypassbg_v'])),
                                    clickthrough = tobool(zn(data[key..'clickthrough'])),
                                   }
        g_cids[strip.controls[c].c_id] = true
        if strip.controls[c].id then
          g_cids[strip.controls[c].id] = true
        end
        if strip.controls[c].grpid then
          g_cids[strip.controls[c].grpid] = true
        end
        
        if strip.controls[c].maxdp == nil or (strip.controls[c].maxdp and strip.controls[c].maxdp == '') then
          strip.controls[c].maxdp = -1
        end
        --DBG(data[key..'fxname'])
        strip.controls[c].xsc = strip.controls[c].x + strip.controls[c].w/2 - (strip.controls[c].w*strip.controls[c].scale)/2
        strip.controls[c].ysc = strip.controls[c].y + strip.controls[c].ctl_info.cellh/2 - (strip.controls[c].ctl_info.cellh*strip.controls[c].scale)/2
        strip.controls[c].wsc = strip.controls[c].w*strip.controls[c].scale
        strip.controls[c].hsc = strip.controls[c].ctl_info.cellh*strip.controls[c].scale
        
        strip.controls[c].tracknum = tonumber(zn(data[key..'tracknum']))
        strip.controls[c].trackguid = data[key..'trackguid']                    
        strip.controls[c].dvaloffset = tonumber(zn(data[key..'dvaloffset'],0))
        strip.controls[c].minov = zn(data[key..'minov'])
        strip.controls[c].maxov = zn(data[key..'maxov'])
        strip.controls[c].membtn = {state = tobool(zn(data[key..'memstate'],false)),
                                            mem = tonumber(zn(data[key..'memmem'],0))
                                            }
        strip.controls[c].knobsens = {norm = tonumber(zn(data[key..'knobsens_norm'],settings_defknobsens.norm)),
                                              fine = tonumber(zn(data[key..'knobsens_fine'],settings_defknobsens.fine)),
                                              wheel = tonumber(zn(data[key..'knobsens_wheel'],settings_defknobsens.wheel)),
                                              wheelfine = tonumber(zn(data[key..'knobsens_wheelfine'],settings_defknobsens.wheelfine))}
        
        strip.controls[c].cycledata.statecnt = tonumber(zn(data[key..'cycledata_statecnt'],0))
        strip.controls[c].cycledata.mapptof = tobool(zn(data[key..'cycledata_mapptof'],false))
        strip.controls[c].cycledata.draggable = tobool(zn(data[key..'cycledata_draggable'],false))
        strip.controls[c].cycledata.spread = tobool(zn(data[key..'cycledata_spread'],false))
        strip.controls[c].cycledata.pos = tonumber(zn(data[key..'cycledata_pos'],1))
        strip.controls[c].cycledata.posdirty = tobool(zn(data[key..'cycledata_posdirty'],false))
        strip.controls[c].cycledata.val = 0
        if nz(strip.controls[c].cycledata.statecnt,0) > 0 then
          for i = 1, strip.controls[c].cycledata.statecnt do
            local key = pfx..'c_'..c..'_cyc_'..i..'_'
          
            strip.controls[c].cycledata[i] = {val = tonumber(zn(data[key..'val'],0)),
                                                      dispval = zn(data[key..'dispval'],'no disp val'),
                                                      dv = zn(data[key..'dispval'])}
            if strip.controls[c].cycledata[i].dv == nil then
              strip.controls[c].cycledata[i].dv = strip.controls[c].cycledata[i].dispval
            end 
          end
        end
        
        local mout = zn(data[key..'midiout_output'])
        --if mout then
          strip.controls[c].midiout = {output = mout}
          strip.controls[c].midiout.mchan = tonumber(zn(data[key..'midiout_mchan'],1))
          strip.controls[c].midiout.msg3 = tonumber(zn(data[key..'midiout_msg3'],0))
          strip.controls[c].midiout.msgtype = tonumber(zn(data[key..'midiout_msgtype'],4))
          strip.controls[c].midiout.osc = zn(data[key..'midiout_osc'])
          strip.controls[c].midiout.vmin = tonumber(zn(data[key..'midiout_vmin'],0))          
          strip.controls[c].midiout.vmax = tonumber(zn(data[key..'midiout_vmax'],127))
          strip.controls[c].midiout.focus = tonumber(zn(data[key..'midiout_focus'],1))
          strip.controls[c].midiout.updategfx = tobool(zn(data[key..'midiout_updategfx'],false))                              
          strip.controls[c].midiout.onmu = tobool(zn(data[key..'midiout_onmu'],false))                              
        --end

        local rcmcnt = tonumber(data[key..'rcmdata_cnt'])
        if rcmcnt and rcmcnt > 0 then
          strip.controls[c].rcmdata = {}
          for r = 1, rcmcnt do
            local key = pfx..'c_'..c..'_rcm_'..r..'_'         
            strip.controls[c].rcmdata[r] = {}
            strip.controls[c].rcmdata[r].name = zn(data[key..'name'])  
            strip.controls[c].rcmdata[r].msb = tonumber(data[key..'msb'])  
            strip.controls[c].rcmdata[r].lsb = tonumber(data[key..'lsb'])  
            strip.controls[c].rcmdata[r].prog = tonumber(data[key..'prog'])          
            strip.controls[c].rcmdata[r].nebfn = zn(data[key..'nebfn'])          
          end
        end

        local rcmrefresh_setvals = tobool(zn(data[key..'rcmrefresh_setvals']))
        local rcmrefresh_guid = data[key..'rcmrefresh_guid']
        local rcmrefresh_delay = tonumber(data[key..'rcmrefresh_delay'])
        if rcmrefresh_guid or rcmrefresh_delay or rcmrefresh_setvals then
          strip.controls[c].rcmrefresh = {guid = rcmrefresh_guid,
                                          delay = rcmrefresh_delay,
                                          setvals = rcmrefresh_setvals}
        end
        
        local gauge = data[key..'gauge']
        if gauge then
          strip.controls[c].gauge = {}
          strip.controls[c].gauge.type = tonumber(zn(data[key..'gauge_type'],1))
          strip.controls[c].gauge.x_offs = tonumber(zn(data[key..'gauge_x_offs']))
          strip.controls[c].gauge.y_offs = tonumber(zn(data[key..'gauge_y_offs']))
          strip.controls[c].gauge.radius = tonumber(zn(data[key..'gauge_radius']))
          strip.controls[c].gauge.arclen = tonumber(zn(data[key..'gauge_arclen']))
          strip.controls[c].gauge.rotation = tonumber(zn(data[key..'gauge_rotation']))
          strip.controls[c].gauge.ticks = tonumber(zn(data[key..'gauge_ticks']))
          strip.controls[c].gauge.tick_size = tonumber(zn(data[key..'gauge_tick_size']))
          strip.controls[c].gauge.tick_offs = tonumber(zn(data[key..'gauge_tick_offs']))
          strip.controls[c].gauge.val_freq = tonumber(zn(data[key..'gauge_val_freq']))
          strip.controls[c].gauge.col_tick = (zn(data[key..'gauge_col_tick']))
          strip.controls[c].gauge.col_arc = (zn(data[key..'gauge_col_arc']))
          strip.controls[c].gauge.col_val = (zn(data[key..'gauge_col_val']))
          strip.controls[c].gauge.show_arc = tobool(zn(data[key..'gauge_show_arc']))
          strip.controls[c].gauge.show_tick = tobool(zn(data[key..'gauge_show_tick']))
          strip.controls[c].gauge.show_val = tobool(zn(data[key..'gauge_show_val']))
          strip.controls[c].gauge.val = 0
          strip.controls[c].gauge.dval = ''
          strip.controls[c].gauge.vals = {}
          strip.controls[c].gauge.val_dp = tonumber(zn(data[key..'gauge_val_dp']))
          strip.controls[c].gauge.font = (zn(data[key..'gauge_font'],fontname_def))
          strip.controls[c].gauge.fontsz = tonumber(zn(data[key..'gauge_fontsz']))
          strip.controls[c].gauge.spread = tobool(zn(data[key..'gauge_spread']))
          strip.controls[c].gauge.mapptof = tobool(zn(data[key..'gauge_mapptof']))
          strip.controls[c].gauge.numonly = tobool(zn(data[key..'gauge_numonly']))
          strip.controls[c].gauge.abbrev = tobool(zn(data[key..'gauge_abbrev'],false))
          strip.controls[c].gauge.vals = {}
          
          local gcnt = tonumber(zn(data[key..'gauge_valcnt']))
          if gcnt and gcnt > 0 then
            for gv = 1, gcnt do
              local key = pfx..'c_'..c..'_gaugevals_'..gv..'_' 
              strip.controls[c].gauge.vals[gv] = {}
              strip.controls[c].gauge.vals[gv].val = tonumber(zn(data[key..'val'],0))
              strip.controls[c].gauge.vals[gv].dval = zn(data[key..'dval'],'')
              strip.controls[c].gauge.vals[gv].dover = zn(data[key..'dover'],'') 
              strip.controls[c].gauge.vals[gv].nudge = zn(data[key..'nudge'],0) 
            end
          
          end
        end

        local mcnt = tonumber(zn(data[key..'macroctl_cnt'],0))
        if mcnt > 0 then
          strip.controls[c].macroctl = {}
          
          for mc = 1, mcnt do
            local key = pfx..'c_'..c..'_mc_'..mc..'_'
            strip.controls[c].macroctl[mc] = {c_id = tonumber(zn(data[key..'c_id'])),
                                                      ctl = tonumber(zn(data[key..'ctl'])),
                                                      A_val = tonumber(zn(data[key..'A'],0)),
                                                      B_val = tonumber(zn(data[key..'B'],0)),
                                                      shape = tonumber(zn(data[key..'shape'],0)),
                                                      mute = tobool(zn(data[key..'mute'],false)),
                                                      bi = tobool(zn(data[key..'bi'],false)), 
                                                      inv = tobool(zn(data[key..'inv'],false)),
                                                      relative = tobool(zn(data[key..'rel'],false))} 
          end
        end

        local bcnt = tonumber(zn(data[key..'eqband_cnt'],0))
        if bcnt > 0 then
          strip.controls[c].eqbands = {}
          
          for bc = 1, bcnt do
            local key = pfx..'c_'..c..'_eqband_'..bc..'_'
            strip.controls[c].eqbands[bc] = {posmin = tonumber(zn(data[key..'posmin'])),
                                                      posmax = tonumber(zn(data[key..'posmax'])),
                                                      gmin = tonumber(zn(data[key..'gmin'],0)),
                                                      gmax = tonumber(zn(data[key..'gmax'],1)),
                                                      col = zn(data[key..'col']),
                                                      fxnum = tonumber(zn(data[key..'fxnum'])),
                                                      fxguid = zn(data[key..'fxguid']),
                                                      fxname = zn(data[key..'fxname']),
                                                      freq_param = tonumber(zn(data[key..'freq_param'])),
                                                      freq_param_name = zn(data[key..'freq_param_name']),
                                                      gain_param = tonumber(zn(data[key..'gain_param'])),
                                                      gain_param_name = zn(data[key..'gain_param_name']),
                                                      q_param = tonumber(zn(data[key..'q_param'])),
                                                      q_param_name = zn(data[key..'q_param_name']),
                                                      bypass_param = tonumber(zn(data[key..'bypass_param'])),
                                                      bypass_param_name = zn(data[key..'bypass_param_name']),
                                                      c1_param = tonumber(zn(data[key..'c1_param'])),
                                                      c1_param_name = zn(data[key..'c1_param_name']),
                                                      c2_param = tonumber(zn(data[key..'c2_param'])),
                                                      c2_param_name = zn(data[key..'c2_param_name']),
                                                      c3_param = tonumber(zn(data[key..'c3_param'])),
                                                      c3_param_name = zn(data[key..'c3_param_name']),
                                                      c4_param = tonumber(zn(data[key..'c4_param'])),
                                                      c4_param_name = zn(data[key..'c4_param_name']),
                                                      c5_param = tonumber(zn(data[key..'c5_param'])),
                                                      c5_param_name = zn(data[key..'c5_param_name']),
                                                      freq_val = tonumber(zn(data[key..'freq_val'])),
                                                      gain_val = tonumber(zn(data[key..'gain_val'])),
                                                      q_val = tonumber(zn(data[key..'q_val'])),
                                                      c1_val = tonumber(zn(data[key..'c1_val'])),
                                                      c2_val = tonumber(zn(data[key..'c2_val'])),
                                                      c3_val = tonumber(zn(data[key..'c3_val'])),
                                                      c4_val = tonumber(zn(data[key..'c4_val'])),
                                                      c5_val = tonumber(zn(data[key..'c5_val'])),
                                                      freq_min = tonumber(zn(data[key..'freq_min'])),
                                                      freq_max = tonumber(zn(data[key..'freq_max'])),
                                                      gain_min = tonumber(zn(data[key..'gain_min'])),
                                                      gain_max = tonumber(zn(data[key..'gain_max'])),
                                                      bandtype = zn(data[key..'bandtype']),
                                                      bandname = zn(data[key..'bandname']),
                                                      khz = tobool(zn(data[key..'khz'],false)),
                                                      gain_inv = tobool(zn(data[key..'gaininv'],false)),
                                                      q_inv = tobool(zn(data[key..'qinv'],false)),
                                                      freq_def = tonumber(zn(data[key..'freq_def'])),
                                                      gain_def = tonumber(zn(data[key..'gain_def'])),
                                                      q_def = tonumber(zn(data[key..'q_def'])),
                                                      c1_def = tonumber(zn(data[key..'c1_def'])),
                                                      c2_def = tonumber(zn(data[key..'c2_def'])),
                                                      c3_def = tonumber(zn(data[key..'c3_def'])),
                                                      c4_def = tonumber(zn(data[key..'c4_def'])),
                                                      c5_def = tonumber(zn(data[key..'c5_def'])),
                                                      } 
            local lcnt = tonumber(zn(data[key..'lookmap_cnt'],0))
            if lcnt > 0 then
              strip.controls[c].eqbands[bc].lookmap = {}
              for lc = 1, lcnt do
                local key = pfx..'c_'..c..'_eqband_'..bc..'_lm_'..lc..'_'
                strip.controls[c].eqbands[bc].lookmap[lc] = {pix = tonumber(zn(data[key..'pix'])),
                                                                     hz = tonumber(zn(data[key..'hz']))}
              end
              
            end

            local lcnt = tonumber(zn(data[key..'gmap_cnt'],0))
            if lcnt > 0 then
              strip.controls[c].eqbands[bc].gmap = {}
              for lc = 1, lcnt do
                local key = pfx..'c_'..c..'_eqband_'..bc..'_gm_'..lc..'_'
                strip.controls[c].eqbands[bc].gmap[lc] = {pix = tonumber(zn(data[key..'pix'])),
                                                                   db = tonumber(zn(data[key..'db']))}
              end
              
            end
          end
          --strip.controls[c].eqgraph = tonumber(zn(data[key..'eqgraph']))
        end

        local key = pfx..'c_'..c..'_'
        if tobool(zn(data[key..'ecg_graph'],false)) == true then
          strip.controls[c].eqgraph = {posmin = tonumber(zn(data[key..'ecg_posmin'])),
                                               posmax = tonumber(zn(data[key..'ecg_posmax'])),
                                               gmin = tonumber(zn(data[key..'ecg_gmin'],0)),
                                               gmax = tonumber(zn(data[key..'ecg_gmax'],1)),
                                               }
          
          local lcnt = tonumber(zn(data[key..'ecg_lookmap_cnt'],0))
          if lcnt > 0 then
            strip.controls[c].eqgraph.lookmap = {}
            for lc = 1, lcnt do
              local key = pfx..'c_'..c..'_ecg_lm_'..lc..'_'
              strip.controls[c].eqgraph.lookmap[lc] = {pix = tonumber(zn(data[key..'pix'])),
                                                               hz = tonumber(zn(data[key..'hz']))}
            end
            
          end
          
          local key = pfx..'c_'..c..'_'
          local lcnt = tonumber(zn(data[key..'ecg_gmap_cnt'],0))
          if lcnt > 0 then
            strip.controls[c].eqgraph.gmap = {}
            for lc = 1, lcnt do
              local key = pfx..'c_'..c..'_ecg_gm_'..lc..'_'
              strip.controls[c].eqgraph.gmap[lc] = {pix = tonumber(zn(data[key..'pix'])),
                                                            db = tonumber(zn(data[key..'db']))}
            end
            
          end

        end

        --load control images - reshuffled to ensure no wasted slots between sessions
        if pfx ~= '' then
          local iidx
          local knob_sel = -1
          for k = 0, #ctl_files do
            if ctl_files[k].fn == strip.controls[c].ctl_info.fn then
              knob_sel = k
              break
            end
          end
          if knob_sel ~= -1 then
            strip.controls[c].knob_select = knob_sel
  
            if ctl_files[knob_sel].imageidx == nil then
              image_count = F_limit(image_count + 1,0,image_max)
              gfx.loadimg(image_count, controls_path..ctl_files[knob_sel].fn)
              iidx = image_count
              
              strip.controls[c].ctl_info.imageidx = iidx
              ctl_files[knob_sel].imageidx = iidx                    
            else
              iidx = ctl_files[knob_sel].imageidx
              strip.controls[c].ctl_info.imageidx = iidx
            end
          else
            --missing
            strip.controls[c].knob_select = -1
            strip.controls[c].ctl_info.imageidx = 1020
          end
        end
      
        if strip.controls[c].ctlcat == ctlcats.rcm_switch then
          rcms = true
        end
      end
    
      if rcms == true then
        RCM_Neb_UpdateProgIDs(strip.controls,false)
      end
        
    end
    
    if gcnt and gcnt > 0 then
    
      for g = 1, gcnt do

        local key = pfx..'g_'..g..'_'
        
        strip.graphics[g] = {
                                    fn = data[key..'fn'],
                                    imageidx = tonumber(data[key..'imageidx']),
                                    x = tonumber(data[key..'x']),
                                    y = tonumber(data[key..'y']),
                                    w = tonumber(data[key..'w']),
                                    h = tonumber(data[key..'h']),
                                    scale = tonumber(data[key..'scale']),
                                    id = deconvnum(data[key..'id']),
                                    grpid = deconvnum(data[key..'grpid']),
                                    gfxtype = tonumber(zn(data[key..'gfxtype'],gfxtype.img)),
                                    font = {idx = tonumber(zn(data[key..'font_idx'])),
                                            name = zn(data[key..'font_name']),
                                            size = tonumber(zn(data[key..'font_size'])),
                                            bold = tobool(zn(data[key..'font_bold'])),
                                            italics = tobool(zn(data[key..'font_italics'])),
                                            underline = tobool(zn(data[key..'font_underline'])),
                                            shadow = tobool(zn(data[key..'font_shadow'],true)),
                                            shadow_x = tonumber(zn(data[key..'font_shadowx'],1)),
                                            shadow_y = tonumber(zn(data[key..'font_shadowy'],1)),
                                            shadow_a = tonumber(zn(data[key..'font_shadowa'],0.6))
                                            },
                                    text = zn(data[key..'text']),
                                    text_col = zn(data[key..'text_col']),
                                    poslock = tobool(zn(data[key..'poslock'],false)),
                                    switcher = tonumber(zn(data[key..'switcher'])),
                                    bright = tonumber(zn(data[key..'bright'],0.5)),
                                    contr = tonumber(zn(data[key..'contr'],0.5)),
                                    rmult = tonumber(zn(data[key..'rmult'],0.5)),
                                    gmult = tonumber(zn(data[key..'gmult'],0.5)),
                                    bmult = tonumber(zn(data[key..'bmult'],0.5)),
                                    alpha = tonumber(zn(data[key..'alpha'],1)),
                                    stretchmode = tonumber(zn(data[key..'stretchmode'],1)),
                                    edgesz = tonumber(zn(data[key..'edgesz'],8)),
                                   }
        strip.graphics[g].stretchw = tonumber(zn(data[key..'stretchw'],strip.graphics[g].w))
        strip.graphics[g].stretchh = tonumber(zn(data[key..'stretchh'],strip.graphics[g].h))

        --load graphics images
        if pfx ~= '' then
          if strip.graphics[g].gfxtype == gfxtype.img then
          
            local iidx = LoadGraphics(strip.graphics[g].fn)
            if iidx then
              strip.graphics[g].imageidx = iidx
            end
            
          end
        end

      end                
    end
    return strip
  end
  
  function LoadGraphics(fn)
  
    local iidx
    local gfx_sel = -1
    for k = 0, #graphics_files do
      if graphics_files[k] and graphics_files[k].fn == fn then
        gfx_sel = k
        break
      end
    end
    if gfx_sel ~= -1 then
      
      if graphics_files[gfx_sel].imageidx == nil then
        image_count = F_limit(image_count + 1,0,image_max)
        local fol = ''
        if graphics_files[gfx_sel].fol and graphics_files[gfx_sel].fol ~= 'GENERAL' then
          fol = graphics_files[gfx_sel].fol..'/'
        end
        gfx.loadimg(image_count, graphics_path..fol..graphics_files[gfx_sel].fn)
        iidx = image_count
        
        graphics_files[gfx_sel].imageidx = iidx                    

      else
        iidx = graphics_files[gfx_sel].imageidx
      end
    else
      --missing
      iidx = 1020
    end
    return iidx
    
  end
  
  function LoadSnapData(s, data)
  
    local pfx = ''
    
    if data == nil then
      local load_path
      local fn = GPES('snaps_datafile_'..string.format("%03d",s))
  
      if settings_savedatainprojectfolder == true then
        load_path=reaper.GetProjectPath('')..'/'
        if reaper.file_exists(load_path..fn) ~= true then
          load_path=projsave_path
        end
      else
        load_path=projsave_path
        if reaper.file_exists(load_path..fn) ~= true then
          load_path=reaper.GetProjectPath('')..'/'
        end      
      end
    
      local ffn=load_path..fn
      if reaper.file_exists(ffn) ~= true then
        DBG('Missing file: '..ffn)
        return 0
      end    
  
      local file
  
      t = reaper.time_precise()
      local ccnt
      
      data = {}
      for line in io.lines(ffn) do
        local idx, val = string.match(line,'%[(.-)%](.*)') --decipher(line)
        if idx then
          data[idx] = val
        end
      end
    else
      pfx = 'snap_s'..s..'_'
    end

    snapshots[s] = {}
  
    for p = 1, 4 do
    
      local key = pfx..'p'..p..'_'
      snapshots[s][p] = LoadSnapDataX(key, data)
      
    end
    --DBG('Snapshot load time: '..reaper.time_precise() - t)

  end
  
  function LoadSnapDataX(pfx, data)
  
    if pfx == nil then pfx = '' end
    --local key = pfx
    
    local snaps = {}
    
    local key = pfx
    local sstcnt = tonumber(zn(data[key..'sstype_count'],0))
    
    if sstcnt > 0 then
      
      for sst = 1, sstcnt do

        if sst == 1 then                
          snaps[sst] = {}
        
          local key = pfx..'sst_'..sst..'_'
          local sscnt = tonumber(zn(data[key..'ss_count'],0))
          if sscnt > 0 then
      
            for ss = 1, sscnt do
              local key = pfx..'sst_'..sst..'_ss_'..ss..'_'
              local dcnt = tonumber(data[key..'data_count'])
              snaps[sst][ss] = {name = data[key..'name'],
                                data = {}}
              for d = 1, dcnt do

                local key = pfx..'sst_'..sst..'_ss_'..ss..'_d_'..d..'_'
              
                snaps[sst][ss].data[d] = {c_id = tonumber(data[key..'cid']),
                                           ctl = tonumber(data[key..'ctl']),
                                           val = tonumber(data[key..'val']),
                                           dval = tonumber(zn(data[key..'dval']))}
                
                local mf = tonumber(data[key..'mf'])
                snaps[sst][ss].data[d].mfset = tobool(zn(data[key..'mfset']))
                if mf then
                  snaps[sst][ss].data[d].mf = mf
                  snaps[sst][ss].data[d].mfdata = {targettype = tonumber(data[key..'mfdata_targettype']),
                                                   strip = tonumber(data[key..'mfdata_strip']),
                                                   page = tonumber(data[key..'mfdata_page']),
                                                   ctl = tonumber(data[key..'mfdata_ctl']),
                                                   c_id = tonumber(data[key..'mfdata_c_id'])}
                end
              end
            end
            
            --Snapshots_Check(s,p)
          end
        elseif sst > 1 then
        
          local key = pfx..'sst_'..sst..'_'
          snaps[sst] = {subsetname = data[key..'subsetname'], snapshot = {}, ctls = {}}
          
          snapsubsets_table[sst] = snaps[sst].subsetname
          
          local sscnt = tonumber(zn(data[key..'ss_count'],0))
          local ctlcnt = tonumber(zn(data[key..'ctl_count'],0))
          
          if ctlcnt > 0 then
            for ctl = 1, ctlcnt do
            
              local key = pfx..'sst_'..sst..'_c_'..ctl..'_'
              snaps[sst].ctls[ctl] = {c_id = tonumber(data[key..'cid']),
                                      ctl = tonumber(data[key..'ctl'])}
            end
          end
          if sscnt > 0 then
            for ss = 1, sscnt do
              local key = pfx..'sst_'..sst..'_ss_'..ss..'_'
              local dcnt = tonumber(data[key..'data_count'])
              snaps[sst].snapshot[ss] = {name = data[key..'name'],
                                         data = {}}
              for d = 1, dcnt do

                local key = pfx..'sst_'..sst..'_ss_'..ss..'_d_'..d..'_'
              
                snaps[sst].snapshot[ss].data[d] = {c_id = tonumber(data[key..'cid']),
                                                   ctl = tonumber(data[key..'ctl']),
                                                   val = tonumber(data[key..'val']),
                                                   dval = tonumber(zn(data[key..'dval']))}

                local mf = tonumber(data[key..'mf'])
                snaps[sst].snapshot[ss].data[d].mfset = tobool(zn(data[key..'mfset']))
                if mf then
                  snaps[sst].snapshot[ss].data[d].mf = mf
                  snaps[sst].snapshot[ss].data[d].mfdata = {targettype = tonumber(data[key..'mfdata_targettype']),
                                                            strip = tonumber(data[key..'mfdata_strip']),
                                                            page = tonumber(data[key..'mfdata_page']),
                                                            ctl = tonumber(data[key..'mfdata_ctl']),
                                                            c_id = tonumber(data[key..'mfdata_c_id'])}
                end

              end
            end
          end                 
           
          --Snapshots_Check(s,p)
        end
        
        local key = pfx..'sst_'..sst..'_'
        if snaps[sst] then
          snaps[sst].selected = tonumber(zn(data[key..'ss_selected']))
        end
        
      end
      
      --Snapshots_Check(s,p)
    end
    return snaps
    
  end
  
  
  function LoadXXYData(s, data)
  
    local pfx = ''
    
    if data == nil then
      local load_path
      local fn = GPES('metalite_datafile_'..string.format("%03d",s))
  
      if settings_savedatainprojectfolder == true then
        load_path=reaper.GetProjectPath('')..'/'
        if reaper.file_exists(load_path..fn) ~= true then
          load_path=projsave_path
        end
      else
        load_path=projsave_path
        if reaper.file_exists(load_path..fn) ~= true then
          load_path=reaper.GetProjectPath('')..'/'
        end      
      end
    
      local ffn=load_path..fn
      if reaper.file_exists(ffn) ~= true then
        DBG('Missing file: '..ffn)
        return 0
      end    
    
      local file
    
      data = {}
      for line in io.lines(ffn) do
        local idx, val = string.match(line,'%[(.-)%](.*)') --decipher(line)
        if idx then
          data[idx] = val
        end
      end
    else
      pfx = 'xxy_s'..s..'_'
    end
      
    for p = 1, 4 do
    
      for sst = 1, #snapshots[s][p] do
      
        local key = pfx..'xxy_p'..p..'_sst_'..sst..'_'
        local ptcnt = tonumber(zn(data[key..'pt_count']))
        if ptcnt then
      
          XXY_INIT(s, p, sst)
          xxy[s][p][sst].pathidx = tonumber(zn(data[key..'pathidx']))
          xxy[s][p][sst].pathfader = tonumber(zn(data[key..'pathfader']))
          xxy[s][p][sst].xfader = tonumber(zn(data[key..'xfader']))
          xxy[s][p][sst].yfader = tonumber(zn(data[key..'yfader']))
          
          for pt = 1, ptcnt do
          
            local key = pfx..'xxy_p'..p..'_sst_'..sst..'_pt_'..pt..'_'
            xxy[s][p][sst].points[pt] = {}
            xxy[s][p][sst].points[pt].x = tonumber(data[key..'x'])
            xxy[s][p][sst].points[pt].y = tonumber(data[key..'y'])
            xxy[s][p][sst].points[pt].ss = tonumber(data[key..'ss'])
            xxy[s][p][sst].points[pt].inactive = tobool(zn(data[key..'inactive']))
          
          end
      
        end
        
      end
    
    end
  
  end
  

  function LoadXXYPathData(data)
  
    local pfx = ''

    if data == nil then
      local load_path
      local fn = GPES('path_datafile', true)
  
      if fn == nil then return end
  
      if settings_savedatainprojectfolder == true then
        load_path=reaper.GetProjectPath('')..'/'
        if reaper.file_exists(load_path..fn) ~= true then
          load_path=projsave_path
        end
      else
        load_path=projsave_path
        if reaper.file_exists(load_path..fn) ~= true then
          load_path=reaper.GetProjectPath('')..'/'
        end      
      end
    
      local ffn=load_path..fn
      if reaper.file_exists(ffn) ~= true then
        DBG('Missing file: '..ffn)
        return 0
      end    
    
      local file
    
      data = {}
      for line in io.lines(ffn) do
        local idx, val = string.match(line,'%[(.-)%](.*)') --decipher(line)
        if idx then
          data[idx] = val
        end
      end
    end
      
    local key = 'pathcnt'
    local pathcnt = tonumber(zn(data[key]))
  
    if pathcnt and pathcnt > 0 then
    
      xxypath = {}
      
      for p = 1, pathcnt do      
        
        local key = 'xxypath_'..p..'_'
        local ptcnt = tonumber(zn(data[key..'pt_count']))      
        local idxcnt = tonumber(zn(data[key..'idxpt_count']))            

        xxypath[p] = {}
        xxypath[p].pathlen = tonumber(zn(data[key..'pathlen']))
      
        xxypath[p].points = {}
        xxypath[p].pathidxpt = {}

        if ptcnt > 0 then      
        
          for pt = 1, ptcnt do
                  
            local key = 'xxypath_'..p..'_pt_'..pt..'_'
            xxypath[p].points[pt] = {}
            xxypath[p].points[pt].len = tonumber(zn(data[key..'len']))
            xxypath[p].points[pt].posstart = tonumber(zn(data[key..'posstart']))
            xxypath[p].points[pt].posend = tonumber(zn(data[key..'posend']))
            
            xxypath[p].points[pt].x = {}
            xxypath[p].points[pt].y = {}
            
            for xy = 1,4 do
                      
              xxypath[p].points[pt].x[xy] = tonumber(zn(data[key..'x_'..xy]))
              xxypath[p].points[pt].y[xy] = tonumber(zn(data[key..'y_'..xy]))             
            end
            
            local tcnt = tonumber(zn(data[key..'t_count']))            
            
            if tcnt and tcnt > 0 then
              
              xxypath[p].points[pt].t = {}
              for t = 0, tcnt do
              
                xxypath[p].points[pt].t[t] = tonumber(zn(data[key..'t_'..t]))             
  
              end
            end          
          end
        end
        if idxcnt > 0 then
          for i = 0, idxcnt do
          
            local key = 'xxypath_'..p..'_idxpt_'..i
            xxypath[p].pathidxpt[i] = tonumber(zn(data[key]))
  
          end      
        end
      end
    end
    
  end
  
  function LoadFaders(data)

    if data == nil then
      local load_path
      local fn = GPES('fader_datafile', true)
      if fn == nil then return end
      
      if settings_savedatainprojectfolder == true then
        load_path=reaper.GetProjectPath('')..'/'
        if reaper.file_exists(load_path..fn) ~= true then
          load_path=projsave_path
        end
      else
        load_path=projsave_path
        if reaper.file_exists(load_path..fn) ~= true then
          load_path=reaper.GetProjectPath('')..'/'
        end      
      end
      
      local ffn=load_path..fn
      if reaper.file_exists(ffn) ~= true then
        DBG('Missing file: '..ffn)
        return 0
      end    
      
      faders = {}
      if reaper.file_exists(ffn) then
        local file
        file=io.open(ffn,"r")
        local content=file:read("*a")
        file:close()
        
        faders = unpickle(content)
      end
    else
    
      local key = 'fadercnt'
      local fadercnt = tonumber(zn(data[key]))

      if fadercnt and fadercnt > 0 then

        local key = 'snapshot_fader'
        snapshot_fader = tonumber(zn(data[key]))

        faders = {}
        
        for f = 1, fadercnt do      
          
          local key = 'fader_'..f..'_'
        
          faders[f] = {}
          faders[f].targettype = tonumber(zn(data[key..'targettype']))
          faders[f].strip = tonumber(zn(data[key..'strip']))
          faders[f].page = tonumber(zn(data[key..'page']))
          faders[f].ctl = tonumber(zn(data[key..'ctl']))
          faders[f].c_id = tonumber(zn(data[key..'c_id']))
          faders[f].sstype = tonumber(zn(data[key..'sstype']))
          faders[f].xy = tonumber(zn(data[key..'xy'])) 
          faders[f].mode = tonumber(zn(data[key..'mode'])) 
          faders[f].voffset = tonumber(zn(data[key..'voffset'])) 
          
          if faders[f].targettype == 7 then
            faders[f].voffset = nz(faders[f].voffset,0)
          end
        end 
    
      end
    end  
    CheckFaders()
    
  end

  function CheckFaders()
  
    if faders == nil then return end
    
    for f = 1, #faders do
      if faders[f].targettype == 3 or faders[f].targettype == 4 or faders[f].targettype == 7 then
        fnd = false
        local s = faders[f].strip
        local p = faders[f].page
        local c = faders[f].ctl
        local cid = faders[f].c_id
        if strips[s][p].controls[c] and cid == strips[s][p].controls[c].c_id and 
           strips[s][p].controls[c].macrofader == f then
          --all good
          fnd = true
        else
          for cc = 1, #strips[s][p].controls do
            if strips[s][p].controls[cc].c_id == cid then
            
              strips[s][p].controls[cc].macrofader = f
              faders[f].ctl = cc
              fnd = true
              break
            end
          end
          if fnd == false then
            for ss = 1, #strips do
              for pp = 1, 4 do
                for cc = 1, #strips[ss][pp].controls do
                  if strips[ss][pp].controls[cc].c_id == cid then
                  
                    strips[ss][pp].controls[cc].macrofader = f
                    faders[f].strip = ss
                    faders[f].page = pp
                    faders[f].ctl = cc
                    fnd = true
                    break
                  end      
                end
                if fnd == true then
                  break
                end
              end
              if fnd == true then
                break
              end
            end
          end
        end
        if fnd == false then
          --not found
          faders[f] = {}
        end
      end
    end
  
  end

  function LoadSwitchers(data)

    local key = 'switcher_cnt'
    local scnt = tonumber(zn(data[key]))

    if scnt and scnt > 0 then
      switchers = {}
      for s = 1, scnt do      
        
        local key = 'switch'..s..'_'
        switchers[s] = {grpids = {},
                        current = tonumber(zn(data[key..'current'])),
                        parent = {switcherid = tonumber(zn(data[key..'par_swid'])),
                                  grpid = tonumber(zn(data[key..'par_grpid'])),
                                 }}
        swcnt = tonumber(zn(data[key..'grpid_cnt']))
        for swc = 1, swcnt do
          local key = 'switch'..s..'_gid_'..swc..'_'
          switchers[s].grpids[swc] = {}
          switchers[s].grpids[swc].id = tonumber(zn(data[key..'grpid']))
          switchers[s].grpids[swc].name = zn(data[key..'grpname'])
        end
      end
  
    end
  end
  
  function GetProjectName()
  
    return reaper.GetProjectName(0, '')
  
  end
  
  function DBGOut(msg)
  
    if DBG_mode then
      DBG(msg)
    end
  
  end
  
  function FindDataFile(fn)
  
    local ret = reaper.MB('Missing data file.  Would you like to manually locate it?','Missing data file', 4)
    if ret == 6 then
      local ret, rfn = reaper.GetUserFileNameForRead(fn, 'Locate lbxstripper data file:', string.match(fn, '.+%.(lbxstripper.*)'))
      if ret == true then
      
        return rfn
      
      end
    end 
  
  end
  
  function LoadDataFile(ffn)

    ZeroProjectFlags()
    
    local s, p, c, g, k
  
    local t = reaper.time_precise()
    local data = {}
    --DBG('a')
    
    DBGOut('')
    DBGOut('*** LOADING DATA ***')    
    DBGOut('LoadData: Saved OK: '..tostring(GPES('savedok')))

    gfx.setimgdim(1, -1, -1)  
    gfx.setimgdim(1, gfx1.main_w,gfx1.main_h)
    GUI_DrawMsgX(obj, gui, 'Reading data file...  Please wait...')

    DBGOut('LoadData: ffn: '..tostring(ffn))
    if reaper.file_exists(ffn) ~= true then              
      nfn = FindDataFile(ffn)
      if nfn ~= nil and reaper.file_exists(nfn) == true then
        ffn = nfn
      else
        if nfn then
          ffn = nfn
        end
        DBG('Missing file: '..ffn)
        return 0
      end
    end    
  
    local ctr = 0
    datafile = ffn
    
    for line in io.lines(ffn) do
      ctr = ctr + 1
      if ctr % 4000 == 0 then
        GUI_DrawMsgX(obj, gui, 'Reading data file...  (line: '..ctr..')', nil, nil, true)
      end
      local idx, val = string.match(line,'%[(.-)%](.*)') --decipher(line)
      if idx then
        data[idx] = val
      end
    end     

    DBGOut('LoadData: Read lines: '..tostring(ctr))
    
    --local scnt = tonumber(nz(GPES('strips_count'),0))
    local v = tonumber(zn(data['version']))
    local scnt = tonumber(zn(data['stripcount']))
    if scnt == nil then data = nil reaper.MB('Not a loadable lbxstripper file','Load Failed',0) return 0 end
    
    DBGOut('LoadData: strip count: '..tostring(scnt))
    
    strips = {}
    local ss = 1
    if scnt > 0 then
      --DBG(scnt)
      for s = 1, scnt do
    
        GUI_DrawMsgX(obj, gui, 'Loading Strip Data...', s, scnt)      
        LoadStripData(s, ss, data)
        ss=ss+1
                   
      end
    end
    
    PopulateTracks()
    Snapshots_INIT()
    --local scnt = tonumber(nz(GPES('snapshots_count'),0))
    local scnt = tonumber(zn(data['snapshotcount']))
    DBGOut('LoadData: snapshot count: '..tostring(scnt))
    
    if scnt and scnt > 0 then
        
      for s = 1, scnt do

        GUI_DrawMsgX(obj, gui, 'Loading Snapshot Data...', s, scnt)
        LoadSnapData(s, data)
                  
      end
    end
    
    --XXY
    
    for s = 1, #strips do
  
      GUI_DrawMsgX(obj, gui, 'Loading Metalite Data...', s, #strips)
      LoadXXYData(s, data)
    
    end
    
    LoadXXYPathData(data)
    LoadFaders(data)
    LoadSwitchers(data)
    
    data = nil
    
    LoadCompatibility(v, strips)
    
    --DBG('Total Load Time: '..reaper.time_precise() - t)
    infomsg = 'Total Load Time: '..round(reaper.time_precise() - t,2)..'s'
    DBGOut(infomsg)
    
    PopulateTracks() --must be called to link tracks to strips
    
    if show_editbar then
      plist_w = oplist_w
    else
      plist_w = 0
    end
    
    if track_select then
      ChangeTrack(track_select)
      local tr = GetTrack(track_select)
      if tr then
        --reaper.SetOnlyTrackSelected(tr)
      end 
    end
    if tracks and tracks[track_select] and tracks[track_select].strip and strips[tracks[track_select].strip] then
      surface_offset.x = tonumber(strips[tracks[track_select].strip][page].surface_x)
      surface_offset.y = tonumber(strips[tracks[track_select].strip][page].surface_y)
    end    
    GUI_DrawCtlBitmap()
    
    ZeroProjectFlags()
    
  end
    
  function LoadData()
    
  
    local find = string.find
    local match = string.match
    local LDF
    
    ZeroProjectFlags()
    
    local s, p, c, g, k
  
    local t = reaper.time_precise()
    local data
    
    DBGOut('')
    DBGOut('*** LOADING DATA ***')    
    DBGOut('LoadData: Saved OK: '..tostring(GPES('savedok')))
  
    if GPES('savedok') ~= '' then
  --DBG(lbxwin_dim)
      if lbxwin_dim then
        gfx1 = {main_w = lbxwin_dim.w,
                main_h = lbxwin_dim.h}
        Lokasenna_Window_At_Center(gfx1.main_w,gfx1.main_h,lbxwin_dim.x,lbxwin_dim.y) 
      else
        local ww, wh = GPES('win_w',true), GPES('win_h',true)
        if ww ~= nil and wh ~= nil then
          gfx1 = {main_w = tonumber(ww),
                  main_h = tonumber(wh)}
        else    
          gfx1 = {main_w = 800,
                  main_h = 450}
        end
        Lokasenna_Window_At_Center(gfx1.main_w,gfx1.main_h) 
        --gfx.dock(dockstate)
      end
      
      gfx.setimgdim(1, -1, -1)  
      gfx.setimgdim(1, gfx1.main_w,gfx1.main_h)
      GUI_DrawMsgX(obj, gui, 'Reading data file...  Please wait...')
      
      local rv, v = reaper.GetProjExtState(0,SCRIPT,'version')
      DBGOut('LoadData: version: '..tostring(v))
      if v ~= '' then
  
        PROJECTID = tonumber(GPES('projectid'))
        settings_gridsize = tonumber(nz(GPES('gridsize',true),settings_gridsize))
        settings_showgrid = tobool(nz(GPES('showgrid',true),true))
        show_editbar = tobool(nz(GPES('showeditbar',true),true))
        ogrid = settings_gridsize
        osg = settings_showgrid
        settings_locksurface = tobool(nz(GPES('locksurface',true),false))
        track_select = tonumber(nz(GPES('lasttrack',true),0))
        xxy_gravity = tonumber(nz(GPES('metalite_gravity',true),xxy_gravity))
        snapshot_win_pos = {x = tonumber(nz(GPES('snapwinpos_x',true))),
                            y = tonumber(nz(GPES('snapwinpos_y',true)))}
        show_snapshots = tobool(nz(GPES('showsnap',true),false))
        
        DBGOut('LoadData: PROJECT ID: '..tostring(PROJECTID))
        
        if tonumber(v) >= 0.94 then
        
          data = {}
          local load_path
          local fn = GPES('lbxstripper_datafile', true)
          LDF = fn
      
          if fn == nil then return end
      
          if settings_savedatainprojectfolder == true then
            load_path=reaper.GetProjectPath('')..'/'
            if reaper.file_exists(load_path..fn) ~= true then
              load_path=projsave_path
            end
          else
            load_path=projsave_path
            if reaper.file_exists(load_path..fn) ~= true then
              load_path=reaper.GetProjectPath('')..'/'
            end      
          end
        
          local ffn=load_path..fn
          DBGOut('LoadData: ffn: '..tostring(ffn))
          if reaper.file_exists(ffn) ~= true then
          
            nfn = FindDataFile(ffn)
            if nfn ~= nil and reaper.file_exists(nfn) == true then
              ffn = nfn
            else
              if nfn then
                ffn = nfn
              end
              DBG('Missing file: '..ffn)
              return 0
            end
          end    
        
          local ctr = 0
          datafile = ffn
          
          local flines = io.lines
          --local fGUI_DrawMsgX = GUI_DrawMsgX
          
          for line in flines(ffn) do
            ctr = ctr + 1
            if ctr % 4000 == 0 then
              GUI_DrawMsgX(obj, gui, 'Reading data file...  (line: '..ctr..')', nil, nil, true)
            end
            local idx, val = match(line,'%[(.-)%](.*)') --decipher(line)
            if idx then
              data[idx] = val
            end
          end     

          DBGOut('LoadData: Read lines: '..tostring(ctr))
        
        end
        
        local scnt = tonumber(nz(GPES('strips_count'),0))
        DBGOut('LoadData: strip count: '..tostring(scnt))
        
        strips = {}
        local ss = 1
        if scnt > 0 then
          --DBG(scnt)
          for s = 1, scnt do

            GUI_DrawMsgX(obj, gui, 'Loading Strip Data...', s, scnt)
          
            if tonumber(v) == 0.93 then
              LoadStripData(s, ss)
              ss=ss+1
              --DBG(scnt..' '..s..'  '..ss..'yeah')
              --if not CheckTrackExists(ss) then
              --  ss = ss - 1
              --end
            elseif tonumber(v) >= 0.94 then
              LoadStripData(s, ss, data)
              ss=ss+1           
            else
            
              key = 'strips_'..s..'_'
              
              strips[ss] = {}
              
              strips[ss].page = tonumber(nz(GPES(key..'page',true),1))
  
              key = 'strips_'..s..'_track_'
  
              strips[ss].track = {
                                 name = GPES(key..'name'),
                                 guid = GPES(key..'guid'),
                                 tracknum = tonumber(GPES(key..'tracknum')),
                                 strip = tonumber(GPES(key..'strip'))
                                }
              if CheckTrackExists(ss) then
                for p = 1, 4 do
                
                  local key = 'strips_'..s..'_'..p..'_'
                
                  strips[ss][p] = {
                                  surface_x = tonumber(GPES(key..'surface_x')),
                                  surface_y = tonumber(GPES(key..'surface_y')),
                                  controls = {},
                                  graphics = {}
                                 }          
                
                  local ccnt = tonumber(GPES(key..'controls_count'))
                  local gcnt = tonumber(GPES(key..'graphics_count'))
                              
                  if ccnt > 0 then
                    for c = 1, ccnt do
      
                      local key = 'strips_'..s..'_'..p..'_controls_'..c..'_'
                      strips[ss][p].controls[c] = {
                                                  c_id = tonumber(nz(GPES(key..'cid',true),GenID() )),
                                                  ctlcat = tonumber(nz(GPES(key..'ctlcat',true),0)),
                                                  fxname = GPES(key..'fxname'),
                                                  fxguid = GPES(key..'fxguid'),
                                                  fxnum = tonumber(GPES(key..'fxnum',true)),
                                                  fxfound = tobool(GPES(key..'fxfound')),
                                                  param = tonumber(GPES(key..'param')),
                                                  param_info = {
                                                                paramname = GPES(key..'param_info_name'),
                                                                paramnum = tonumber(GPES(key..'param_info_paramnum',true)),
                                                                paramidx = GPES(key..'param_info_idx',true),
                                                                paramstr = GPES(key..'param_info_str',true),
                                                                paramdestguid = GPES(key..'param_info_guid',true),
                                                                paramdestchan = tonumber(GPES(key..'param_info_chan',true)),
                                                                paramsrcchan = tonumber(GPES(key..'param_info_srcchan',true))
                                                               },
                                                  ctltype = tonumber(GPES(key..'ctltype')),
                                                  knob_select = tonumber(GPES(key..'knob_select')),
                                                  ctl_info = {
                                                              fn = GPES(key..'ctl_info_fn'),
                                                              frames = tonumber(GPES(key..'ctl_info_frames')),
                                                              imageidx = tonumber(GPES(key..'ctl_info_imageidx')),
                                                              cellh = tonumber(GPES(key..'ctl_info_cellh'))
                                                             },
                                                  x = tonumber(GPES(key..'x')),
                                                  y = tonumber(GPES(key..'y')),
                                                  w = tonumber(GPES(key..'w')),
                                                  scale = tonumber(GPES(key..'scale')),
                                                  show_paramname = tobool(GPES(key..'show_paramname')),
                                                  show_paramval = tobool(GPES(key..'show_paramval')),
                                                  ctlname_override = nz(GPES(key..'ctlname_override'),''),
                                                  textcol = GPES(key..'textcol'),
                                                  textoff = tonumber(GPES(key..'textoff')),
                                                  textoffval = tonumber(nz(GPES(key..'textoffval',true),0)),
                                                  textoffx = tonumber(nz(GPES(key..'textoffx',true),0)),
                                                  textoffvalx = tonumber(nz(GPES(key..'textoffvalx',true),0)),
                                                  textsize = tonumber(nz(GPES(key..'textsize'),0)),
                                                  val = tonumber(GPES(key..'val')),
                                                  defval = tonumber(GPES(key..'defval')),
                                                  maxdp = tonumber(nz(GPES(key..'maxdp',true),-1)),
                                                  cycledata = {statecnt = 0,{}},
                                                  xydata = {x = tonumber(nz(GPES(key..'xydata_x',true),0.5)), 
                                                            y = tonumber(nz(GPES(key..'xydata_y',true),0.5)), 
                                                            snapa = tonumber(nz(GPES(key..'xydata_snapa',true),1)),
                                                            snapb = tonumber(nz(GPES(key..'xydata_snapb',true),1)),
                                                            snapc = tonumber(nz(GPES(key..'xydata_snapc',true),1)),
                                                            snapd = tonumber(nz(GPES(key..'xydata_snapd',true),1))},
                                                  id = deconvnum(GPES(key..'id',true)),
                                                  scalemode = tonumber(nz(GPES(key..'scalemodex',true),8)),
                                                  framemode = tonumber(nz(GPES(key..'framemodex',true),1)),
                                                  poslock = tobool(nz(GPES(key..'poslock',true),false)),
                                                  horiz = tobool(nz(GPES(key..'horiz',true),false)),
                                                  knobsens = {norm = settings_defknobsens.norm,
                                                              fine = settings_defknobsens.fine,
                                                              wheel = settings_defknobsens.wheel,
                                                              wheelfine = settings_defknobsens.wheelfine}
                                                 }
                      g_cids[strips[ss][p].controls[c].c_id] = true
                      if strips[ss][p].controls[c].maxdp == nil or (strips[ss][p].controls[c].maxdp and strips[ss][p].controls[c].maxdp == '') then
                        strips[ss][p].controls[c].maxdp = -1
                      end
                      strips[ss][p].controls[c].xsc = strips[ss][p].controls[c].x + strips[ss][p].controls[c].w/2 - (strips[ss][p].controls[c].w*strips[ss][p].controls[c].scale)/2
                      strips[ss][p].controls[c].ysc = strips[ss][p].controls[c].y + strips[ss][p].controls[c].ctl_info.cellh/2 - (strips[ss][p].controls[c].ctl_info.cellh*strips[ss][p].controls[c].scale)/2
                      strips[ss][p].controls[c].wsc = strips[ss][p].controls[c].w*strips[ss][p].controls[c].scale
                      strips[ss][p].controls[c].hsc = strips[ss][p].controls[c].ctl_info.cellh*strips[ss][p].controls[c].scale
                      
                      strips[ss][p].controls[c].tracknum = tonumber(GPES(key..'tracknum',true))
                      strips[ss][p].controls[c].trackguid = GPES(key..'trackguid')                    
                      strips[ss][p].controls[c].dvaloffset = GPES(key..'dvaloffset',true)
                      strips[ss][p].controls[c].minov = GPES(key..'minov',true)
                      strips[ss][p].controls[c].maxov = GPES(key..'maxov',true)
                      strips[ss][p].controls[c].membtn = {state = tobool(nz(GPES(key..'memstate',true),false)),
                                                          mem = tonumber(nz(GPES(key..'memmem',true),0))
                                                          }
                      
                      strips[ss][p].controls[c].cycledata.statecnt = tonumber(nz(GPES(key..'cycledata_statecnt',true),0))
                      strips[ss][p].controls[c].cycledata.mapptof = tobool(nz(GPES(key..'cycledata_mapptof',true),false))
                      strips[ss][p].controls[c].cycledata.draggable = tobool(nz(GPES(key..'cycledata_draggable',true),false))
                      strips[ss][p].controls[c].cycledata.spread = tobool(nz(GPES(key..'cycledata_spread',true),false))
                      strips[ss][p].controls[c].cycledata.pos = tonumber(nz(GPES(key..'cycledata_pos',true),1))
                      strips[ss][p].controls[c].cycledata.posdirty = tobool(nz(GPES(key..'cycledata_posdirty',true),false))
                      strips[ss][p].controls[c].cycledata.val = 0
                      if nz(strips[ss][p].controls[c].cycledata.statecnt,0) > 0 then
                        for i = 1, strips[ss][p].controls[c].cycledata.statecnt do
                          local key = 'strips_'..s..'_'..p..'_controls_'..c..'_cycledata_'..i..'_'
                        
                          strips[ss][p].controls[c].cycledata[i] = {val = tonumber(nz(GPES(key..'val',true),0)),
                                                                    dispval = nz(GPES(key..'dispval',true),'no disp val'),
                                                                    dv = GPES(key..'dispval',true)}
                          if strips[ss][p].controls[c].cycledata[i].dv == nil then
                            strips[ss][p].controls[c].cycledata[i].dv = strips[ss][p].controls[c].cycledata[i].dispval
                          end 
                        end
                      end
                                          
                      --load control images - reshuffled to ensure no wasted slots between sessions
                      local iidx
                      local knob_sel = -1
                      for k = 0, #ctl_files do
                        if ctl_files[k].fn == strips[ss][p].controls[c].ctl_info.fn then
                          knob_sel = k
                          break
                        end
                      end
                      if knob_sel ~= -1 then
                        strips[ss][p].controls[c].knob_select = knob_sel
      
                        if ctl_files[knob_sel].imageidx == nil then
                          image_count = F_limit(image_count + 1,0,image_max)
                          gfx.loadimg(image_count, controls_path..ctl_files[knob_sel].fn)
                          iidx = image_count
                          
                          strips[ss][p].controls[c].ctl_info.imageidx = iidx
                          ctl_files[knob_sel].imageidx = iidx                    
                        else
                          iidx = ctl_files[knob_sel].imageidx
                          strips[ss][p].controls[c].ctl_info.imageidx = iidx
                        end
                      else
                        --missing
                        strips[ss][p].controls[c].knob_select = -1
                        strips[ss][p].controls[c].ctl_info.imageidx = 1020
                      end
                    end
                  end
                  
                  if gcnt > 0 then
                  
                    for g = 1, gcnt do
      
                      local key = 'strips_'..s..'_'..p..'_graphics_'..g..'_'
                      
                      strips[ss][p].graphics[g] = {
                                                  fn = GPES(key..'fn'),
                                                  imageidx = tonumber(GPES(key..'imageidx')),
                                                  x = tonumber(GPES(key..'x')),
                                                  y = tonumber(GPES(key..'y')),
                                                  w = tonumber(GPES(key..'w')),
                                                  h = tonumber(GPES(key..'h')),
                                                  scale = tonumber(GPES(key..'scale')),
                                                  id = deconvnum(GPES(key..'id',true)),
                                                  gfxtype = tonumber(nz(GPES(key..'gfxtype',true),gfxtype.img)),
                                                  font = {idx = tonumber(GPES(key..'font_idx',true)),
                                                          name = GPES(key..'font_name',true),
                                                          size = tonumber(GPES(key..'font_size',true)),
                                                          bold = tobool(GPES(key..'font_bold',true)),
                                                          italics = tobool(GPES(key..'font_italics',true)),
                                                          underline = tobool(GPES(key..'font_underline',true)),
                                                          shadow = tobool(nz(GPES(key..'font_shadow',true),true)),
                                                          shadow_x = tonumber(nz(GPES(key..'font_shadowx',true),1)),
                                                          shadow_y = tonumber(nz(GPES(key..'font_shadowy',true),1)),
                                                          shadow_a = tonumber(nz(GPES(key..'font_shadowa',true),0.6))
                                                          },
                                                  text = GPES(key..'text',true),
                                                  text_col = GPES(key..'text_col',true),
                                                  poslock = tobool(nz(GPES(key..'poslock',true),false))
                                                 }
                      strips[ss][p].graphics[g].stretchw = tonumber(nz(GPES(key..'stretchw',true),strips[ss][p].graphics[g].w))
                      strips[ss][p].graphics[g].stretchh = tonumber(nz(GPES(key..'stretchh',true),strips[ss][p].graphics[g].h))
  
                      --load graphics images
                      local iidx = LoadGraphics(strips[ss][p].graphics[g].fn)
                      if iidx then
                        strips[ss][p].graphics[g].imageidx = iidx
                      end
                      
                      --[[local iidx
                      local gfx_sel = -1
                      for k = 0, #graphics_files do
                        if graphics_files[k].fn == strips[ss][p].graphics[g].fn then
                          gfx_sel = k
                          break
                        end
                      end
                      if gfx_sel ~= -1 then
                        
                        if graphics_files[gfx_sel].imageidx == nil then
                          image_count = F_limit(image_count + 1,0,image_max)
                          gfx.loadimg(image_count, graphics_path..graphics_files[gfx_sel].fn)
                          iidx = image_count
                          
                          strips[ss][p].graphics[g].imageidx = iidx
                          graphics_files[gfx_sel].imageidx = iidx                    
        
                        else
                          iidx = graphics_files[gfx_sel].imageidx
                          strips[ss][p].graphics[g].imageidx = iidx                                  
                        end
                      else
                        --missing
                        strips[ss][p].graphics[g].imageidx = 1020
                      end]]
                    end                
                  end
                end
                ss = ss + 1
              else
                --not found
                --strips[s] = nil
              end
            end
          end
        end
        
        PopulateTracks()
        Snapshots_INIT()
        local scnt = tonumber(nz(GPES('snapshots_count'),0))
        DBGOut('LoadData: snapshot count: '..tostring(scnt))
        
        if scnt and scnt > 0 then
            
          for s = 1, scnt do

            GUI_DrawMsgX(obj, gui, 'Loading Snapshot Data...', s, scnt)

            if tonumber(v) == 0.93 then
            
              LoadSnapData(s)

            elseif tonumber(v) >= 0.94 then

              LoadSnapData(s, data)

            else
            
              snapshots[s] = {}
            
              for p = 1, 4 do
              
                snapshots[s][p] = {}
  
                local key = 'snap_strip_'..s..'_'..p..'_'
                local sstcnt = tonumber(nz(GPES(key..'sstype_count',true),0))
                
                if sstcnt > 0 then
                  
                  for sst = 1, sstcnt do
  
                    if sst == 1 then                
                      snapshots[s][p][sst] = {}
                    
                      local key = 'snap_strip_'..s..'_'..p..'_type_'..sst..'_'
                      local sscnt = tonumber(nz(GPES(key..'ss_count',true),0))
                      if sscnt > 0 then
                  
                        for ss = 1, sscnt do
                          local key = 'snap_strip_'..s..'_'..p..'_type_'..sst..'_snapshot_'..ss..'_'
                          local dcnt = tonumber(GPES(key..'data_count'))
                          snapshots[s][p][sst][ss] = {name = GPES(key..'name'),
                                                      data = {}}
                          for d = 1, dcnt do
        
                            local key = 'snap_strip_'..s..'_'..p..'_type_'..sst..'_snapshot_'..ss..'_data_'..d..'_'
                          
                            snapshots[s][p][sst][ss].data[d] = {c_id = tonumber(GPES(key..'cid')),
                                                               ctl = tonumber(GPES(key..'ctl')),
                                                               val = tonumber(GPES(key..'val')),
                                                               dval = tonumber(GPES(key..'dval',true))}
                          end
                        end
                        
                        --Snapshots_Check(s,p)
                      end
                    elseif sst > 1 then
                    
                      local key = 'snap_strip_'..s..'_'..p..'_type_'..sst..'_'
                      snapshots[s][p][sst] = {subsetname = GPES(key..'subsetname'), snapshot = {}, ctls = {}}
                      
                      snapsubsets_table[sst] = snapshots[s][p][sst].subsetname
                      
                      local sscnt = nz(tonumber(GPES(key..'ss_count')),0)
                      local ctlcnt = nz(tonumber(GPES(key..'ctl_count')),0)
                      
                      if ctlcnt > 0 then
                        for ctl = 1, ctlcnt do
                        
                          local key = 'snap_strip_'..s..'_'..p..'_type_'..sst..'_ctl_'..ctl..'_'
                          snapshots[s][p][sst].ctls[ctl] = {c_id = tonumber(GPES(key..'cid')),
                                                            ctl = tonumber(GPES(key..'ctl'))}
                        end
                      end
                      if sscnt > 0 then
                        for ss = 1, sscnt do
                          local key = 'snap_strip_'..s..'_'..p..'_type_'..sst..'_snapshot_'..ss..'_'
                          local dcnt = tonumber(GPES(key..'data_count'))
                          snapshots[s][p][sst].snapshot[ss] = {name = GPES(key..'name'),
                                                               data = {}}
                          for d = 1, dcnt do
        
                            local key = 'snap_strip_'..s..'_'..p..'_type_'..sst..'_snapshot_'..ss..'_data_'..d..'_'
                          
                            snapshots[s][p][sst].snapshot[ss].data[d] = {c_id = tonumber(GPES(key..'cid')),
                                                                         ctl = tonumber(GPES(key..'ctl')),
                                                                         val = tonumber(GPES(key..'val')),
                                                                         dval = tonumber(GPES(key..'dval',true))}
                          end
                        end
                      end                 
                       
                      --Snapshots_Check(s,p)
                    end
                    
                    local key = 'snap_strip_'..s..'_'..p..'_type_'..sst..'_'
                    if snapshots[s][p][sst] then
                      snapshots[s][p][sst].selected = tonumber(GPES(key..'ss_selected',true))
                    end
                    
                  end
                  
                  --Snapshots_Check(s,p)
                end
              end
            end
            
          end
        end
        
        --XXY
        
        for s = 1, #strips do

          GUI_DrawMsgX(obj, gui, 'Loading Metalite Data...', s, #strips)
        
          if tonumber(v) == 0.93 then
          
            LoadXXYData(s)
          
          elseif tonumber(v) >= 0.94 then

            LoadXXYData(s, data)

          else
        
            for p = 1, 4 do
          
              for sst = 1, #snapshots[s][p] do
              
                local key = 'xxy_strip_'..s..'_'..p..'_type_'..sst..'_'
                local ptcnt = tonumber(GPES(key..'pt_count',true))
                if ptcnt then
              
                  XXY_INIT(s, p, sst)
                  for pt = 1, ptcnt do
                  
                    local key = 'xxy_strip_'..s..'_'..p..'_type_'..sst..'_pt_'..pt..'_'
                    xxy[s][p][sst].points[pt] = {}
                    xxy[s][p][sst].points[pt].x = tonumber(GPES(key..'x'))
                    xxy[s][p][sst].points[pt].y = tonumber(GPES(key..'y'))
                    xxy[s][p][sst].points[pt].ss = tonumber(GPES(key..'ss'))
                  
                  end
              
                end
                
              end
          
            end
          end
                  
        end
        
        if tonumber(v) == 0.93 then
          LoadXXYPathData()
          LoadFaders()

        elseif tonumber(v) >= 0.94 then

          LoadXXYPathData(data)
          LoadFaders(data)
          LoadSwitchers(data)

        end
              
      else
        SaveData()
      end
      
      data = nil
      
      LoadCompatibility(v, strips)
      
      --DBG('Total Load Time: '..reaper.time_precise() - t)
      infomsg = 'Total Load Time: '..round(reaper.time_precise() - t,2)..'s'
      DBGOut(infomsg)
      
      PopulateTracks() --must be called to link tracks to strips
      
      if show_editbar then
        plist_w = oplist_w
      else
        plist_w = 0
      end
      
    else
      --error with saved data
      SaveData()
      PopulateTracks() --must be called to link tracks to strips
      
      if lbxwin_dim then
        gfx1 = {main_w = lbxwin_dim.w,
                main_h = lbxwin_dim.h}
        Lokasenna_Window_At_Center(gfx1.main_w,gfx1.main_h,lbxwin_dim.x,lbxwin_dim.y) 
      
      else
        local ww, wh = GPES('win_w',true), GPES('win_h',true)
        if ww ~= nil and wh ~= nil then
          gfx1 = {main_w = tonumber(ww),
                  main_h = tonumber(wh)}
        else    
          gfx1 = {main_w = 800,
                  main_h = 450}
        end    
        Lokasenna_Window_At_Center(gfx1.main_w,gfx1.main_h) 
        --gfx.dock(dockstate)
      end
              
    end
    if track_select then
      ChangeTrack(track_select)
      --if settings_followselectedtrack then
        local tr = GetTrack(track_select)
        if tr then
          --reaper.SetOnlyTrackSelected(tr)
        end 
      --end 
    end
    if tracks and tracks[track_select] and tracks[track_select].strip and strips[tracks[track_select].strip] then
    --if tracks[track_select].strip and strips[tracks[track_select].strip] then
      surface_offset.x = tonumber(strips[tracks[track_select].strip][page].surface_x)
      surface_offset.y = tonumber(strips[tracks[track_select].strip][page].surface_y)
    end    
    --[[local ww = gfx1.main_w-(plist_w+2)
    if surface_size.w < ww then
      surface_offset.x = -math.floor((ww - surface_size.w)/2)
    end]]
    GUI_DrawCtlBitmap()
    
    ZeroProjectFlags()

    if track_select and track_select == LBX_GTRACK then
      gpage = true
      gpage_otrackselect = -1
    end
    
    force_resize = true
    update_gfx = true
    lastprojdirty = 0
    LASTPROJECTID = PROJECTID
    lastprojname = GetProjectName()
    LOADEDDATAFILE = LDF
    
  end
  
  function LoadCompatibility(v, strips)
  
    if v == nil or tonumber(v) < 0.95 then
      
      if strips and #strips > 0 then
        for s = 1, #strips do
          for p = 1, 4 do            
            
            --compatibility
            --DBG('compat d')
            
            local ctls = strips[s][p].controls
            if ctls and #ctls > 0 then
            
              for c = 1, #ctls do
                if ctls[c].lcflag == nil then
                  gfx.setfont(1, ctls[c].font, gui.fontsz_knob + ctls[c].textsize-4)
                  local _, th = gfx.measurestr('|')
                  ctls[c].textoff = ctls[c].textoff - math.floor(th/2)
                  ctls[c].lcflag = true
                end
              end
            
            end
          end
        end
      end    
    end
    
  end
  
  function LoadSettings()
  
    settings_saveallfxinststrip = tobool(nz(GES('saveallfxinststrip',true),settings_saveallfxinststrip))
    settings_followselectedtrack = tobool(nz(GES('followselectedtrack',true),settings_followselectedtrack))
    settings_disablesendchecks = tobool(nz(GES('disablesendchecks',false),settings_disablesendchecks))
    settings_updatefreq = tonumber(nz(GES('updatefreq',true),settings_updatefreq))
    settings_mousewheelknob = tobool(nz(GES('mousewheelknob',true),settings_mousewheelknob))
    dockstate = nz(GES('dockstate',true),0)
    
    local wx = GES('winx',true)
    local wy = GES('winy',true)
    local ww = GES('winw',true)
    local wh = GES('winh',true)
    if wx and wy and ww and wh then
      lbxwin_dim = {x = tonumber(wx), y = tonumber(wy), w = tonumber(ww), h = tonumber(wh)}
    end
    
    lockx = tobool(nz(GES('lockx',true),false))
    locky = tobool(nz(GES('locky',true),false))
    lockw = tonumber(nz(GES('lockw',true),400))
    lockh = tonumber(nz(GES('lockh',true),400))
    auto_delay = tonumber(nz(GES('auto_sensitivity',true),auto_delay))    
    settings_swapctrlclick = tobool(nz(GES('swapctrlclick',true),settings_swapctrlclick))
    settings_showbars = tobool(nz(GES('showbars',true),settings_showbars))
    settings_insertdefaultoneverytrack = tobool(nz(GES('insertdefstripontrack',true),settings_insertdefaultoneverytrack))
    settings_insertdefaultoneverypage = tobool(nz(GES('insertdefstriponpage',true),settings_insertdefaultoneverypage))
    settings_snaplistbgcol = tostring(nz(GES('snaplistbgcol',true),settings_snaplistbgcol))

    settings_savedatainprojectfolder = tobool(nz(GES('savedatainprojectfolder',true),settings_savedatainprojectfolder))
    save_subfolder = nz(GES('save_subfolder',true),save_subfolder)
    settings_createbackuponmanualsave = tobool(nz(GES('createbackup',true),settings_createbackuponmanualsave))

    settings_usectlbitmap = tobool(nz(GES('usectlbitmap',true),settings_usectlbitmap))
    settings_macroeditmonitor = tobool(nz(GES('macroeditmonitor',true),settings_macroeditmonitor))
    hide_topbar = tobool(nz(GES('hide_topbar',true),hide_topbar))
    settings_hideeditbaronnewproject = tobool(nz(GES('hide_editbar',true),settings_hideeditbaronnewproject))
    settings_locksurfaceonnewproject = tobool(nz(GES('lock_surface',true),settings_locksurfaceonnewproject))
    settings_showminimaltopbar = tobool(nz(GES('settings_showminimaltopbar',true),settings_showminimaltopbar))
    backcol = nz(GES('backcol',true),'16 16 16')
    nebscanboot_file = zn(GES('nebscanboot',true),nil)
    settings_touchFB = tobool(nz(GES('settings_touchfb',true),settings_touchFB))
    settings_trackchangemidi = tobool(nz(GES('settings_trackchangemidi',true),settings_trackchangemidi))
    settings_savefaderboxassinsnapshots = tobool(nz(GES('settings_savefaderboxassinsnapshots',true),settings_savefaderboxassinsnapshots))
    
    if settings_hideeditbaronnewproject then
      plist_w = 0
      show_editbar = false
    else
      plist_w = oplist_w
      show_editbar = true
    end
    
    if settings_locksurfaceonnewproject then
      settings_locksurface = true
    end
    
    local sd = tonumber(GES('strip_default',true))
    local sdf = tonumber(GES('stripfol_default',true))
    if sd and sdf then
      strip_default = {stripfol_select = sdf, strip_select = sd}
    end

    local sd = tonumber(GES('strip_default_mast',true))
    local sdf = tonumber(GES('stripfol_default_mast',true))
    if sd and sdf then
      strip_default_mast = {stripfol_select = sdf, strip_select = sd}
    end

    local sd = tonumber(GES('strip_default_glob',true))
    local sdf = tonumber(GES('stripfol_default_glob',true))
    if sd and sdf then
      strip_default_glob = {stripfol_select = sdf, strip_select = sd}
    end
    
    LoadFavStrips()
    
  end
  
  function ClearSettings()
    --reaper.DeleteExtState(SCRIPT)
    reaper.DeleteExtState(SCRIPT,'saveallfxinststrip', true)
    reaper.DeleteExtState(SCRIPT,'followselectedtrack', true)
    reaper.DeleteExtState(SCRIPT,'disablesendchecks', true)
    reaper.DeleteExtState(SCRIPT,'updatefreq', true)
    reaper.DeleteExtState(SCRIPT,'mousewheelknob', true)
    reaper.DeleteExtState(SCRIPT,'dockstate', true)
    reaper.DeleteExtState(SCRIPT,'lockx', true)
    reaper.DeleteExtState(SCRIPT,'locky', true)
    reaper.DeleteExtState(SCRIPT,'lockw', true)
    reaper.DeleteExtState(SCRIPT,'lockh', true)
    reaper.DeleteExtState(SCRIPT,'auto_sensitivity', true)
    reaper.DeleteExtState(SCRIPT,'swapctrlclick', true)
    reaper.DeleteExtState(SCRIPT,'showbars',true)
    reaper.DeleteExtState(SCRIPT,'insertdefstripontrack',true)
    reaper.DeleteExtState(SCRIPT,'insertdefstriponpage',true)
    reaper.DeleteExtState(SCRIPT,'snaplistbgcol',true)
   
    reaper.DeleteExtState(SCRIPT,'savedatainprojectfolder',true)
    reaper.DeleteExtState(SCRIPT,'save_subfolder',true)
    reaper.DeleteExtState(SCRIPT,'createbackup',true)
   
    reaper.DeleteExtState(SCRIPT,'usectlbitmap',true)
    reaper.DeleteExtState(SCRIPT,'macroeditmonitor',true)
    reaper.DeleteExtState(SCRIPT,'hide_topbar',true)
    reaper.DeleteExtState(SCRIPT,'settings_showminimaltopbar',true)
    reaper.DeleteExtState(SCRIPT,'hide_editbar',true)    
    reaper.DeleteExtState(SCRIPT,'lock_surface',true)    
    reaper.DeleteExtState(SCRIPT,'backcol',true)    
    
    reaper.DeleteExtState(SCRIPT,'strip_default',true)
    reaper.DeleteExtState(SCRIPT,'stripfol_default',true)
    reaper.DeleteExtState(SCRIPT,'strip_default_mast',true)
    reaper.DeleteExtState(SCRIPT,'stripfol_default_mast',true)
    reaper.DeleteExtState(SCRIPT,'strip_default_glob',true)
    reaper.DeleteExtState(SCRIPT,'stripfol_default_glob',true)
  end
  
  function SaveSettings()
    reaper.SetExtState(SCRIPT,'saveallfxinststrip',tostring(settings_saveallfxinststrip), true)
    reaper.SetExtState(SCRIPT,'followselectedtrack',tostring(settings_followselectedtrack), true)
    reaper.SetExtState(SCRIPT,'disablesendchecks',tostring(settings_disablesendchecks), true)
    reaper.SetExtState(SCRIPT,'updatefreq',settings_updatefreq, true)
    reaper.SetExtState(SCRIPT,'mousewheelknob',tostring(settings_mousewheelknob), true)
    local d,wx,wy,ww,wh = gfx.dock(-1,-1,-1,-1,-1)
    
    if wx and wy and ww and wh then
      reaper.SetExtState(SCRIPT,'winx',wx, true)      
      reaper.SetExtState(SCRIPT,'winy',wy, true)
      reaper.SetExtState(SCRIPT,'winw',ww, true)
      reaper.SetExtState(SCRIPT,'winh',wh, true)
    end
    
    reaper.SetExtState(SCRIPT,'dockstate',d, true)
    reaper.SetExtState(SCRIPT,'lockx',tostring(lockx), true)
    reaper.SetExtState(SCRIPT,'locky',tostring(locky), true)
    reaper.SetExtState(SCRIPT,'lockw',tostring(lockw), true)
    reaper.SetExtState(SCRIPT,'lockh',tostring(lockh), true)
    reaper.SetExtState(SCRIPT,'auto_sensitivity',auto_delay, true)
    reaper.SetExtState(SCRIPT,'swapctrlclick',tostring(settings_swapctrlclick), true)
    reaper.SetExtState(SCRIPT,'showbars',tostring(settings_showbars), true)
    reaper.SetExtState(SCRIPT,'insertdefstripontrack',tostring(settings_insertdefaultoneverytrack), true)
    reaper.SetExtState(SCRIPT,'insertdefstriponpage',tostring(settings_insertdefaultoneverypage), true)
    reaper.SetExtState(SCRIPT,'snaplistbgcol',settings_snaplistbgcol, true)
   
    reaper.SetExtState(SCRIPT,'savedatainprojectfolder',tostring(settings_savedatainprojectfolder), true)
    reaper.SetExtState(SCRIPT,'save_subfolder',nz(save_subfolder,''), true)
    reaper.SetExtState(SCRIPT,'createbackup',tostring(settings_createbackuponmanualsave), true)
   
    reaper.SetExtState(SCRIPT,'usectlbitmap',tostring(settings_usectlbitmap), true)
    reaper.SetExtState(SCRIPT,'macroeditmonitor',tostring(settings_macroeditmonitor), true)
    reaper.SetExtState(SCRIPT,'hide_topbar',tostring(hide_topbar), true)
    reaper.SetExtState(SCRIPT,'settings_showminimaltopbar',tostring(settings_showminimaltopbar), true)
    reaper.SetExtState(SCRIPT,'hide_editbar',tostring(settings_hideeditbaronnewproject), true)    
    reaper.SetExtState(SCRIPT,'lock_surface',tostring(settings_locksurfaceonnewproject), true)    
    reaper.SetExtState(SCRIPT,'backcol',tostring(backcol), true)    
    reaper.SetExtState(SCRIPT,'nebscanboot',tostring(nebscanboot_file), true)    
    reaper.SetExtState(SCRIPT,'settings_touchfb',tostring(settings_touchFB), true)    
    reaper.SetExtState(SCRIPT,'settings_trackchangemidi',tostring(settings_trackchangemidi), true)    
    reaper.SetExtState(SCRIPT,'settings_savefaderboxassinsnapshots',tostring(settings_savefaderboxassinsnapshots), true)    
    
    if strip_default then
      reaper.SetExtState(SCRIPT,'strip_default',tostring(strip_default.strip_select), true)
      reaper.SetExtState(SCRIPT,'stripfol_default',tostring(strip_default.stripfol_select), true)
    else
      reaper.SetExtState(SCRIPT,'strip_default','',true)
      reaper.SetExtState(SCRIPT,'stripfol_default','',true)
    end
    if strip_default_mast then
      reaper.SetExtState(SCRIPT,'strip_default_mast',tostring(strip_default_mast.strip_select), true)
      reaper.SetExtState(SCRIPT,'stripfol_default_mast',tostring(strip_default_mast.stripfol_select), true)
    else
      reaper.SetExtState(SCRIPT,'strip_default_mast', '', true)
      reaper.SetExtState(SCRIPT,'stripfol_default_mast', '', true)    
    end
    if strip_default_glob then
      reaper.SetExtState(SCRIPT,'strip_default_glob',tostring(strip_default_glob.strip_select), true)
      reaper.SetExtState(SCRIPT,'stripfol_default_glob',tostring(strip_default_glob.stripfol_select), true)
    else
      reaper.SetExtState(SCRIPT,'strip_default_glob', '', true)
      reaper.SetExtState(SCRIPT,'stripfol_default_glob', '', true)    
    end
    
    SaveFavStrips()
  end
  
  function SaveFavStrips()
  
    local save_path=strips_path
    local fn=save_path.."favs.txt"
    
    local DELETE=true
    local file
    
    if reaper.file_exists(fn) then
    
    end
    if strip_favs == nil then strip_favs = {} end
    
    if DELETE then
      file=io.open(fn,"w")
      local pickled_table=pickle(strip_favs)
      file:write(pickled_table)
      file:close()
    end
  
  end

  function LoadFavStrips()

    local load_path=strips_path
    local fn=load_path.."favs.txt"
    
    strip_favs = {}
    if reaper.file_exists(fn) then
      local file
      file=io.open(fn,"r")
      local content=file:read("*a")
      file:close()
      
      strip_favs = unpickle(content)
      
      CheckFavs()
    end
  
  end
    
  function SaveSingleStrip(s)
  
    if strips then
      reaper.SetProjExtState(0,SCRIPT,'strips_count',#strips)
    else
      reaper.SetProjExtState(0,SCRIPT,'strips_count',0)    
    end
    SaveStripData_FN(s)
    
    if snapshots then
      reaper.SetProjExtState(0,SCRIPT,'snapshots_count',#snapshots)
    else
      reaper.SetProjExtState(0,SCRIPT,'snapshots_count',0)    
    end
    SaveSnapshotData_FN(s)
    SaveXXYData_FN(s)
    
  end

  function SaveFaders(file)
  
    if file and faders and #faders > 0 then
  
      CheckFaders()
  
      local key = 'fadercnt'
      file:write('['..key..']'.. #faders ..'\n')
      local key = 'snapshot_fader'
      file:write('['..key..']'.. nz(snapshot_fader,'') ..'\n')
      
      for f = 1, #faders do
    
        if faders[f] then
  
          local key = 'fader_'..f..'_'
          file:write('['..key..'targettype]'.. nz(faders[f].targettype,'') ..'\n')
          file:write('['..key..'strip]'.. nz(faders[f].strip,'') ..'\n')
          file:write('['..key..'page]'.. nz(faders[f].page,'') ..'\n')
          file:write('['..key..'ctl]'.. nz(faders[f].ctl,'') ..'\n')
          file:write('['..key..'c_id]'.. nz(faders[f].c_id,'') ..'\n')
          file:write('['..key..'sstype]'.. nz(faders[f].sstype,'') ..'\n')
          file:write('['..key..'xy]'.. nz(faders[f].xy,'') ..'\n')
          file:write('['..key..'mode]'.. nz(faders[f].mode,'') ..'\n')
          file:write('['..key..'voffset]'.. nz(faders[f].voffset,'') ..'\n')
  
        end
      end  
    end
    
  end

  function SaveSwitchers(file)
  
    if file and switchers and #switchers > 0 then

      local scnt = #switchers
      file:write('[switcher_cnt]'..scnt..'\n')                                 

      for s = 1, scnt do

        local key = 'switch'..s..'_'
    
        local swcnt = #switchers[s].grpids
        file:write('['..key..'grpid_cnt]'..swcnt..'\n')                                 
        file:write('['..key..'current]'..nz(switchers[s].current,-1)..'\n')
        if switchers[s].parent then
          file:write('['..key..'par_swid]'..nz(switchers[s].parent.switcherid,'')..'\n')                                 
          file:write('['..key..'par_grpid]'..nz(switchers[s].parent.grpid,'')..'\n')                                         
        end                                  
        for swc = 1,swcnt do
          local key = 'switch'..s..'_gid_'..swc..'_'
          file:write('['..key..'grpid]'..nz(switchers[s].grpids[swc].id,'')..'\n')                                 
          file:write('['..key..'grpname]'..nz(switchers[s].grpids[swc].name,'')..'\n')                                 
        end
      end
    else
      file:write('[switcher_cnt]'..0 ..'\n')                                               
    end
  
  end
  
  function SaveXXYPathData_FN(fn,save_path,file)
  
    local nofile = false
    if file == nil then
      nofile = true
      local save_path=projsave_path..'/'
      if settings_savedatainprojectfolder == true then
        save_path=reaper.GetProjectPath('')..'/'
      end
  
      local ffn=save_path..fn
       
      file=io.open(ffn,"w")
    end
     
    if xxypath and #xxypath > 0 then

      local key = 'pathcnt'
      file:write('['..key..']'.. #xxypath ..'\n')
      
      for p = 1, #xxypath do
    
        if xxypath[p] then
                  
          local key = 'xxypath_'..p..'_'
          local ptcnt = #xxypath[p].points
          local idxcnt = #xxypath[p].pathidxpt
          
          file:write('['..key..'pathlen]'.. nz(xxypath[p].pathlen,'') ..'\n')
          file:write('['..key..'pt_count]'.. ptcnt ..'\n')
          file:write('['..key..'idxpt_count]'.. idxcnt ..'\n')

          if ptcnt > 0 then          
            for pt = 1, ptcnt do
            
              local key = 'xxypath_'..p..'_pt_'..pt..'_'
              file:write('['..key..'len]'.. nz(xxypath[p].points[pt].len,'') ..'\n')
              file:write('['..key..'posstart]'.. nz(xxypath[p].points[pt].posstart,'') ..'\n')
              file:write('['..key..'posend]'.. nz(xxypath[p].points[pt].posend,'') ..'\n')
  
              for xy = 1, 4 do
                file:write('['..key..'x_'..xy..']'.. nz(xxypath[p].points[pt].x[xy],'') ..'\n')
                file:write('['..key..'y_'..xy..']'.. nz(xxypath[p].points[pt].y[xy],'') ..'\n')
              end
              
              if xxypath[p].points[pt].t then
                local tcnt = #xxypath[p].points[pt].t
                file:write('['..key..'t_count]'.. tcnt ..'\n')
      
                if tcnt > 0 then
                  for t = 0, tcnt do
                  
                    file:write('['..key..'t_'..t..']'.. nz(xxypath[p].points[pt].t[t],'') ..'\n')            
                  
                  end
                end 
              end            
            end
          end
          if idxcnt > 0 then
            for i = 0, idxcnt do
  
              local key = 'xxypath_'..p..'_idxpt_'..i
              file:write('['..key..']'.. xxypath[p].pathidxpt[i] ..'\n')
  
            end
          end                    
        end
        
      end
    end

    if nofile == true then
      file:close()
      reaper.SetProjExtState(0,SCRIPT,'path_datafile',fn)   
    end
  
  end

  function SaveXXYData_FN(s,fn,save_path, file)

    local nofile = false
    local pfx = ''
    if file == nil then
      local save_path=projsave_path..'/'
      if settings_savedatainprojectfolder == true then
        save_path=reaper.GetProjectPath('')..'/'
      end
  
      local ffn=save_path..fn
       
      file=io.open(ffn,"w")

    else
      pfx = 'xxy_s'..s..'_'
    end
     
    if xxy and xxy[s] then
      for p = 1, 4 do
    
        if xxy[s][p] then
        
          for sst = 1, #snapshots[s][p] do
            
            if xxy[s][p][sst] then
          
              local key = pfx..'xxy_p'..p..'_sst_'..sst..'_'
              local ptcnt = #xxy[s][p][sst].points
              file:write('['..key..'x]'.. xxy[s][p][sst].x ..'\n')
              file:write('['..key..'y]'.. xxy[s][p][sst].y ..'\n')
              file:write('['..key..'pt_count]'.. ptcnt ..'\n')
              file:write('['..key..'pathidx]'.. nz(xxy[s][p][sst].pathidx,'') ..'\n')
              file:write('['..key..'pathfader]'.. nz(xxy[s][p][sst].pathfader,'') ..'\n')
              file:write('['..key..'xfader]'.. nz(xxy[s][p][sst].xfader,'') ..'\n')
              file:write('['..key..'yfader]'.. nz(xxy[s][p][sst].yfader,'') ..'\n')
              
              for pt = 1, ptcnt do
              
                local key = pfx..'xxy_p'..p..'_sst_'..sst..'_pt_'..pt..'_'
                file:write('['..key..'x]'.. xxy[s][p][sst].points[pt].x ..'\n')
                file:write('['..key..'y]'.. xxy[s][p][sst].points[pt].y ..'\n')
                file:write('['..key..'ss]'.. xxy[s][p][sst].points[pt].ss ..'\n')
                file:write('['..key..'inactive]'.. nz(tostring(xxy[s][p][sst].points[pt].inactive),'') ..'\n')
              
              end
              
            end
            
          end
        
        end
    
      end
    end

    if nofile == true then
      file:close()
      reaper.SetProjExtState(0,SCRIPT,'metalite_datafile_'..string.format("%03d",s),fn) 
    end
        
  end

  function SaveSnapshotData_FN(s,fn,save_path, file)
  
    t = reaper.time_precise()
    
    local nofile = false
    local pfx = ''
    if file == nil then
    
      local save_path=projsave_path..'/'
      if settings_savedatainprojectfolder == true then
        save_path=reaper.GetProjectPath('')..'/'
      end
      local ffn=save_path..fn      
      
      file=io.open(ffn,"w")

    else
      pfx = 'snap_s'..s..'_'
    end
    
    for p = 1, #snapshots[s] do
    
      local key = pfx..'p'..p..'_'
      SaveSnapshotDataX(s,p,key,file)
                
      --[[file:write('['..key..'sstype_count]'..#snapshots[s][p]..'\n')
    
      for sst = 1, #snapshots[s][p] do
    
        local key = pfx..'p'..p..'_sst_'..sst..'_'
        file:write('['..key..'ss_selected]'..nz(snapshots[s][p][sst].selected,'')..'\n')
        
        if sst == 1 then          
          file:write('['..key..'ss_count]'..#snapshots[s][p][sst]..'\n')
        
          if #snapshots[s][p][sst] > 0 then

            for ss = 1, #snapshots[s][p][sst] do

              local key = pfx..'p'..p..'_sst_'..sst..'_ss_'..ss..'_'
            
              file:write('['..key..'name]'.. snapshots[s][p][sst][ss].name ..'\n')
              file:write('['..key..'data_count]'.. #snapshots[s][p][sst][ss].data ..'\n')
          
              if #snapshots[s][p][sst][ss].data > 0 then
                for d = 1, #snapshots[s][p][sst][ss].data do
  
                  local key = pfx..'p'..p..'_sst_'..sst..'_ss_'..ss..'_d_'..d..'_'

                  file:write('['..key..'cid]'.. snapshots[s][p][sst][ss].data[d].c_id ..'\n')
                  file:write('['..key..'ctl]'.. snapshots[s][p][sst][ss].data[d].ctl ..'\n')
                  file:write('['..key..'val]'.. snapshots[s][p][sst][ss].data[d].val ..'\n')
                  file:write('['..key..'dval]'.. nz(snapshots[s][p][sst][ss].data[d].dval,'') ..'\n')
            
                end
              end
            end
          end      

        elseif sst > 1 then
        
          file:write('['..key..'subsetname]'.. snapshots[s][p][sst].subsetname ..'\n')
          file:write('['..key..'ss_count]'.. #snapshots[s][p][sst].snapshot ..'\n')
          file:write('['..key..'ctl_count]'.. #snapshots[s][p][sst].ctls ..'\n')
          
          if #snapshots[s][p][sst].ctls > 0 then
    
            for ctl = 1, #snapshots[s][p][sst].ctls do
              local key = pfx..'p'..p..'_sst_'..sst..'_c_'..ctl..'_'
              file:write('['..key..'cid]'.. snapshots[s][p][sst].ctls[ctl].c_id ..'\n')
              file:write('['..key..'ctl]'.. snapshots[s][p][sst].ctls[ctl].ctl ..'\n')                            
            end
          end
          if #snapshots[s][p][sst].snapshot > 0 then
          
            for ss = 1, #snapshots[s][p][sst].snapshot do
            
              local key = pfx..'p'..p..'_sst_'..sst..'_ss_'..ss..'_'
              file:write('['..key..'name]'.. snapshots[s][p][sst].snapshot[ss].name ..'\n')
              file:write('['..key..'data_count]'.. #snapshots[s][p][sst].snapshot[ss].data ..'\n')
            
              if #snapshots[s][p][sst].snapshot[ss].data > 0 then
                for d = 1, #snapshots[s][p][sst].snapshot[ss].data do
  
                  local key = pfx..'p'..p..'_sst_'..sst..'_ss_'..ss..'_d_'..d..'_'
            
                  file:write('['..key..'cid]'.. snapshots[s][p][sst].snapshot[ss].data[d].c_id ..'\n')
                  file:write('['..key..'ctl]'.. snapshots[s][p][sst].snapshot[ss].data[d].ctl ..'\n')
                  file:write('['..key..'val]'.. snapshots[s][p][sst].snapshot[ss].data[d].val ..'\n')
                  file:write('['..key..'dval]'.. nz(snapshots[s][p][sst].snapshot[ss].data[d].dval,'') ..'\n')
            
                end
              end
            end
          end
        end
      end]]
    end
  
    if nofile == true then
      file:close()    
      reaper.SetProjExtState(0,SCRIPT,'snaps_datafile_'..string.format("%03d",s),fn) 
    end
        
    --DBG('Save snapshot time: '..reaper.time_precise() - t)
    return reaper.time_precise() - t
    
  end
  
  function SaveSnapshotDataX(s, p, pfx, file)
  
    if pfx == nil then pfx = '' end
    local key = pfx
    
    file:write('['..key..'sstype_count]'..#snapshots[s][p]..'\n')
    
    for sst = 1, #snapshots[s][p] do
    
      local key = pfx..'sst_'..sst..'_'
      file:write('['..key..'ss_selected]'..nz(snapshots[s][p][sst].selected,'')..'\n')
      
      if sst == 1 then          
        file:write('['..key..'ss_count]'..#snapshots[s][p][sst]..'\n')
      
        if #snapshots[s][p][sst] > 0 then
    
          for ss = 1, #snapshots[s][p][sst] do
    
            local key = pfx..'sst_'..sst..'_ss_'..ss..'_'
          
            file:write('['..key..'name]'.. snapshots[s][p][sst][ss].name ..'\n')
            file:write('['..key..'data_count]'.. #snapshots[s][p][sst][ss].data ..'\n')
        
            if #snapshots[s][p][sst][ss].data > 0 then
              for d = 1, #snapshots[s][p][sst][ss].data do
    
                local key = pfx..'sst_'..sst..'_ss_'..ss..'_d_'..d..'_'
    
                file:write('['..key..'cid]'.. snapshots[s][p][sst][ss].data[d].c_id ..'\n')
                file:write('['..key..'ctl]'.. snapshots[s][p][sst][ss].data[d].ctl ..'\n')
                file:write('['..key..'val]'.. snapshots[s][p][sst][ss].data[d].val ..'\n')
                file:write('['..key..'dval]'.. nz(snapshots[s][p][sst][ss].data[d].dval,'') ..'\n')
                          
                file:write('['..key..'mfset]'.. tostring(nz(snapshots[s][p][sst][ss].data[d].mfset,'')) ..'\n')                
                if snapshots[s][p][sst][ss].data[d].mf then
                  file:write('['..key..'mf]'.. snapshots[s][p][sst][ss].data[d].mf ..'\n')
                  file:write('['..key..'mfdata_targettype]'.. snapshots[s][p][sst][ss].data[d].mfdata.targettype ..'\n')
                  file:write('['..key..'mfdata_strip]'.. snapshots[s][p][sst][ss].data[d].mfdata.strip ..'\n')                
                  file:write('['..key..'mfdata_page]'.. snapshots[s][p][sst][ss].data[d].mfdata.page ..'\n')                
                  file:write('['..key..'mfdata_ctl]'.. snapshots[s][p][sst][ss].data[d].mfdata.ctl ..'\n')                
                  file:write('['..key..'mfdata_c_id]'.. snapshots[s][p][sst][ss].data[d].mfdata.c_id ..'\n')                
                end
          
              end
            end
          end
        end      
    
      elseif sst > 1 then
      
        file:write('['..key..'subsetname]'.. snapshots[s][p][sst].subsetname ..'\n')
        file:write('['..key..'ss_count]'.. #snapshots[s][p][sst].snapshot ..'\n')
        file:write('['..key..'ctl_count]'.. #snapshots[s][p][sst].ctls ..'\n')
        
        if #snapshots[s][p][sst].ctls > 0 then
    
          for ctl = 1, #snapshots[s][p][sst].ctls do
            local key = pfx..'sst_'..sst..'_c_'..ctl..'_'
            file:write('['..key..'cid]'.. snapshots[s][p][sst].ctls[ctl].c_id ..'\n')
            file:write('['..key..'ctl]'.. snapshots[s][p][sst].ctls[ctl].ctl ..'\n')                            
          end
        end
        if #snapshots[s][p][sst].snapshot > 0 then
        
          for ss = 1, #snapshots[s][p][sst].snapshot do
          
            local key = pfx..'sst_'..sst..'_ss_'..ss..'_'
            file:write('['..key..'name]'.. snapshots[s][p][sst].snapshot[ss].name ..'\n')
            file:write('['..key..'data_count]'.. #snapshots[s][p][sst].snapshot[ss].data ..'\n')
          
            if #snapshots[s][p][sst].snapshot[ss].data > 0 then
              for d = 1, #snapshots[s][p][sst].snapshot[ss].data do
    
                local key = pfx..'sst_'..sst..'_ss_'..ss..'_d_'..d..'_'
          
                file:write('['..key..'cid]'.. snapshots[s][p][sst].snapshot[ss].data[d].c_id ..'\n')
                file:write('['..key..'ctl]'.. snapshots[s][p][sst].snapshot[ss].data[d].ctl ..'\n')
                file:write('['..key..'val]'.. snapshots[s][p][sst].snapshot[ss].data[d].val ..'\n')
                file:write('['..key..'dval]'.. nz(snapshots[s][p][sst].snapshot[ss].data[d].dval,'') ..'\n')

                file:write('['..key..'mfset]'.. tostring(nz(snapshots[s][p][sst].snapshot[ss].data[d].mfset,'')) ..'\n')                
                if snapshots[s][p][sst].snapshot[ss].data[d].mf then
                  file:write('['..key..'mf]'.. snapshots[s][p][sst].snapshot[ss].data[d].mf ..'\n')
                  file:write('['..key..'mfdata_targettype]'.. snapshots[s][p][sst].snapshot[ss].data[d].mfdata.targettype ..'\n')
                  file:write('['..key..'mfdata_strip]'.. snapshots[s][p][sst].snapshot[ss].data[d].mfdata.strip ..'\n')                
                  file:write('['..key..'mfdata_page]'.. snapshots[s][p][sst].snapshot[ss].data[d].mfdata.page ..'\n')                
                  file:write('['..key..'mfdata_ctl]'.. snapshots[s][p][sst].snapshot[ss].data[d].mfdata.ctl ..'\n')                
                  file:write('['..key..'mfdata_c_id]'.. snapshots[s][p][sst].snapshot[ss].data[d].mfdata.c_id ..'\n')                
                end
          
              end
            end
          end
        end
      end
    end
    
  end
  
  function SaveStripData_FN(s,fn,save_path,file)
  
    t = reaper.time_precise()
    local nofile = false
    local pfx = ''
    if file == nil then
      local ffn=save_path..fn
  
      --DBG(fn)
      --DBG(ffn)
      
      file=io.open(ffn,"w")
    else
      pfx = 'strip_s'..s..'_'
    end

    --file:write('[strips_count]'..#strips..'\n')
    if strips[s] then
      file:write('[' .. pfx ..'page]'..nz(strips[s].page,1)..'\n')
      file:write('[' ..pfx ..'track_name]'..strips[s].track.name..'\n')
      file:write('[' ..pfx ..'track_guid]'..nz(strips[s].track.guid,'')..'\n')
      file:write('[' ..pfx ..'track_num]'..strips[s].track.tracknum..'\n')
      file:write('[' ..pfx ..'track_strip]'..strips[s].track.strip..'\n')
    
      for p = 1, 4 do
      
        local key = pfx..'p'..p..'_'

        GenStripSaveData2(strips[s][p],key,file)
      
      end
    
    end

    --file:write(pickled_table)
    if nofile == true then
      file:close()
      reaper.SetProjExtState(0,SCRIPT,'strips_count',#strips) 
      reaper.SetProjExtState(0,SCRIPT,'strips_datafile_'..string.format("%03d",s),fn) 
    end
        
    --DBG('Save strip time: '..reaper.time_precise() - t)
    return reaper.time_precise() - t

  end
  
  function GenStripSaveData2(stripdata,pfx,file)
  
    if file == nil then return end
    if pfx == nil then pfx = '' end
  
    t = reaper.time_precise()
      
        local key = pfx

        if stripdata then

          file:write('['..key..'surface_x]'..stripdata.surface_x..'\n')
          file:write('['..key..'surface_y]'..stripdata.surface_y..'\n')
          file:write('['..key..'controls_count]'..#stripdata.controls..'\n')
          file:write('['..key..'graphics_count]'..#stripdata.graphics..'\n')
          
          if #stripdata.controls > 0 then
            for c = 1, #stripdata.controls do
          
              local key = pfx..'c_'..c..'_'
              
              file:write('['..key..'cid]'..stripdata.controls[c].c_id..'\n')
              file:write('['..key..'fxname]'..stripdata.controls[c].fxname..'\n')
              file:write('['..key..'fxguid]'..nz(stripdata.controls[c].fxguid,'')..'\n')
              file:write('['..key..'fxnum]'..nz(stripdata.controls[c].fxnum,'')..'\n')
              file:write('['..key..'fxfound]'..tostring(stripdata.controls[c].fxfound)..'\n')
              file:write('['..key..'param]'..stripdata.controls[c].param..'\n')
  
              file:write('['..key..'param_info_name]'..stripdata.controls[c].param_info.paramname..'\n')
              file:write('['..key..'param_info_paramnum]'..nz(stripdata.controls[c].param_info.paramnum,'')..'\n')
              file:write('['..key..'param_info_idx]'..nz(stripdata.controls[c].param_info.paramidx,'')..'\n')
              file:write('['..key..'param_info_str]'..nz(stripdata.controls[c].param_info.paramstr,'')..'\n')
              file:write('['..key..'param_info_guid]'..nz(stripdata.controls[c].param_info.paramdestguid,'')..'\n')
              file:write('['..key..'param_info_chan]'..nz(stripdata.controls[c].param_info.paramdestchan,'')..'\n')
              file:write('['..key..'param_info_srcchan]'..nz(stripdata.controls[c].param_info.paramsrcchan,'')..'\n')
              file:write('['..key..'ctltype]'..stripdata.controls[c].ctltype..'\n')
              file:write('['..key..'knob_select]'..stripdata.controls[c].knob_select..'\n')
              file:write('['..key..'ctl_info_fn]'..stripdata.controls[c].ctl_info.fn..'\n')
              file:write('['..key..'ctl_info_frames]'..stripdata.controls[c].ctl_info.frames..'\n')
              file:write('['..key..'ctl_info_imageidx]'..stripdata.controls[c].ctl_info.imageidx..'\n')
              file:write('['..key..'ctl_info_cellh]'..stripdata.controls[c].ctl_info.cellh..'\n')
              file:write('['..key..'x]'..stripdata.controls[c].x..'\n')
              file:write('['..key..'y]'..stripdata.controls[c].y..'\n')
              file:write('['..key..'w]'..stripdata.controls[c].w..'\n')
              file:write('['..key..'scale]'..stripdata.controls[c].scale..'\n')
              file:write('['..key..'show_paramname]'..tostring(stripdata.controls[c].show_paramname)..'\n')
              file:write('['..key..'show_paramval]'..tostring(stripdata.controls[c].show_paramval)..'\n')
              file:write('['..key..'ctlname_override]'..nz(stripdata.controls[c].ctlname_override,'')..'\n')
              file:write('['..key..'textcol]'..stripdata.controls[c].textcol..'\n')
              file:write('['..key..'textcolv]'..nz(stripdata.controls[c].textcolv,stripdata.controls[c].textcol)..'\n')
              file:write('['..key..'textoff]'..stripdata.controls[c].textoff..'\n')
              file:write('['..key..'textoffval]'..stripdata.controls[c].textoffval..'\n')
              file:write('['..key..'textoffx]'..stripdata.controls[c].textoffx..'\n')
              file:write('['..key..'textoffvalx]'..stripdata.controls[c].textoffvalx..'\n')
              file:write('['..key..'textsize]'..nz(stripdata.controls[c].textsize,0)..'\n')
              file:write('['..key..'textsizev]'..nz(stripdata.controls[c].textsizev,nz(stripdata.controls[c].textsize,0))..'\n')
              file:write('['..key..'font]'..nz(stripdata.controls[c].font,fontname_def)..'\n')
              file:write('['..key..'val]'..nz(stripdata.controls[c].val,0)..'\n')
              file:write('['..key..'mval]'..nz(stripdata.controls[c].mval,nz(stripdata.controls[c].val,0))..'\n')
              file:write('['..key..'defval]'..nz(stripdata.controls[c].defval,0)..'\n')   
              file:write('['..key..'maxdp]'..nz(stripdata.controls[c].maxdp,-1)..'\n')   
              file:write('['..key..'dvaloffset]'..nz(stripdata.controls[c].dvaloffset,'')..'\n')   
              file:write('['..key..'minov]'..nz(stripdata.controls[c].minov,'')..'\n')   
              file:write('['..key..'maxov]'..nz(stripdata.controls[c].maxov,'')..'\n')   
              file:write('['..key..'scalemodex]'..nz(stripdata.controls[c].scalemode,8)..'\n')   
              file:write('['..key..'framemodex]'..nz(stripdata.controls[c].framemode,1)..'\n')   
              file:write('['..key..'poslock]'..nz(tostring(stripdata.controls[c].poslock),false)..'\n')   
              file:write('['..key..'horiz]'..tostring(nz(stripdata.controls[c].horiz,false))..'\n')
              file:write('['..key..'knobsens_norm]'..tostring(nz(stripdata.controls[c].knobsens.norm,settings_defknobsens.norm))..'\n')
              file:write('['..key..'knobsens_fine]'..tostring(nz(stripdata.controls[c].knobsens.fine,settings_defknobsens.fine))..'\n')                 
              file:write('['..key..'knobsens_wheel]'..tostring(nz(stripdata.controls[c].knobsens.wheel,settings_defknobsens.wheel))..'\n')
              file:write('['..key..'knobsens_wheelfine]'..tostring(nz(stripdata.controls[c].knobsens.wheelfine,settings_defknobsens.wheelfine))..'\n')                 
              file:write('['..key..'hidden]'..tostring(nz(stripdata.controls[c].hidden,false))..'\n')
              file:write('['..key..'switcherid]'..tostring(nz(stripdata.controls[c].switcherid,''))..'\n')
              file:write('['..key..'switcher]'..tostring(nz(stripdata.controls[c].switcher,''))..'\n')
              file:write('['..key..'noss]'..tostring(nz(stripdata.controls[c].noss,''))..'\n')
              file:write('['..key..'bypassbg_c]'..tostring(nz(stripdata.controls[c].bypassbg_c,''))..'\n')
              file:write('['..key..'bypassbg_n]'..tostring(nz(stripdata.controls[c].bypassbg_n,''))..'\n')
              file:write('['..key..'bypassbg_v]'..tostring(nz(stripdata.controls[c].bypassbg_v,''))..'\n')
              file:write('['..key..'clickthrough]'..tostring(nz(stripdata.controls[c].clickthrough,''))..'\n')
  
              file:write('['..key..'id]'..convnum(stripdata.controls[c].id)..'\n')
              file:write('['..key..'grpid]'..convnum(stripdata.controls[c].grpid)..'\n')
      
              file:write('['..key..'ctlcat]'..nz(stripdata.controls[c].ctlcat,'')..'\n')
              file:write('['..key..'tracknum]'..nz(stripdata.controls[c].tracknum,'')..'\n')
              file:write('['..key..'trackguid]'..nz(stripdata.controls[c].trackguid,'')..'\n')
              file:write('['..key..'memstate]'..tostring(nz(stripdata.controls[c].membtn.state,false))..'\n')
              file:write('['..key..'memmem]'..nz(stripdata.controls[c].membtn.mem,0)..'\n')
              
              file:write('['..key..'xydata_x]'..nz(stripdata.controls[c].xydata.x,0.5)..'\n')
              file:write('['..key..'xydata_y]'..nz(stripdata.controls[c].xydata.y,0.5)..'\n')
              file:write('['..key..'xydata_snapa]'..nz(stripdata.controls[c].xydata.snapa,1)..'\n')
              file:write('['..key..'xydata_snapb]'..nz(stripdata.controls[c].xydata.snapb,1)..'\n')
              file:write('['..key..'xydata_snapc]'..nz(stripdata.controls[c].xydata.snapc,1)..'\n')
              file:write('['..key..'xydata_snapd]'..nz(stripdata.controls[c].xydata.snapd,1)..'\n')

              file:write('['..key..'macrofader]'..nz(stripdata.controls[c].macrofader,'')..'\n')
              file:write('['..key..'switchfader]'..nz(stripdata.controls[c].switchfader,'')..'\n')
  
              if stripdata.controls[c].cycledata and stripdata.controls[c].cycledata.statecnt then
                file:write('['..key..'cycledata_statecnt]'..nz(stripdata.controls[c].cycledata.statecnt,0)..'\n')
                file:write('['..key..'cycledata_mapptof]'..tostring(nz(stripdata.controls[c].cycledata.mapptof,false))..'\n')
                file:write('['..key..'cycledata_draggable]'..tostring(nz(stripdata.controls[c].cycledata.draggable,false))..'\n')
                file:write('['..key..'cycledata_spread]'..tostring(nz(stripdata.controls[c].cycledata.spread,false))..'\n')
                file:write('['..key..'cycledata_pos]'..tostring(nz(stripdata.controls[c].cycledata.pos,1))..'\n')
                file:write('['..key..'cycledata_posdirty]'..tostring(nz(stripdata.controls[c].cycledata.posdirty,false))..'\n')
                if nz(stripdata.controls[c].cycledata.statecnt,0) > 0 then
                  for i = 1, stripdata.controls[c].cycledata.statecnt do
                    local key = pfx..'c_'..c..'_cyc_'..i..'_'
                    file:write('['..key..'val]'..nz(stripdata.controls[c].cycledata[i].val,0)..'\n')   
                    file:write('['..key..'dispval]'..nz(stripdata.controls[c].cycledata[i].dispval,'')..'\n')   
                    file:write('['..key..'dv]'..nz(stripdata.controls[c].cycledata[i].dv,'')..'\n')   
                  end
                end
              else
                file:write('['..key..'cycledata_statecnt]'..0 ..'\n')                   
              end

              if stripdata.controls[c].midiout then
                file:write('['..key..'midiout_output]'..nz(stripdata.controls[c].midiout.output,'')..'\n')
                file:write('['..key..'midiout_mchan]'..nz(stripdata.controls[c].midiout.mchan,'')..'\n')
                file:write('['..key..'midiout_msg3]'..nz(stripdata.controls[c].midiout.msg3,'')..'\n')              
                file:write('['..key..'midiout_msgtype]'..nz(stripdata.controls[c].midiout.msgtype,4)..'\n')              
                file:write('['..key..'midiout_osc]'..nz(stripdata.controls[c].midiout.osc,'')..'\n')              
                file:write('['..key..'midiout_vmin]'..nz(stripdata.controls[c].midiout.vmin,0)..'\n')              
                file:write('['..key..'midiout_vmax]'..nz(stripdata.controls[c].midiout.vmax,127)..'\n')              
                file:write('['..key..'midiout_focus]'..nz(stripdata.controls[c].midiout.focus,1)..'\n')              
                file:write('['..key..'midiout_updategfx]'..tostring(nz(stripdata.controls[c].midiout.updategfx,false))..'\n')              
                file:write('['..key..'midiout_onmu]'..tostring(nz(stripdata.controls[c].midiout.onmu,false))..'\n')              
              end

              if stripdata.controls[c].rcmdata and #stripdata.controls[c].rcmdata > 0 then
                file:write('['..key..'rcmdata_cnt]'..#stripdata.controls[c].rcmdata ..'\n')                                 
                for r = 1, #stripdata.controls[c].rcmdata do
                  local key = pfx..'c_'..c..'_rcm_'..r..'_'
                  file:write('['..key..'name]'..stripdata.controls[c].rcmdata[r].name..'\n')                                 
                  file:write('['..key..'msb]'..stripdata.controls[c].rcmdata[r].msb..'\n')
                  file:write('['..key..'lsb]'..stripdata.controls[c].rcmdata[r].lsb..'\n')
                  file:write('['..key..'prog]'..stripdata.controls[c].rcmdata[r].prog..'\n')                  
                  file:write('['..key..'nebfn]'..nz(stripdata.controls[c].rcmdata[r].nebfn,'')..'\n')                  
                end 
              else
                file:write('['..key..'rcmdata_cnt]'..0 ..'\n')                                               
              end
              
              if stripdata.controls[c].rcmrefresh then
                file:write('['..key..'rcmrefresh_guid]'..nz(stripdata.controls[c].rcmrefresh.guid,'')..'\n')                                 
                file:write('['..key..'rcmrefresh_delay]'..nz(stripdata.controls[c].rcmrefresh.delay,'')..'\n')              
                file:write('['..key..'rcmrefresh_setvals]'..tostring(nz(stripdata.controls[c].rcmrefresh.setvals,''))..'\n')              
              end
              
              if stripdata.controls[c].gauge then
                file:write('['..key..'gauge]'..tostring(true)..'\n')
              
                file:write('['..key..'gauge_type]'..nz(stripdata.controls[c].gauge.type,1)..'\n')
                file:write('['..key..'gauge_x_offs]'..nz(stripdata.controls[c].gauge.x_offs,0)..'\n')
                file:write('['..key..'gauge_y_offs]'..nz(stripdata.controls[c].gauge.y_offs,0)..'\n')
                file:write('['..key..'gauge_radius]'..nz(stripdata.controls[c].gauge.radius,50)..'\n')
                file:write('['..key..'gauge_arclen]'..nz(stripdata.controls[c].gauge.arclen,1)..'\n')
                file:write('['..key..'gauge_rotation]'..nz(stripdata.controls[c].gauge.rotation,0)..'\n')
                file:write('['..key..'gauge_ticks]'..nz(stripdata.controls[c].gauge.ticks,0)..'\n')
                file:write('['..key..'gauge_tick_size]'..nz(stripdata.controls[c].gauge.tick_size,2)..'\n')
                file:write('['..key..'gauge_tick_offs]'..nz(stripdata.controls[c].gauge.tick_offs,1)..'\n')
                file:write('['..key..'gauge_val_freq]'..nz(stripdata.controls[c].gauge.val_freq,0)..'\n')
                file:write('['..key..'gauge_col_tick]'..nz(stripdata.controls[c].gauge.col_tick,'205 205 205')..'\n')
                file:write('['..key..'gauge_col_arc]'..nz(stripdata.controls[c].gauge.col_arc,'205 205 205')..'\n')
                file:write('['..key..'gauge_col_val]'..nz(stripdata.controls[c].gauge.col_val,'205 205 205')..'\n')
                file:write('['..key..'gauge_show_arc]'..tostring(nz(stripdata.controls[c].gauge.show_arc,true))..'\n')
                file:write('['..key..'gauge_show_tick]'..tostring(nz(stripdata.controls[c].gauge.show_tick,true))..'\n')
                file:write('['..key..'gauge_show_val]'..tostring(nz(stripdata.controls[c].gauge.show_val,true))..'\n')
                file:write('['..key..'gauge_val_dp]'..nz(stripdata.controls[c].gauge.val_dp,0)..'\n')
                file:write('['..key..'gauge_font]'..nz(stripdata.controls[c].gauge.font,fontname_def)..'\n')
                file:write('['..key..'gauge_fontsz]'..nz(stripdata.controls[c].gauge.fontsz,0)..'\n')
                file:write('['..key..'gauge_spread]'..tostring(nz(stripdata.controls[c].gauge.spread,''))..'\n')
                file:write('['..key..'gauge_mapptof]'..tostring(nz(stripdata.controls[c].gauge.mapptof,''))..'\n')
                file:write('['..key..'gauge_numonly]'..tostring(nz(stripdata.controls[c].gauge.numonly,''))..'\n')
                file:write('['..key..'gauge_abbrev]'..tostring(nz(stripdata.controls[c].gauge.abbrev,''))..'\n')
                file:write('['..key..'gauge_valcnt]'..#stripdata.controls[c].gauge.vals..'\n')
              
                if stripdata.controls[c].gauge.vals and #stripdata.controls[c].gauge.vals > 0 then
                  for gv = 1, #stripdata.controls[c].gauge.vals do
                    local key = pfx..'c_'..c..'_gaugevals_'..gv..'_' 
                    file:write('['..key..'val]'..nz(stripdata.controls[c].gauge.vals[gv].val,0)..'\n')
                    file:write('['..key..'dval]'..nz(stripdata.controls[c].gauge.vals[gv].dval,'-')..'\n')
                    file:write('['..key..'dover]'..nz(stripdata.controls[c].gauge.vals[gv].dover,'')..'\n')                  
                    file:write('['..key..'nudge]'..nz(stripdata.controls[c].gauge.vals[gv].nudge,0)..'\n')                  
                  end
                end
              end
                            
              if stripdata.controls[c].macroctl then
                local mcnt = #stripdata.controls[c].macroctl
                file:write('['..key..'macroctl_cnt]'..mcnt..'\n')                                 
                for mc = 1,mcnt do
                  local key = pfx..'c_'..c..'_mc_'..mc..'_'
                  file:write('['..key..'c_id]'..stripdata.controls[c].macroctl[mc].c_id..'\n')                                 
                  file:write('['..key..'ctl]'..stripdata.controls[c].macroctl[mc].ctl..'\n')                                 
                  file:write('['..key..'A]'..stripdata.controls[c].macroctl[mc].A_val..'\n')                                 
                  file:write('['..key..'B]'..stripdata.controls[c].macroctl[mc].B_val..'\n')                                 
                  file:write('['..key..'shape]'..stripdata.controls[c].macroctl[mc].shape..'\n')                                 
                  file:write('['..key..'mute]'..tostring(nz(stripdata.controls[c].macroctl[mc].mute,false))..'\n')                                 
                  file:write('['..key..'bi]'..tostring(nz(stripdata.controls[c].macroctl[mc].bi,false))..'\n')
                  file:write('['..key..'inv]'..tostring(nz(stripdata.controls[c].macroctl[mc].inv,false))..'\n')                                 
                  file:write('['..key..'rel]'..tostring(nz(stripdata.controls[c].macroctl[mc].relative,false))..'\n')                                 
                end
              else
                file:write('['..key..'macroctl_cnt]'..0 ..'\n')                                 
              end

              if stripdata.controls[c].eqbands then
                local bcnt = #stripdata.controls[c].eqbands
                file:write('['..key..'eqband_cnt]'..bcnt..'\n')
                if bcnt > 0 then                                 
                  for bc = 1,bcnt do
                    local key = pfx..'c_'..c..'_eqband_'..bc..'_'
                    file:write('['..key..'posmin]'..nz(stripdata.controls[c].eqbands[bc].posmin,'')..'\n')                                 
                    file:write('['..key..'posmax]'..nz(stripdata.controls[c].eqbands[bc].posmax,'')..'\n')                                 
                    file:write('['..key..'col]'..nz(stripdata.controls[c].eqbands[bc].col,'')..'\n')                                 
                    file:write('['..key..'fxnum]'..nz(stripdata.controls[c].eqbands[bc].fxnum,'')..'\n')                                 
                    file:write('['..key..'fxguid]'..nz(stripdata.controls[c].eqbands[bc].fxguid,'')..'\n')                                 
                    file:write('['..key..'fxname]'..nz(stripdata.controls[c].eqbands[bc].fxname,'')..'\n')                                 
                    file:write('['..key..'freq_param]'..nz(stripdata.controls[c].eqbands[bc].freq_param,'')..'\n')                                 
                    file:write('['..key..'freq_param_name]'..nz(stripdata.controls[c].eqbands[bc].freq_param_name,'')..'\n')                                 
                    file:write('['..key..'gain_param]'..nz(stripdata.controls[c].eqbands[bc].gain_param,'')..'\n')                                 
                    file:write('['..key..'gain_param_name]'..nz(stripdata.controls[c].eqbands[bc].gain_param_name,'')..'\n')                                 
                    file:write('['..key..'q_param]'..nz(stripdata.controls[c].eqbands[bc].q_param,'')..'\n')                                 
                    file:write('['..key..'q_param_name]'..nz(stripdata.controls[c].eqbands[bc].q_param_name,'')..'\n')                                 
                    file:write('['..key..'bypass_param]'..nz(stripdata.controls[c].eqbands[bc].bypass_param,'')..'\n')                                 
                    file:write('['..key..'bypass_param_name]'..nz(stripdata.controls[c].eqbands[bc].bypass_param_name,'')..'\n')                                 
                    file:write('['..key..'c1_param]'..nz(stripdata.controls[c].eqbands[bc].c1_param,'')..'\n')                                 
                    file:write('['..key..'c1_param_name]'..nz(stripdata.controls[c].eqbands[bc].c1_param_name,'')..'\n')                                 
                    file:write('['..key..'c2_param]'..nz(stripdata.controls[c].eqbands[bc].c2_param,'')..'\n')                                 
                    file:write('['..key..'c2_param_name]'..nz(stripdata.controls[c].eqbands[bc].c2_param_name,'')..'\n')                                 
                    file:write('['..key..'c3_param]'..nz(stripdata.controls[c].eqbands[bc].c3_param,'')..'\n')                                 
                    file:write('['..key..'c3_param_name]'..nz(stripdata.controls[c].eqbands[bc].c3_param_name,'')..'\n')                                 
                    file:write('['..key..'c4_param]'..nz(stripdata.controls[c].eqbands[bc].c4_param,'')..'\n')                                 
                    file:write('['..key..'c4_param_name]'..nz(stripdata.controls[c].eqbands[bc].c4_param_name,'')..'\n')                                 
                    file:write('['..key..'c5_param]'..nz(stripdata.controls[c].eqbands[bc].c5_param,'')..'\n')                                 
                    file:write('['..key..'c5_param_name]'..nz(stripdata.controls[c].eqbands[bc].c5_param_name,'')..'\n')                                 
                    file:write('['..key..'freq_val]'..nz(stripdata.controls[c].eqbands[bc].freq_val,'')..'\n')                                 
                    file:write('['..key..'gain_val]'..nz(stripdata.controls[c].eqbands[bc].gain_val,'')..'\n')                                 
                    file:write('['..key..'q_val]'..nz(stripdata.controls[c].eqbands[bc].q_val,'')..'\n')                                 
                    file:write('['..key..'c1_val]'..nz(stripdata.controls[c].eqbands[bc].c1_val,'')..'\n')                                 
                    file:write('['..key..'c2_val]'..nz(stripdata.controls[c].eqbands[bc].c2_val,'')..'\n')                                 
                    file:write('['..key..'c3_val]'..nz(stripdata.controls[c].eqbands[bc].c3_val,'')..'\n')                                 
                    file:write('['..key..'c4_val]'..nz(stripdata.controls[c].eqbands[bc].c4_val,'')..'\n')                                 
                    file:write('['..key..'c5_val]'..nz(stripdata.controls[c].eqbands[bc].c5_val,'')..'\n')                                 

                    file:write('['..key..'freq_min]'..nz(stripdata.controls[c].eqbands[bc].freq_min,'')..'\n')                                 
                    file:write('['..key..'freq_max]'..nz(stripdata.controls[c].eqbands[bc].freq_max,'')..'\n')
                    file:write('['..key..'gain_min]'..nz(stripdata.controls[c].eqbands[bc].gain_min,'')..'\n')                                 
                    file:write('['..key..'gain_max]'..nz(stripdata.controls[c].eqbands[bc].gain_max,'')..'\n')
                    file:write('['..key..'bandtype]'..nz(stripdata.controls[c].eqbands[bc].bandtype,'')..'\n')                                 
                    file:write('['..key..'bandname]'..nz(stripdata.controls[c].eqbands[bc].bandname,'')..'\n')                    
                    file:write('['..key..'khz]'..nz(tostring(stripdata.controls[c].eqbands[bc].khz),tostring(false))..'\n')                    
                    file:write('['..key..'gaininv]'..nz(tostring(stripdata.controls[c].eqbands[bc].gain_inv),tostring(false))..'\n')                    
                    file:write('['..key..'qinv]'..nz(tostring(stripdata.controls[c].eqbands[bc].q_inv),tostring(false))..'\n')                    
                    file:write('['..key..'gmin]'..nz(stripdata.controls[c].eqbands[bc].gmin,'')..'\n')                                 
                    file:write('['..key..'gmax]'..nz(stripdata.controls[c].eqbands[bc].gmax,'')..'\n')                                 

                    file:write('['..key..'freq_def]'..nz(stripdata.controls[c].eqbands[bc].freq_def,'')..'\n')                                 
                    file:write('['..key..'gain_def]'..nz(stripdata.controls[c].eqbands[bc].gain_def,'')..'\n')                                 
                    file:write('['..key..'q_def]'..nz(stripdata.controls[c].eqbands[bc].q_def,'')..'\n')                                 
                    file:write('['..key..'c1_def]'..nz(stripdata.controls[c].eqbands[bc].c1_def,'')..'\n')                                 
                    file:write('['..key..'c2_def]'..nz(stripdata.controls[c].eqbands[bc].c2_def,'')..'\n')                                 
                    file:write('['..key..'c3_def]'..nz(stripdata.controls[c].eqbands[bc].c3_def,'')..'\n')                                 
                    file:write('['..key..'c4_def]'..nz(stripdata.controls[c].eqbands[bc].c4_def,'')..'\n')                                 
                    file:write('['..key..'c5_def]'..nz(stripdata.controls[c].eqbands[bc].c5_def,'')..'\n')                                 
                    
                    local key = pfx..'c_'..c..'_eqband_'..bc..'_'
                    if stripdata.controls[c].eqbands[bc].lookmap then
                      local lcnt = #stripdata.controls[c].eqbands[bc].lookmap
                      file:write('['..key..'lookmap_cnt]'..lcnt..'\n')
                      
                      if lcnt > 0 then
                        for lc = 1, lcnt do
                          local key = pfx..'c_'..c..'_eqband_'..bc..'_lm_'..lc..'_'
                          file:write('['..key..'pix]'..nz(stripdata.controls[c].eqbands[bc].lookmap[lc].pix,'')..'\n')                                 
                          file:write('['..key..'hz]'..nz(stripdata.controls[c].eqbands[bc].lookmap[lc].hz,'')..'\n')                                 
                        end
                      end
                    
                    else
                      file:write('['..key..'lookmap_cnt]'..0 ..'\n')                    
                    end

                    local key = pfx..'c_'..c..'_eqband_'..bc..'_'
                    if stripdata.controls[c].eqbands[bc].gmap then
                      local lcnt = #stripdata.controls[c].eqbands[bc].gmap
                      file:write('['..key..'gmap_cnt]'..lcnt..'\n')
                      
                      if lcnt > 0 then
                        for lc = 1, lcnt do
                          local key = pfx..'c_'..c..'_eqband_'..bc..'_gm_'..lc..'_'
                          file:write('['..key..'pix]'..nz(stripdata.controls[c].eqbands[bc].gmap[lc].pix,'')..'\n')                                 
                          file:write('['..key..'db]'..nz(stripdata.controls[c].eqbands[bc].gmap[lc].db,'')..'\n')                                 
                        end
                      end
                    
                    else
                      file:write('['..key..'gmap_cnt]'..0 ..'\n')                    
                    end
                                                     
                  end
                  
                end
              else
                file:write('['..key..'eqband_cnt]'..0 ..'\n')                                 
              end

              if stripdata.controls[c].eqgraph and type(stripdata.controls[c].eqgraph) == 'table' then

                local key = pfx..'c_'..c..'_'
                file:write('['..key..'ecg_graph]'..tostring(true)..'\n')                                               
                file:write('['..key..'ecg_gmin]'..nz(stripdata.controls[c].eqgraph.gmin,'')..'\n')                                 
                file:write('['..key..'ecg_gmax]'..nz(stripdata.controls[c].eqgraph.gmax,'')..'\n')                                 
                file:write('['..key..'ecg_posmin]'..nz(stripdata.controls[c].eqgraph.posmin,'')..'\n')                                 
                file:write('['..key..'ecg_posmax]'..nz(stripdata.controls[c].eqgraph.posmax,'')..'\n')                                 

                if stripdata.controls[c].eqgraph.lookmap then
                  local lcnt = #stripdata.controls[c].eqgraph.lookmap
                  file:write('['..key..'ecg_lookmap_cnt]'..lcnt..'\n')
                  
                  if lcnt > 0 then
                    for lc = 1, lcnt do
                      local key = pfx..'c_'..c..'_ecg_lm_'..lc..'_'
                      file:write('['..key..'pix]'..nz(stripdata.controls[c].eqgraph.lookmap[lc].pix,'')..'\n')                                 
                      file:write('['..key..'hz]'..nz(stripdata.controls[c].eqgraph.lookmap[lc].hz,'')..'\n')                                 
                    end
                  end
                
                else
                  file:write('['..key..'ecg_lookmap_cnt]'..0 ..'\n')                    
                end

                local key = pfx..'c_'..c..'_'
                if stripdata.controls[c].eqgraph.gmap then
                  local lcnt = #stripdata.controls[c].eqgraph.gmap
                  file:write('['..key..'ecg_gmap_cnt]'..lcnt..'\n')
                  
                  if lcnt > 0 then
                    for lc = 1, lcnt do
                      local key = pfx..'c_'..c..'_ecg_gm_'..lc..'_'
                      file:write('['..key..'pix]'..nz(stripdata.controls[c].eqgraph.gmap[lc].pix,'')..'\n')                                 
                      file:write('['..key..'db]'..nz(stripdata.controls[c].eqgraph.gmap[lc].db,'')..'\n')                                 
                    end
                  end
                
                else
                  file:write('['..key..'ecg_gmap_cnt]'..0 ..'\n')
                end
                
              end

            end
          end        

          if #stripdata.graphics > 0 then
            for g = 1, #stripdata.graphics do

              local key = pfx..'g_'..g..'_'
          
              file:write('['..key..'fn]'..stripdata.graphics[g].fn..'\n')
              --file:write('['..key..'imageidx]'..stripdata.graphics[g].imageidx..'\n')
              file:write('['..key..'x]'..stripdata.graphics[g].x..'\n')
              file:write('['..key..'y]'..stripdata.graphics[g].y..'\n')
              file:write('['..key..'w]'..stripdata.graphics[g].w..'\n')
              file:write('['..key..'h]'..stripdata.graphics[g].h..'\n')
              file:write('['..key..'stretchw]'..nz(stripdata.graphics[g].stretchw,stripdata.graphics[g].w)..'\n')
              file:write('['..key..'stretchh]'..nz(stripdata.graphics[g].stretchh,stripdata.graphics[g].h)..'\n')
              file:write('['..key..'scale]'..stripdata.graphics[g].scale..'\n')
              file:write('['..key..'id]'..convnum(stripdata.graphics[g].id)..'\n')
              file:write('['..key..'grpid]'..convnum(stripdata.graphics[g].grpid)..'\n')
            
              file:write('['..key..'gfxtype]'..nz(stripdata.graphics[g].gfxtype, gfxtype.img)..'\n')
              file:write('['..key..'font_idx]'..nz(stripdata.graphics[g].font.idx, '')..'\n')
              file:write('['..key..'font_name]'..nz(stripdata.graphics[g].font.name, '')..'\n')
              file:write('['..key..'font_size]'..nz(stripdata.graphics[g].font.size, '')..'\n')
              file:write('['..key..'font_bold]'..nz(tostring(stripdata.graphics[g].font.bold), '')..'\n')
              file:write('['..key..'font_italics]'..nz(tostring(stripdata.graphics[g].font.italics), '')..'\n')
              file:write('['..key..'font_underline]'..nz(tostring(stripdata.graphics[g].font.underline), '')..'\n')
              file:write('['..key..'font_shadow]'..nz(tostring(stripdata.graphics[g].font.shadow), '')..'\n')
              file:write('['..key..'font_shadowx]'..nz(stripdata.graphics[g].font.shadow_x, '')..'\n')
              file:write('['..key..'font_shadowy]'..nz(stripdata.graphics[g].font.shadow_y, '')..'\n')
              file:write('['..key..'font_shadowa]'..nz(stripdata.graphics[g].font.shadow_a, '')..'\n')
              file:write('['..key..'text]'..nz(stripdata.graphics[g].text, '')..'\n')
              file:write('['..key..'text_col]'..nz(stripdata.graphics[g].text_col, '')..'\n')
              file:write('['..key..'poslock]'..nz(tostring(stripdata.graphics[g].poslock), false)..'\n')
              file:write('['..key..'switcher]'..tostring(nz(stripdata.graphics[g].switcher,''))..'\n')
              file:write('['..key..'bright]'..tostring(nz(stripdata.graphics[g].bright,0.5))..'\n')
              file:write('['..key..'contr]'..tostring(nz(stripdata.graphics[g].contr,0.5))..'\n')
              file:write('['..key..'rmult]'..tostring(nz(stripdata.graphics[g].rmult,0.5))..'\n')
              file:write('['..key..'gmult]'..tostring(nz(stripdata.graphics[g].gmult,0.5))..'\n')
              file:write('['..key..'bmult]'..tostring(nz(stripdata.graphics[g].bmult,0.5))..'\n')
              file:write('['..key..'alpha]'..tostring(nz(stripdata.graphics[g].alpha,1))..'\n')
              file:write('['..key..'stretchmode]'..tostring(nz(stripdata.graphics[g].stretchmode,1))..'\n')
              file:write('['..key..'edgesz]'..tostring(nz(stripdata.graphics[g].edgesz,8))..'\n')
              
            end
          end
      
        else
          file:write('['..key..'surface_x]'..0 ..'\n')
          file:write('['..key..'surface_y]'..0 ..'\n')
          file:write('['..key..'controls_count]'..0 ..'\n')
          file:write('['..key..'graphics_count]'..0 ..'\n')          
        end      
      
    return reaper.time_precise() - t
  
  end
  
      
  function SaveEditedData()
    for i, v in pairs(g_edstrips) do 
      SaveStripData_FN(tracks[i].strip) 
    end
  end
  
  function GetSaveFN(tmp)
  
    local save_path=projsave_path..'/'
    if settings_savedatainprojectfolder == true then
      save_path=reaper.GetProjectPath('')..'/'
    end
    
    local pn = GetProjectName()
    local projname = string.sub(pn,0,string.len(pn)-4) --..'_'..PROJECTID
    if projname == nil or projname == '' then
      projname = 'unnamed_project'
    end
    if save_subfolder and save_subfolder ~= '' then
      local sf = save_subfolder
      if sf == '#' then
        sf = projname
        if projname == 'unnamed_project' then
          projname = projname..'_'..PROJECTID
        end
      end
      projname = sf..'/'..projname
      reaper.RecursiveCreateDirectory(save_path..sf,1)
    end
    
    if tmp then
      fn=projname..".lbxstripper__"
    else
      fn=projname..".lbxstripper"
    end
    local ffn=save_path..fn
    
    return ffn, save_path, fn
    
  end
  
  function SaveData(tmp, bak, noclean)
  
    ZeroProjectFlags()
    
    DBGOut('')
    DBGOut('*** SAVING DATA ***')    
  
    SaveSettings()
    
    if noclean == nil then
      PopulateTracks()
      CleanData()
    end
        
    local t = reaper.time_precise()
        
    local ffn, save_path, fn = GetSaveFN(tmp)
    DBGOut('SaveData: ffn: '..tostring(ffn))
    
    file=io.open(ffn,"w")
    if file == nil then
      DBG('Failed to create save file:\n\n'..ffn)
      return nil
    end
        
    local s, p, c, g
    reaper.SetProjExtState(0,SCRIPT,"","") -- clear first
    --DBG('saving')
    reaper.SetProjExtState(0,SCRIPT,'version',VERSION)
    reaper.SetProjExtState(0,SCRIPT,'projectid',PROJECTID)
    reaper.SetProjExtState(0,SCRIPT,'gridsize',settings_gridsize)
    reaper.SetProjExtState(0,SCRIPT,'showgrid',tostring(settings_showgrid))
    reaper.SetProjExtState(0,SCRIPT,'showeditbar',tostring(show_editbar))
    reaper.SetProjExtState(0,SCRIPT,'locksurface',tostring(settings_locksurface))
    reaper.SetProjExtState(0,SCRIPT,'lasttrack',track_select)
    reaper.SetProjExtState(0,SCRIPT,'metalite_gravity',xxy_gravity)
    if snapshot_win_pos == nil then snapshot_win_pos = {} end
    reaper.SetProjExtState(0,SCRIPT,'snapwinpos_x',nz(snapshot_win_pos.x,''))
    reaper.SetProjExtState(0,SCRIPT,'snapwinpos_y',nz(snapshot_win_pos.y,''))
    reaper.SetProjExtState(0,SCRIPT,'showsnap',tostring(show_snapshots))
    
    if gfx1 then
      reaper.SetProjExtState(0,SCRIPT,'win_w',nz(gfx1.main_w,800))
      reaper.SetProjExtState(0,SCRIPT,'win_h',nz(gfx1.main_h,450))    
    end
    
    SaveDataFile(file, save_path)
    
    file:close()
    reaper.SetProjExtState(0,SCRIPT,'lbxstripper_datafile',fn)
    LOADEDDATAFILE = fn
    reaper.SetProjExtState(0,SCRIPT,'savedok',tostring(true))
    DBGOut('SaveData: Saved OK: '..tostring(true))
    
    if settings_createbackuponmanualsave and bak == true then
      local srcffn = ffn
      if tmp then
        ffn = string.match(ffn,'(.+)__')
        if ffn == nil then
          ffn = srcffn..'.lbxbak'
        end
        ffn=ffn..'.lbxbak'
        
      else
        ffn = ffn..'.lbxbak'      
      end
      --local t = reaper.time_precise()
      copyfile(srcffn, ffn)
      --[[DBG('bkp: '..reaper.time_precise()-t)
      local t = reaper.time_precise()
      file=io.open(ffn,"w")
      if file == nil then
        DBG('Failed to create backup file:/n/n'..ffn)
        return nil
      end
      SaveDataFile(file, save_path)
      file:close()
      DBG('bkp: '..reaper.time_precise()-t)]]
      
      DBGOut('SaveData: Backup created: '..tostring(true))      
    end
    
    infomsg = 'Total Save Time: '..round(reaper.time_precise() - t,2)..'s'
    DBGOut(infomsg)
    g_savedirty = false
    
  end
  
  function SaveDataFile(file, save_path)
    
    file:write('[version]'..tostring(VERSION)..'\n')
    if strips and #strips > 0 then
    
      reaper.SetProjExtState(0,SCRIPT,'strips_count',#strips)
      file:write('[stripcount]'..tostring(#strips)..'\n')    
      DBGOut('SaveData: strips count: '..tostring(#strips))
      
      for s = 1, #strips do
        GUI_DrawMsgX(obj, gui, 'Saving Strip Data...',s,#strips)
        SaveStripData_FN(s,'dummy',save_path,file)
      end
      
    else
      reaper.SetProjExtState(0,SCRIPT,'strips_count',0)    
      file:write('[stripcount]'..tostring(0)..'\n')    
      DBGOut('SaveData: strips count: '..tostring(0))
    end
    
    if snapshots and #snapshots > 0 then
      reaper.SetProjExtState(0,SCRIPT,'snapshots_count',#snapshots)
      file:write('[snapshotcount]'..tostring(#snapshots)..'\n')    
      DBGOut('SaveData: snapshots count: '..tostring(#snapshots))
    
      for s = 1, #snapshots do
        GUI_DrawMsgX(obj, gui, 'Saving Snapshot/Metalite Data...',s,#snapshots)
        SaveSnapshotData_FN(s,'dummy',save_path,file)
        SaveXXYData_FN(s,'dummy',save_path,file)
      end
    
      SaveXXYPathData_FN('dummy',save_path,file)
    else
      reaper.SetProjExtState(0,SCRIPT,'snapshots_count',0)        
      file:write('[snapshotcount]'..tostring(0)..'\n')    
      DBGOut('SaveData: snapshots count: '..tostring(0))
    end
    
    if faders then
      SaveFaders(file)
    end
    if switchers then
      SaveSwitchers(file)
    end
    
  end
  
  function convnum(val)
  
    if val == nil then
      val = -0xFFFFFF
    end
    return val
       
  end
  
  function deconvnum(val)
    
    if tonumber(val) == -0xFFFFFF then
      val = nil
    else
      val = tonumber(val)
    end
    return val
       
  end
    
  ------------------------------------------------------------
  
  function SetSurfaceSize()
  
    gfx.setimgdim(1000,surface_size.w, surface_size.h)
    gfx.setimgdim(1004,surface_size.w, surface_size.h)
      
  end
  
  ------------------------------------------------------------

  function Snapshots_Check(strip, page)
    if snapshots and snapshots[strip] then
      if #snapshots[strip][page] > 0 then    
    
        local ctls = {}
        for c = 1, #strips[strip][page].controls do
          --local cc = strips[strip][page].controls[c]
          ctls[strips[strip][page].controls[c].c_id] = c
        end
    
        for sst = 1, #snapshots[strip][page] do

          GUI_DrawMsgX(obj, gui, 'Checking snapshots...',sst,#snapshots[strip][page])
        
          if sst == 1 then
            if #snapshots[strip][page][sst] > 0 then
          
              local sscnt = #snapshots[strip][page][sst]
              for ss = 1, sscnt do
              
              
                local ss_entry_deleted = false
                local dcnt = #snapshots[strip][page][sst][ss].data    
                if dcnt > 0 then
                  local notfoundcnt = 0
                  for d = 1, dcnt do
                  
                    if strips[strip][page].controls[snapshots[strip][page][sst][ss].data[d].ctl] == nil or
                       snapshots[strip][page][sst][ss].data[d].c_id ~= strips[strip][page].controls[snapshots[strip][page][sst][ss].data[d].ctl].c_id then
                      local c = ctls[snapshots[strip][page][sst][ss].data[d].c_id]
                      if c then
                        snapshots[strip][page][sst][ss].data[d].ctl = c
                      else
                        --snapshot entry not found
                        notfoundcnt = notfoundcnt + 1
                        snapshots[strip][page][sst][ss].data[d] = nil
                        ss_entry_deleted = true
                      end
                    end
                  end
                  
                  if ss_entry_deleted == true then
                    snapshots[strip][page][sst][ss].data = Table_RemoveNils(snapshots[strip][page][sst][ss].data, dcnt)
                  end
                end
              end
            end
          elseif sst > 1 then

            if #snapshots[strip][page][sst].ctls > 0 then
                    
              local ctlcnt = #snapshots[strip][page][sst].ctls
              local ctl_entry_deleted = false
              for ctl = 1, ctlcnt do
          
                if strips[strip][page].controls[snapshots[strip][page][sst].ctls[ctl].ctl] == nil or
                   snapshots[strip][page][sst].ctls[ctl].c_id ~= strips[strip][page].controls[snapshots[strip][page][sst].ctls[ctl].ctl].c_id then
                  local c = ctls[snapshots[strip][page][sst].ctls[ctl].c_id]
                  if c then
                    snapshots[strip][page][sst].ctls[ctl].ctl = c                  
                  else
                    --snapshot entry not found
                    snapshots[strip][page][sst].ctls[ctl] = nil
                    ctl_entry_deleted = true
                  end
                end
              end
              if ctl_entry_deleted == true then
                snapshots[strip][page][sst].ctls = Table_RemoveNils(snapshots[strip][page][sst].ctls, ctlcnt)
              end
            end
            
            if #snapshots[strip][page][sst].snapshot > 0 then
            
              local sscnt = #snapshots[strip][page][sst].snapshot
              for ss = 1, #snapshots[strip][page][sst].snapshot do

                local ss_entry_deleted = false
                local dcnt = #snapshots[strip][page][sst].snapshot[ss].data    
                if dcnt > 0 then
                  local notfoundcnt = 0
                  for d = 1, dcnt do
                  
                    if strips[strip][page].controls[snapshots[strip][page][sst].snapshot[ss].data[d].ctl] == nil or
                       snapshots[strip][page][sst].snapshot[ss].data[d].c_id ~= strips[strip][page].controls[snapshots[strip][page][sst].snapshot[ss].data[d].ctl].c_id then
                      
                      local c = ctls[snapshots[strip][page][sst].snapshot[ss].data[d].c_id]
                      if c then
                        snapshots[strip][page][sst].snapshot[ss].data[d].ctl = c
                      else
                        --snapshot entry not found
                        notfoundcnt = notfoundcnt + 1
                        snapshots[strip][page][sst].snapshot[ss].data[d] = nil
                        ss_entry_deleted = true
                      end
                    end
                  end
                  
                  if ss_entry_deleted == true then
                    snapshots[strip][page][sst].snapshot[ss].data = Table_RemoveNils(snapshots[strip][page][sst].snapshot[ss].data, dcnt)
                  end
                end
              end
            end
          
          end
        end
      end
    end  
  
  end

  ------------------------------------------------------------

  function Table_RemoveNils(srctbl, dcnt)
  
    local tbl = {}
    
    if dcnt > 0 then
      for i = 1, dcnt do
        if srctbl[i] ~= nil then
          table.insert(tbl, srctbl[i])
        end
      end
    end
    return tbl
      
  end

  ------------------------------------------------------------

  function Table_RemoveEntry(srctbl, dcnt, dremidx)
  
    local tbl = {}
    
    if dcnt > 0 then
      for i = 1, dcnt do
        if i ~= dremidx then
          table.insert(tbl, srctbl[i])
        end
      end
    end
    return tbl
      
  end
  
  ------------------------------------------------------------

  function Snap_RemoveDeletedSS(strip, page, sstype)
  
    if snapshots[strip][page][sstype] then
    
      if #snapshots[strip][page][sstype].ctls > 0 then
      local ctlcnt = #snapshots[strip][page][sstype].ctls
        for ctl = 1, ctlcnt do
          if snapshots[strip][page][sstype].ctls[ctl].delete then
          
            local cid = snapshots[strip][page][sstype].ctls[ctl].c_id
            sscnt = #snapshots[strip][page][sstype].snapshot
            for ss = 1, sscnt do          
              dcnt = #snapshots[strip][page][sstype].snapshot[ss].data
              for d = 1, dcnt do
                if snapshots[strip][page][sstype].snapshot[ss].data[d].c_id == cid then
                  --remove
                  snapshots[strip][page][sstype].snapshot[ss].data[d] = nil
                end
              end
              snapshots[strip][page][sstype].snapshot[ss].data = Table_RemoveNils(snapshots[strip][page][sstype].snapshot[ss].data,dcnt)
            end

            snapshots[strip][page][sstype].ctls[ctl] = nil
          end    
        end
        snapshots[strip][page][sstype].ctls = Table_RemoveNils(snapshots[strip][page][sstype].ctls,ctlcnt)
      end

      g_savedirty = true
    end
  
  end
  
  function CleanSS(strip, page, sstype)
  
    if sstype > 1 then
      if snapshots[strip][page][sstype] then
  
        if #snapshots[strip][page][sstype].ctls > 0 then
  
          local ctlcnt = #snapshots[strip][page][sstype].ctls
          for ctl = 1, ctlcnt do
  
            local c = snapshots[strip][page][sstype].ctls[ctl].ctl
            
            --check ctl in each snapshot
            if #snapshots[strip][page][sstype].snapshot > 0 then
              for ss = 1, #snapshots[strip][page][sstype].snapshot do
    
                if #snapshots[strip][page][sstype].snapshot[ss].data > 0 then
                  local fnd = false
                  for d = 1, #snapshots[strip][page][sstype].snapshot[ss].data do
                    if snapshots[strip][page][sstype].snapshot[ss].data[d].ctl == c then
                      fnd = true
                      break
                    end
                  end
                  if fnd == false then 
                    --add to data  
                    AddCtlValToSS(strip,page,sstype,ss,c)
                  end
                else
                  --add to data
                  AddCtlValToSS(strip,page,sstype,ss,c)  
                end
              end  

            end
          end
          
        end  
  
      end
    end      
  end

  function AddCtlValToSS(strip, page, sstype, ss, c)
  --DBG('adding '..c)
    local track = GetTrack(nz(strips[strip][page].controls[c].tracknum,strips[strip].track.tracknum))
    local cc = strips[strip][page].controls[c].ctlcat
    local fxnum = strips[strip][page].controls[c].fxnum
    local param = strips[strip][page].controls[c].param
    local min, max = GetParamMinMax(cc,track,nz(fxnum,-1),param,true,c)
    local dval = DenormalizeValue(min,max,strips[strip][page].controls[c].val)
    if sstype == 1 then
      local sscnt = #snapshots[strip][page][sstype][ss].data + 1
      snapshots[strip][page][sstype][ss].data[sscnt] = {c_id = strips[strip][page].controls[c].c_id,
                                                              ctl = c,
                                                              val = strips[strip][page].controls[c].val,
                                                              dval = dval}    
    elseif sstype > 1 then
      local sscnt = #snapshots[strip][page][sstype].snapshot[ss].data + 1
      snapshots[strip][page][sstype].snapshot[ss].data[sscnt] = {c_id = strips[strip][page].controls[c].c_id,
                                                              ctl = c,
                                                              val = strips[strip][page].controls[c].val,
                                                              dval = dval}
    end
  end

  function XY_Set(strip, page, sstype_select, ctl)

    if sstype_select > 1 then
    
      local x = strips[strip][page].controls[ctl].xydata.x
      local y = strips[strip][page].controls[ctl].xydata.y
      
      local ssa = strips[strip][page].controls[ctl].xydata.snapa
      local ssb = strips[strip][page].controls[ctl].xydata.snapb
      local ssc = strips[strip][page].controls[ctl].xydata.snapc
      local ssd = strips[strip][page].controls[ctl].xydata.snapd

      local gtrack = GetTrack(strips[strip].track.tracknum)
      if snapshots[strip][page][sstype_select].snapshot[ssa] then
        for ss = 1, #snapshots[strip][page][sstype_select].snapshot[ssa].data do
          
          local c = snapshots[strip][page][sstype_select].snapshot[ssa].data[ss].ctl
          local v_A, v_B, v_C, v_D = 0,0,0,0
          if ssa then
            v_A = snapshots[strip][page][sstype_select].snapshot[ssa].data[ss].dval
          end
          if ssb then
            v_B = snapshots[strip][page][sstype_select].snapshot[ssb].data[ss].dval
          end
          if ssc then
            v_C = snapshots[strip][page][sstype_select].snapshot[ssc].data[ss].dval
          end
          if ssd then
            v_D = snapshots[strip][page][sstype_select].snapshot[ssd].data[ss].dval
          end
  
          --local nv_A = snapshots[strip][page][sstype_select].snapshot[ssa].data[ss].val
          --local nv_B = snapshots[strip][page][sstype_select].snapshot[ssb].data[ss].val
          
          local v_AB = (v_B-v_A)*x + v_A
          local v_CD = (v_D-v_C)*x + v_C
          
          local v_ABCD = (v_CD-v_AB)*y + v_AB
          
          if c and v_ABCD and tostring(v_ABCD) ~= tostring(strips[strip][page].controls[c].val) then
            trackfxparam_select = c
            local trnum = nz(strips[strip][page].controls[c].tracknum,strips[strip].track.tracknum)
            if strips[strip][page].controls[c].tracknum then
              track = GetTrack(strips[strip][page].controls[c].tracknum)
            else
              track = gtrack
            end
            SetParam3_Denorm2_Safe2(track, v_ABCD, strip, page, reaper, c)
          end      
        end
      end
    end    
  end

  function Snapshot_RANDOMIZE(strip, page, sstype_select, respectminmax)

    if sstype_select == 1 then
      --page
      if #strips[strip][page].controls > 0 then
        for c = 1, #strips[strip][page].controls do
          local ctl = strips[strip][page].controls[c]
          if ctl.noss ~= true then
            if ctl.ctlcat == ctlcats.fxparam or 
               ctl.ctlcat == ctlcats.trackparam or
               ctl.ctlcat == ctlcats.tracksend then
              trackfxparam_select = ctl
              local v = math.random()
              if ctl.ctltype == 2 or 
                 ctl.ctltype == 3 or 
                 ctl.ctltype == 7 or
                 ctl.ctltype == 8 or
                 ctl.ctltype == 9 or
                 ctl.ctltype == 10 then
                 v = round(v)
              end
              if respectminmax == true then
                --local min, max = GetParamMinMax_ctl(ctl,true)
                --v = v*(max-min)+min            
                SetParam3(strip,page,c,ctl,v)
              else
                SetParam5(v)                          
              end
            end
          end
        end
      end
      
    elseif sstype_select > 1 then
      if snapshots[strip][page][sstype_select] then
        if #snapshots[strip][page][sstype_select].ctls > 0 then
          for ctl = 1, #snapshots[strip][page][sstype_select].ctls do
            local c = snapshots[strip][page][sstype_select].ctls[ctl].ctl
            local cctl = strips[strip][page].controls[c]
            trackfxparam_select = c
            local v = math.random()
            if cctl.ctltype == 2 or 
               cctl.ctltype == 3 or 
               cctl.ctltype == 7 or
               cctl.ctltype == 8 or
               cctl.ctltype == 9 or
               cctl.ctltype == 10 then
               v = round(v)
            end
            if respectminmax == true then
              SetParam3(strip,page,c,cctl,v)        
            else
              SetParam5(v)                          
            end
          end
        end
      end    
    
    end

  end
  
  function XXYPath_Delete(path)
  
    if XXYPath and XXYPath[path] then
  
      local pcnt = #XXYPath
      XXYPath[path] = nil
      
      local ptbl = Table_RemoveNils(XXYPath, pcnt)
      XXYPath = ptbl
  
      for s = 1, #xxy do
        if xxy[s] then
          for p = 1, #xxy[s] do
            if xxy[s][p] then
              for sst = 1, #xxy[s][p] do
                if xxy[s][p][sst] then
             
                  if xxy[s][p][sst].pathidx == path then
                    xxy[s][p][sst].pathidx = nil
                  elseif xxy[s][p][sst].pathidx > path then
                    xxy[s][p][sst].pathidx = xxy[s][p][sst].pathidx -1
                  end
                end              
              end
            end
          end
        end
      end
      
    end
    
  end
  
  function Snapshot_CloneToSubset(strip, page, sst, copy)
  
    local newsst 
    if sst == 1 then
      local strip = tracks[track_select].strip
      local ctls = strips[strip][page].controls
      if ctls and #ctls > 0 then
        newsst = #snapshots[strip][page]+1
        snapshots[strip][page][newsst] = {subsetname = 'SUBSET '..newsst-1, snapshot = {}, ctls = {}}
        snapsubsets_table[newsst] = 'SUBSET '..newsst-1
        
        for i = 1, #ctls do
        
          if ctls[i].ctlcat == ctlcats.fxparam or 
             ctls[i].ctlcat == ctlcats.trackparam or 
             ctls[i].ctlcat == ctlcats.tracksend or 
             ctls[i].ctlcat == ctlcats.fxoffline then 
            --add
            local ctlidx = #snapshots[strip][page][newsst].ctls + 1
            snapshots[strip][page][newsst].ctls[ctlidx] = {c_id = ctls[i].c_id,
                                                           ctl = i}
          end
        end
      end
    elseif sst > 1 then

      local strip = tracks[track_select].strip
      local ctls = snapshots[strip][page][sst].ctls
      if ctls and #ctls > 0 then
        newsst = #snapshots[strip][page]+1
        snapshots[strip][page][newsst] = {subsetname = 'SUBSET '..newsst-1, snapshot = {}, ctls = {}}
        snapsubsets_table[newsst] = 'SUBSET '..newsst-1
        for i = 1, #ctls do
        
          --add
          local ctlidx = #snapshots[strip][page][newsst].ctls + 1
          snapshots[strip][page][newsst].ctls[ctlidx] = {c_id = ctls[i].c_id,
                                                         ctl = ctls[i].ctl}
        end
      end

    end
    return newsst
  end
  
  function Snapshot_DeleteSubset(strip, page, sst)
  
    if sst > 1 and snapshots[strip][page][sst] then
    
      local scnt = #snapshots[strip][page]
      local xcnt 
      
      snapshots[strip][page][sst] = nil
      if xxy and xxy[strip] and xxy[strip][page] then
        xcnt = #xxy[strip][page]
        if xxy[strip][page][sst] then
          local pathidx = xxy[strip][page][sst].pathidx 
          xxy[strip][page][sst] = nil
          XXYPath_Delete(pathidx)        
        end
      end

      local stbl = Table_RemoveEntry(snapshots[strip][page], scnt, sst)
      snapshots[strip][page] = stbl
      if xcnt then
        local xtbl = Table_RemoveEntry(xxy[strip][page], xcnt, sst)
        xxy[strip][page] = xtbl
      end
                
      ctl_select = {}
      gfx2_select = nil
      gfx3_select = nil
    
      for c = 1, #strips[strip][page].controls do
      
        if strips[strip][page].controls[c].ctlcat == ctlcats.snapshot or 
           strips[strip][page].controls[c].ctlcat == ctlcats.xy or 
           strips[strip][page].controls[c].ctlcat == ctlcats.snapshotrand then
          if strips[strip][page].controls[c].param == sst then
            ctl_select[#ctl_select+1] = {ctl = c} 
          elseif strips[strip][page].controls[c].param > sst then
            strips[strip][page].controls[c].param = strips[strip][page].controls[c].param -1
            if tonumber(strips[strip][page].controls[c].param_info.paramidx) then
              strips[strip][page].controls[c].param_info.paramidx = strips[strip][page].controls[c].param_info.paramidx -1
            end
          end        
        end
      
      end
      if #ctl_select > 0 then
        DeleteSelectedCtls()
      end
      
      if sstype_select > #snapshots[strip][page] then
      
        sstype_select = #snapshots[strip][page]
      
      end
        
    end
  
  end
  
  function Snapshot_Move(src, dst)
  
    local strip = tracks[track_select].strip
    if sstype_select == 1 then
      local snaptbl = snapshots[strip][page][sstype_select]
      local ssdst = {}
      local inserted = false
      local npos = 0
      for i = 1, #snaptbl do
        if i == src then
          --skip
        else
          if inserted == false then
            npos = npos + 1
          end
          if i == dst then
            table.insert(ssdst, snaptbl[src])
            inserted = true
          end
          table.insert(ssdst, snaptbl[i])
        end      
      end
      if inserted == false then
        table.insert(ssdst, snaptbl[src])
        npos = npos + 1
      end
      snapshots[strip][page][sstype_select] = ssdst
      ss_select = math.min(npos,#snapshots[strip][page][sstype_select])    
    
    else
      local snaptbl = snapshots[strip][page][sstype_select].snapshot    
      local ssdst = {}
      local inserted = false
      local npos = 0
      for i = 1, #snaptbl do
        if i == src then
          --skip
        else
          if inserted == false then
            npos = npos + 1
          end
          if i == dst then
            table.insert(ssdst, snaptbl[src])
            inserted = true
          end
          table.insert(ssdst, snaptbl[i])
        end      
      end
      if inserted == false then
        table.insert(ssdst, snaptbl[src])
        npos = npos + 1
      end
      snapshots[strip][page][sstype_select].snapshot = ssdst
      ss_select = math.min(npos,#snapshots[strip][page][sstype_select].snapshot)
    end
    update_snaps = true
    update_fsnaps = true
  
  end
    
  function Snapshot_Set(strip, page, sstype_select, ss_select)

    --local r = reaper
    --local t = reaper.time_precise()
    local reaper = reaper
    if sstype_select == 1 then
      local snaptbl = snapshots[strip][page][sstype_select][ss_select]
      if snaptbl then
        local gtrack = GetTrack(strips[strip].track.tracknum)
        mfchk = {}
        for ss = 1, #snaptbl.data do
          local c = snaptbl.data[ss].ctl
          local v = snaptbl.data[ss].dval
          local nv = snaptbl.data[ss].val
          local ctl = strips[strip][page].controls[c]
          local mfs = snaptbl.data[ss].mfset
          if mfs then
            local mf = snaptbl.data[ss].mf
            if mf and ctl.macrofader ~= mf then
              local f = snaptbl.data[ss].mfdata
              
              if ctl.macrofader and not mfchk[ctl.macrofader] then
                faders[ctl.macrofader] = {}
              end
              
              ctl.macrofader = mf
              mfchk[mf] = true
              faders[mf] = {targettype = 4,
                            strip = f.strip,
                            page = f.page,
                            ctl = f.ctl,
                            c_id = f.c_id}              
            
            elseif mf == nil then
              if ctl.macrofader and not mfchk[ctl.macrofader] then
                faders[ctl.macrofader] = {}
              end
              
              ctl.macrofader = nil
            end
          end
          
          if ctl.noss ~= true and c and v and tostring(nv) ~= tostring(ctl.val) then
            trackfxparam_select = c
            if ctl.tracknum then
              track = GetTrack(ctl.tracknum)
            else
              track = gtrack
            end
            SetParam3_Denorm2_Safe2(track, v, strip, page, reaper, c)
          end
          
          if ctl.macrofader then
            SetFader(ctl.macrofader, nv)
          end
        end
      end    
    elseif sstype_select > 1 then
      local snaptbl = snapshots[strip][page][sstype_select].snapshot[ss_select]
      if snaptbl then
        local gtrack = GetTrack(strips[strip].track.tracknum)
        mfchk = {}
        for ss = 1, #snaptbl.data do
          local c = snaptbl.data[ss].ctl
          local v = snaptbl.data[ss].dval
          local nv = snaptbl.data[ss].val
          local ctl = strips[strip][page].controls[c]

          local mfs = snaptbl.data[ss].mfset
          if mfs then
            local mf = snaptbl.data[ss].mf
            if mf and ctl.macrofader ~= mf then
              local f = snaptbl.data[ss].mfdata
              
              if ctl.macrofader and not mfchk[ctl.macrofader] then
                faders[ctl.macrofader] = {}
              end
              
              ctl.macrofader = mf
              mfchk[mf] = true
              faders[mf] = {targettype = 4,
                            strip = f.strip,
                            page = f.page,
                            ctl = f.ctl,
                            c_id = f.c_id}              
            
            elseif mf == nil then
              if ctl.macrofader and not mfchk[ctl.macrofader] then
                faders[ctl.macrofader] = {}
              end
              
              ctl.macrofader = nil
            end
          end
          if c and v and tostring(nv) ~= tostring(ctl.val) then
            trackfxparam_select = c
            if ctl.tracknum then
              track = GetTrack(ctl.tracknum)
            else
              track = gtrack
            end
            SetParam3_Denorm2_Safe2(track, v, strip, page, reaper, c)        
          end
          
          if ctl.macrofader then
            SetFader(ctl.macrofader, nv)
          end

        end
      end    
    
    end
    snapshots[strip][page][sstype_select].selected = ss_select
    --DBG(round(reaper.time_precise() - t,6))
  end

  function Snapshots_INIT()

    if snapshots == nil then
      snapshots = {}
    end
    for s = 1, #strips do --reaper.CountTracks(0)+1 do
      if snapshots[s] == nil then
        snapshots[s] = {}
      end
      
      for p = 1, 4 do
        if snapshots[s][p] == nil then
          snapshots[s][p] = {}
        end
        if snapshots[s][p][1] == nil then
          snapshots[s][p][1] = {}
        end
      end
    end
  end
    
  function Snapshots_CREATE(strip, page, sstype, ss_ovr)

    if strips and strips[strip] and strips[strip][page] and #strips[strip][page].controls > 0 then

      if snapshots == nil then
        snapshots = {}
      end
      for s = 1, reaper.CountTracks(0)+1 do
        if snapshots[s] == nil then
          snapshots[s] = {}
          for p = 1, 4 do
            snapshots[s][p] = {}
            snapshots[s][p][1] = {}
          end
        end
      end
      if snapshots[strip][page] == nil then
        snapshots[strip][page] = {}
      end
      
      if sstype == 1 then

        if snapshots[strip][page][sstype] == nil then
          snapshots[strip][page][sstype] = {}
        end
      
        if ss_ovr then
          snappos = ss_ovr
          if snapshots[strip][page][sstype][snappos] then
            snapshots[strip][page][sstype][snappos].data = {}
          else
            return false
          end
        else
          snappos = #snapshots[strip][page][sstype] + 1
          snapshots[strip][page][sstype][snappos] = {name = 'Snapshot '..snappos,
                                                     data = {}} 
        end
        
        local offflag = false
        local sscnt = 1
        for c = 1, #strips[strip][page].controls do
        
          local sflag = false
          if strips[strip][page].controls[c].noss ~= true then
            if strips[strip][page].controls[c].ctlcat == ctlcats.fxparam or
               strips[strip][page].controls[c].ctlcat == ctlcats.trackparam or
               strips[strip][page].controls[c].ctlcat == ctlcats.tracksend or 
               strips[strip][page].controls[c].ctlcat == ctlcats.fxoffline or 
               strips[strip][page].controls[c].ctlcat == ctlcats.midictl then
              if strips[strip][page].controls[c].ctltype ~= 5 then
                local track = GetTrack(nz(strips[strip][page].controls[c].tracknum,strips[strip].track.tracknum))
                local cc = strips[strip][page].controls[c].ctlcat
                local fxnum = strips[strip][page].controls[c].fxnum
                local param = strips[strip][page].controls[c].param
                local min, max = GetParamMinMax(cc,track,nz(fxnum,-1),param,true,c)
                local dval = DenormalizeValue(min,max,strips[strip][page].controls[c].val)
                snapshots[strip][page][sstype][snappos].data[sscnt] = {c_id = strips[strip][page].controls[c].c_id,
                                                                        ctl = c,
                                                                        val = strips[strip][page].controls[c].val,
                                                                        dval = dval}
                if cc == ctlcats.fxoffline then
                  offflag = true
                end

                if settings_savefaderboxassinsnapshots == true then
                  snapshots[strip][page][sstype][snappos].data[sscnt].mfset = true
                  local mf = strips[strip][page].controls[c].macrofader
                  if mf then
                    if faders[mf] and faders[mf].targettype == 4 then
                      local f = {targettype = 4,
                                 strip = faders[mf].strip,
                                 page = faders[mf].page,
                                 ctl = faders[mf].ctl,
                                 c_id = faders[mf].c_id}
                      snapshots[strip][page][sstype][snappos].data[sscnt].mf = mf
                      snapshots[strip][page][sstype][snappos].data[sscnt].mfdata = f

                    end
                  end
                end
                
                sscnt = sscnt + 1
                sflag = true
              end
            end
          end
          --[[if settings_savefaderboxassinsnapshots == true then
            local mf = strips[strip][page].controls[c].macrofader
            if mf then
              if faders[mf] and faders[mf].targettype == 4 then
              
                local sscntx = sscnt
                if sflag then
                  sscntx = ssxntx -1
                end
                if not snapshots[strip][page][sstype][snappos].data[sscntx] then
                
                end 
                
              
              end
            end
          end]]
        end
        
        if offflag == true then
          --place offline buttons at top of list otherwise snapshots not recalled correctly first click
          local tmp = {}
          --local sscnt = 1
          for sspos = 1, #snapshots[strip][page][sstype][snappos].data do
            if strips[strip][page].controls[snapshots[strip][page][sstype][snappos].data[sspos].ctl].ctlcat == ctlcats.fxoffline then
              table.insert(tmp, snapshots[strip][page][sstype][snappos].data[sspos])
            end
          end
          for sspos = 1, #snapshots[strip][page][sstype][snappos].data do
            if strips[strip][page].controls[snapshots[strip][page][sstype][snappos].data[sspos].ctl].ctlcat ~= ctlcats.fxoffline then
              table.insert(tmp, snapshots[strip][page][sstype][snappos].data[sspos])
            end
          end
          snapshots[strip][page][sstype][snappos].data = tmp
        end
        ss_select = snappos
        
      elseif sstype > 1 then
      
        if snapshots[strip][page][sstype] == nil then
          snapshots[strip][page][sstype] = {subsetname = 'SUBSET '..sstype-1, snapshot = {}, ctls = {}}
          snapsubsets_table[sstype] = 'SUBSET '..sstype-1
        end

        local sctls = #snapshots[strip][page][sstype].ctls
        if sctls > 0 then

          if ss_ovr then
            snappos = ss_ovr
            if snapshots[strip][page][sstype].snapshot[snappos] then
              snapshots[strip][page][sstype].snapshot[snappos].data = {}
            else
              return false
            end
          else
            snappos = #snapshots[strip][page][sstype].snapshot + 1
            snapshots[strip][page][sstype].snapshot[snappos] = {name = 'Snapshot '..snappos,
                                                                data = {}} 
          end
    
          local offflag = false
          local sscnt = 1
          for cctl = 1, sctls do
            local c = snapshots[strip][page][sstype].ctls[cctl].ctl
            if nz(snapshots[strip][page][sstype].ctls[cctl].delete,false) == false then
              if strips[strip][page].controls[c].ctlcat == ctlcats.fxparam or
                 strips[strip][page].controls[c].ctlcat == ctlcats.trackparam or
                 strips[strip][page].controls[c].ctlcat == ctlcats.tracksend or 
                 strips[strip][page].controls[c].ctlcat == ctlcats.fxoffline or 
                 strips[strip][page].controls[c].ctlcat == ctlcats.midictl then
                if strips[strip][page].controls[c].ctltype ~= 5 then
                  local track = GetTrack(nz(strips[strip][page].controls[c].tracknum,strips[strip].track.tracknum))
                  local cc = strips[strip][page].controls[c].ctlcat
                  local fxnum = strips[strip][page].controls[c].fxnum
                  local param = strips[strip][page].controls[c].param
                  local min, max = GetParamMinMax(cc,track,nz(fxnum,-1),param,true,c)
                  local dval = DenormalizeValue(min,max,strips[strip][page].controls[c].val)
                  snapshots[strip][page][sstype].snapshot[snappos].data[sscnt] = {c_id = strips[strip][page].controls[c].c_id,
                                                                                ctl = c,
                                                                                val = strips[strip][page].controls[c].val,
                                                                                dval = dval}
                  if cc == ctlcats.fxoffline then
                    offflag = true
                  end

                  if settings_savefaderboxassinsnapshots == true then
                    snapshots[strip][page][sstype].snapshot[snappos].data[sscnt].mfset = true
                    local mf = strips[strip][page].controls[c].macrofader
                    if mf then
                      if faders[mf] and faders[mf].targettype == 4 then
  
                        local f = {targettype = 4,
                                   strip = faders[mf].strip,
                                   page = faders[mf].page,
                                   ctl = faders[mf].ctl,
                                   c_id = faders[mf].c_id}
                        snapshots[strip][page][sstype].snapshot[snappos].data[sscnt].mf = mf
                        snapshots[strip][page][sstype].snapshot[snappos].data[sscnt].mfdata = f
  
                      end
                    end
                  end

                  sscnt = sscnt + 1
                end
              end
            end
          end
          if offflag == true then
            --place offline buttons at top of list otherwise snapshots not recalled correctly first click
            local tmp = {}
            --local sscnt = 1
            for sspos = 1, #snapshots[strip][page][sstype].snapshot[snappos].data do
              if strips[strip][page].controls[snapshots[strip][page][sstype].snapshot[snappos].data[sspos].ctl].ctlcat == ctlcats.fxoffline then
                table.insert(tmp, snapshots[strip][page][sstype].snapshot[snappos].data[sspos])
              end
            end
            for sspos = 1, #snapshots[strip][page][sstype].snapshot[snappos].data do
              if strips[strip][page].controls[snapshots[strip][page][sstype].snapshot[snappos].data[sspos].ctl].ctlcat ~= ctlcats.fxoffline then
                table.insert(tmp, snapshots[strip][page][sstype].snapshot[snappos].data[sspos])
              end
            end
            snapshots[strip][page][sstype].snapshot[snappos].data = tmp
          end
          ss_select = snappos
        end      
      end
      snapshots[strip][page][sstype].selected = ss_select
      
      g_savedirty = true
    end
    
  end
  
  ------------------------------------------------------------
  
  function EnableLatch(c)
  
    if strips[tracks[track_select].strip][page].controls[c].ctlcat == ctlcats.fxparam then
      local trn = nz(strips[tracks[track_select].strip][page].controls[c].tracknum, strips[tracks[track_select].strip].track.tracknum)
      local track = GetTrack(trn)
      local env = reaper.GetFXEnvelope(track,strips[tracks[track_select].strip][page].controls[c].fxnum,strips[tracks[track_select].strip][page].controls[c].param, false)
      if env then
        local retval, envchunk = reaper.GetEnvelopeStateChunk(env,'',true)
        local s, e = string.find(envchunk,'ACT 1')
        if s and e then
          nchunk = string.sub(envchunk,1,s-1) .. 'ACT 0' .. string.sub(envchunk,e+1)
          reaper.SetEnvelopeStateChunk(env, nchunk, true)
        end
      end
    end
    
  end
    
  ------------------------------------------------------------
  -- STRIP SETS    
  ------------------------------------------------------------

  function SaveSet(fn)
  
    if fn and string.len(fn)>0 then
    
      local savedata = {version = VERSION,
                        trackdata = {},
                        stripdata = {},
                        snapdata = {},
                        switchers = {}}
      for t = 0, reaper.CountTracks(0)-1 do
      
        local tr = GetTrack(t)
        local r, chunk = reaper.GetTrackStateChunk(tr, '', false)
        savedata.trackdata[t] = {track = t,
                                 guid = reaper.GetTrackGUID(tr),
                                 chunkdata = chunk}
      end
      savedata.stripdata = strips
      savedata.snapdata = snapshots
      savedata.switchers = switchers
      
      --Pickle doesn't like {} and -1#INF in strings (much) - remove before pickling
      if savedata.stripdata and #savedata.stripdata > 0 then
        for s = 1, #savedata.stripdata do
          for p = 1, 4 do
            if #savedata.stripdata[s][p].controls > 0 then
              for c = 1, #savedata.stripdata[s][p].controls do
                if savedata.stripdata[s][p].controls[c].ctlcat == ctlcats.pkmeter then
                  savedata.stripdata[s][p].controls[c].val = -150
                end
              end
            end
          end
        end
      end
            
      --[[for i = 1, #savedata.strip.controls do
        savedata.strip.controls[i].fxguid = convertguid(savedata.strip.controls[i].fxguid)
      end]]
      
      local save_path=sets_path
      local fn=save_path..fn..".stripset"
      
      local DELETE=true
      local file
      
      if reaper.file_exists(fn) then
      
      end
      
      if DELETE then
        file=io.open(fn,"w")
        local pickled_table=pickle(savedata)
        file:write(pickled_table)
        file:close()
      end
      
      --reinstate {} after pickling
      --[[for i = 1, #savedata.strip.controls do
        if savedata.strip.controls[i].fxguid then
          savedata.strip.controls[i].fxguid = '{'..savestrip.strip.controls[i].fxguid..'}'
        end
      end]]
      
      OpenMsgBox(1,'Strip set saved.',1)
    
    end  
  
  end

  function LoadSet(merge)
  
    local retval, fn = reaper.GetUserFileNameForRead(sets_path..'*', 'Load Strip Set', '.stripset')
    if retval then
    
      local loaddata = nil
      if reaper.file_exists(fn) then
        if merge == nil then merge = false end
        lsmerge = merge
        return fn
              
      else
        OpenMsgBox(1,'File not found.',1)
      end
    
    end
    
  end

  function LoadSet2(fn, merge)

    if merge == nil then merge = false end
    
    local file
    file=io.open(fn,"r")
    local content=file:read("*a")
    file:close()
    
    local loaddata = unpickle(content)

    if loaddata == nil then return end
    
    guids = {}
    --INIT()
    local t_offset = reaper.CountTracks(0)
    
    for i = 0, #loaddata.trackdata do
      loaddata.trackdata[i].chunkdata = string.gsub(loaddata.trackdata[i].chunkdata,
                                                    '({%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x})',
                                                    function(d) if guids[d] == nil then guids[d]=reaper.genGuid('') end return guids[d] end)
      loaddata.trackdata[i].chunkdata = ReplaceRCVs(loaddata.trackdata[i].chunkdata, t_offset)
    end    
        
    for i = 0, #loaddata.trackdata do
    
      reaper.InsertTrackAtIndex(t_offset+i+1, false)
    
    end
    
    for i = 0, #loaddata.trackdata do

      local tr = GetTrack(t_offset+i)
      reaper.SetTrackStateChunk(tr, loaddata.trackdata[i].chunkdata, false) 

    end        
    
    local cids = {}
    local grids = {}
    local swids = {}
    
    --update tracknums and guids, and cids
    for s = 1, #loaddata.stripdata do
    
      if loaddata.stripdata and loaddata.stripdata[s] then
    
        loaddata.stripdata[s].track.tracknum = loaddata.stripdata[s].track.tracknum + t_offset
        loaddata.stripdata[s].track.guid = guids[loaddata.stripdata[s].track.guid]
    
        for p = 1, 4 do
    
          if loaddata.stripdata[s][p] then
            if #loaddata.stripdata[s][p].controls > 0 then
            
              for c = 1, #loaddata.stripdata[s][p].controls do
              
                local ctl = loaddata.stripdata[s][p].controls[c]
                if ctl.tracknum then
                  ctl.tracknum = ctl.tracknum + t_offset
                  ctl.trackguid = guids[ctl.trackguid]
                end
                if ctl.fxguid then
                  ctl.fxguid = guids[ctl.fxguid]
                end
                if ctl.param_info.paramdesttrnum then
                  ctl.param_info.paramdesttrnum = ctl.param_info.paramdesttrnum + t_offset
                  ctl.param_info.paramdestguid = guids[ctl.param_info.paramdestguid]
                end
                if merge then
                  if cids[ctl.c_id] == nil then
                    cids[ctl.c_id] = GenID()
                    ctl.c_id = cids[ctl.c_id]
                  end
                end
                
                --compatibility
                if ctl.font == nil then ctl.font = fontname_def end
                if ctl.xydata == nil then ctl.xydata = {snapa = 1, snapb = 1, snapc = 1, snapd = 1, x = 0.5, y = 0.5} end
                if ctl.textoffx == nil then ctl.textoffx = 0 end
                if ctl.textoffvalx == nil then ctl.textoffvalx = 0 end      
                if ctl.textcolv == nil then ctl.textcolv = ctl.textcol end
                if ctl.textsizev == nil then ctl.textsizev = ctl.textsize end
                
                if ctl.grpid then
                  if grids[ctl.grpid] then
                    ctl.grpid = grids[ctl.grpid]
                  else
                    local grpid = GenID()
                    grids[ctl.grpid] = grpid
                    ctl.grpid = grpid
                  end
                end
                
              end
              
            end
            if #loaddata.stripdata[s][p].graphics > 0 then
              for c = 1, #loaddata.stripdata[s][p].graphics do
                local ctl = loaddata.stripdata[s][p].graphics[c]
                
                if ctl.bright == nil then ctl.bright = 0.5 end      
                if ctl.contr == nil then ctl.contr = 0.5 end      
                if ctl.rmult == nil then ctl.rmult = 0.5 end      
                if ctl.gmult == nil then ctl.gmult = 0.5 end      
                if ctl.bmult == nil then ctl.bmult = 0.5 end      
                if ctl.alpha == nil then ctl.alpha = 1 end      
                                
                if ctl.stretchmode == nil then ctl.stretchmode = 1 end
                if ctl.edgesz == nil then ctl.edgesz = 8 end              
                
                if ctl.grpid then
                  if grids[ctl.grpid] then
                    ctl.grpid = grids[ctl.grpid]
                  else
                    local grpid = GenID()
                    grids[ctl.grpid] = grpid
                    ctl.grpid = grpid
                  end
                end
              end            
            end
          end
    
        end
      end
      
    end

    if merge then
      if #loaddata.snapdata > 0 then
        for s = 1, #loaddata.snapdata do
          for p = 1, 4 do
          
            if loaddata.snapdata[s][p] and #loaddata.snapdata[s][p] > 0 then
              for sst = 1, #loaddata.snapdata[s][p] do
          
                if sst == 1 then
                  if loaddata.snapdata[s][p][sst] and #loaddata.snapdata[s][p][sst] > 0 then
                
                    for ss = 1, #loaddata.snapdata[s][p][sst] do
                      if loaddata.snapdata[s][p][sst][ss].data and #loaddata.snapdata[s][p][sst][ss].data > 0 then
                        for d = 1, #loaddata.snapdata[s][p][sst][ss].data do 
                          if cids[loaddata.snapdata[s][p][sst][ss].data[d].c_id] then
                            loaddata.snapdata[s][p][sst][ss].data[d].c_id = cids[loaddata.snapdata[s][p][sst][ss].data[d].c_id]
                          end
                        end
                      end
                    end
                  end
                else
                  if loaddata.snapdata[s][p][sst].ctls and #loaddata.snapdata[s][p][sst].ctls > 0 then
                    for ctl = 1, #loaddata.snapdata[s][p][sst].ctls do
                      if cids[loaddata.snapdata[s][p][sst].ctls[ctl].c_id] then
                        loaddata.snapdata[s][p][sst].ctls[ctl].c_id = cids[loaddata.snapdata[s][p][sst].ctls[ctl].c_id]
                      end                
                    end
                  end
                
                  if loaddata.snapdata[s][p][sst].snapshot and #loaddata.snapdata[s][p][sst].snapshot > 0 then
                    for ss = 1, #loaddata.snapdata[s][p][sst].snapshot do
                      if loaddata.snapdata[s][p][sst].snapshot[ss].data and #loaddata.snapdata[s][p][sst].snapshot[ss].data > 0 then
                        for d = 1, #loaddata.snapdata[s][p][sst].snapshot[ss].data do
                          if cids[loaddata.snapdata[s][p][sst].snapshot[ss].data[d].c_id] then
                            loaddata.snapdata[s][p][sst].snapshot[ss].data[d].c_id = cids[loaddata.snapdata[s][p][sst].snapshot[ss].data[d].c_id]
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end

    local swstart = #switchers+1
    local nsflag = false
    
    for s = 1, #loaddata.stripdata do
    
      if loaddata.stripdata and loaddata.stripdata[s] then
    
        for p = 1, 4 do
    
          if loaddata.stripdata[s][p] then
            if #loaddata.stripdata[s][p].controls > 0 then
            
              for c = 1, #loaddata.stripdata[s][p].controls do
                local ctl = loaddata.stripdata[s][p].controls[c]
                if ctl.ctlcat == ctlcats.switcher then
                  --local stab = GetSwitcherTable(ctls[c].switcherid)
                  local stab = loaddata.switchers[ctl.switcherid]
                  ns = #switchers+1
                  nsflag = true
                  switchers[ns] = stab
                  swids[ctl.switcherid] = ns
                end      
              end
            end
          end
        end
      end
    end    
    
    if nsflag then
      for s = swstart, #switchers do
        if switchers[s].parent and swids[switchers[s].parent.switcherid] then
          switchers[s].parent.switcherid = swids[switchers[s].parent.switcherid]
          switchers[s].parent.grpid = grids[switchers[s].parent.grpid]
        else
          switchers[s].parent = nil
        end
        if switchers[s].grpids and #switchers[s].grpids > 0 then
          for g = 1, #switchers[s].grpids do
            if grids[switchers[s].grpids[g].id] then
              switchers[s].grpids[g].id = grids[switchers[s].grpids[g].id]
            else
              switchers[s].grpids[g].id = GenID()
            end
          end
        end
        if switchers[s].current and grids[switchers[s].current] then
          switchers[s].current = grids[switchers[s].current]
        else
          if switchers[s].grpids and switchers[s].grpids[1] then
            switchers[s].current = switchers[s].grpids[1].id
          else
            switchers[s].current = -1
          end
        end
      end
    end
    
    for s = 1, #loaddata.stripdata do
    
      if loaddata.stripdata and loaddata.stripdata[s] then
    
        for p = 1, 4 do
    
          if loaddata.stripdata[s][p] then
            if #loaddata.stripdata[s][p].controls > 0 then
            
              for c = 1, #loaddata.stripdata[s][p].controls do
              
                local ctl = loaddata.stripdata[s][p].controls[c]
                if ctl.switcherid then
                  if swids[ctl.switcherid] then
                    ctl.switcherid = swids[ctl.switcherid]
                  else
                  
                  end
                end
                if ctl.switcher then
                  if swids[ctl.switcher] then
                    ctl.switcher = swids[ctl.switcher]
                  else
                    ctl.switcher = nil
                  end
                end
              end 
            end
            if #loaddata.stripdata[s][p].graphics > 0 then
                      
              for c = 1, #loaddata.stripdata[s][p].graphics do
                local ctl = loaddata.stripdata[s][p].graphics[c]              
                if ctl.switcher then
                  if swids[ctl.switcher] then
                    ctl.switcher = swids[ctl.switcher]
                  else
                    ctl.switcher = nil
                  end
                end
              end 
            end
          end
        end
      end
    end
 
    image_count_add = image_count    
    if #loaddata.stripdata > 0 then
      for s = 1, #loaddata.stripdata do
        for p = 1, 4 do
          if #loaddata.stripdata[s][p].graphics > 0 then
            for i = 1, #loaddata.stripdata[s][p].graphics do
      
              local fnd = false
              for j = 0, #graphics_files do
                if nz(loaddata.stripdata[s][p].graphics[i].gfxtype,gfxtype.img) == gfxtype.img then
                  local iidx = LoadGraphics(loaddata.stripdata[s][p].graphics[i].fn)
                  if iidx then
                    if iidx > image_count_add then
                      image_count_add = iidx
                    end
                    loaddata.stripdata[s][p].graphics[i].imageidx = iidx
                  end
                  break
                  
                end
              end
              if not fnd then
              end
            end
          end
        end
      end

      for s = 1, #loaddata.stripdata do
        for p = 1, 4 do

          if #loaddata.stripdata[s][p].controls > 0 then      
            for i = 1, #loaddata.stripdata[s][p].controls do
              local fnd = false
              for j = 0, #ctl_files do
                if ctl_files[j].fn == loaddata.stripdata[s][p].controls[i].ctl_info.fn then
                  if ctl_files[j].imageidx ~= nil then
                    fnd = true
                    loaddata.stripdata[s][p].controls[i].ctl_info.imageidx = ctl_files[j].imageidx
                    loaddata.stripdata[s][p].controls[i].knob_select = j
                  else
                    fnd = true
                    image_count_add = F_limit(image_count_add + 1,0,image_max)
                    gfx.loadimg(image_count_add, controls_path..loaddata.stripdata[s][p].controls[i].ctl_info.fn)
                    ctl_files[j].imageidx = image_count_add
                    loaddata.stripdata[s][p].controls[i].ctl_info.imageidx = image_count_add
                    loaddata.stripdata[s][p].controls[i].knob_select = j
                  end
                  break
                end
              end
              if not fnd then
              end
            end
          end
        end
      end

    end
    image_count = image_count_add

    if strips == nil then    
      strips = {}
    end
    
    --snapshots = {}
    if merge then    
      Snapshots_INIT()
    end
    
    LoadCompatibility(loaddata.version,loaddata.stripdata)
    
    for s = 1, #loaddata.stripdata do    
      if loaddata.stripdata and loaddata.stripdata[s] then
        local sc = #strips + 1 
        strips[sc] = loaddata.stripdata[s]
        snapshots[sc] = loaddata.snapdata[s]
      end
    end    
    
    PopulateTracks()
    
  end
  
  function ReplaceRCVs(chunk, t_offset)
  
    local ch = string.gsub(chunk,'AUXRECV (%d-) ',function(d) return 'AUXRECV '..string.format('%i',t_offset+d)..' ' end)
    return ch
    
  end
  
  function InsertDefaultStrip()
    if settings_insertdefaultoneverytrack then
      if tracks[track_select] and (strips[tracks[track_select].strip] == nil or (strips[tracks[track_select].strip][page].controls and #strips[tracks[track_select].strip][page].controls == 0)) then
        --[[DBG('page'..page)
        DBG(track_select)
        DBG(LBX_GTRACK)]]
        if settings_insertdefaultoneverypage or page == 1 then
          local ls = false
          if track_select == -1 then
            if strip_default_mast then
              stripfol_select = strip_default_mast.stripfol_select
              strip_select = strip_default_mast.strip_select          
              ls = true
            end
          elseif track_select == LBX_GTRACK then
            if strip_default_glob then
              stripfol_select = strip_default_glob.stripfol_select
              strip_select = strip_default_glob.strip_select          
              ls = true
            end          
          else
            if strip_default then
              stripfol_select = strip_default.stripfol_select
              strip_select = strip_default.strip_select
              ls = true
            end
          end
          if ls then
            PopulateStrips()
            loadstrip = LoadStrip(strip_select)
            if loadstrip then
              if gui == nil then
                GetGUI_vars()
              end
              GenStripPreview(gui, loadstrip.strip, loadstrip.switchers, loadstrip.switchconvtab)
              local _, strip = Strip_AddStrip(loadstrip,0,0)
              --image_count = image_count_add
              loadstrip = nil
              reaper.MarkProjectDirty(0)
              --SaveSingleStrip(strip)
            end
          end
        end
      end
    end
  end
  
  function CleanData()
  
    local striptbl = {}
    local snaptbl = {}
    local xxytbl = {} 
  
    for t = -1, reaper.CountTracks(0)-1 do
      if tracks[t].strip then
        if strips[tracks[t].strip] then

          table.insert(striptbl, strips[tracks[t].strip])
          table.insert(snaptbl, snapshots[tracks[t].strip])
          tblpos = #striptbl
          if xxy then
            xxytbl[tblpos] = xxy[tracks[t].strip]
          end
          
          striptbl[tblpos].track.strip = tblpos
          tracks[t].strip = tblpos
    
        end
      end
    end
    strips = striptbl
    snapshots = snaptbl
    if xxy then
      xxy = xxytbl
    end
    
  end
  
  
  ------------------------------------------------------------

  function GaugeSelect_INIT()
  
    local gs = {type = 1,
                x_offs = 0,
                y_offs = 0,
                radius = 50,
                arclen = 0.7,
                rotation = 0,
                ticks = 2,
                tick_size = 4,
                tick_offs = 1,
                val_freq = 1,
                col_tick = '192 192 192',
                col_arc = '192 192 192',
                col_val = '192 192 192',
                show_arc = true,
                show_tick = true,
                show_val = true,
                val = 0,
                dval = '',
                vals = {},
                val_dp = 0,
                font = fontname_def,
                fontsz = -5,
                nudge = 0,
                spread = nil,
                mapptof = nil,
                numonly = false,
                abbrev = false}
    return gs
    
  end

  function INIT(keepprojid)

    DBGOut('')
    DBGOut('** DATA INITIALIZATION ***')    
    LASTPROJECTID = PROJECTID
    
    if keepprojid then
      DBGOut('KEEP PROJECT ID: '..PROJECTID)    
    else
      PROJECTID = math.ceil((math.abs(math.sin( -1 + (os.clock() % 2)))) * 0xFFFFFFFF)
      DBGOut('NEW PROJECT ID: '..PROJECTID)          
    end
    lastprojdirty = reaper.IsProjectDirty(0)
    last_proj_change_count = -1
    projnamechange = false
    lastprojname = GetProjectName()
    
    g_cids = {}
    g_edstrips = {}
    g_savedirty = false
    
    toffY = true
    
    mode = 0
    submode = 2
    fxmode = 0
    snaplrn_mode = false
    butt_h = 20
    fx_h = 160
    snaph = 300
    fsnaph = 300
  
    ogrid = settings_gridsize
    sb_size = 3
    
    cbi_filter = -1
    cbi_offset = 0
    P_butt_cnt = 0
    F_butt_cnt = 0
    G_butt_cnt = 0
    S_butt_cnt = 0
    SF_butt_cnt = 0
    SS_butt_cnt = 0
    FSS_butt_cnt = 0
    tlist_offset = 0
    sflist_offset = 0
    cyclist_offset = 0
    trctltypelist_offset = 0
    trctlslist_offset = 0
    plist_offset = 0
    flist_offset = 0
    slist_offset = 0
    xxylist_offset = 0
    ssoffset = 0
    fssoffset = 0
    al_offset = 0
    
    strips = {}
    switchers = {}
    snapshots = nil
    xxy = nil
    xxy_gravity = 1.5
    
    surface_offset = {x = 0, y = 0}
    
    max_cycle = 256
    
    image_count = 1
    knob_select = 0
    ksel_size = 50
    ksel_loaded = false
    page = 1
    gpage = false
    navigate = true
    
    gfx_select = 0
    gfxfol_select = 0
    track_select = -1
    trackedit_select = -1
    trackfx_select = 0
    trackfxparam_select = 0
    ctl_select = nil
    scale_select = 1
    textcol_select = '205 205 205'
    textcolv_select = '205 205 205'
    ctltype_select = 1
    textoff_select = 45
    textoffval_select = 0
    textoff_selectx = 0
    textoffval_selectx = 0
    textsize_select = 0
    textsizev_select = 0
    defval_select = 0
    strip_select = 0
    stripfol_select = 0
    maxdp_select = -1
    cycle_select = {statecnt = 0,val = 0,mapptof = false,draggable = false,spread = false,nil}
    minov_select = nil
    maxov_select = nil
    dvaloff_select = 0
    trctltype_select = 0
    trctl_select = 1
    gfx_font_select = {idx = 1,
                         name = fontname_def,
                         size = fontsize_def,
                         bold = false,
                         italic = false,
                         underline = false,
                         shadow = true,
                         shadow_x = 1,
                         shadow_y = 1,
                         shadow_a = 0.6}
    gfx_textcol_select = '255 255 255'
    gfx_text_select = ''
    knob_scalemode_select = 1
    scalemode_select = 8
    framemode_select = 1
    sstype_select = 1
    fsstype_select = 1
    horiz_select = false
    mapptof_select = false
    draggable_select = false
    spread_select = false
    al_select = 0
    gauge_select = GaugeSelect_INIT()
    ctlfont_select = fontname_def
    bypass_bgdraw_c_select = false
    bypass_bgdraw_n_select = false
    bypass_bgdraw_v_select = false
    clickthrough_select = false
    
    gfxbright_select = 0.5
    gfxcontr_select = 0.5
    gfxr_select = 0.5
    gfxg_select = 0.5
    gfxb_select = 0.5
    gfxa_select = 1
    gfxstretchmode_select = 1
    gfxedgesz_select = 8
    
    plist_w = 140
    oplist_w = 140
    
    time_nextupdate = 0
    time_nextupdate_pkmeter = 0
    time_checksend = 0
    time_sendupdate = 0
    
    show_ctlbrowser = false
    show_ctloptions = false
    show_lbloptions = false
    show_gfxoptions = false
    show_editbar = true
    show_settings = false
    show_cycleoptions = false
    show_paramlearn = false
    show_snapshots = false
    show_fsnapshots = false
    show_actionchooser = false
    show_xxy = false
    show_gaugeedit = false
    show_trackfxorder = false
    show_midiout = false
    show_bitmap = false
    show_dd = false
    
    show_paramname = true
    show_paramval = true
    
    xxypath = {points = {}}
    xxypath_select = 1
    xxymode = 0
    xxyrecord = false
    xxypath_edit = true
    xxypath_tres = 400
    
    macro_lrn_mode = false
    macro_edit_mode = false
    eq_edit = false
    
    ctl_page = 0
    cycle_editmode = false
    
    last_gfx_w = 0
    last_gfx_h = 0
    
    octlval = -1
    otrkcnt = -1
    ofxcnt = -1
    checktr = 0    
  
    otrkcnt = reaper.CountTracks(0)
  
    PopulateTracks()
    PopulateGFX()
    PopulateControls()
    PopulateStripFolders()
    PopulateStrips()
    PopulateMediaItemInfo()
    PopulateTrackSendsInfo()
    PopulateTrackFX()
    PopulateTrackFXParams()

    Faders_INIT(force)
            
    EB_Open = 0
    EB_Enter = false
    
    MS_Open = 0
    MB_Enter = false
    
    update_gfx = true
    update_surface = true
    update_ctls = true
    update_sidebar = true
    update_topbar = true
    update_ctlopts = true
    update_actcho = false
    update_xxy = false
    force_gfx_update = true
    
    rcmrefreshtimercount = 0
    
    Snapshots_INIT()
    snapshot_fader = nil
    
    mouse = {}
    
    SetSurfaceSize()
    
  end
  
  ------------------------------------------------------------
  
  function frameScale(m, v)
    
    if m == 1 then
      return v
    elseif m == 2 then
      return outCirc(v)
    else
      return v
    end
  
  end
  
  function ctlScale(m, v)
  
    local mm = scalemode_table[m]
    return v^mm
  
  end

  function ctlScaleInv(m, v)
  
    local mm = 1/scalemode_table[m]
    return v^mm
  
  end
  
  function macScale(m, v)
    if m == 1 then
      return v
    elseif m == 2 then
      return inSine(v)
    elseif m == 3 then
      return outSine(v)    
    elseif m == 4 then
      return inOutSine(v)        
    elseif m == 5 then
      return inCubic(v)
    elseif m == 6 then
      return outCubic(v)
    elseif m == 7 then
      return inOutCubic(v)
    elseif m == 8 then
      return inQuart(v)
    elseif m == 9 then
      return outQuart(v)
    elseif m == 10 then
      return inOutQuart(v)
    else
      return v
    end
  end
  
  --b=0 c=1 d=1
  function inSine(t)
    if t < 0 then
      return -(-1 * math.cos(-t * (pi / 2)) + 1)
    else
      return -1 * math.cos(t * (pi / 2)) + 1
    end
  end
  
  function outSine(t)
    return 1 * math.sin(t * (pi / 2))
  end
  
  function inOutSine(t)
    if t < 0 then
      return 1/2 * (math.cos(pi * t) - 1)
    else
      return -1/2 * (math.cos(pi * t) - 1)
    end
  end
  
  function inCubic(t)
    return t^3
  end
  
  function outCubic(t)
    if t < 0 then
      t = -t - 1
      return -(t^3 + 1)
    else
      t = t - 1
      return t^3 + 1
    end
  end
  
  function inOutCubic(t)
    if t < 0 then
      t = -t * 2
      if t < 1 then
        return -(1/2 * t * t * t)
      else
        t = t - 2
        return -(1/2 * (t * t * t + 2))
      end
    else
      t = t * 2
      if t < 1 then
        return 1/2 * t * t * t
      else
        t = t - 2
        return 1/2 * (t * t * t + 2)
      end
    end
  end
  
  function inQuart(t)
  
    if t < 0 then
      return -(t^4)
    else
      return t^4
    end
  end
  
  function outQuart(t)
    if t < 0 then
      t = -t - 1
      return -(-1 * (t^4 - 1))    
    else
      t = t - 1
      return -1 * (t^4 - 1)
    end
  end
  
  function inOutQuart(t)
    if t < 0 then
      t = -t * 2
      if t < 1 then
        return -(1/2 * t^4)
      else
        t = t - 2
        return -(-1/2 * (t^4 - 2))
      end
    else
      t = t * 2
      if t < 1 then
        return 1/2 * t^4
      else
        t = t - 2
        return -1/2 * (t^4 - 2)
      end
    end
  end
  
  
  function inQuint(t)
    return t^5
  end

  function inQuintInv(v)
    return v^0.2
  end
  
  function testfunc(txt1)
    DBG(txt1)
    return 'return'..txt1
  end
  
  function tablelength(T)
    local count = 0
    for _ in pairs(T) do count = count + 1 end
    return count
  end

  function testfx()
  
    --DBG('    <FXCHAIN\n      SHOW 0\n      LASTSEL 0\n      DOCKED 0\n')
    for i = 0, reaper.CountTracks(0)-1 do
      
      local str = GetTrack(i)
      --local dtr = GetTrack(dsttrn)
      
      local _, chunk = reaper.GetTrackStateChunk(str,'',false)
      local fnd, fxc, s, e = testchunkfxextract(chunk,1)
      --[[DBG('')
      DBG('TRACK '..i+1)
      DBG('')
      DBG(fnd)
      DBG('')
      DBG(fxc)]]
      
    end
  
  end

  function testfxinsert()
  
    local str = GetTrack(1)
    local _, chunk = reaper.GetTrackStateChunk(str,'',false)
    local fnd, fxc, s, e = GetFXChunkFromTrackChunk(chunk,1)
    local trn = -1
    local str = GetTrack(trn)
    local _, chunk = reaper.GetTrackStateChunk(str,'',false)
    local nchunk, nfxguid, ofxguid = Chunk_InsertFXChunkAtEndOfFXChain(trn, chunk,fxc)
    DBG(nchunk)
    --DBG('guid='..nfxguid..'  '..ofxguid)
    
    DBG(tostring(reaper.SetTrackStateChunk(str,nchunk,false)))
  
  end

  --returns new track chunk, new fxguid, old fxguid
  --[[function InsertFXChunkAtEndOfChain(trn, trchunk, insfxchunk)

    guids = {}
    local ofxid, nfxid = nil, nil
    local rchunk = nil
    
    if insfxchunk then
      insfxchunk = string.gsub(insfxchunk,
                              'FXID ({%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x})',
                              function(d) if guids[d] == nil then guids[d]=reaper.genGuid('') end return 'FXID '..guids[d] end)
      --insfxchunk = string.gsub(insfxchunk,'PRESETNAME.-\n','')
    end
    --trchunk = string.gsub(trchunk,'PRESETNAME.-\n','')
    
    --should be just one
    for i, v in pairs(guids) do 
      ofxid = i
      nfxid = v 
    end
    s, e = string.find(trchunk,'(BYPASS.+WAK %d)',s)
    if s and e then 
      rchunk = string.sub(trchunk,0,e+1)..insfxchunk..string.sub(trchunk,e+1)
    else
      s, e = string.find(trchunk,'(<FXCHAIN.-DOCKED %d)',s)
      if s and e then
        rchunk = string.sub(trchunk,0,e+1)..insfxchunk..string.sub(trchunk,e+1)      
      else
        if trn == -1 then
          local ms, me = string.find(trchunk,'.+>')
          if me then  
            --master track -- insert at very end
              rchunk = string.sub(trchunk,0,me-1).. '<FXCHAIN\nSHOW 0\nLASTSEL 0\nDOCKED 0\n'.. insfxchunk ..'\n>\n'..string.sub(trchunk,me)  
          end
        else
          --normal track -- insert after MAINSEND
          s, e = string.find(trchunk,'(MAINSEND %d %d)',s)
          if e then
            rchunk = string.sub(trchunk,0,e+1)..'<FXCHAIN\nSHOW 0\nLASTSEL 0\nDOCKED 0\n'.. insfxchunk ..'\n>\n'..string.sub(trchunk,e+2)
          end
        end
      end
    end
    return rchunk, nfxid, ofxid
    
  end]]
  
  function MoveFXChunk(srcfxnum, dstfxnum)
  
    --DBG(srcfxnum..'  '..dstfxnum)
    local writechunk = false
    local trn = tracks[track_select].tracknum
    local tr = GetTrack(trn)
    local fxcnt = reaper.TrackFX_GetCount(tr)
    local _, chunk = reaper.GetTrackStateChunk(tr,'',false)
    local _, nchunk, movechunk = RemoveFXChunkFromTrackChunk(chunk, srcfxnum)
    if nchunk then
      if dstfxnum == fxcnt then
        --insert at end
        nchunk = Chunk_InsertFXChunkAtEndOfFXChain(trn, nchunk, movechunk, true)
        if nchunk then
          writechunk = true
        end
      else
        local fnd, _, s, e = GetFXChunkFromTrackChunk(nchunk, dstfxnum)
        if fnd then
          nchunk = string.sub(nchunk,0,s-1)..movechunk..string.sub(nchunk,s)
          writechunk = true
        end
      end
    
      if writechunk == true then
        reaper.SetTrackStateChunk(tr,nchunk,true)
        --DBG(nchunk)
      end
    end
  end
    
  --returns success, fxchunk, start loc, end loc
  function GetFXChunkFromTrackChunk(trchunk, fxn)
  
    local s,e, fnd = 0,0,nil
    for i = 1,fxn do
      s, e = string.find(trchunk,'(BYPASS.-WAK %d)',s)
      if s and e then
        fxchunk = string.sub(trchunk,s,e)

        if i == fxn then fnd = true break end
        s=e+1
      else
        fxchunk = nil
        fndn = nil
        break
      end
    end
    return fnd, fxchunk, s, e  
  
  end

  function RemoveFXChunkFromTrackChunk(trchunk, fxn)
  
    local s,e, fnd = 0,0,nil
    local nchunk
    for i = 1,fxn do
      s, e = string.find(trchunk,'(BYPASS.-WAK %d)',s)
      if s and e then
        fxchunk = string.sub(trchunk,s,e+1)

        if i == fxn then 
          fnd = true 
          nchunk = string.sub(trchunk,0,s-2)..string.sub(trchunk,e+1)
          break 
        end
        s=e+1
      else
        fxchunk = nil
        fndn = nil
        break
      end
    end
    return fnd, nchunk, fxchunk  
  
  end

  function SetFXOffline(strip, page, ctl, trn, v)

    local trn = nz(strips[strip][page].controls[ctl].tracknum, trn)
    local fxn = strips[strip][page].controls[ctl].fxnum
    local str = GetTrack(trn)
    local _, chunk = reaper.GetTrackStateChunk(str,'',false)

    local s,e, fnd = 0,0,nil
    for i = 0,fxn do
      s, e = string.find(chunk,'BYPASS %d %d %d',s)
      if s and e then
        if i == fxn then 
          local byp = string.sub(chunk,s,e)
          if v == 1 then
            byp = string.gsub(byp,'(%d) (%d) (%d)', function(d,e,f) return d..' 1 '..f end)
          else
            byp = string.gsub(byp,'(%d) (%d) (%d)', function(d,e,f) return d..' 0 '..f end)          
          end
          local nchunk = string.sub(chunk,0,s-1)..byp..string.sub(chunk,e+1)
          reaper.SetTrackStateChunk(str,nchunk,false)
          fnd = true 
          break 
        end
        s=e+1
      else
        break
      end
    end
    return fnd, fxchunk, s, e  
  
  end

  function SetFXOffline2(strip, page, ctl, track, v)

    local fxn = strips[strip][page].controls[ctl].fxnum
    local str = track
    local _, chunk = reaper.GetTrackStateChunk(str,'',false)

    local s,e, fnd = 0,0,nil
    for i = 0,fxn do
      s, e = string.find(chunk,'BYPASS %d %d %d',s)
      if s and e then
        if i == fxn then 
          local byp = string.sub(chunk,s,e)
          if v == 1 then
            byp = string.gsub(byp,'(%d) (%d) (%d)', function(d,e,f) return d..' 1 '..f end)
          else
            byp = string.gsub(byp,'(%d) (%d) (%d)', function(d,e,f) return d..' 0 '..f end)          
          end
          local nchunk = string.sub(chunk,0,s-1)..byp..string.sub(chunk,e+1)
          reaper.SetTrackStateChunk(str,nchunk,false)
          fnd = true 
          break 
        end
        s=e+1
      else
        break
      end
    end
    return fnd, fxchunk, s, e  
  
  end
  
  function ToggleFXOffline(strip, page, ctl, trn)
    local trn = nz(strips[strip][page].controls[ctl].tracknum, trn)
    local fxn = strips[strip][page].controls[ctl].fxnum
    local str = GetTrack(trn)
    local _, chunk = reaper.GetTrackStateChunk(str,'',false)

    --local chlines = {}
    local s,e=0,0
    --[[while e<string.len(chunk) or chline == nil do
      chline = string.find(chunk,s,)
    end]]
    --ts = reaper.time_precise()
    --[[chlines = split(chunk, "\n")
    local c = 0
    for i = 1, #chlines do
      if string.sub(chlines[i],0,5) == 'BYPASS' then
        if c == fxn then
          byp = string.gsub(byp,'(%d) (%d) (%d)', function(d,e,f) if e == '0' then return d..' 1 '..f else return d..' 0 '..f end end)
          chlines[i] = byp
          break
        end 
        c=c+1        
      end
    end
    local nchunk = ''
    for i = 1, #chlines do
    
      nchunk = nchunk .. #chlines[i]
    
    end
    DBG(reaper.time_precise()-ts..'  '..#chlines)]]

    local s,e, fnd = 0,0,nil
    for i = 0,fxn do
      s, e = string.find(chunk,'BYPASS %d %d %d',s)
      if s and e then
        if i == fxn then 
          local byp = string.sub(chunk,s,e)
          byp = string.gsub(byp,'(%d) (%d) (%d)', function(d,e,f) if e == '0' then return d..' 1 '..f else return d..' 0 '..f end end)
          local nchunk = string.sub(chunk,0,s-1)..byp..string.sub(chunk,e+1)
          reaper.SetTrackStateChunk(str,nchunk,false)
          fnd = true 
          break 
        end
        s=e+1
      else
        break
      end
    end
    return fnd, fxchunk, s, e  
  
  end
  
  function testchunkcopy(srctrn, dsttrn)
  
    local str = GetTrack(srctrn)
    --local dtr = GetTrack(dsttrn)
    
    local _, chunk = reaper.GetTrackStateChunk(str,'',false)
    --[[DBG('')
    DBG('SOURCE')
    DBG('')]]
    --DBG(chunk)
    
    local ch, s, e = Chunk_GetFXChainSection(chunk)
    --[[local guids = {}
    local ch = string.gsub(chunk,'({%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x})',
                           function(d) if guids[d] == nil then guids[d]=reaper.genGuid('') end DBG(d..'  '..guids[d]) return guids[d] end)
    DBG('')
    DBG('RESULT')
    DBG('')
    DBG(ch)
    DBG('')
    DBG('Total guids swapped = '..tablelength(guids))]]

    --DBG(string.match(chunk,'{.-}'))
    --DBG(string.match(chunk,'{%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x}'))
    
    --reaper.SetTrackStateChunk(dtr, chunk, false)
    
    --[[local ret, chunk = reaper.GetTrackStateChunk(dtr,'',false)
    DBG('ret: '..tostring(ret))
    DBG('DEST')
    DBG('')
    DBG(chunk)
    DBG('')
    DBG('')
    DBG(reaper.genGuid(''))  
    DBG(reaper.genGuid(''))  
    local guid = reaper.genGuid('')
    
    local p = {}
    p[guid] = reaper.genGuid('')
    DBG(guid..'  p[guid]='..p[guid])
    ]]
    
  end
  
  function Chunk_GetFXChainSection(chunk)
  
    -- If FXChain - return section
    -- If none - return char after MAIN SEND \n
  
    local s1 = string.find(chunk, '<FXCHAIN.-\n')
    if s1 then
      local s = s1
      local indent, op, cl = 1
      while indent > 0 do
        op = string.find(chunk, '<', s+1, true)
        cl = string.find(chunk, '>', s+1, true)
        if op == nil and cl == nil then break end
        if op ~= nil then
          if op <= cl then
            indent = indent + 1
            s = op
          else
            indent = indent - 1
            s = cl
          end
        else
          indent = indent - 1
          s = cl        
        end
      end
    
      local retch = string.sub(chunk,s1,cl)
      return retch, s1, cl
    else
      local s1, e1 = string.find(chunk, 'MAINSEND.-\n')
      return nil, s1, e1
    end
  end
  
  --returns new track chunk, new fxguid, old fxguid
  function Chunk_InsertFXChunkAtEndOfFXChain(trn, trchunk, insfxchunk, keepid)

    guids = {}
    local ofxid, nfxid = nil, nil
    local rchunk = nil

    if keepid == nil then
      --prepare insert chunk    
      if insfxchunk then
        insfxchunk = string.gsub(insfxchunk,
                                'FXID ({%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x})',
                                function(d) if guids[d] == nil then guids[d]=reaper.genGuid('') end return 'FXID '..guids[d] end)
      end
      
      --should be just one
      for i, v in pairs(guids) do 
        ofxid = i
        nfxid = v 
      end
    end
      
    local chunk, chs, che = Chunk_GetFXChainSection(trchunk)
    if chunk then
      --insert before final character
      rchunk = string.sub(trchunk,0,che-1) .. insfxchunk .. string.sub(trchunk,che-1)
    else
      if trn == -1 then
        --master track
        local ms, me = string.find(trchunk,'.+>')
        if me then  
          --insert at very end
          rchunk = string.sub(trchunk,0,me-1).. '<FXCHAIN\nSHOW 0\nLASTSEL 0\nDOCKED 0\n'.. insfxchunk ..'\n>\n'..string.sub(trchunk,me)  
        end
      else
        --normal track -- insert after MAINSEND
        rchunk = string.sub(trchunk,0,che)..'<FXCHAIN\nSHOW 0\nLASTSEL 0\nDOCKED 0\n'.. insfxchunk ..'\n>\n'..string.sub(trchunk,che+1)
      end    
    end
    
    return rchunk, nfxid, ofxid
    
  end

    
  function SaveProj(tmp, bak, noclean)
    --DBG(reaper.GetProjectPath(''))
    if #strips > 0 then
      GUI_DrawMsgX(obj, gui, 'Saving Data...')
      if tmp == nil then
        local pn = GetProjectName()
        if pn == '' then
          reaper.Main_SaveProject(0,false)
          pn = GetProjectName()
        end
        --DBG(pn..'  '..lastprojname)
        if pn ~= '' then
          if lastprojname ~= pn then
            projnamechange = true
            lastprojname = pn
          end
  
          local t = reaper.time_precise()
          SaveData(nil, bak, noclean)
          reaper.Main_SaveProject(0,false)
          infomsg = "DATA SAVED (" .. round(reaper.time_precise() - t,2)..'s)'
          projnamechange = false
        else
          DBG('Save failed.  Project file must be created.')
        end
      else
        local t = reaper.time_precise()
        SaveData(tmp, bak, noclean)
        infomsg = "DATA SAVED (" .. round(reaper.time_precise() - t,2)..'s)'
        --projnamechange = false
      end
      update_surface = true      
    end
      
  end
  
  function GetProjectName()
  
    if reaper.APIExists('GetProjectName') then
      return reaper.GetProjectName(0,'')
    else
      return 'RPR_LBXProjID_'
    end
    
  end
  
  function StripperRunning(state)
    if state == true then
      reaper.SetProjExtState(0,'LBXFLAGS','LBX_RUNNING','*')
    else
      reaper.SetProjExtState(0,'LBXFLAGS','LBX_RUNNING','')    
    end
  end    
  
  function quit()

      
    --[[local ffn = GetSaveFN()
    local srcffn = ffn
    ffn = ffn..'.lbxbak_'      
    copyfile(srcffn, ffn)]]

    --[[local ffn=resource_path..'aa.testdata'    
    local file=io.open(ffn,"w")    
    file:write('[strips]'..#strips..'\n')
    file:write('[snapshots]'..#snapshots..'\n')
    file:write('[tracks]'..#tracks..'\n')]]
      
    SaveProj(true,nil,true)
    SaveSettings()

    --[[file:write('[strips]'..#strips..'\n')
    file:write('[snapshots]'..#snapshots..'\n')
    file:write('[tracks]'..#tracks..'\n')
    file:close()]]

    StripperRunning(false)
    
    gfx.quit()
    
  end
  
  function Sleep(sec)
  
    os.sleep = function(sec)
       local timr = reaper.time_precise()
       repeat until reaper.time_precise() > timr + sec
    end
    
  end
  
  function LoadFontList()
  
    local ffn=resource_path..'lbx_font_list.txt'
    if reaper.file_exists(ffn) ~= true then
      --DBG('Missing file: '..ffn)
      return 0
    end    
    fontlist = {}
   
    data = {}
    local i = 1
    for line in io.lines(ffn) do
      fontlist[i] = line
      i=i+1
    end    
  
  end
  
  function ChooseFontMenu(x,y)
  
    if fontlist and #fontlist > 0 then
    
      local fl = ''
      for i = 1, #fontlist do
        if fl ~= '' then
          fl = fl .. '|'
        end
        fl = fl..fontlist[i]
      end
    
      if x and y then
        gfx.x = x
        gfx.y = y
      end
      res = OpenMenu(fl)
      if res then
        return fontlist[res]
      end
    end
  
  end
  
  function PopMIDIOutputs()
  
    local midiouts = {}
    local midioutsidx = {}
    local moutnum = reaper.GetNumMIDIOutputs()
    local mcnt = 3

    midiouts[0] = {outnum = 0,
                   foutnum = 0,
                   mchan = 1,
                   name = '--- [None] ---'}
    
    midiouts[1] = {outnum = 0,
                    foutnum = 0,
                    mchan = 1,
                    name = 'Virtual Midi Keyboard'}
    midioutsidx['Virtual Midi Keyboard'] = 0

    midiouts[2] = {outnum = 0,
                    foutnum = 0,
                    mchan = 1,
                    name = 'Reaper Control'}
    midioutsidx['Reaper Control'] = 1
    
    for i = 0, moutnum do
    
      local retval ,moutname = reaper.GetMIDIOutputName(i,'')
      if retval == true then
        --DBG(tostring(retval)..'  '..moutname)
        midiouts[mcnt] = {outnum = i,
                           foutnum = i+16,
                           mchan = 1,
                           name = moutname}
        midioutsidx[moutname] = i+16
        mcnt = mcnt + 1
      end
      
    end
    return midiouts, midioutsidx
  
  end
  
  function SendMIDIMsg(miditab, val, mu)
  
    --Send MIDI CC
    if miditab.focus > 1 then
      if miditab.focus == 2 then
        FocusArrange()
      elseif miditab.focus == 3 then
        FocusMIDIEditor()
      end
    end
    if miditab.onmu == false or mu == true then
      if (val and midioutsidx[miditab.output]) then

        if miditab.updategfx == true then
          if mu then
          
            local ctl = strips[tracks[track_select].strip][page].controls[trackfxparam_select]
            ctl.val = 0
            ctl.dirty = true
            update_ctls = true
          end
          touch_trigger = false
          touch_timer = reaper.time_precise()+0.2
          midimsg = true
          midimsgto = reaper.time_precise() + 0.1
          GUI_draw(obj, gui)
          gfx.update()
        end
              
        local vald = math.floor((miditab.vmax - miditab.vmin)*val) + miditab.vmin
      
        if miditab.msgtype <= 4 then      
          reaper.StuffMIDIMessage(midioutsidx[miditab.output], 
                                  midimsgval_table[miditab.msgtype]..string.format('%x',miditab.mchan-1),
                                  miditab.msg3, --CC num
                                  F_limit(vald,0,127)) -- CC val
        elseif miditab.msgtype == 5 or miditab.msgtype == 6 then      
          reaper.StuffMIDIMessage(midioutsidx[miditab.output], 
                                  midimsgval_table[miditab.msgtype]..string.format('%x',miditab.mchan-1),
                                  F_limit(vald,0,127), 
                                  0) -- CC val      
        elseif miditab.msgtype == 6 then      
          reaper.StuffMIDIMessage(midioutsidx[miditab.output], 
                                  midimsgval_table[miditab.msgtype]..string.format('%x',miditab.mchan-1),
                                  miditab.msg3, --CC num
                                  F_limit(vald,0,127)) -- CC val      
        elseif miditab.msgtype == 7 then
          local v1 = math.floor(vald / 128)
          local v2 = vald % 128
          reaper.StuffMIDIMessage(midioutsidx[miditab.output], 
                                  midimsgval_table[miditab.msgtype]..string.format('%x',miditab.mchan-1),
                                  v2, 
                                  v1)
        end
  
        if miditab.osc then
          local msg = string.gsub(miditab.osc, '%[val%]', vald)
          --DBG(msg)    
          reaper.OscLocalMessageToHost(msg)
        end
        
        midimsg = true
        midimsgto = reaper.time_precise() + 0.1
  
      elseif miditab.osc then
        local vald = 0
        if val then
          vald = math.floor((miditab.vmax - miditab.vmin)*val) + miditab.vmin
        end
        
        if miditab.osc then
          local msg = string.gsub(miditab.osc, '%[val%]', vald)
          --DBG(msg)    
          reaper.OscLocalMessageToHost(msg)
        end
        
        midimsg = true
        midimsgto = reaper.time_precise() + 0.1
      end             
    else
      mu_mmsg = {midiout = miditab, val = val}
      mididelay = reaper.time_precise() +0.05
      midi1st = true
      
      if miditab.updategfx == true then
        --local ctl = strips[tracks[track_select].strip][page].controls[trackfxparam_select]
        --ctl.val = 1
        --ctl.dirty = true
        GUI_draw(obj, gui)
        gfx.update()
      end
      
    end
    
  end
  
  function FocusArrange()
    reaper.Main_OnCommand(reaper.NamedCommandLookup('_BR_FOCUS_ARRANGE_WND'),0)
  end
  function FocusMIDIEditor()
    reaper.Main_OnCommand(reaper.NamedCommandLookup('_SN_FOCUS_MIDI_EDITOR'),0)
  end
  
  function LoadScanBoot(fn)

    local file
    file=io.open(fn,"r")
    if file then
      content=file:read("*a")
      file:close()
    
      neb_scanboot_tab = {}
      neb_scanboot_fn = {}
      
      if content then    
        for progid, filen in string.gmatch(content, "<SEQUENCE> (.-) </SEQUENCE>.-<FILENAME> (.-) </FILENAME>") do
          neb_scanboot_tab[progid+200] = filen
          neb_scanboot_fn[filen] = tonumber(progid+200)
        end
      end
    end
        
  end
  
  function RCM_Neb_UpdateAllProgIDs()
  
    if strips and #strips > 0 then
      local str = ''
      for s = 1, #strips do
        for p = 1, 4 do
        
          if strips[s] and strips[s][p] then
            str = str .. RCM_Neb_UpdateProgIDs(strips[s][p].controls, false) ..'\n'
          end
        
        end
      end
      
      DBG(str)
    end
      
  end
  
  function RCM_Neb_UpdateProgIDs(ctls, verbose)
  
    if neb_scanboot_fn and ctls then
    
      local upd = 0
      local fail = 0
    
      for i = 1, #ctls do
        local ctl = ctls[i]
        if ctl.ctlcat == ctlcats.rcm_switch then
      
          if ctl.rcmdata and #ctl.rcmdata > 0 then
      
            for j = 1, #ctl.rcmdata do
            
              if ctl.rcmdata[j].nebfn and neb_scanboot_fn[ctl.rcmdata[j].nebfn] then
            
                local nprog = neb_scanboot_fn[ctl.rcmdata[j].nebfn]
                if nprog then
                
                  local msb = F_limit(tonumber(math.floor(math.floor(nprog/100) / 128)),0,127)
                  local lsb = F_limit(tonumber(math.floor(nprog/100) % 128),0,127)
                  local prog = F_limit(tonumber(nprog % 100),0,127)
                  
                  ctl.rcmdata[j].msb = msb
                  ctl.rcmdata[j].lsb = lsb
                  ctl.rcmdata[j].prog = prog
            
                  upd = upd + 1
                end
                
              else
                if ctl.rcmdata[j].nebfn then
                  fail = fail + 1
                end
              end
            
            end
      
          end
      
        end
      end
    
      local str = 'Neb IDs updated: '..upd..'\n\nNeb IDs not updated: '..fail
      if nz(verbose,true) == true then
        OpenMsgBox(1, str, 1)
      end    
      return str
    end
  
  end
  
  ------------------------------------------------------------

  SCRIPT = 'LBX_STRIPPER'
  VERSION = 0.95
  STRIPSET = 'STRIP SET 1'

  LBX_FB_CNT = 32

  OS = reaper.GetOS()
  math.randomseed(os.clock())

  ZeroProjectFlags()
  StripperRunning(true)
  Sleep()
  
  midiouts, midioutsidx = PopMIDIOutputs()
  
  gmode = 0
  
  fact = {}
  for f = 0,4 do
    fact[f] = cfact(f)  
  end
  
  image_max = 849
  ctl_browser_image = 910
  maximg_browse = 79
  b_sz = 100
  lockx = false
  locky = false
  lockw, olockw = 400, 400
  lockh, olockh = 400, 400
  auto_delay = 0
  xxypath_indexcnt = 50
  
  resource_path = reaper.GetResourcePath().."/Scripts/LBX/LBXCS_resources/"
  controls_path = resource_path.."controls/"
  graphics_path = resource_path.."graphics/"
  actiondump_path = resource_path.."actiondumps/"    
  icon_path = resource_path.."icons/"
  strips_path = resource_path.."strips/"
  sets_path = resource_path.."sets/"
  projsave_path = resource_path.."projsave/"
  paths_path = resource_path.."paths/"
  eqbands_path = resource_path.."eqbands/"
  eq_path = resource_path.."eq/"
  skins_path = resource_path.."skins/LBXDEF/"
  share_path = resource_path.."share/"
  nebscanboot_file = nil
  
  --font_folder = "C:/Windows/Fonts/"
  
  LoadFontList()
    
  --copyfile('C:/Users/HMSStudio/AppData/Roaming/REAPER/Scripts/LBX/LBXCS_resources/controls/__default.png', 'C:/Users/HMSStudio/AppData/Roaming/REAPER/Scripts/LBX/LBXCS_resources/controls/cpcpcpcpcpc.png')  
  
  reaper.RecursiveCreateDirectory(sets_path,1)
  reaper.RecursiveCreateDirectory(icon_path,1)
  reaper.RecursiveCreateDirectory(actiondump_path,1)
  reaper.RecursiveCreateDirectory(projsave_path,1)  
  reaper.RecursiveCreateDirectory(paths_path,1)
  reaper.RecursiveCreateDirectory(eqbands_path,1)
  reaper.RecursiveCreateDirectory(eq_path,1)
  reaper.RecursiveCreateDirectory(share_path,1)

  LBX_CTL_TRNAME='__LBX_CTL'
  LBX_GTRACK_NAME = '__GLOBAL'
  LBX_GTRACK = nil

  settings_savedatainprojectfolder = true
  settings_followselectedtrack = true
  settings_autocentrectls = false
  settings_disablesendchecks = false
  settings_gridsize = 16
  settings_showgrid = true
  osg = settings_showgrid
  settings_saveallfxinststrip = false
  settings_updatefreq = 0.05
  settings_updatefreq_pkmeter = 0.05
  settings_showbars = false
  settings_mousewheelknob = false
  settings_locksurface = false
  settings_ExtendedAPI = reaper.APIExists('BR_GetMediaTrackSendInfo_Track')
  settings_swapctrlclick = false
  settings_insertdefaultoneverytrack = false
  settings_insertdefaultoneverypage = false
  settings_hideofflinelabel = true
  settings_showparamnamelabelwhenoffline = true
  settings_snaplistbgcol = '0 0 0'
  settings_defknobsens = {norm = 2,
                          fine = 0.1,
                          wheel = 0.05,
                          wheelfine = 0.003}
  settings_usectlbitmap = false
  settings_macroeditmonitor = false
  hide_topbar = false
  settings_hideeditbaronnewproject = false
  settings_locksurfaceonnewproject = false
  setting_reddotindicator = false
  settings_showminimaltopbar = true
  settings_createbackuponmanualsave = false
  settings_UCV = 1
  settings_touchFB = false
  settings_trackchangemidi = false
  settings_savefaderboxassinsnapshots = false
  
  textoptlink_select = true
  
  show_midioutind = true
  
  save_subfolder = ''
  
  DBG_mode = false
  
  backalpha = 1
  backalpha2 = 0
  backcol = '16 16 16'
  
  eq_scale = true
  eq_single = false
  
  strip_favs = {}
  peak_info = {}
  
  dockstate = 0
  
  EQC_min = 20
  EQC_max = 24000
  
  fontname_def = 'Calibri'
  fontsize_def  = 18
  
  surface_size = {w = 2048, h = 2048, limit = true}
  
  gfx.loadimg(0,controls_path.."__default.png") -- default control
  --gfx.loadimg(1010,controls_path.."__default.png")
  
  --def_knob = 0  
  gfx.loadimg(1021,icon_path.."bin.png")
  
  defctls = {}
  
  --gfx.loadimg(1020,controls_path.."missing.png") --update to missing png
  def_knob = LoadControl(1019, '__default.knb')
  def_knobsm = LoadControl(1018, 'SimpleFlat_48.knb')
  def_snapshot = LoadControl(1017, '__Snapshot.knb')
  def_xy = LoadControl(1016, '__XY.knb')
  def_xytarget = LoadControl(1015, '__XYTarget.knb')
  def_eqcknobf = LoadControl(1013, 'SimpleFlat_64.knb')
  def_eqcknobg = LoadControl(1014, 'SimpleFlat2_64.knb')
  def_box = LoadControl(1012, 'SimpleBox_9632.knb')
  def_switch = LoadControl(997, 'Switcher.knb')
  ctl_bitmap = 1010
  
  skin, ret = LoadSkin()

  --os.execute('E:\\AutoHotkey\\SRD_Home_TouchScreen.ahk')

  --TestStuff()  
  --testchunkcopy(0,3)
--testfxinsert()
  
  if def_knob == -1 or def_knobsm == -1 or def_snapshot == -1 or def_xy == -1 or def_xytarget == -1 or def_eqcknobf == -1 or def_eqcknobg == -1 or def_box == -1 or def_switch == -1 then
    DBG("Please ensure you have the: \n\n__default\nSimpleFlat_48\nSimpleFlat_96\nSimpleFlat2_96\n__Snapshot\n__XY\n__XYTarget\nSimpleBox_9632\nSwitcher\n\nfiles in your LBXCS_resources/controls/ folder.")
    DBG("You can get these files from the LBX Stripper project on github - in the LBXCS_resources zip file")
    reaper.atexit()
  elseif ret == false then
    reaper.atexit()  
  else
    def_snapshotctl = -1
        
    --DBG(_G['testfunc']('testtext'))
    INIT()
    
    gui = GetGUI_vars()
    def_graph = EQC_LoadGraph()
    LoadSettings()
    LoadData()
    CleanData()
    
    if nebscanboot_file ~= nil then
      LoadScanBoot(nebscanboot_file)
    end      
    
    gfx.dock(dockstate)
  --test jsfx plug name in quotes

    local startbat = resource_path..'\\lbxstart.bat'
    if reaper.file_exists(startbat) then
      os.execute(startbat)
    end  
  
    run()

    reaper.atexit(quit)
  end
    
  
